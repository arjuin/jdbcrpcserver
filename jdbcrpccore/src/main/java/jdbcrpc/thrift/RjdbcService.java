/**
 * Autogenerated by Thrift Compiler (0.9.2)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
package jdbcrpc.thrift;

import org.apache.thrift.scheme.IScheme;
import org.apache.thrift.scheme.SchemeFactory;
import org.apache.thrift.scheme.StandardScheme;

import org.apache.thrift.scheme.TupleScheme;
import org.apache.thrift.protocol.TTupleProtocol;
import org.apache.thrift.protocol.TProtocolException;
import org.apache.thrift.EncodingUtils;
import org.apache.thrift.TException;
import org.apache.thrift.async.AsyncMethodCallback;
import org.apache.thrift.server.AbstractNonblockingServer.*;
import java.util.List;
import java.util.ArrayList;
import java.util.Map;
import java.util.HashMap;
import java.util.EnumMap;
import java.util.Set;
import java.util.HashSet;
import java.util.EnumSet;
import java.util.Collections;
import java.util.BitSet;
import java.nio.ByteBuffer;
import java.util.Arrays;
import javax.annotation.Generated;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

@SuppressWarnings({"cast", "rawtypes", "serial", "unchecked"})
@Generated(value = "Autogenerated by Thrift Compiler (0.9.2)", date = "2015-5-7")
public class RjdbcService {

  public interface Iface {

    public RConnection createConnection(String url, Map<String,String> properties) throws RSQLException, org.apache.thrift.TException;

    public RStatement createStatement(RConnection connection) throws RSQLException, org.apache.thrift.TException;

    public RStatement prepareStatement(RConnection connection, String sql) throws RSQLException, org.apache.thrift.TException;

    public RStatement prepareCall(RConnection connection, String sql) throws RSQLException, org.apache.thrift.TException;

    public RStaticMetaData connection_getstaticmetadata(RConnection connection) throws RSQLException, org.apache.thrift.TException;

    public boolean connection_isvalid(RConnection connection, int timeout) throws RSQLException, org.apache.thrift.TException;

    public void connection_commit(RConnection connection) throws RSQLException, org.apache.thrift.TException;

    public void connection_rollback(RConnection connection) throws RSQLException, org.apache.thrift.TException;

    public void connection_setAutoCommit(RConnection connection, boolean autoCommit) throws RSQLException, org.apache.thrift.TException;

    public boolean connection_getAutoCommit(RConnection connection) throws RSQLException, org.apache.thrift.TException;

    public void connection_setTransactionIsolation(RConnection connection, int level) throws RSQLException, org.apache.thrift.TException;

    public int connection_getTransactionIsolation(RConnection connection) throws RSQLException, org.apache.thrift.TException;

    public void connection_setReadOnly(RConnection connection, boolean readOnly) throws RSQLException, org.apache.thrift.TException;

    public boolean connection_getReadOnly(RConnection connection) throws RSQLException, org.apache.thrift.TException;

    public void connection_setCatalog(RConnection connection, String catalog) throws RSQLException, org.apache.thrift.TException;

    public String connection_getCatalog(RConnection connection) throws RSQLException, org.apache.thrift.TException;

    public void connection_setSchema(RConnection connection, String schema) throws RSQLException, org.apache.thrift.TException;

    public String connection_getSchema(RConnection connection) throws RSQLException, org.apache.thrift.TException;

    public String connection_getCatalogSeparator(RConnection connection) throws RSQLException, org.apache.thrift.TException;

    public String connection_getCatalogTerm(RConnection connection) throws RSQLException, org.apache.thrift.TException;

    public String connection_getSchemaTerm(RConnection connection) throws RSQLException, org.apache.thrift.TException;

    public RResultSet connection_getCatalogs(RConnection connection) throws RSQLException, org.apache.thrift.TException;

    public RResultSet connection_getSchemas(RConnection connection, String catalog, String schemaPattern) throws RSQLException, org.apache.thrift.TException;

    public RResultSet connection_getTables(RConnection connection, String catalog, String schemaPattern, String tableNamePattern, List<String> types) throws RSQLException, org.apache.thrift.TException;

    public RResultSet connection_getColumns(RConnection connection, String catalog, String schemaPattern, String tableNamePattern, String columnNamePattern) throws RSQLException, org.apache.thrift.TException;

    public String connection_getSQLKeywords(RConnection connection) throws RSQLException, org.apache.thrift.TException;

    public RResultSet connection_getTableTypes(RConnection connection) throws RSQLException, org.apache.thrift.TException;

    public RResultSet connection_getTypeInfo(RConnection connection) throws RSQLException, org.apache.thrift.TException;

    public void closeConnection(RConnection connection) throws RSQLException, org.apache.thrift.TException;

    public void statement_close(RStatement statement) throws RSQLException, org.apache.thrift.TException;

    public boolean statement_execute(RStatement statement, String sql) throws RSQLException, org.apache.thrift.TException;

    public RResultSet statement_executeQuery(RStatement statement, String sql) throws RSQLException, org.apache.thrift.TException;

    public int statement_executeUpdate(RStatement statement, String sql) throws RSQLException, org.apache.thrift.TException;

    public RResultSet statement_getResultSet(RStatement statement) throws RSQLException, org.apache.thrift.TException;

    public int statement_getUpdateCount(RStatement statement) throws RSQLException, org.apache.thrift.TException;

    public int statement_getResultSetType(RStatement statement) throws RSQLException, org.apache.thrift.TException;

    public void statement_cancel(RStatement statement) throws RSQLException, org.apache.thrift.TException;

    public void statement_addBatch(RStatement statement, String sql) throws RSQLException, org.apache.thrift.TException;

    public void statement_addBatches(RStatement statement, List<String> sqlList) throws RSQLException, org.apache.thrift.TException;

    public void statement_clearBatch(RStatement statement) throws RSQLException, org.apache.thrift.TException;

    public List<Integer> statement_executeBatch(RStatement statement) throws RSQLException, org.apache.thrift.TException;

    public boolean preparedstatement_execute(RStatement preparedstatement) throws RSQLException, org.apache.thrift.TException;

    public RResultSet preparedstatement_executeQuery(RStatement preparedstatement) throws RSQLException, org.apache.thrift.TException;

    public int preparedstatement_executeUpdate(RStatement preparedstatement) throws RSQLException, org.apache.thrift.TException;

    public boolean preparedstatement_setParametersThenExecute(RStatement preparedstatement, List<RValueSQL> parameters) throws RSQLException, org.apache.thrift.TException;

    public RResultSet preparedstatement_setParametersThenExecuteQuery(RStatement preparedstatement, List<RValueSQL> parameters) throws RSQLException, org.apache.thrift.TException;

    public int preparedstatement_setParametersThenExecuteUpdate(RStatement preparedstatement, List<RValueSQL> parameters) throws RSQLException, org.apache.thrift.TException;

    public void preparedstatement_setParameters(RStatement preparedStatement, List<RValueSQL> parameters) throws RSQLException, org.apache.thrift.TException;

    public void preparedstatement_setParameter(RStatement preparedStatement, RValueSQL parameter, int position) throws RSQLException, org.apache.thrift.TException;

    public void preparedstatement_clearParameters(RStatement preparedStatement) throws RSQLException, org.apache.thrift.TException;

    public void preparedstatement_addBatchWithParameters(RStatement preparedStatement, List<RValueSQL> parameters) throws RSQLException, org.apache.thrift.TException;

    public void preparedstatement_addBatch(RStatement preparedStatement) throws RSQLException, org.apache.thrift.TException;

    public List<Integer> preparedstatement_executeBatch(RStatement statement, List<List<RValueSQL>> parameters) throws RSQLException, org.apache.thrift.TException;

    public statement_getWarnings_return statement_getWarnings(RStatement statement) throws RSQLException, org.apache.thrift.TException;

    public void statement_clearWarnings(RStatement statement) throws RSQLException, org.apache.thrift.TException;

    public int statement_getMaxRows(RStatement statement) throws RSQLException, org.apache.thrift.TException;

    public void statement_setMaxRows(RStatement statement, int max) throws RSQLException, org.apache.thrift.TException;

    public int statement_getQueryTimeout(RStatement statement) throws RSQLException, org.apache.thrift.TException;

    public void statement_setQueryTimeout(RStatement statement, int seconds) throws RSQLException, org.apache.thrift.TException;

  }

  public interface AsyncIface {

    public void createConnection(String url, Map<String,String> properties, org.apache.thrift.async.AsyncMethodCallback resultHandler) throws org.apache.thrift.TException;

    public void createStatement(RConnection connection, org.apache.thrift.async.AsyncMethodCallback resultHandler) throws org.apache.thrift.TException;

    public void prepareStatement(RConnection connection, String sql, org.apache.thrift.async.AsyncMethodCallback resultHandler) throws org.apache.thrift.TException;

    public void prepareCall(RConnection connection, String sql, org.apache.thrift.async.AsyncMethodCallback resultHandler) throws org.apache.thrift.TException;

    public void connection_getstaticmetadata(RConnection connection, org.apache.thrift.async.AsyncMethodCallback resultHandler) throws org.apache.thrift.TException;

    public void connection_isvalid(RConnection connection, int timeout, org.apache.thrift.async.AsyncMethodCallback resultHandler) throws org.apache.thrift.TException;

    public void connection_commit(RConnection connection, org.apache.thrift.async.AsyncMethodCallback resultHandler) throws org.apache.thrift.TException;

    public void connection_rollback(RConnection connection, org.apache.thrift.async.AsyncMethodCallback resultHandler) throws org.apache.thrift.TException;

    public void connection_setAutoCommit(RConnection connection, boolean autoCommit, org.apache.thrift.async.AsyncMethodCallback resultHandler) throws org.apache.thrift.TException;

    public void connection_getAutoCommit(RConnection connection, org.apache.thrift.async.AsyncMethodCallback resultHandler) throws org.apache.thrift.TException;

    public void connection_setTransactionIsolation(RConnection connection, int level, org.apache.thrift.async.AsyncMethodCallback resultHandler) throws org.apache.thrift.TException;

    public void connection_getTransactionIsolation(RConnection connection, org.apache.thrift.async.AsyncMethodCallback resultHandler) throws org.apache.thrift.TException;

    public void connection_setReadOnly(RConnection connection, boolean readOnly, org.apache.thrift.async.AsyncMethodCallback resultHandler) throws org.apache.thrift.TException;

    public void connection_getReadOnly(RConnection connection, org.apache.thrift.async.AsyncMethodCallback resultHandler) throws org.apache.thrift.TException;

    public void connection_setCatalog(RConnection connection, String catalog, org.apache.thrift.async.AsyncMethodCallback resultHandler) throws org.apache.thrift.TException;

    public void connection_getCatalog(RConnection connection, org.apache.thrift.async.AsyncMethodCallback resultHandler) throws org.apache.thrift.TException;

    public void connection_setSchema(RConnection connection, String schema, org.apache.thrift.async.AsyncMethodCallback resultHandler) throws org.apache.thrift.TException;

    public void connection_getSchema(RConnection connection, org.apache.thrift.async.AsyncMethodCallback resultHandler) throws org.apache.thrift.TException;

    public void connection_getCatalogSeparator(RConnection connection, org.apache.thrift.async.AsyncMethodCallback resultHandler) throws org.apache.thrift.TException;

    public void connection_getCatalogTerm(RConnection connection, org.apache.thrift.async.AsyncMethodCallback resultHandler) throws org.apache.thrift.TException;

    public void connection_getSchemaTerm(RConnection connection, org.apache.thrift.async.AsyncMethodCallback resultHandler) throws org.apache.thrift.TException;

    public void connection_getCatalogs(RConnection connection, org.apache.thrift.async.AsyncMethodCallback resultHandler) throws org.apache.thrift.TException;

    public void connection_getSchemas(RConnection connection, String catalog, String schemaPattern, org.apache.thrift.async.AsyncMethodCallback resultHandler) throws org.apache.thrift.TException;

    public void connection_getTables(RConnection connection, String catalog, String schemaPattern, String tableNamePattern, List<String> types, org.apache.thrift.async.AsyncMethodCallback resultHandler) throws org.apache.thrift.TException;

    public void connection_getColumns(RConnection connection, String catalog, String schemaPattern, String tableNamePattern, String columnNamePattern, org.apache.thrift.async.AsyncMethodCallback resultHandler) throws org.apache.thrift.TException;

    public void connection_getSQLKeywords(RConnection connection, org.apache.thrift.async.AsyncMethodCallback resultHandler) throws org.apache.thrift.TException;

    public void connection_getTableTypes(RConnection connection, org.apache.thrift.async.AsyncMethodCallback resultHandler) throws org.apache.thrift.TException;

    public void connection_getTypeInfo(RConnection connection, org.apache.thrift.async.AsyncMethodCallback resultHandler) throws org.apache.thrift.TException;

    public void closeConnection(RConnection connection, org.apache.thrift.async.AsyncMethodCallback resultHandler) throws org.apache.thrift.TException;

    public void statement_close(RStatement statement, org.apache.thrift.async.AsyncMethodCallback resultHandler) throws org.apache.thrift.TException;

    public void statement_execute(RStatement statement, String sql, org.apache.thrift.async.AsyncMethodCallback resultHandler) throws org.apache.thrift.TException;

    public void statement_executeQuery(RStatement statement, String sql, org.apache.thrift.async.AsyncMethodCallback resultHandler) throws org.apache.thrift.TException;

    public void statement_executeUpdate(RStatement statement, String sql, org.apache.thrift.async.AsyncMethodCallback resultHandler) throws org.apache.thrift.TException;

    public void statement_getResultSet(RStatement statement, org.apache.thrift.async.AsyncMethodCallback resultHandler) throws org.apache.thrift.TException;

    public void statement_getUpdateCount(RStatement statement, org.apache.thrift.async.AsyncMethodCallback resultHandler) throws org.apache.thrift.TException;

    public void statement_getResultSetType(RStatement statement, org.apache.thrift.async.AsyncMethodCallback resultHandler) throws org.apache.thrift.TException;

    public void statement_cancel(RStatement statement, org.apache.thrift.async.AsyncMethodCallback resultHandler) throws org.apache.thrift.TException;

    public void statement_addBatch(RStatement statement, String sql, org.apache.thrift.async.AsyncMethodCallback resultHandler) throws org.apache.thrift.TException;

    public void statement_addBatches(RStatement statement, List<String> sqlList, org.apache.thrift.async.AsyncMethodCallback resultHandler) throws org.apache.thrift.TException;

    public void statement_clearBatch(RStatement statement, org.apache.thrift.async.AsyncMethodCallback resultHandler) throws org.apache.thrift.TException;

    public void statement_executeBatch(RStatement statement, org.apache.thrift.async.AsyncMethodCallback resultHandler) throws org.apache.thrift.TException;

    public void preparedstatement_execute(RStatement preparedstatement, org.apache.thrift.async.AsyncMethodCallback resultHandler) throws org.apache.thrift.TException;

    public void preparedstatement_executeQuery(RStatement preparedstatement, org.apache.thrift.async.AsyncMethodCallback resultHandler) throws org.apache.thrift.TException;

    public void preparedstatement_executeUpdate(RStatement preparedstatement, org.apache.thrift.async.AsyncMethodCallback resultHandler) throws org.apache.thrift.TException;

    public void preparedstatement_setParametersThenExecute(RStatement preparedstatement, List<RValueSQL> parameters, org.apache.thrift.async.AsyncMethodCallback resultHandler) throws org.apache.thrift.TException;

    public void preparedstatement_setParametersThenExecuteQuery(RStatement preparedstatement, List<RValueSQL> parameters, org.apache.thrift.async.AsyncMethodCallback resultHandler) throws org.apache.thrift.TException;

    public void preparedstatement_setParametersThenExecuteUpdate(RStatement preparedstatement, List<RValueSQL> parameters, org.apache.thrift.async.AsyncMethodCallback resultHandler) throws org.apache.thrift.TException;

    public void preparedstatement_setParameters(RStatement preparedStatement, List<RValueSQL> parameters, org.apache.thrift.async.AsyncMethodCallback resultHandler) throws org.apache.thrift.TException;

    public void preparedstatement_setParameter(RStatement preparedStatement, RValueSQL parameter, int position, org.apache.thrift.async.AsyncMethodCallback resultHandler) throws org.apache.thrift.TException;

    public void preparedstatement_clearParameters(RStatement preparedStatement, org.apache.thrift.async.AsyncMethodCallback resultHandler) throws org.apache.thrift.TException;

    public void preparedstatement_addBatchWithParameters(RStatement preparedStatement, List<RValueSQL> parameters, org.apache.thrift.async.AsyncMethodCallback resultHandler) throws org.apache.thrift.TException;

    public void preparedstatement_addBatch(RStatement preparedStatement, org.apache.thrift.async.AsyncMethodCallback resultHandler) throws org.apache.thrift.TException;

    public void preparedstatement_executeBatch(RStatement statement, List<List<RValueSQL>> parameters, org.apache.thrift.async.AsyncMethodCallback resultHandler) throws org.apache.thrift.TException;

    public void statement_getWarnings(RStatement statement, org.apache.thrift.async.AsyncMethodCallback resultHandler) throws org.apache.thrift.TException;

    public void statement_clearWarnings(RStatement statement, org.apache.thrift.async.AsyncMethodCallback resultHandler) throws org.apache.thrift.TException;

    public void statement_getMaxRows(RStatement statement, org.apache.thrift.async.AsyncMethodCallback resultHandler) throws org.apache.thrift.TException;

    public void statement_setMaxRows(RStatement statement, int max, org.apache.thrift.async.AsyncMethodCallback resultHandler) throws org.apache.thrift.TException;

    public void statement_getQueryTimeout(RStatement statement, org.apache.thrift.async.AsyncMethodCallback resultHandler) throws org.apache.thrift.TException;

    public void statement_setQueryTimeout(RStatement statement, int seconds, org.apache.thrift.async.AsyncMethodCallback resultHandler) throws org.apache.thrift.TException;

  }

  public static class Client extends org.apache.thrift.TServiceClient implements Iface {
    public static class Factory implements org.apache.thrift.TServiceClientFactory<Client> {
      public Factory() {}
      public Client getClient(org.apache.thrift.protocol.TProtocol prot) {
        return new Client(prot);
      }
      public Client getClient(org.apache.thrift.protocol.TProtocol iprot, org.apache.thrift.protocol.TProtocol oprot) {
        return new Client(iprot, oprot);
      }
    }

    public Client(org.apache.thrift.protocol.TProtocol prot)
    {
      super(prot, prot);
    }

    public Client(org.apache.thrift.protocol.TProtocol iprot, org.apache.thrift.protocol.TProtocol oprot) {
      super(iprot, oprot);
    }

    public RConnection createConnection(String url, Map<String,String> properties) throws RSQLException, org.apache.thrift.TException
    {
      send_createConnection(url, properties);
      return recv_createConnection();
    }

    public void send_createConnection(String url, Map<String,String> properties) throws org.apache.thrift.TException
    {
      createConnection_args args = new createConnection_args();
      args.setUrl(url);
      args.setProperties(properties);
      sendBase("createConnection", args);
    }

    public RConnection recv_createConnection() throws RSQLException, org.apache.thrift.TException
    {
      createConnection_result result = new createConnection_result();
      receiveBase(result, "createConnection");
      if (result.isSetSuccess()) {
        return result.success;
      }
      if (result.sqlException != null) {
        throw result.sqlException;
      }
      throw new org.apache.thrift.TApplicationException(org.apache.thrift.TApplicationException.MISSING_RESULT, "createConnection failed: unknown result");
    }

    public RStatement createStatement(RConnection connection) throws RSQLException, org.apache.thrift.TException
    {
      send_createStatement(connection);
      return recv_createStatement();
    }

    public void send_createStatement(RConnection connection) throws org.apache.thrift.TException
    {
      createStatement_args args = new createStatement_args();
      args.setConnection(connection);
      sendBase("createStatement", args);
    }

    public RStatement recv_createStatement() throws RSQLException, org.apache.thrift.TException
    {
      createStatement_result result = new createStatement_result();
      receiveBase(result, "createStatement");
      if (result.isSetSuccess()) {
        return result.success;
      }
      if (result.sqlException != null) {
        throw result.sqlException;
      }
      throw new org.apache.thrift.TApplicationException(org.apache.thrift.TApplicationException.MISSING_RESULT, "createStatement failed: unknown result");
    }

    public RStatement prepareStatement(RConnection connection, String sql) throws RSQLException, org.apache.thrift.TException
    {
      send_prepareStatement(connection, sql);
      return recv_prepareStatement();
    }

    public void send_prepareStatement(RConnection connection, String sql) throws org.apache.thrift.TException
    {
      prepareStatement_args args = new prepareStatement_args();
      args.setConnection(connection);
      args.setSql(sql);
      sendBase("prepareStatement", args);
    }

    public RStatement recv_prepareStatement() throws RSQLException, org.apache.thrift.TException
    {
      prepareStatement_result result = new prepareStatement_result();
      receiveBase(result, "prepareStatement");
      if (result.isSetSuccess()) {
        return result.success;
      }
      if (result.sqlException != null) {
        throw result.sqlException;
      }
      throw new org.apache.thrift.TApplicationException(org.apache.thrift.TApplicationException.MISSING_RESULT, "prepareStatement failed: unknown result");
    }

    public RStatement prepareCall(RConnection connection, String sql) throws RSQLException, org.apache.thrift.TException
    {
      send_prepareCall(connection, sql);
      return recv_prepareCall();
    }

    public void send_prepareCall(RConnection connection, String sql) throws org.apache.thrift.TException
    {
      prepareCall_args args = new prepareCall_args();
      args.setConnection(connection);
      args.setSql(sql);
      sendBase("prepareCall", args);
    }

    public RStatement recv_prepareCall() throws RSQLException, org.apache.thrift.TException
    {
      prepareCall_result result = new prepareCall_result();
      receiveBase(result, "prepareCall");
      if (result.isSetSuccess()) {
        return result.success;
      }
      if (result.sqlException != null) {
        throw result.sqlException;
      }
      throw new org.apache.thrift.TApplicationException(org.apache.thrift.TApplicationException.MISSING_RESULT, "prepareCall failed: unknown result");
    }

    public RStaticMetaData connection_getstaticmetadata(RConnection connection) throws RSQLException, org.apache.thrift.TException
    {
      send_connection_getstaticmetadata(connection);
      return recv_connection_getstaticmetadata();
    }

    public void send_connection_getstaticmetadata(RConnection connection) throws org.apache.thrift.TException
    {
      connection_getstaticmetadata_args args = new connection_getstaticmetadata_args();
      args.setConnection(connection);
      sendBase("connection_getstaticmetadata", args);
    }

    public RStaticMetaData recv_connection_getstaticmetadata() throws RSQLException, org.apache.thrift.TException
    {
      connection_getstaticmetadata_result result = new connection_getstaticmetadata_result();
      receiveBase(result, "connection_getstaticmetadata");
      if (result.isSetSuccess()) {
        return result.success;
      }
      if (result.sqlException != null) {
        throw result.sqlException;
      }
      throw new org.apache.thrift.TApplicationException(org.apache.thrift.TApplicationException.MISSING_RESULT, "connection_getstaticmetadata failed: unknown result");
    }

    public boolean connection_isvalid(RConnection connection, int timeout) throws RSQLException, org.apache.thrift.TException
    {
      send_connection_isvalid(connection, timeout);
      return recv_connection_isvalid();
    }

    public void send_connection_isvalid(RConnection connection, int timeout) throws org.apache.thrift.TException
    {
      connection_isvalid_args args = new connection_isvalid_args();
      args.setConnection(connection);
      args.setTimeout(timeout);
      sendBase("connection_isvalid", args);
    }

    public boolean recv_connection_isvalid() throws RSQLException, org.apache.thrift.TException
    {
      connection_isvalid_result result = new connection_isvalid_result();
      receiveBase(result, "connection_isvalid");
      if (result.isSetSuccess()) {
        return result.success;
      }
      if (result.sqlException != null) {
        throw result.sqlException;
      }
      throw new org.apache.thrift.TApplicationException(org.apache.thrift.TApplicationException.MISSING_RESULT, "connection_isvalid failed: unknown result");
    }

    public void connection_commit(RConnection connection) throws RSQLException, org.apache.thrift.TException
    {
      send_connection_commit(connection);
      recv_connection_commit();
    }

    public void send_connection_commit(RConnection connection) throws org.apache.thrift.TException
    {
      connection_commit_args args = new connection_commit_args();
      args.setConnection(connection);
      sendBase("connection_commit", args);
    }

    public void recv_connection_commit() throws RSQLException, org.apache.thrift.TException
    {
      connection_commit_result result = new connection_commit_result();
      receiveBase(result, "connection_commit");
      if (result.sqlException != null) {
        throw result.sqlException;
      }
      return;
    }

    public void connection_rollback(RConnection connection) throws RSQLException, org.apache.thrift.TException
    {
      send_connection_rollback(connection);
      recv_connection_rollback();
    }

    public void send_connection_rollback(RConnection connection) throws org.apache.thrift.TException
    {
      connection_rollback_args args = new connection_rollback_args();
      args.setConnection(connection);
      sendBase("connection_rollback", args);
    }

    public void recv_connection_rollback() throws RSQLException, org.apache.thrift.TException
    {
      connection_rollback_result result = new connection_rollback_result();
      receiveBase(result, "connection_rollback");
      if (result.sqlException != null) {
        throw result.sqlException;
      }
      return;
    }

    public void connection_setAutoCommit(RConnection connection, boolean autoCommit) throws RSQLException, org.apache.thrift.TException
    {
      send_connection_setAutoCommit(connection, autoCommit);
      recv_connection_setAutoCommit();
    }

    public void send_connection_setAutoCommit(RConnection connection, boolean autoCommit) throws org.apache.thrift.TException
    {
      connection_setAutoCommit_args args = new connection_setAutoCommit_args();
      args.setConnection(connection);
      args.setAutoCommit(autoCommit);
      sendBase("connection_setAutoCommit", args);
    }

    public void recv_connection_setAutoCommit() throws RSQLException, org.apache.thrift.TException
    {
      connection_setAutoCommit_result result = new connection_setAutoCommit_result();
      receiveBase(result, "connection_setAutoCommit");
      if (result.sqlException != null) {
        throw result.sqlException;
      }
      return;
    }

    public boolean connection_getAutoCommit(RConnection connection) throws RSQLException, org.apache.thrift.TException
    {
      send_connection_getAutoCommit(connection);
      return recv_connection_getAutoCommit();
    }

    public void send_connection_getAutoCommit(RConnection connection) throws org.apache.thrift.TException
    {
      connection_getAutoCommit_args args = new connection_getAutoCommit_args();
      args.setConnection(connection);
      sendBase("connection_getAutoCommit", args);
    }

    public boolean recv_connection_getAutoCommit() throws RSQLException, org.apache.thrift.TException
    {
      connection_getAutoCommit_result result = new connection_getAutoCommit_result();
      receiveBase(result, "connection_getAutoCommit");
      if (result.isSetSuccess()) {
        return result.success;
      }
      if (result.sqlException != null) {
        throw result.sqlException;
      }
      throw new org.apache.thrift.TApplicationException(org.apache.thrift.TApplicationException.MISSING_RESULT, "connection_getAutoCommit failed: unknown result");
    }

    public void connection_setTransactionIsolation(RConnection connection, int level) throws RSQLException, org.apache.thrift.TException
    {
      send_connection_setTransactionIsolation(connection, level);
      recv_connection_setTransactionIsolation();
    }

    public void send_connection_setTransactionIsolation(RConnection connection, int level) throws org.apache.thrift.TException
    {
      connection_setTransactionIsolation_args args = new connection_setTransactionIsolation_args();
      args.setConnection(connection);
      args.setLevel(level);
      sendBase("connection_setTransactionIsolation", args);
    }

    public void recv_connection_setTransactionIsolation() throws RSQLException, org.apache.thrift.TException
    {
      connection_setTransactionIsolation_result result = new connection_setTransactionIsolation_result();
      receiveBase(result, "connection_setTransactionIsolation");
      if (result.sqlException != null) {
        throw result.sqlException;
      }
      return;
    }

    public int connection_getTransactionIsolation(RConnection connection) throws RSQLException, org.apache.thrift.TException
    {
      send_connection_getTransactionIsolation(connection);
      return recv_connection_getTransactionIsolation();
    }

    public void send_connection_getTransactionIsolation(RConnection connection) throws org.apache.thrift.TException
    {
      connection_getTransactionIsolation_args args = new connection_getTransactionIsolation_args();
      args.setConnection(connection);
      sendBase("connection_getTransactionIsolation", args);
    }

    public int recv_connection_getTransactionIsolation() throws RSQLException, org.apache.thrift.TException
    {
      connection_getTransactionIsolation_result result = new connection_getTransactionIsolation_result();
      receiveBase(result, "connection_getTransactionIsolation");
      if (result.isSetSuccess()) {
        return result.success;
      }
      if (result.sqlException != null) {
        throw result.sqlException;
      }
      throw new org.apache.thrift.TApplicationException(org.apache.thrift.TApplicationException.MISSING_RESULT, "connection_getTransactionIsolation failed: unknown result");
    }

    public void connection_setReadOnly(RConnection connection, boolean readOnly) throws RSQLException, org.apache.thrift.TException
    {
      send_connection_setReadOnly(connection, readOnly);
      recv_connection_setReadOnly();
    }

    public void send_connection_setReadOnly(RConnection connection, boolean readOnly) throws org.apache.thrift.TException
    {
      connection_setReadOnly_args args = new connection_setReadOnly_args();
      args.setConnection(connection);
      args.setReadOnly(readOnly);
      sendBase("connection_setReadOnly", args);
    }

    public void recv_connection_setReadOnly() throws RSQLException, org.apache.thrift.TException
    {
      connection_setReadOnly_result result = new connection_setReadOnly_result();
      receiveBase(result, "connection_setReadOnly");
      if (result.sqlException != null) {
        throw result.sqlException;
      }
      return;
    }

    public boolean connection_getReadOnly(RConnection connection) throws RSQLException, org.apache.thrift.TException
    {
      send_connection_getReadOnly(connection);
      return recv_connection_getReadOnly();
    }

    public void send_connection_getReadOnly(RConnection connection) throws org.apache.thrift.TException
    {
      connection_getReadOnly_args args = new connection_getReadOnly_args();
      args.setConnection(connection);
      sendBase("connection_getReadOnly", args);
    }

    public boolean recv_connection_getReadOnly() throws RSQLException, org.apache.thrift.TException
    {
      connection_getReadOnly_result result = new connection_getReadOnly_result();
      receiveBase(result, "connection_getReadOnly");
      if (result.isSetSuccess()) {
        return result.success;
      }
      if (result.sqlException != null) {
        throw result.sqlException;
      }
      throw new org.apache.thrift.TApplicationException(org.apache.thrift.TApplicationException.MISSING_RESULT, "connection_getReadOnly failed: unknown result");
    }

    public void connection_setCatalog(RConnection connection, String catalog) throws RSQLException, org.apache.thrift.TException
    {
      send_connection_setCatalog(connection, catalog);
      recv_connection_setCatalog();
    }

    public void send_connection_setCatalog(RConnection connection, String catalog) throws org.apache.thrift.TException
    {
      connection_setCatalog_args args = new connection_setCatalog_args();
      args.setConnection(connection);
      args.setCatalog(catalog);
      sendBase("connection_setCatalog", args);
    }

    public void recv_connection_setCatalog() throws RSQLException, org.apache.thrift.TException
    {
      connection_setCatalog_result result = new connection_setCatalog_result();
      receiveBase(result, "connection_setCatalog");
      if (result.sqlException != null) {
        throw result.sqlException;
      }
      return;
    }

    public String connection_getCatalog(RConnection connection) throws RSQLException, org.apache.thrift.TException
    {
      send_connection_getCatalog(connection);
      return recv_connection_getCatalog();
    }

    public void send_connection_getCatalog(RConnection connection) throws org.apache.thrift.TException
    {
      connection_getCatalog_args args = new connection_getCatalog_args();
      args.setConnection(connection);
      sendBase("connection_getCatalog", args);
    }

    public String recv_connection_getCatalog() throws RSQLException, org.apache.thrift.TException
    {
      connection_getCatalog_result result = new connection_getCatalog_result();
      receiveBase(result, "connection_getCatalog");
      if (result.isSetSuccess()) {
        return result.success;
      }
      if (result.sqlException != null) {
        throw result.sqlException;
      }
      throw new org.apache.thrift.TApplicationException(org.apache.thrift.TApplicationException.MISSING_RESULT, "connection_getCatalog failed: unknown result");
    }

    public void connection_setSchema(RConnection connection, String schema) throws RSQLException, org.apache.thrift.TException
    {
      send_connection_setSchema(connection, schema);
      recv_connection_setSchema();
    }

    public void send_connection_setSchema(RConnection connection, String schema) throws org.apache.thrift.TException
    {
      connection_setSchema_args args = new connection_setSchema_args();
      args.setConnection(connection);
      args.setSchema(schema);
      sendBase("connection_setSchema", args);
    }

    public void recv_connection_setSchema() throws RSQLException, org.apache.thrift.TException
    {
      connection_setSchema_result result = new connection_setSchema_result();
      receiveBase(result, "connection_setSchema");
      if (result.sqlException != null) {
        throw result.sqlException;
      }
      return;
    }

    public String connection_getSchema(RConnection connection) throws RSQLException, org.apache.thrift.TException
    {
      send_connection_getSchema(connection);
      return recv_connection_getSchema();
    }

    public void send_connection_getSchema(RConnection connection) throws org.apache.thrift.TException
    {
      connection_getSchema_args args = new connection_getSchema_args();
      args.setConnection(connection);
      sendBase("connection_getSchema", args);
    }

    public String recv_connection_getSchema() throws RSQLException, org.apache.thrift.TException
    {
      connection_getSchema_result result = new connection_getSchema_result();
      receiveBase(result, "connection_getSchema");
      if (result.isSetSuccess()) {
        return result.success;
      }
      if (result.sqlException != null) {
        throw result.sqlException;
      }
      throw new org.apache.thrift.TApplicationException(org.apache.thrift.TApplicationException.MISSING_RESULT, "connection_getSchema failed: unknown result");
    }

    public String connection_getCatalogSeparator(RConnection connection) throws RSQLException, org.apache.thrift.TException
    {
      send_connection_getCatalogSeparator(connection);
      return recv_connection_getCatalogSeparator();
    }

    public void send_connection_getCatalogSeparator(RConnection connection) throws org.apache.thrift.TException
    {
      connection_getCatalogSeparator_args args = new connection_getCatalogSeparator_args();
      args.setConnection(connection);
      sendBase("connection_getCatalogSeparator", args);
    }

    public String recv_connection_getCatalogSeparator() throws RSQLException, org.apache.thrift.TException
    {
      connection_getCatalogSeparator_result result = new connection_getCatalogSeparator_result();
      receiveBase(result, "connection_getCatalogSeparator");
      if (result.isSetSuccess()) {
        return result.success;
      }
      if (result.sqlException != null) {
        throw result.sqlException;
      }
      throw new org.apache.thrift.TApplicationException(org.apache.thrift.TApplicationException.MISSING_RESULT, "connection_getCatalogSeparator failed: unknown result");
    }

    public String connection_getCatalogTerm(RConnection connection) throws RSQLException, org.apache.thrift.TException
    {
      send_connection_getCatalogTerm(connection);
      return recv_connection_getCatalogTerm();
    }

    public void send_connection_getCatalogTerm(RConnection connection) throws org.apache.thrift.TException
    {
      connection_getCatalogTerm_args args = new connection_getCatalogTerm_args();
      args.setConnection(connection);
      sendBase("connection_getCatalogTerm", args);
    }

    public String recv_connection_getCatalogTerm() throws RSQLException, org.apache.thrift.TException
    {
      connection_getCatalogTerm_result result = new connection_getCatalogTerm_result();
      receiveBase(result, "connection_getCatalogTerm");
      if (result.isSetSuccess()) {
        return result.success;
      }
      if (result.sqlException != null) {
        throw result.sqlException;
      }
      throw new org.apache.thrift.TApplicationException(org.apache.thrift.TApplicationException.MISSING_RESULT, "connection_getCatalogTerm failed: unknown result");
    }

    public String connection_getSchemaTerm(RConnection connection) throws RSQLException, org.apache.thrift.TException
    {
      send_connection_getSchemaTerm(connection);
      return recv_connection_getSchemaTerm();
    }

    public void send_connection_getSchemaTerm(RConnection connection) throws org.apache.thrift.TException
    {
      connection_getSchemaTerm_args args = new connection_getSchemaTerm_args();
      args.setConnection(connection);
      sendBase("connection_getSchemaTerm", args);
    }

    public String recv_connection_getSchemaTerm() throws RSQLException, org.apache.thrift.TException
    {
      connection_getSchemaTerm_result result = new connection_getSchemaTerm_result();
      receiveBase(result, "connection_getSchemaTerm");
      if (result.isSetSuccess()) {
        return result.success;
      }
      if (result.sqlException != null) {
        throw result.sqlException;
      }
      throw new org.apache.thrift.TApplicationException(org.apache.thrift.TApplicationException.MISSING_RESULT, "connection_getSchemaTerm failed: unknown result");
    }

    public RResultSet connection_getCatalogs(RConnection connection) throws RSQLException, org.apache.thrift.TException
    {
      send_connection_getCatalogs(connection);
      return recv_connection_getCatalogs();
    }

    public void send_connection_getCatalogs(RConnection connection) throws org.apache.thrift.TException
    {
      connection_getCatalogs_args args = new connection_getCatalogs_args();
      args.setConnection(connection);
      sendBase("connection_getCatalogs", args);
    }

    public RResultSet recv_connection_getCatalogs() throws RSQLException, org.apache.thrift.TException
    {
      connection_getCatalogs_result result = new connection_getCatalogs_result();
      receiveBase(result, "connection_getCatalogs");
      if (result.isSetSuccess()) {
        return result.success;
      }
      if (result.sqlException != null) {
        throw result.sqlException;
      }
      throw new org.apache.thrift.TApplicationException(org.apache.thrift.TApplicationException.MISSING_RESULT, "connection_getCatalogs failed: unknown result");
    }

    public RResultSet connection_getSchemas(RConnection connection, String catalog, String schemaPattern) throws RSQLException, org.apache.thrift.TException
    {
      send_connection_getSchemas(connection, catalog, schemaPattern);
      return recv_connection_getSchemas();
    }

    public void send_connection_getSchemas(RConnection connection, String catalog, String schemaPattern) throws org.apache.thrift.TException
    {
      connection_getSchemas_args args = new connection_getSchemas_args();
      args.setConnection(connection);
      args.setCatalog(catalog);
      args.setSchemaPattern(schemaPattern);
      sendBase("connection_getSchemas", args);
    }

    public RResultSet recv_connection_getSchemas() throws RSQLException, org.apache.thrift.TException
    {
      connection_getSchemas_result result = new connection_getSchemas_result();
      receiveBase(result, "connection_getSchemas");
      if (result.isSetSuccess()) {
        return result.success;
      }
      if (result.sqlException != null) {
        throw result.sqlException;
      }
      throw new org.apache.thrift.TApplicationException(org.apache.thrift.TApplicationException.MISSING_RESULT, "connection_getSchemas failed: unknown result");
    }

    public RResultSet connection_getTables(RConnection connection, String catalog, String schemaPattern, String tableNamePattern, List<String> types) throws RSQLException, org.apache.thrift.TException
    {
      send_connection_getTables(connection, catalog, schemaPattern, tableNamePattern, types);
      return recv_connection_getTables();
    }

    public void send_connection_getTables(RConnection connection, String catalog, String schemaPattern, String tableNamePattern, List<String> types) throws org.apache.thrift.TException
    {
      connection_getTables_args args = new connection_getTables_args();
      args.setConnection(connection);
      args.setCatalog(catalog);
      args.setSchemaPattern(schemaPattern);
      args.setTableNamePattern(tableNamePattern);
      args.setTypes(types);
      sendBase("connection_getTables", args);
    }

    public RResultSet recv_connection_getTables() throws RSQLException, org.apache.thrift.TException
    {
      connection_getTables_result result = new connection_getTables_result();
      receiveBase(result, "connection_getTables");
      if (result.isSetSuccess()) {
        return result.success;
      }
      if (result.sqlException != null) {
        throw result.sqlException;
      }
      throw new org.apache.thrift.TApplicationException(org.apache.thrift.TApplicationException.MISSING_RESULT, "connection_getTables failed: unknown result");
    }

    public RResultSet connection_getColumns(RConnection connection, String catalog, String schemaPattern, String tableNamePattern, String columnNamePattern) throws RSQLException, org.apache.thrift.TException
    {
      send_connection_getColumns(connection, catalog, schemaPattern, tableNamePattern, columnNamePattern);
      return recv_connection_getColumns();
    }

    public void send_connection_getColumns(RConnection connection, String catalog, String schemaPattern, String tableNamePattern, String columnNamePattern) throws org.apache.thrift.TException
    {
      connection_getColumns_args args = new connection_getColumns_args();
      args.setConnection(connection);
      args.setCatalog(catalog);
      args.setSchemaPattern(schemaPattern);
      args.setTableNamePattern(tableNamePattern);
      args.setColumnNamePattern(columnNamePattern);
      sendBase("connection_getColumns", args);
    }

    public RResultSet recv_connection_getColumns() throws RSQLException, org.apache.thrift.TException
    {
      connection_getColumns_result result = new connection_getColumns_result();
      receiveBase(result, "connection_getColumns");
      if (result.isSetSuccess()) {
        return result.success;
      }
      if (result.sqlException != null) {
        throw result.sqlException;
      }
      throw new org.apache.thrift.TApplicationException(org.apache.thrift.TApplicationException.MISSING_RESULT, "connection_getColumns failed: unknown result");
    }

    public String connection_getSQLKeywords(RConnection connection) throws RSQLException, org.apache.thrift.TException
    {
      send_connection_getSQLKeywords(connection);
      return recv_connection_getSQLKeywords();
    }

    public void send_connection_getSQLKeywords(RConnection connection) throws org.apache.thrift.TException
    {
      connection_getSQLKeywords_args args = new connection_getSQLKeywords_args();
      args.setConnection(connection);
      sendBase("connection_getSQLKeywords", args);
    }

    public String recv_connection_getSQLKeywords() throws RSQLException, org.apache.thrift.TException
    {
      connection_getSQLKeywords_result result = new connection_getSQLKeywords_result();
      receiveBase(result, "connection_getSQLKeywords");
      if (result.isSetSuccess()) {
        return result.success;
      }
      if (result.sqlException != null) {
        throw result.sqlException;
      }
      throw new org.apache.thrift.TApplicationException(org.apache.thrift.TApplicationException.MISSING_RESULT, "connection_getSQLKeywords failed: unknown result");
    }

    public RResultSet connection_getTableTypes(RConnection connection) throws RSQLException, org.apache.thrift.TException
    {
      send_connection_getTableTypes(connection);
      return recv_connection_getTableTypes();
    }

    public void send_connection_getTableTypes(RConnection connection) throws org.apache.thrift.TException
    {
      connection_getTableTypes_args args = new connection_getTableTypes_args();
      args.setConnection(connection);
      sendBase("connection_getTableTypes", args);
    }

    public RResultSet recv_connection_getTableTypes() throws RSQLException, org.apache.thrift.TException
    {
      connection_getTableTypes_result result = new connection_getTableTypes_result();
      receiveBase(result, "connection_getTableTypes");
      if (result.isSetSuccess()) {
        return result.success;
      }
      if (result.sqlException != null) {
        throw result.sqlException;
      }
      throw new org.apache.thrift.TApplicationException(org.apache.thrift.TApplicationException.MISSING_RESULT, "connection_getTableTypes failed: unknown result");
    }

    public RResultSet connection_getTypeInfo(RConnection connection) throws RSQLException, org.apache.thrift.TException
    {
      send_connection_getTypeInfo(connection);
      return recv_connection_getTypeInfo();
    }

    public void send_connection_getTypeInfo(RConnection connection) throws org.apache.thrift.TException
    {
      connection_getTypeInfo_args args = new connection_getTypeInfo_args();
      args.setConnection(connection);
      sendBase("connection_getTypeInfo", args);
    }

    public RResultSet recv_connection_getTypeInfo() throws RSQLException, org.apache.thrift.TException
    {
      connection_getTypeInfo_result result = new connection_getTypeInfo_result();
      receiveBase(result, "connection_getTypeInfo");
      if (result.isSetSuccess()) {
        return result.success;
      }
      if (result.sqlException != null) {
        throw result.sqlException;
      }
      throw new org.apache.thrift.TApplicationException(org.apache.thrift.TApplicationException.MISSING_RESULT, "connection_getTypeInfo failed: unknown result");
    }

    public void closeConnection(RConnection connection) throws RSQLException, org.apache.thrift.TException
    {
      send_closeConnection(connection);
      recv_closeConnection();
    }

    public void send_closeConnection(RConnection connection) throws org.apache.thrift.TException
    {
      closeConnection_args args = new closeConnection_args();
      args.setConnection(connection);
      sendBase("closeConnection", args);
    }

    public void recv_closeConnection() throws RSQLException, org.apache.thrift.TException
    {
      closeConnection_result result = new closeConnection_result();
      receiveBase(result, "closeConnection");
      if (result.sqlException != null) {
        throw result.sqlException;
      }
      return;
    }

    public void statement_close(RStatement statement) throws RSQLException, org.apache.thrift.TException
    {
      send_statement_close(statement);
      recv_statement_close();
    }

    public void send_statement_close(RStatement statement) throws org.apache.thrift.TException
    {
      statement_close_args args = new statement_close_args();
      args.setStatement(statement);
      sendBase("statement_close", args);
    }

    public void recv_statement_close() throws RSQLException, org.apache.thrift.TException
    {
      statement_close_result result = new statement_close_result();
      receiveBase(result, "statement_close");
      if (result.sqlException != null) {
        throw result.sqlException;
      }
      return;
    }

    public boolean statement_execute(RStatement statement, String sql) throws RSQLException, org.apache.thrift.TException
    {
      send_statement_execute(statement, sql);
      return recv_statement_execute();
    }

    public void send_statement_execute(RStatement statement, String sql) throws org.apache.thrift.TException
    {
      statement_execute_args args = new statement_execute_args();
      args.setStatement(statement);
      args.setSql(sql);
      sendBase("statement_execute", args);
    }

    public boolean recv_statement_execute() throws RSQLException, org.apache.thrift.TException
    {
      statement_execute_result result = new statement_execute_result();
      receiveBase(result, "statement_execute");
      if (result.isSetSuccess()) {
        return result.success;
      }
      if (result.sqlException != null) {
        throw result.sqlException;
      }
      throw new org.apache.thrift.TApplicationException(org.apache.thrift.TApplicationException.MISSING_RESULT, "statement_execute failed: unknown result");
    }

    public RResultSet statement_executeQuery(RStatement statement, String sql) throws RSQLException, org.apache.thrift.TException
    {
      send_statement_executeQuery(statement, sql);
      return recv_statement_executeQuery();
    }

    public void send_statement_executeQuery(RStatement statement, String sql) throws org.apache.thrift.TException
    {
      statement_executeQuery_args args = new statement_executeQuery_args();
      args.setStatement(statement);
      args.setSql(sql);
      sendBase("statement_executeQuery", args);
    }

    public RResultSet recv_statement_executeQuery() throws RSQLException, org.apache.thrift.TException
    {
      statement_executeQuery_result result = new statement_executeQuery_result();
      receiveBase(result, "statement_executeQuery");
      if (result.isSetSuccess()) {
        return result.success;
      }
      if (result.sqlException != null) {
        throw result.sqlException;
      }
      throw new org.apache.thrift.TApplicationException(org.apache.thrift.TApplicationException.MISSING_RESULT, "statement_executeQuery failed: unknown result");
    }

    public int statement_executeUpdate(RStatement statement, String sql) throws RSQLException, org.apache.thrift.TException
    {
      send_statement_executeUpdate(statement, sql);
      return recv_statement_executeUpdate();
    }

    public void send_statement_executeUpdate(RStatement statement, String sql) throws org.apache.thrift.TException
    {
      statement_executeUpdate_args args = new statement_executeUpdate_args();
      args.setStatement(statement);
      args.setSql(sql);
      sendBase("statement_executeUpdate", args);
    }

    public int recv_statement_executeUpdate() throws RSQLException, org.apache.thrift.TException
    {
      statement_executeUpdate_result result = new statement_executeUpdate_result();
      receiveBase(result, "statement_executeUpdate");
      if (result.isSetSuccess()) {
        return result.success;
      }
      if (result.sqlException != null) {
        throw result.sqlException;
      }
      throw new org.apache.thrift.TApplicationException(org.apache.thrift.TApplicationException.MISSING_RESULT, "statement_executeUpdate failed: unknown result");
    }

    public RResultSet statement_getResultSet(RStatement statement) throws RSQLException, org.apache.thrift.TException
    {
      send_statement_getResultSet(statement);
      return recv_statement_getResultSet();
    }

    public void send_statement_getResultSet(RStatement statement) throws org.apache.thrift.TException
    {
      statement_getResultSet_args args = new statement_getResultSet_args();
      args.setStatement(statement);
      sendBase("statement_getResultSet", args);
    }

    public RResultSet recv_statement_getResultSet() throws RSQLException, org.apache.thrift.TException
    {
      statement_getResultSet_result result = new statement_getResultSet_result();
      receiveBase(result, "statement_getResultSet");
      if (result.isSetSuccess()) {
        return result.success;
      }
      if (result.sqlException != null) {
        throw result.sqlException;
      }
      throw new org.apache.thrift.TApplicationException(org.apache.thrift.TApplicationException.MISSING_RESULT, "statement_getResultSet failed: unknown result");
    }

    public int statement_getUpdateCount(RStatement statement) throws RSQLException, org.apache.thrift.TException
    {
      send_statement_getUpdateCount(statement);
      return recv_statement_getUpdateCount();
    }

    public void send_statement_getUpdateCount(RStatement statement) throws org.apache.thrift.TException
    {
      statement_getUpdateCount_args args = new statement_getUpdateCount_args();
      args.setStatement(statement);
      sendBase("statement_getUpdateCount", args);
    }

    public int recv_statement_getUpdateCount() throws RSQLException, org.apache.thrift.TException
    {
      statement_getUpdateCount_result result = new statement_getUpdateCount_result();
      receiveBase(result, "statement_getUpdateCount");
      if (result.isSetSuccess()) {
        return result.success;
      }
      if (result.sqlException != null) {
        throw result.sqlException;
      }
      throw new org.apache.thrift.TApplicationException(org.apache.thrift.TApplicationException.MISSING_RESULT, "statement_getUpdateCount failed: unknown result");
    }

    public int statement_getResultSetType(RStatement statement) throws RSQLException, org.apache.thrift.TException
    {
      send_statement_getResultSetType(statement);
      return recv_statement_getResultSetType();
    }

    public void send_statement_getResultSetType(RStatement statement) throws org.apache.thrift.TException
    {
      statement_getResultSetType_args args = new statement_getResultSetType_args();
      args.setStatement(statement);
      sendBase("statement_getResultSetType", args);
    }

    public int recv_statement_getResultSetType() throws RSQLException, org.apache.thrift.TException
    {
      statement_getResultSetType_result result = new statement_getResultSetType_result();
      receiveBase(result, "statement_getResultSetType");
      if (result.isSetSuccess()) {
        return result.success;
      }
      if (result.sqlException != null) {
        throw result.sqlException;
      }
      throw new org.apache.thrift.TApplicationException(org.apache.thrift.TApplicationException.MISSING_RESULT, "statement_getResultSetType failed: unknown result");
    }

    public void statement_cancel(RStatement statement) throws RSQLException, org.apache.thrift.TException
    {
      send_statement_cancel(statement);
      recv_statement_cancel();
    }

    public void send_statement_cancel(RStatement statement) throws org.apache.thrift.TException
    {
      statement_cancel_args args = new statement_cancel_args();
      args.setStatement(statement);
      sendBase("statement_cancel", args);
    }

    public void recv_statement_cancel() throws RSQLException, org.apache.thrift.TException
    {
      statement_cancel_result result = new statement_cancel_result();
      receiveBase(result, "statement_cancel");
      if (result.sqlException != null) {
        throw result.sqlException;
      }
      return;
    }

    public void statement_addBatch(RStatement statement, String sql) throws RSQLException, org.apache.thrift.TException
    {
      send_statement_addBatch(statement, sql);
      recv_statement_addBatch();
    }

    public void send_statement_addBatch(RStatement statement, String sql) throws org.apache.thrift.TException
    {
      statement_addBatch_args args = new statement_addBatch_args();
      args.setStatement(statement);
      args.setSql(sql);
      sendBase("statement_addBatch", args);
    }

    public void recv_statement_addBatch() throws RSQLException, org.apache.thrift.TException
    {
      statement_addBatch_result result = new statement_addBatch_result();
      receiveBase(result, "statement_addBatch");
      if (result.sqlException != null) {
        throw result.sqlException;
      }
      return;
    }

    public void statement_addBatches(RStatement statement, List<String> sqlList) throws RSQLException, org.apache.thrift.TException
    {
      send_statement_addBatches(statement, sqlList);
      recv_statement_addBatches();
    }

    public void send_statement_addBatches(RStatement statement, List<String> sqlList) throws org.apache.thrift.TException
    {
      statement_addBatches_args args = new statement_addBatches_args();
      args.setStatement(statement);
      args.setSqlList(sqlList);
      sendBase("statement_addBatches", args);
    }

    public void recv_statement_addBatches() throws RSQLException, org.apache.thrift.TException
    {
      statement_addBatches_result result = new statement_addBatches_result();
      receiveBase(result, "statement_addBatches");
      if (result.sqlException != null) {
        throw result.sqlException;
      }
      return;
    }

    public void statement_clearBatch(RStatement statement) throws RSQLException, org.apache.thrift.TException
    {
      send_statement_clearBatch(statement);
      recv_statement_clearBatch();
    }

    public void send_statement_clearBatch(RStatement statement) throws org.apache.thrift.TException
    {
      statement_clearBatch_args args = new statement_clearBatch_args();
      args.setStatement(statement);
      sendBase("statement_clearBatch", args);
    }

    public void recv_statement_clearBatch() throws RSQLException, org.apache.thrift.TException
    {
      statement_clearBatch_result result = new statement_clearBatch_result();
      receiveBase(result, "statement_clearBatch");
      if (result.sqlException != null) {
        throw result.sqlException;
      }
      return;
    }

    public List<Integer> statement_executeBatch(RStatement statement) throws RSQLException, org.apache.thrift.TException
    {
      send_statement_executeBatch(statement);
      return recv_statement_executeBatch();
    }

    public void send_statement_executeBatch(RStatement statement) throws org.apache.thrift.TException
    {
      statement_executeBatch_args args = new statement_executeBatch_args();
      args.setStatement(statement);
      sendBase("statement_executeBatch", args);
    }

    public List<Integer> recv_statement_executeBatch() throws RSQLException, org.apache.thrift.TException
    {
      statement_executeBatch_result result = new statement_executeBatch_result();
      receiveBase(result, "statement_executeBatch");
      if (result.isSetSuccess()) {
        return result.success;
      }
      if (result.sqlException != null) {
        throw result.sqlException;
      }
      throw new org.apache.thrift.TApplicationException(org.apache.thrift.TApplicationException.MISSING_RESULT, "statement_executeBatch failed: unknown result");
    }

    public boolean preparedstatement_execute(RStatement preparedstatement) throws RSQLException, org.apache.thrift.TException
    {
      send_preparedstatement_execute(preparedstatement);
      return recv_preparedstatement_execute();
    }

    public void send_preparedstatement_execute(RStatement preparedstatement) throws org.apache.thrift.TException
    {
      preparedstatement_execute_args args = new preparedstatement_execute_args();
      args.setPreparedstatement(preparedstatement);
      sendBase("preparedstatement_execute", args);
    }

    public boolean recv_preparedstatement_execute() throws RSQLException, org.apache.thrift.TException
    {
      preparedstatement_execute_result result = new preparedstatement_execute_result();
      receiveBase(result, "preparedstatement_execute");
      if (result.isSetSuccess()) {
        return result.success;
      }
      if (result.sqlException != null) {
        throw result.sqlException;
      }
      throw new org.apache.thrift.TApplicationException(org.apache.thrift.TApplicationException.MISSING_RESULT, "preparedstatement_execute failed: unknown result");
    }

    public RResultSet preparedstatement_executeQuery(RStatement preparedstatement) throws RSQLException, org.apache.thrift.TException
    {
      send_preparedstatement_executeQuery(preparedstatement);
      return recv_preparedstatement_executeQuery();
    }

    public void send_preparedstatement_executeQuery(RStatement preparedstatement) throws org.apache.thrift.TException
    {
      preparedstatement_executeQuery_args args = new preparedstatement_executeQuery_args();
      args.setPreparedstatement(preparedstatement);
      sendBase("preparedstatement_executeQuery", args);
    }

    public RResultSet recv_preparedstatement_executeQuery() throws RSQLException, org.apache.thrift.TException
    {
      preparedstatement_executeQuery_result result = new preparedstatement_executeQuery_result();
      receiveBase(result, "preparedstatement_executeQuery");
      if (result.isSetSuccess()) {
        return result.success;
      }
      if (result.sqlException != null) {
        throw result.sqlException;
      }
      throw new org.apache.thrift.TApplicationException(org.apache.thrift.TApplicationException.MISSING_RESULT, "preparedstatement_executeQuery failed: unknown result");
    }

    public int preparedstatement_executeUpdate(RStatement preparedstatement) throws RSQLException, org.apache.thrift.TException
    {
      send_preparedstatement_executeUpdate(preparedstatement);
      return recv_preparedstatement_executeUpdate();
    }

    public void send_preparedstatement_executeUpdate(RStatement preparedstatement) throws org.apache.thrift.TException
    {
      preparedstatement_executeUpdate_args args = new preparedstatement_executeUpdate_args();
      args.setPreparedstatement(preparedstatement);
      sendBase("preparedstatement_executeUpdate", args);
    }

    public int recv_preparedstatement_executeUpdate() throws RSQLException, org.apache.thrift.TException
    {
      preparedstatement_executeUpdate_result result = new preparedstatement_executeUpdate_result();
      receiveBase(result, "preparedstatement_executeUpdate");
      if (result.isSetSuccess()) {
        return result.success;
      }
      if (result.sqlException != null) {
        throw result.sqlException;
      }
      throw new org.apache.thrift.TApplicationException(org.apache.thrift.TApplicationException.MISSING_RESULT, "preparedstatement_executeUpdate failed: unknown result");
    }

    public boolean preparedstatement_setParametersThenExecute(RStatement preparedstatement, List<RValueSQL> parameters) throws RSQLException, org.apache.thrift.TException
    {
      send_preparedstatement_setParametersThenExecute(preparedstatement, parameters);
      return recv_preparedstatement_setParametersThenExecute();
    }

    public void send_preparedstatement_setParametersThenExecute(RStatement preparedstatement, List<RValueSQL> parameters) throws org.apache.thrift.TException
    {
      preparedstatement_setParametersThenExecute_args args = new preparedstatement_setParametersThenExecute_args();
      args.setPreparedstatement(preparedstatement);
      args.setParameters(parameters);
      sendBase("preparedstatement_setParametersThenExecute", args);
    }

    public boolean recv_preparedstatement_setParametersThenExecute() throws RSQLException, org.apache.thrift.TException
    {
      preparedstatement_setParametersThenExecute_result result = new preparedstatement_setParametersThenExecute_result();
      receiveBase(result, "preparedstatement_setParametersThenExecute");
      if (result.isSetSuccess()) {
        return result.success;
      }
      if (result.sqlException != null) {
        throw result.sqlException;
      }
      throw new org.apache.thrift.TApplicationException(org.apache.thrift.TApplicationException.MISSING_RESULT, "preparedstatement_setParametersThenExecute failed: unknown result");
    }

    public RResultSet preparedstatement_setParametersThenExecuteQuery(RStatement preparedstatement, List<RValueSQL> parameters) throws RSQLException, org.apache.thrift.TException
    {
      send_preparedstatement_setParametersThenExecuteQuery(preparedstatement, parameters);
      return recv_preparedstatement_setParametersThenExecuteQuery();
    }

    public void send_preparedstatement_setParametersThenExecuteQuery(RStatement preparedstatement, List<RValueSQL> parameters) throws org.apache.thrift.TException
    {
      preparedstatement_setParametersThenExecuteQuery_args args = new preparedstatement_setParametersThenExecuteQuery_args();
      args.setPreparedstatement(preparedstatement);
      args.setParameters(parameters);
      sendBase("preparedstatement_setParametersThenExecuteQuery", args);
    }

    public RResultSet recv_preparedstatement_setParametersThenExecuteQuery() throws RSQLException, org.apache.thrift.TException
    {
      preparedstatement_setParametersThenExecuteQuery_result result = new preparedstatement_setParametersThenExecuteQuery_result();
      receiveBase(result, "preparedstatement_setParametersThenExecuteQuery");
      if (result.isSetSuccess()) {
        return result.success;
      }
      if (result.sqlException != null) {
        throw result.sqlException;
      }
      throw new org.apache.thrift.TApplicationException(org.apache.thrift.TApplicationException.MISSING_RESULT, "preparedstatement_setParametersThenExecuteQuery failed: unknown result");
    }

    public int preparedstatement_setParametersThenExecuteUpdate(RStatement preparedstatement, List<RValueSQL> parameters) throws RSQLException, org.apache.thrift.TException
    {
      send_preparedstatement_setParametersThenExecuteUpdate(preparedstatement, parameters);
      return recv_preparedstatement_setParametersThenExecuteUpdate();
    }

    public void send_preparedstatement_setParametersThenExecuteUpdate(RStatement preparedstatement, List<RValueSQL> parameters) throws org.apache.thrift.TException
    {
      preparedstatement_setParametersThenExecuteUpdate_args args = new preparedstatement_setParametersThenExecuteUpdate_args();
      args.setPreparedstatement(preparedstatement);
      args.setParameters(parameters);
      sendBase("preparedstatement_setParametersThenExecuteUpdate", args);
    }

    public int recv_preparedstatement_setParametersThenExecuteUpdate() throws RSQLException, org.apache.thrift.TException
    {
      preparedstatement_setParametersThenExecuteUpdate_result result = new preparedstatement_setParametersThenExecuteUpdate_result();
      receiveBase(result, "preparedstatement_setParametersThenExecuteUpdate");
      if (result.isSetSuccess()) {
        return result.success;
      }
      if (result.sqlException != null) {
        throw result.sqlException;
      }
      throw new org.apache.thrift.TApplicationException(org.apache.thrift.TApplicationException.MISSING_RESULT, "preparedstatement_setParametersThenExecuteUpdate failed: unknown result");
    }

    public void preparedstatement_setParameters(RStatement preparedStatement, List<RValueSQL> parameters) throws RSQLException, org.apache.thrift.TException
    {
      send_preparedstatement_setParameters(preparedStatement, parameters);
      recv_preparedstatement_setParameters();
    }

    public void send_preparedstatement_setParameters(RStatement preparedStatement, List<RValueSQL> parameters) throws org.apache.thrift.TException
    {
      preparedstatement_setParameters_args args = new preparedstatement_setParameters_args();
      args.setPreparedStatement(preparedStatement);
      args.setParameters(parameters);
      sendBase("preparedstatement_setParameters", args);
    }

    public void recv_preparedstatement_setParameters() throws RSQLException, org.apache.thrift.TException
    {
      preparedstatement_setParameters_result result = new preparedstatement_setParameters_result();
      receiveBase(result, "preparedstatement_setParameters");
      if (result.sqlException != null) {
        throw result.sqlException;
      }
      return;
    }

    public void preparedstatement_setParameter(RStatement preparedStatement, RValueSQL parameter, int position) throws RSQLException, org.apache.thrift.TException
    {
      send_preparedstatement_setParameter(preparedStatement, parameter, position);
      recv_preparedstatement_setParameter();
    }

    public void send_preparedstatement_setParameter(RStatement preparedStatement, RValueSQL parameter, int position) throws org.apache.thrift.TException
    {
      preparedstatement_setParameter_args args = new preparedstatement_setParameter_args();
      args.setPreparedStatement(preparedStatement);
      args.setParameter(parameter);
      args.setPosition(position);
      sendBase("preparedstatement_setParameter", args);
    }

    public void recv_preparedstatement_setParameter() throws RSQLException, org.apache.thrift.TException
    {
      preparedstatement_setParameter_result result = new preparedstatement_setParameter_result();
      receiveBase(result, "preparedstatement_setParameter");
      if (result.sqlException != null) {
        throw result.sqlException;
      }
      return;
    }

    public void preparedstatement_clearParameters(RStatement preparedStatement) throws RSQLException, org.apache.thrift.TException
    {
      send_preparedstatement_clearParameters(preparedStatement);
      recv_preparedstatement_clearParameters();
    }

    public void send_preparedstatement_clearParameters(RStatement preparedStatement) throws org.apache.thrift.TException
    {
      preparedstatement_clearParameters_args args = new preparedstatement_clearParameters_args();
      args.setPreparedStatement(preparedStatement);
      sendBase("preparedstatement_clearParameters", args);
    }

    public void recv_preparedstatement_clearParameters() throws RSQLException, org.apache.thrift.TException
    {
      preparedstatement_clearParameters_result result = new preparedstatement_clearParameters_result();
      receiveBase(result, "preparedstatement_clearParameters");
      if (result.sqlException != null) {
        throw result.sqlException;
      }
      return;
    }

    public void preparedstatement_addBatchWithParameters(RStatement preparedStatement, List<RValueSQL> parameters) throws RSQLException, org.apache.thrift.TException
    {
      send_preparedstatement_addBatchWithParameters(preparedStatement, parameters);
      recv_preparedstatement_addBatchWithParameters();
    }

    public void send_preparedstatement_addBatchWithParameters(RStatement preparedStatement, List<RValueSQL> parameters) throws org.apache.thrift.TException
    {
      preparedstatement_addBatchWithParameters_args args = new preparedstatement_addBatchWithParameters_args();
      args.setPreparedStatement(preparedStatement);
      args.setParameters(parameters);
      sendBase("preparedstatement_addBatchWithParameters", args);
    }

    public void recv_preparedstatement_addBatchWithParameters() throws RSQLException, org.apache.thrift.TException
    {
      preparedstatement_addBatchWithParameters_result result = new preparedstatement_addBatchWithParameters_result();
      receiveBase(result, "preparedstatement_addBatchWithParameters");
      if (result.sqlException != null) {
        throw result.sqlException;
      }
      return;
    }

    public void preparedstatement_addBatch(RStatement preparedStatement) throws RSQLException, org.apache.thrift.TException
    {
      send_preparedstatement_addBatch(preparedStatement);
      recv_preparedstatement_addBatch();
    }

    public void send_preparedstatement_addBatch(RStatement preparedStatement) throws org.apache.thrift.TException
    {
      preparedstatement_addBatch_args args = new preparedstatement_addBatch_args();
      args.setPreparedStatement(preparedStatement);
      sendBase("preparedstatement_addBatch", args);
    }

    public void recv_preparedstatement_addBatch() throws RSQLException, org.apache.thrift.TException
    {
      preparedstatement_addBatch_result result = new preparedstatement_addBatch_result();
      receiveBase(result, "preparedstatement_addBatch");
      if (result.sqlException != null) {
        throw result.sqlException;
      }
      return;
    }

    public List<Integer> preparedstatement_executeBatch(RStatement statement, List<List<RValueSQL>> parameters) throws RSQLException, org.apache.thrift.TException
    {
      send_preparedstatement_executeBatch(statement, parameters);
      return recv_preparedstatement_executeBatch();
    }

    public void send_preparedstatement_executeBatch(RStatement statement, List<List<RValueSQL>> parameters) throws org.apache.thrift.TException
    {
      preparedstatement_executeBatch_args args = new preparedstatement_executeBatch_args();
      args.setStatement(statement);
      args.setParameters(parameters);
      sendBase("preparedstatement_executeBatch", args);
    }

    public List<Integer> recv_preparedstatement_executeBatch() throws RSQLException, org.apache.thrift.TException
    {
      preparedstatement_executeBatch_result result = new preparedstatement_executeBatch_result();
      receiveBase(result, "preparedstatement_executeBatch");
      if (result.isSetSuccess()) {
        return result.success;
      }
      if (result.sqlException != null) {
        throw result.sqlException;
      }
      throw new org.apache.thrift.TApplicationException(org.apache.thrift.TApplicationException.MISSING_RESULT, "preparedstatement_executeBatch failed: unknown result");
    }

    public statement_getWarnings_return statement_getWarnings(RStatement statement) throws RSQLException, org.apache.thrift.TException
    {
      send_statement_getWarnings(statement);
      return recv_statement_getWarnings();
    }

    public void send_statement_getWarnings(RStatement statement) throws org.apache.thrift.TException
    {
      statement_getWarnings_args args = new statement_getWarnings_args();
      args.setStatement(statement);
      sendBase("statement_getWarnings", args);
    }

    public statement_getWarnings_return recv_statement_getWarnings() throws RSQLException, org.apache.thrift.TException
    {
      statement_getWarnings_result result = new statement_getWarnings_result();
      receiveBase(result, "statement_getWarnings");
      if (result.isSetSuccess()) {
        return result.success;
      }
      if (result.sqlException != null) {
        throw result.sqlException;
      }
      throw new org.apache.thrift.TApplicationException(org.apache.thrift.TApplicationException.MISSING_RESULT, "statement_getWarnings failed: unknown result");
    }

    public void statement_clearWarnings(RStatement statement) throws RSQLException, org.apache.thrift.TException
    {
      send_statement_clearWarnings(statement);
      recv_statement_clearWarnings();
    }

    public void send_statement_clearWarnings(RStatement statement) throws org.apache.thrift.TException
    {
      statement_clearWarnings_args args = new statement_clearWarnings_args();
      args.setStatement(statement);
      sendBase("statement_clearWarnings", args);
    }

    public void recv_statement_clearWarnings() throws RSQLException, org.apache.thrift.TException
    {
      statement_clearWarnings_result result = new statement_clearWarnings_result();
      receiveBase(result, "statement_clearWarnings");
      if (result.sqlException != null) {
        throw result.sqlException;
      }
      return;
    }

    public int statement_getMaxRows(RStatement statement) throws RSQLException, org.apache.thrift.TException
    {
      send_statement_getMaxRows(statement);
      return recv_statement_getMaxRows();
    }

    public void send_statement_getMaxRows(RStatement statement) throws org.apache.thrift.TException
    {
      statement_getMaxRows_args args = new statement_getMaxRows_args();
      args.setStatement(statement);
      sendBase("statement_getMaxRows", args);
    }

    public int recv_statement_getMaxRows() throws RSQLException, org.apache.thrift.TException
    {
      statement_getMaxRows_result result = new statement_getMaxRows_result();
      receiveBase(result, "statement_getMaxRows");
      if (result.isSetSuccess()) {
        return result.success;
      }
      if (result.sqlException != null) {
        throw result.sqlException;
      }
      throw new org.apache.thrift.TApplicationException(org.apache.thrift.TApplicationException.MISSING_RESULT, "statement_getMaxRows failed: unknown result");
    }

    public void statement_setMaxRows(RStatement statement, int max) throws RSQLException, org.apache.thrift.TException
    {
      send_statement_setMaxRows(statement, max);
      recv_statement_setMaxRows();
    }

    public void send_statement_setMaxRows(RStatement statement, int max) throws org.apache.thrift.TException
    {
      statement_setMaxRows_args args = new statement_setMaxRows_args();
      args.setStatement(statement);
      args.setMax(max);
      sendBase("statement_setMaxRows", args);
    }

    public void recv_statement_setMaxRows() throws RSQLException, org.apache.thrift.TException
    {
      statement_setMaxRows_result result = new statement_setMaxRows_result();
      receiveBase(result, "statement_setMaxRows");
      if (result.sqlException != null) {
        throw result.sqlException;
      }
      return;
    }

    public int statement_getQueryTimeout(RStatement statement) throws RSQLException, org.apache.thrift.TException
    {
      send_statement_getQueryTimeout(statement);
      return recv_statement_getQueryTimeout();
    }

    public void send_statement_getQueryTimeout(RStatement statement) throws org.apache.thrift.TException
    {
      statement_getQueryTimeout_args args = new statement_getQueryTimeout_args();
      args.setStatement(statement);
      sendBase("statement_getQueryTimeout", args);
    }

    public int recv_statement_getQueryTimeout() throws RSQLException, org.apache.thrift.TException
    {
      statement_getQueryTimeout_result result = new statement_getQueryTimeout_result();
      receiveBase(result, "statement_getQueryTimeout");
      if (result.isSetSuccess()) {
        return result.success;
      }
      if (result.sqlException != null) {
        throw result.sqlException;
      }
      throw new org.apache.thrift.TApplicationException(org.apache.thrift.TApplicationException.MISSING_RESULT, "statement_getQueryTimeout failed: unknown result");
    }

    public void statement_setQueryTimeout(RStatement statement, int seconds) throws RSQLException, org.apache.thrift.TException
    {
      send_statement_setQueryTimeout(statement, seconds);
      recv_statement_setQueryTimeout();
    }

    public void send_statement_setQueryTimeout(RStatement statement, int seconds) throws org.apache.thrift.TException
    {
      statement_setQueryTimeout_args args = new statement_setQueryTimeout_args();
      args.setStatement(statement);
      args.setSeconds(seconds);
      sendBase("statement_setQueryTimeout", args);
    }

    public void recv_statement_setQueryTimeout() throws RSQLException, org.apache.thrift.TException
    {
      statement_setQueryTimeout_result result = new statement_setQueryTimeout_result();
      receiveBase(result, "statement_setQueryTimeout");
      if (result.sqlException != null) {
        throw result.sqlException;
      }
      return;
    }

  }
  public static class AsyncClient extends org.apache.thrift.async.TAsyncClient implements AsyncIface {
    public static class Factory implements org.apache.thrift.async.TAsyncClientFactory<AsyncClient> {
      private org.apache.thrift.async.TAsyncClientManager clientManager;
      private org.apache.thrift.protocol.TProtocolFactory protocolFactory;
      public Factory(org.apache.thrift.async.TAsyncClientManager clientManager, org.apache.thrift.protocol.TProtocolFactory protocolFactory) {
        this.clientManager = clientManager;
        this.protocolFactory = protocolFactory;
      }
      public AsyncClient getAsyncClient(org.apache.thrift.transport.TNonblockingTransport transport) {
        return new AsyncClient(protocolFactory, clientManager, transport);
      }
    }

    public AsyncClient(org.apache.thrift.protocol.TProtocolFactory protocolFactory, org.apache.thrift.async.TAsyncClientManager clientManager, org.apache.thrift.transport.TNonblockingTransport transport) {
      super(protocolFactory, clientManager, transport);
    }

    public void createConnection(String url, Map<String,String> properties, org.apache.thrift.async.AsyncMethodCallback resultHandler) throws org.apache.thrift.TException {
      checkReady();
      createConnection_call method_call = new createConnection_call(url, properties, resultHandler, this, ___protocolFactory, ___transport);
      this.___currentMethod = method_call;
      ___manager.call(method_call);
    }

    public static class createConnection_call extends org.apache.thrift.async.TAsyncMethodCall {
      private String url;
      private Map<String,String> properties;
      public createConnection_call(String url, Map<String,String> properties, org.apache.thrift.async.AsyncMethodCallback resultHandler, org.apache.thrift.async.TAsyncClient client, org.apache.thrift.protocol.TProtocolFactory protocolFactory, org.apache.thrift.transport.TNonblockingTransport transport) throws org.apache.thrift.TException {
        super(client, protocolFactory, transport, resultHandler, false);
        this.url = url;
        this.properties = properties;
      }

      public void write_args(org.apache.thrift.protocol.TProtocol prot) throws org.apache.thrift.TException {
        prot.writeMessageBegin(new org.apache.thrift.protocol.TMessage("createConnection", org.apache.thrift.protocol.TMessageType.CALL, 0));
        createConnection_args args = new createConnection_args();
        args.setUrl(url);
        args.setProperties(properties);
        args.write(prot);
        prot.writeMessageEnd();
      }

      public RConnection getResult() throws RSQLException, org.apache.thrift.TException {
        if (getState() != org.apache.thrift.async.TAsyncMethodCall.State.RESPONSE_READ) {
          throw new IllegalStateException("Method call not finished!");
        }
        org.apache.thrift.transport.TMemoryInputTransport memoryTransport = new org.apache.thrift.transport.TMemoryInputTransport(getFrameBuffer().array());
        org.apache.thrift.protocol.TProtocol prot = client.getProtocolFactory().getProtocol(memoryTransport);
        return (new Client(prot)).recv_createConnection();
      }
    }

    public void createStatement(RConnection connection, org.apache.thrift.async.AsyncMethodCallback resultHandler) throws org.apache.thrift.TException {
      checkReady();
      createStatement_call method_call = new createStatement_call(connection, resultHandler, this, ___protocolFactory, ___transport);
      this.___currentMethod = method_call;
      ___manager.call(method_call);
    }

    public static class createStatement_call extends org.apache.thrift.async.TAsyncMethodCall {
      private RConnection connection;
      public createStatement_call(RConnection connection, org.apache.thrift.async.AsyncMethodCallback resultHandler, org.apache.thrift.async.TAsyncClient client, org.apache.thrift.protocol.TProtocolFactory protocolFactory, org.apache.thrift.transport.TNonblockingTransport transport) throws org.apache.thrift.TException {
        super(client, protocolFactory, transport, resultHandler, false);
        this.connection = connection;
      }

      public void write_args(org.apache.thrift.protocol.TProtocol prot) throws org.apache.thrift.TException {
        prot.writeMessageBegin(new org.apache.thrift.protocol.TMessage("createStatement", org.apache.thrift.protocol.TMessageType.CALL, 0));
        createStatement_args args = new createStatement_args();
        args.setConnection(connection);
        args.write(prot);
        prot.writeMessageEnd();
      }

      public RStatement getResult() throws RSQLException, org.apache.thrift.TException {
        if (getState() != org.apache.thrift.async.TAsyncMethodCall.State.RESPONSE_READ) {
          throw new IllegalStateException("Method call not finished!");
        }
        org.apache.thrift.transport.TMemoryInputTransport memoryTransport = new org.apache.thrift.transport.TMemoryInputTransport(getFrameBuffer().array());
        org.apache.thrift.protocol.TProtocol prot = client.getProtocolFactory().getProtocol(memoryTransport);
        return (new Client(prot)).recv_createStatement();
      }
    }

    public void prepareStatement(RConnection connection, String sql, org.apache.thrift.async.AsyncMethodCallback resultHandler) throws org.apache.thrift.TException {
      checkReady();
      prepareStatement_call method_call = new prepareStatement_call(connection, sql, resultHandler, this, ___protocolFactory, ___transport);
      this.___currentMethod = method_call;
      ___manager.call(method_call);
    }

    public static class prepareStatement_call extends org.apache.thrift.async.TAsyncMethodCall {
      private RConnection connection;
      private String sql;
      public prepareStatement_call(RConnection connection, String sql, org.apache.thrift.async.AsyncMethodCallback resultHandler, org.apache.thrift.async.TAsyncClient client, org.apache.thrift.protocol.TProtocolFactory protocolFactory, org.apache.thrift.transport.TNonblockingTransport transport) throws org.apache.thrift.TException {
        super(client, protocolFactory, transport, resultHandler, false);
        this.connection = connection;
        this.sql = sql;
      }

      public void write_args(org.apache.thrift.protocol.TProtocol prot) throws org.apache.thrift.TException {
        prot.writeMessageBegin(new org.apache.thrift.protocol.TMessage("prepareStatement", org.apache.thrift.protocol.TMessageType.CALL, 0));
        prepareStatement_args args = new prepareStatement_args();
        args.setConnection(connection);
        args.setSql(sql);
        args.write(prot);
        prot.writeMessageEnd();
      }

      public RStatement getResult() throws RSQLException, org.apache.thrift.TException {
        if (getState() != org.apache.thrift.async.TAsyncMethodCall.State.RESPONSE_READ) {
          throw new IllegalStateException("Method call not finished!");
        }
        org.apache.thrift.transport.TMemoryInputTransport memoryTransport = new org.apache.thrift.transport.TMemoryInputTransport(getFrameBuffer().array());
        org.apache.thrift.protocol.TProtocol prot = client.getProtocolFactory().getProtocol(memoryTransport);
        return (new Client(prot)).recv_prepareStatement();
      }
    }

    public void prepareCall(RConnection connection, String sql, org.apache.thrift.async.AsyncMethodCallback resultHandler) throws org.apache.thrift.TException {
      checkReady();
      prepareCall_call method_call = new prepareCall_call(connection, sql, resultHandler, this, ___protocolFactory, ___transport);
      this.___currentMethod = method_call;
      ___manager.call(method_call);
    }

    public static class prepareCall_call extends org.apache.thrift.async.TAsyncMethodCall {
      private RConnection connection;
      private String sql;
      public prepareCall_call(RConnection connection, String sql, org.apache.thrift.async.AsyncMethodCallback resultHandler, org.apache.thrift.async.TAsyncClient client, org.apache.thrift.protocol.TProtocolFactory protocolFactory, org.apache.thrift.transport.TNonblockingTransport transport) throws org.apache.thrift.TException {
        super(client, protocolFactory, transport, resultHandler, false);
        this.connection = connection;
        this.sql = sql;
      }

      public void write_args(org.apache.thrift.protocol.TProtocol prot) throws org.apache.thrift.TException {
        prot.writeMessageBegin(new org.apache.thrift.protocol.TMessage("prepareCall", org.apache.thrift.protocol.TMessageType.CALL, 0));
        prepareCall_args args = new prepareCall_args();
        args.setConnection(connection);
        args.setSql(sql);
        args.write(prot);
        prot.writeMessageEnd();
      }

      public RStatement getResult() throws RSQLException, org.apache.thrift.TException {
        if (getState() != org.apache.thrift.async.TAsyncMethodCall.State.RESPONSE_READ) {
          throw new IllegalStateException("Method call not finished!");
        }
        org.apache.thrift.transport.TMemoryInputTransport memoryTransport = new org.apache.thrift.transport.TMemoryInputTransport(getFrameBuffer().array());
        org.apache.thrift.protocol.TProtocol prot = client.getProtocolFactory().getProtocol(memoryTransport);
        return (new Client(prot)).recv_prepareCall();
      }
    }

    public void connection_getstaticmetadata(RConnection connection, org.apache.thrift.async.AsyncMethodCallback resultHandler) throws org.apache.thrift.TException {
      checkReady();
      connection_getstaticmetadata_call method_call = new connection_getstaticmetadata_call(connection, resultHandler, this, ___protocolFactory, ___transport);
      this.___currentMethod = method_call;
      ___manager.call(method_call);
    }

    public static class connection_getstaticmetadata_call extends org.apache.thrift.async.TAsyncMethodCall {
      private RConnection connection;
      public connection_getstaticmetadata_call(RConnection connection, org.apache.thrift.async.AsyncMethodCallback resultHandler, org.apache.thrift.async.TAsyncClient client, org.apache.thrift.protocol.TProtocolFactory protocolFactory, org.apache.thrift.transport.TNonblockingTransport transport) throws org.apache.thrift.TException {
        super(client, protocolFactory, transport, resultHandler, false);
        this.connection = connection;
      }

      public void write_args(org.apache.thrift.protocol.TProtocol prot) throws org.apache.thrift.TException {
        prot.writeMessageBegin(new org.apache.thrift.protocol.TMessage("connection_getstaticmetadata", org.apache.thrift.protocol.TMessageType.CALL, 0));
        connection_getstaticmetadata_args args = new connection_getstaticmetadata_args();
        args.setConnection(connection);
        args.write(prot);
        prot.writeMessageEnd();
      }

      public RStaticMetaData getResult() throws RSQLException, org.apache.thrift.TException {
        if (getState() != org.apache.thrift.async.TAsyncMethodCall.State.RESPONSE_READ) {
          throw new IllegalStateException("Method call not finished!");
        }
        org.apache.thrift.transport.TMemoryInputTransport memoryTransport = new org.apache.thrift.transport.TMemoryInputTransport(getFrameBuffer().array());
        org.apache.thrift.protocol.TProtocol prot = client.getProtocolFactory().getProtocol(memoryTransport);
        return (new Client(prot)).recv_connection_getstaticmetadata();
      }
    }

    public void connection_isvalid(RConnection connection, int timeout, org.apache.thrift.async.AsyncMethodCallback resultHandler) throws org.apache.thrift.TException {
      checkReady();
      connection_isvalid_call method_call = new connection_isvalid_call(connection, timeout, resultHandler, this, ___protocolFactory, ___transport);
      this.___currentMethod = method_call;
      ___manager.call(method_call);
    }

    public static class connection_isvalid_call extends org.apache.thrift.async.TAsyncMethodCall {
      private RConnection connection;
      private int timeout;
      public connection_isvalid_call(RConnection connection, int timeout, org.apache.thrift.async.AsyncMethodCallback resultHandler, org.apache.thrift.async.TAsyncClient client, org.apache.thrift.protocol.TProtocolFactory protocolFactory, org.apache.thrift.transport.TNonblockingTransport transport) throws org.apache.thrift.TException {
        super(client, protocolFactory, transport, resultHandler, false);
        this.connection = connection;
        this.timeout = timeout;
      }

      public void write_args(org.apache.thrift.protocol.TProtocol prot) throws org.apache.thrift.TException {
        prot.writeMessageBegin(new org.apache.thrift.protocol.TMessage("connection_isvalid", org.apache.thrift.protocol.TMessageType.CALL, 0));
        connection_isvalid_args args = new connection_isvalid_args();
        args.setConnection(connection);
        args.setTimeout(timeout);
        args.write(prot);
        prot.writeMessageEnd();
      }

      public boolean getResult() throws RSQLException, org.apache.thrift.TException {
        if (getState() != org.apache.thrift.async.TAsyncMethodCall.State.RESPONSE_READ) {
          throw new IllegalStateException("Method call not finished!");
        }
        org.apache.thrift.transport.TMemoryInputTransport memoryTransport = new org.apache.thrift.transport.TMemoryInputTransport(getFrameBuffer().array());
        org.apache.thrift.protocol.TProtocol prot = client.getProtocolFactory().getProtocol(memoryTransport);
        return (new Client(prot)).recv_connection_isvalid();
      }
    }

    public void connection_commit(RConnection connection, org.apache.thrift.async.AsyncMethodCallback resultHandler) throws org.apache.thrift.TException {
      checkReady();
      connection_commit_call method_call = new connection_commit_call(connection, resultHandler, this, ___protocolFactory, ___transport);
      this.___currentMethod = method_call;
      ___manager.call(method_call);
    }

    public static class connection_commit_call extends org.apache.thrift.async.TAsyncMethodCall {
      private RConnection connection;
      public connection_commit_call(RConnection connection, org.apache.thrift.async.AsyncMethodCallback resultHandler, org.apache.thrift.async.TAsyncClient client, org.apache.thrift.protocol.TProtocolFactory protocolFactory, org.apache.thrift.transport.TNonblockingTransport transport) throws org.apache.thrift.TException {
        super(client, protocolFactory, transport, resultHandler, false);
        this.connection = connection;
      }

      public void write_args(org.apache.thrift.protocol.TProtocol prot) throws org.apache.thrift.TException {
        prot.writeMessageBegin(new org.apache.thrift.protocol.TMessage("connection_commit", org.apache.thrift.protocol.TMessageType.CALL, 0));
        connection_commit_args args = new connection_commit_args();
        args.setConnection(connection);
        args.write(prot);
        prot.writeMessageEnd();
      }

      public void getResult() throws RSQLException, org.apache.thrift.TException {
        if (getState() != org.apache.thrift.async.TAsyncMethodCall.State.RESPONSE_READ) {
          throw new IllegalStateException("Method call not finished!");
        }
        org.apache.thrift.transport.TMemoryInputTransport memoryTransport = new org.apache.thrift.transport.TMemoryInputTransport(getFrameBuffer().array());
        org.apache.thrift.protocol.TProtocol prot = client.getProtocolFactory().getProtocol(memoryTransport);
        (new Client(prot)).recv_connection_commit();
      }
    }

    public void connection_rollback(RConnection connection, org.apache.thrift.async.AsyncMethodCallback resultHandler) throws org.apache.thrift.TException {
      checkReady();
      connection_rollback_call method_call = new connection_rollback_call(connection, resultHandler, this, ___protocolFactory, ___transport);
      this.___currentMethod = method_call;
      ___manager.call(method_call);
    }

    public static class connection_rollback_call extends org.apache.thrift.async.TAsyncMethodCall {
      private RConnection connection;
      public connection_rollback_call(RConnection connection, org.apache.thrift.async.AsyncMethodCallback resultHandler, org.apache.thrift.async.TAsyncClient client, org.apache.thrift.protocol.TProtocolFactory protocolFactory, org.apache.thrift.transport.TNonblockingTransport transport) throws org.apache.thrift.TException {
        super(client, protocolFactory, transport, resultHandler, false);
        this.connection = connection;
      }

      public void write_args(org.apache.thrift.protocol.TProtocol prot) throws org.apache.thrift.TException {
        prot.writeMessageBegin(new org.apache.thrift.protocol.TMessage("connection_rollback", org.apache.thrift.protocol.TMessageType.CALL, 0));
        connection_rollback_args args = new connection_rollback_args();
        args.setConnection(connection);
        args.write(prot);
        prot.writeMessageEnd();
      }

      public void getResult() throws RSQLException, org.apache.thrift.TException {
        if (getState() != org.apache.thrift.async.TAsyncMethodCall.State.RESPONSE_READ) {
          throw new IllegalStateException("Method call not finished!");
        }
        org.apache.thrift.transport.TMemoryInputTransport memoryTransport = new org.apache.thrift.transport.TMemoryInputTransport(getFrameBuffer().array());
        org.apache.thrift.protocol.TProtocol prot = client.getProtocolFactory().getProtocol(memoryTransport);
        (new Client(prot)).recv_connection_rollback();
      }
    }

    public void connection_setAutoCommit(RConnection connection, boolean autoCommit, org.apache.thrift.async.AsyncMethodCallback resultHandler) throws org.apache.thrift.TException {
      checkReady();
      connection_setAutoCommit_call method_call = new connection_setAutoCommit_call(connection, autoCommit, resultHandler, this, ___protocolFactory, ___transport);
      this.___currentMethod = method_call;
      ___manager.call(method_call);
    }

    public static class connection_setAutoCommit_call extends org.apache.thrift.async.TAsyncMethodCall {
      private RConnection connection;
      private boolean autoCommit;
      public connection_setAutoCommit_call(RConnection connection, boolean autoCommit, org.apache.thrift.async.AsyncMethodCallback resultHandler, org.apache.thrift.async.TAsyncClient client, org.apache.thrift.protocol.TProtocolFactory protocolFactory, org.apache.thrift.transport.TNonblockingTransport transport) throws org.apache.thrift.TException {
        super(client, protocolFactory, transport, resultHandler, false);
        this.connection = connection;
        this.autoCommit = autoCommit;
      }

      public void write_args(org.apache.thrift.protocol.TProtocol prot) throws org.apache.thrift.TException {
        prot.writeMessageBegin(new org.apache.thrift.protocol.TMessage("connection_setAutoCommit", org.apache.thrift.protocol.TMessageType.CALL, 0));
        connection_setAutoCommit_args args = new connection_setAutoCommit_args();
        args.setConnection(connection);
        args.setAutoCommit(autoCommit);
        args.write(prot);
        prot.writeMessageEnd();
      }

      public void getResult() throws RSQLException, org.apache.thrift.TException {
        if (getState() != org.apache.thrift.async.TAsyncMethodCall.State.RESPONSE_READ) {
          throw new IllegalStateException("Method call not finished!");
        }
        org.apache.thrift.transport.TMemoryInputTransport memoryTransport = new org.apache.thrift.transport.TMemoryInputTransport(getFrameBuffer().array());
        org.apache.thrift.protocol.TProtocol prot = client.getProtocolFactory().getProtocol(memoryTransport);
        (new Client(prot)).recv_connection_setAutoCommit();
      }
    }

    public void connection_getAutoCommit(RConnection connection, org.apache.thrift.async.AsyncMethodCallback resultHandler) throws org.apache.thrift.TException {
      checkReady();
      connection_getAutoCommit_call method_call = new connection_getAutoCommit_call(connection, resultHandler, this, ___protocolFactory, ___transport);
      this.___currentMethod = method_call;
      ___manager.call(method_call);
    }

    public static class connection_getAutoCommit_call extends org.apache.thrift.async.TAsyncMethodCall {
      private RConnection connection;
      public connection_getAutoCommit_call(RConnection connection, org.apache.thrift.async.AsyncMethodCallback resultHandler, org.apache.thrift.async.TAsyncClient client, org.apache.thrift.protocol.TProtocolFactory protocolFactory, org.apache.thrift.transport.TNonblockingTransport transport) throws org.apache.thrift.TException {
        super(client, protocolFactory, transport, resultHandler, false);
        this.connection = connection;
      }

      public void write_args(org.apache.thrift.protocol.TProtocol prot) throws org.apache.thrift.TException {
        prot.writeMessageBegin(new org.apache.thrift.protocol.TMessage("connection_getAutoCommit", org.apache.thrift.protocol.TMessageType.CALL, 0));
        connection_getAutoCommit_args args = new connection_getAutoCommit_args();
        args.setConnection(connection);
        args.write(prot);
        prot.writeMessageEnd();
      }

      public boolean getResult() throws RSQLException, org.apache.thrift.TException {
        if (getState() != org.apache.thrift.async.TAsyncMethodCall.State.RESPONSE_READ) {
          throw new IllegalStateException("Method call not finished!");
        }
        org.apache.thrift.transport.TMemoryInputTransport memoryTransport = new org.apache.thrift.transport.TMemoryInputTransport(getFrameBuffer().array());
        org.apache.thrift.protocol.TProtocol prot = client.getProtocolFactory().getProtocol(memoryTransport);
        return (new Client(prot)).recv_connection_getAutoCommit();
      }
    }

    public void connection_setTransactionIsolation(RConnection connection, int level, org.apache.thrift.async.AsyncMethodCallback resultHandler) throws org.apache.thrift.TException {
      checkReady();
      connection_setTransactionIsolation_call method_call = new connection_setTransactionIsolation_call(connection, level, resultHandler, this, ___protocolFactory, ___transport);
      this.___currentMethod = method_call;
      ___manager.call(method_call);
    }

    public static class connection_setTransactionIsolation_call extends org.apache.thrift.async.TAsyncMethodCall {
      private RConnection connection;
      private int level;
      public connection_setTransactionIsolation_call(RConnection connection, int level, org.apache.thrift.async.AsyncMethodCallback resultHandler, org.apache.thrift.async.TAsyncClient client, org.apache.thrift.protocol.TProtocolFactory protocolFactory, org.apache.thrift.transport.TNonblockingTransport transport) throws org.apache.thrift.TException {
        super(client, protocolFactory, transport, resultHandler, false);
        this.connection = connection;
        this.level = level;
      }

      public void write_args(org.apache.thrift.protocol.TProtocol prot) throws org.apache.thrift.TException {
        prot.writeMessageBegin(new org.apache.thrift.protocol.TMessage("connection_setTransactionIsolation", org.apache.thrift.protocol.TMessageType.CALL, 0));
        connection_setTransactionIsolation_args args = new connection_setTransactionIsolation_args();
        args.setConnection(connection);
        args.setLevel(level);
        args.write(prot);
        prot.writeMessageEnd();
      }

      public void getResult() throws RSQLException, org.apache.thrift.TException {
        if (getState() != org.apache.thrift.async.TAsyncMethodCall.State.RESPONSE_READ) {
          throw new IllegalStateException("Method call not finished!");
        }
        org.apache.thrift.transport.TMemoryInputTransport memoryTransport = new org.apache.thrift.transport.TMemoryInputTransport(getFrameBuffer().array());
        org.apache.thrift.protocol.TProtocol prot = client.getProtocolFactory().getProtocol(memoryTransport);
        (new Client(prot)).recv_connection_setTransactionIsolation();
      }
    }

    public void connection_getTransactionIsolation(RConnection connection, org.apache.thrift.async.AsyncMethodCallback resultHandler) throws org.apache.thrift.TException {
      checkReady();
      connection_getTransactionIsolation_call method_call = new connection_getTransactionIsolation_call(connection, resultHandler, this, ___protocolFactory, ___transport);
      this.___currentMethod = method_call;
      ___manager.call(method_call);
    }

    public static class connection_getTransactionIsolation_call extends org.apache.thrift.async.TAsyncMethodCall {
      private RConnection connection;
      public connection_getTransactionIsolation_call(RConnection connection, org.apache.thrift.async.AsyncMethodCallback resultHandler, org.apache.thrift.async.TAsyncClient client, org.apache.thrift.protocol.TProtocolFactory protocolFactory, org.apache.thrift.transport.TNonblockingTransport transport) throws org.apache.thrift.TException {
        super(client, protocolFactory, transport, resultHandler, false);
        this.connection = connection;
      }

      public void write_args(org.apache.thrift.protocol.TProtocol prot) throws org.apache.thrift.TException {
        prot.writeMessageBegin(new org.apache.thrift.protocol.TMessage("connection_getTransactionIsolation", org.apache.thrift.protocol.TMessageType.CALL, 0));
        connection_getTransactionIsolation_args args = new connection_getTransactionIsolation_args();
        args.setConnection(connection);
        args.write(prot);
        prot.writeMessageEnd();
      }

      public int getResult() throws RSQLException, org.apache.thrift.TException {
        if (getState() != org.apache.thrift.async.TAsyncMethodCall.State.RESPONSE_READ) {
          throw new IllegalStateException("Method call not finished!");
        }
        org.apache.thrift.transport.TMemoryInputTransport memoryTransport = new org.apache.thrift.transport.TMemoryInputTransport(getFrameBuffer().array());
        org.apache.thrift.protocol.TProtocol prot = client.getProtocolFactory().getProtocol(memoryTransport);
        return (new Client(prot)).recv_connection_getTransactionIsolation();
      }
    }

    public void connection_setReadOnly(RConnection connection, boolean readOnly, org.apache.thrift.async.AsyncMethodCallback resultHandler) throws org.apache.thrift.TException {
      checkReady();
      connection_setReadOnly_call method_call = new connection_setReadOnly_call(connection, readOnly, resultHandler, this, ___protocolFactory, ___transport);
      this.___currentMethod = method_call;
      ___manager.call(method_call);
    }

    public static class connection_setReadOnly_call extends org.apache.thrift.async.TAsyncMethodCall {
      private RConnection connection;
      private boolean readOnly;
      public connection_setReadOnly_call(RConnection connection, boolean readOnly, org.apache.thrift.async.AsyncMethodCallback resultHandler, org.apache.thrift.async.TAsyncClient client, org.apache.thrift.protocol.TProtocolFactory protocolFactory, org.apache.thrift.transport.TNonblockingTransport transport) throws org.apache.thrift.TException {
        super(client, protocolFactory, transport, resultHandler, false);
        this.connection = connection;
        this.readOnly = readOnly;
      }

      public void write_args(org.apache.thrift.protocol.TProtocol prot) throws org.apache.thrift.TException {
        prot.writeMessageBegin(new org.apache.thrift.protocol.TMessage("connection_setReadOnly", org.apache.thrift.protocol.TMessageType.CALL, 0));
        connection_setReadOnly_args args = new connection_setReadOnly_args();
        args.setConnection(connection);
        args.setReadOnly(readOnly);
        args.write(prot);
        prot.writeMessageEnd();
      }

      public void getResult() throws RSQLException, org.apache.thrift.TException {
        if (getState() != org.apache.thrift.async.TAsyncMethodCall.State.RESPONSE_READ) {
          throw new IllegalStateException("Method call not finished!");
        }
        org.apache.thrift.transport.TMemoryInputTransport memoryTransport = new org.apache.thrift.transport.TMemoryInputTransport(getFrameBuffer().array());
        org.apache.thrift.protocol.TProtocol prot = client.getProtocolFactory().getProtocol(memoryTransport);
        (new Client(prot)).recv_connection_setReadOnly();
      }
    }

    public void connection_getReadOnly(RConnection connection, org.apache.thrift.async.AsyncMethodCallback resultHandler) throws org.apache.thrift.TException {
      checkReady();
      connection_getReadOnly_call method_call = new connection_getReadOnly_call(connection, resultHandler, this, ___protocolFactory, ___transport);
      this.___currentMethod = method_call;
      ___manager.call(method_call);
    }

    public static class connection_getReadOnly_call extends org.apache.thrift.async.TAsyncMethodCall {
      private RConnection connection;
      public connection_getReadOnly_call(RConnection connection, org.apache.thrift.async.AsyncMethodCallback resultHandler, org.apache.thrift.async.TAsyncClient client, org.apache.thrift.protocol.TProtocolFactory protocolFactory, org.apache.thrift.transport.TNonblockingTransport transport) throws org.apache.thrift.TException {
        super(client, protocolFactory, transport, resultHandler, false);
        this.connection = connection;
      }

      public void write_args(org.apache.thrift.protocol.TProtocol prot) throws org.apache.thrift.TException {
        prot.writeMessageBegin(new org.apache.thrift.protocol.TMessage("connection_getReadOnly", org.apache.thrift.protocol.TMessageType.CALL, 0));
        connection_getReadOnly_args args = new connection_getReadOnly_args();
        args.setConnection(connection);
        args.write(prot);
        prot.writeMessageEnd();
      }

      public boolean getResult() throws RSQLException, org.apache.thrift.TException {
        if (getState() != org.apache.thrift.async.TAsyncMethodCall.State.RESPONSE_READ) {
          throw new IllegalStateException("Method call not finished!");
        }
        org.apache.thrift.transport.TMemoryInputTransport memoryTransport = new org.apache.thrift.transport.TMemoryInputTransport(getFrameBuffer().array());
        org.apache.thrift.protocol.TProtocol prot = client.getProtocolFactory().getProtocol(memoryTransport);
        return (new Client(prot)).recv_connection_getReadOnly();
      }
    }

    public void connection_setCatalog(RConnection connection, String catalog, org.apache.thrift.async.AsyncMethodCallback resultHandler) throws org.apache.thrift.TException {
      checkReady();
      connection_setCatalog_call method_call = new connection_setCatalog_call(connection, catalog, resultHandler, this, ___protocolFactory, ___transport);
      this.___currentMethod = method_call;
      ___manager.call(method_call);
    }

    public static class connection_setCatalog_call extends org.apache.thrift.async.TAsyncMethodCall {
      private RConnection connection;
      private String catalog;
      public connection_setCatalog_call(RConnection connection, String catalog, org.apache.thrift.async.AsyncMethodCallback resultHandler, org.apache.thrift.async.TAsyncClient client, org.apache.thrift.protocol.TProtocolFactory protocolFactory, org.apache.thrift.transport.TNonblockingTransport transport) throws org.apache.thrift.TException {
        super(client, protocolFactory, transport, resultHandler, false);
        this.connection = connection;
        this.catalog = catalog;
      }

      public void write_args(org.apache.thrift.protocol.TProtocol prot) throws org.apache.thrift.TException {
        prot.writeMessageBegin(new org.apache.thrift.protocol.TMessage("connection_setCatalog", org.apache.thrift.protocol.TMessageType.CALL, 0));
        connection_setCatalog_args args = new connection_setCatalog_args();
        args.setConnection(connection);
        args.setCatalog(catalog);
        args.write(prot);
        prot.writeMessageEnd();
      }

      public void getResult() throws RSQLException, org.apache.thrift.TException {
        if (getState() != org.apache.thrift.async.TAsyncMethodCall.State.RESPONSE_READ) {
          throw new IllegalStateException("Method call not finished!");
        }
        org.apache.thrift.transport.TMemoryInputTransport memoryTransport = new org.apache.thrift.transport.TMemoryInputTransport(getFrameBuffer().array());
        org.apache.thrift.protocol.TProtocol prot = client.getProtocolFactory().getProtocol(memoryTransport);
        (new Client(prot)).recv_connection_setCatalog();
      }
    }

    public void connection_getCatalog(RConnection connection, org.apache.thrift.async.AsyncMethodCallback resultHandler) throws org.apache.thrift.TException {
      checkReady();
      connection_getCatalog_call method_call = new connection_getCatalog_call(connection, resultHandler, this, ___protocolFactory, ___transport);
      this.___currentMethod = method_call;
      ___manager.call(method_call);
    }

    public static class connection_getCatalog_call extends org.apache.thrift.async.TAsyncMethodCall {
      private RConnection connection;
      public connection_getCatalog_call(RConnection connection, org.apache.thrift.async.AsyncMethodCallback resultHandler, org.apache.thrift.async.TAsyncClient client, org.apache.thrift.protocol.TProtocolFactory protocolFactory, org.apache.thrift.transport.TNonblockingTransport transport) throws org.apache.thrift.TException {
        super(client, protocolFactory, transport, resultHandler, false);
        this.connection = connection;
      }

      public void write_args(org.apache.thrift.protocol.TProtocol prot) throws org.apache.thrift.TException {
        prot.writeMessageBegin(new org.apache.thrift.protocol.TMessage("connection_getCatalog", org.apache.thrift.protocol.TMessageType.CALL, 0));
        connection_getCatalog_args args = new connection_getCatalog_args();
        args.setConnection(connection);
        args.write(prot);
        prot.writeMessageEnd();
      }

      public String getResult() throws RSQLException, org.apache.thrift.TException {
        if (getState() != org.apache.thrift.async.TAsyncMethodCall.State.RESPONSE_READ) {
          throw new IllegalStateException("Method call not finished!");
        }
        org.apache.thrift.transport.TMemoryInputTransport memoryTransport = new org.apache.thrift.transport.TMemoryInputTransport(getFrameBuffer().array());
        org.apache.thrift.protocol.TProtocol prot = client.getProtocolFactory().getProtocol(memoryTransport);
        return (new Client(prot)).recv_connection_getCatalog();
      }
    }

    public void connection_setSchema(RConnection connection, String schema, org.apache.thrift.async.AsyncMethodCallback resultHandler) throws org.apache.thrift.TException {
      checkReady();
      connection_setSchema_call method_call = new connection_setSchema_call(connection, schema, resultHandler, this, ___protocolFactory, ___transport);
      this.___currentMethod = method_call;
      ___manager.call(method_call);
    }

    public static class connection_setSchema_call extends org.apache.thrift.async.TAsyncMethodCall {
      private RConnection connection;
      private String schema;
      public connection_setSchema_call(RConnection connection, String schema, org.apache.thrift.async.AsyncMethodCallback resultHandler, org.apache.thrift.async.TAsyncClient client, org.apache.thrift.protocol.TProtocolFactory protocolFactory, org.apache.thrift.transport.TNonblockingTransport transport) throws org.apache.thrift.TException {
        super(client, protocolFactory, transport, resultHandler, false);
        this.connection = connection;
        this.schema = schema;
      }

      public void write_args(org.apache.thrift.protocol.TProtocol prot) throws org.apache.thrift.TException {
        prot.writeMessageBegin(new org.apache.thrift.protocol.TMessage("connection_setSchema", org.apache.thrift.protocol.TMessageType.CALL, 0));
        connection_setSchema_args args = new connection_setSchema_args();
        args.setConnection(connection);
        args.setSchema(schema);
        args.write(prot);
        prot.writeMessageEnd();
      }

      public void getResult() throws RSQLException, org.apache.thrift.TException {
        if (getState() != org.apache.thrift.async.TAsyncMethodCall.State.RESPONSE_READ) {
          throw new IllegalStateException("Method call not finished!");
        }
        org.apache.thrift.transport.TMemoryInputTransport memoryTransport = new org.apache.thrift.transport.TMemoryInputTransport(getFrameBuffer().array());
        org.apache.thrift.protocol.TProtocol prot = client.getProtocolFactory().getProtocol(memoryTransport);
        (new Client(prot)).recv_connection_setSchema();
      }
    }

    public void connection_getSchema(RConnection connection, org.apache.thrift.async.AsyncMethodCallback resultHandler) throws org.apache.thrift.TException {
      checkReady();
      connection_getSchema_call method_call = new connection_getSchema_call(connection, resultHandler, this, ___protocolFactory, ___transport);
      this.___currentMethod = method_call;
      ___manager.call(method_call);
    }

    public static class connection_getSchema_call extends org.apache.thrift.async.TAsyncMethodCall {
      private RConnection connection;
      public connection_getSchema_call(RConnection connection, org.apache.thrift.async.AsyncMethodCallback resultHandler, org.apache.thrift.async.TAsyncClient client, org.apache.thrift.protocol.TProtocolFactory protocolFactory, org.apache.thrift.transport.TNonblockingTransport transport) throws org.apache.thrift.TException {
        super(client, protocolFactory, transport, resultHandler, false);
        this.connection = connection;
      }

      public void write_args(org.apache.thrift.protocol.TProtocol prot) throws org.apache.thrift.TException {
        prot.writeMessageBegin(new org.apache.thrift.protocol.TMessage("connection_getSchema", org.apache.thrift.protocol.TMessageType.CALL, 0));
        connection_getSchema_args args = new connection_getSchema_args();
        args.setConnection(connection);
        args.write(prot);
        prot.writeMessageEnd();
      }

      public String getResult() throws RSQLException, org.apache.thrift.TException {
        if (getState() != org.apache.thrift.async.TAsyncMethodCall.State.RESPONSE_READ) {
          throw new IllegalStateException("Method call not finished!");
        }
        org.apache.thrift.transport.TMemoryInputTransport memoryTransport = new org.apache.thrift.transport.TMemoryInputTransport(getFrameBuffer().array());
        org.apache.thrift.protocol.TProtocol prot = client.getProtocolFactory().getProtocol(memoryTransport);
        return (new Client(prot)).recv_connection_getSchema();
      }
    }

    public void connection_getCatalogSeparator(RConnection connection, org.apache.thrift.async.AsyncMethodCallback resultHandler) throws org.apache.thrift.TException {
      checkReady();
      connection_getCatalogSeparator_call method_call = new connection_getCatalogSeparator_call(connection, resultHandler, this, ___protocolFactory, ___transport);
      this.___currentMethod = method_call;
      ___manager.call(method_call);
    }

    public static class connection_getCatalogSeparator_call extends org.apache.thrift.async.TAsyncMethodCall {
      private RConnection connection;
      public connection_getCatalogSeparator_call(RConnection connection, org.apache.thrift.async.AsyncMethodCallback resultHandler, org.apache.thrift.async.TAsyncClient client, org.apache.thrift.protocol.TProtocolFactory protocolFactory, org.apache.thrift.transport.TNonblockingTransport transport) throws org.apache.thrift.TException {
        super(client, protocolFactory, transport, resultHandler, false);
        this.connection = connection;
      }

      public void write_args(org.apache.thrift.protocol.TProtocol prot) throws org.apache.thrift.TException {
        prot.writeMessageBegin(new org.apache.thrift.protocol.TMessage("connection_getCatalogSeparator", org.apache.thrift.protocol.TMessageType.CALL, 0));
        connection_getCatalogSeparator_args args = new connection_getCatalogSeparator_args();
        args.setConnection(connection);
        args.write(prot);
        prot.writeMessageEnd();
      }

      public String getResult() throws RSQLException, org.apache.thrift.TException {
        if (getState() != org.apache.thrift.async.TAsyncMethodCall.State.RESPONSE_READ) {
          throw new IllegalStateException("Method call not finished!");
        }
        org.apache.thrift.transport.TMemoryInputTransport memoryTransport = new org.apache.thrift.transport.TMemoryInputTransport(getFrameBuffer().array());
        org.apache.thrift.protocol.TProtocol prot = client.getProtocolFactory().getProtocol(memoryTransport);
        return (new Client(prot)).recv_connection_getCatalogSeparator();
      }
    }

    public void connection_getCatalogTerm(RConnection connection, org.apache.thrift.async.AsyncMethodCallback resultHandler) throws org.apache.thrift.TException {
      checkReady();
      connection_getCatalogTerm_call method_call = new connection_getCatalogTerm_call(connection, resultHandler, this, ___protocolFactory, ___transport);
      this.___currentMethod = method_call;
      ___manager.call(method_call);
    }

    public static class connection_getCatalogTerm_call extends org.apache.thrift.async.TAsyncMethodCall {
      private RConnection connection;
      public connection_getCatalogTerm_call(RConnection connection, org.apache.thrift.async.AsyncMethodCallback resultHandler, org.apache.thrift.async.TAsyncClient client, org.apache.thrift.protocol.TProtocolFactory protocolFactory, org.apache.thrift.transport.TNonblockingTransport transport) throws org.apache.thrift.TException {
        super(client, protocolFactory, transport, resultHandler, false);
        this.connection = connection;
      }

      public void write_args(org.apache.thrift.protocol.TProtocol prot) throws org.apache.thrift.TException {
        prot.writeMessageBegin(new org.apache.thrift.protocol.TMessage("connection_getCatalogTerm", org.apache.thrift.protocol.TMessageType.CALL, 0));
        connection_getCatalogTerm_args args = new connection_getCatalogTerm_args();
        args.setConnection(connection);
        args.write(prot);
        prot.writeMessageEnd();
      }

      public String getResult() throws RSQLException, org.apache.thrift.TException {
        if (getState() != org.apache.thrift.async.TAsyncMethodCall.State.RESPONSE_READ) {
          throw new IllegalStateException("Method call not finished!");
        }
        org.apache.thrift.transport.TMemoryInputTransport memoryTransport = new org.apache.thrift.transport.TMemoryInputTransport(getFrameBuffer().array());
        org.apache.thrift.protocol.TProtocol prot = client.getProtocolFactory().getProtocol(memoryTransport);
        return (new Client(prot)).recv_connection_getCatalogTerm();
      }
    }

    public void connection_getSchemaTerm(RConnection connection, org.apache.thrift.async.AsyncMethodCallback resultHandler) throws org.apache.thrift.TException {
      checkReady();
      connection_getSchemaTerm_call method_call = new connection_getSchemaTerm_call(connection, resultHandler, this, ___protocolFactory, ___transport);
      this.___currentMethod = method_call;
      ___manager.call(method_call);
    }

    public static class connection_getSchemaTerm_call extends org.apache.thrift.async.TAsyncMethodCall {
      private RConnection connection;
      public connection_getSchemaTerm_call(RConnection connection, org.apache.thrift.async.AsyncMethodCallback resultHandler, org.apache.thrift.async.TAsyncClient client, org.apache.thrift.protocol.TProtocolFactory protocolFactory, org.apache.thrift.transport.TNonblockingTransport transport) throws org.apache.thrift.TException {
        super(client, protocolFactory, transport, resultHandler, false);
        this.connection = connection;
      }

      public void write_args(org.apache.thrift.protocol.TProtocol prot) throws org.apache.thrift.TException {
        prot.writeMessageBegin(new org.apache.thrift.protocol.TMessage("connection_getSchemaTerm", org.apache.thrift.protocol.TMessageType.CALL, 0));
        connection_getSchemaTerm_args args = new connection_getSchemaTerm_args();
        args.setConnection(connection);
        args.write(prot);
        prot.writeMessageEnd();
      }

      public String getResult() throws RSQLException, org.apache.thrift.TException {
        if (getState() != org.apache.thrift.async.TAsyncMethodCall.State.RESPONSE_READ) {
          throw new IllegalStateException("Method call not finished!");
        }
        org.apache.thrift.transport.TMemoryInputTransport memoryTransport = new org.apache.thrift.transport.TMemoryInputTransport(getFrameBuffer().array());
        org.apache.thrift.protocol.TProtocol prot = client.getProtocolFactory().getProtocol(memoryTransport);
        return (new Client(prot)).recv_connection_getSchemaTerm();
      }
    }

    public void connection_getCatalogs(RConnection connection, org.apache.thrift.async.AsyncMethodCallback resultHandler) throws org.apache.thrift.TException {
      checkReady();
      connection_getCatalogs_call method_call = new connection_getCatalogs_call(connection, resultHandler, this, ___protocolFactory, ___transport);
      this.___currentMethod = method_call;
      ___manager.call(method_call);
    }

    public static class connection_getCatalogs_call extends org.apache.thrift.async.TAsyncMethodCall {
      private RConnection connection;
      public connection_getCatalogs_call(RConnection connection, org.apache.thrift.async.AsyncMethodCallback resultHandler, org.apache.thrift.async.TAsyncClient client, org.apache.thrift.protocol.TProtocolFactory protocolFactory, org.apache.thrift.transport.TNonblockingTransport transport) throws org.apache.thrift.TException {
        super(client, protocolFactory, transport, resultHandler, false);
        this.connection = connection;
      }

      public void write_args(org.apache.thrift.protocol.TProtocol prot) throws org.apache.thrift.TException {
        prot.writeMessageBegin(new org.apache.thrift.protocol.TMessage("connection_getCatalogs", org.apache.thrift.protocol.TMessageType.CALL, 0));
        connection_getCatalogs_args args = new connection_getCatalogs_args();
        args.setConnection(connection);
        args.write(prot);
        prot.writeMessageEnd();
      }

      public RResultSet getResult() throws RSQLException, org.apache.thrift.TException {
        if (getState() != org.apache.thrift.async.TAsyncMethodCall.State.RESPONSE_READ) {
          throw new IllegalStateException("Method call not finished!");
        }
        org.apache.thrift.transport.TMemoryInputTransport memoryTransport = new org.apache.thrift.transport.TMemoryInputTransport(getFrameBuffer().array());
        org.apache.thrift.protocol.TProtocol prot = client.getProtocolFactory().getProtocol(memoryTransport);
        return (new Client(prot)).recv_connection_getCatalogs();
      }
    }

    public void connection_getSchemas(RConnection connection, String catalog, String schemaPattern, org.apache.thrift.async.AsyncMethodCallback resultHandler) throws org.apache.thrift.TException {
      checkReady();
      connection_getSchemas_call method_call = new connection_getSchemas_call(connection, catalog, schemaPattern, resultHandler, this, ___protocolFactory, ___transport);
      this.___currentMethod = method_call;
      ___manager.call(method_call);
    }

    public static class connection_getSchemas_call extends org.apache.thrift.async.TAsyncMethodCall {
      private RConnection connection;
      private String catalog;
      private String schemaPattern;
      public connection_getSchemas_call(RConnection connection, String catalog, String schemaPattern, org.apache.thrift.async.AsyncMethodCallback resultHandler, org.apache.thrift.async.TAsyncClient client, org.apache.thrift.protocol.TProtocolFactory protocolFactory, org.apache.thrift.transport.TNonblockingTransport transport) throws org.apache.thrift.TException {
        super(client, protocolFactory, transport, resultHandler, false);
        this.connection = connection;
        this.catalog = catalog;
        this.schemaPattern = schemaPattern;
      }

      public void write_args(org.apache.thrift.protocol.TProtocol prot) throws org.apache.thrift.TException {
        prot.writeMessageBegin(new org.apache.thrift.protocol.TMessage("connection_getSchemas", org.apache.thrift.protocol.TMessageType.CALL, 0));
        connection_getSchemas_args args = new connection_getSchemas_args();
        args.setConnection(connection);
        args.setCatalog(catalog);
        args.setSchemaPattern(schemaPattern);
        args.write(prot);
        prot.writeMessageEnd();
      }

      public RResultSet getResult() throws RSQLException, org.apache.thrift.TException {
        if (getState() != org.apache.thrift.async.TAsyncMethodCall.State.RESPONSE_READ) {
          throw new IllegalStateException("Method call not finished!");
        }
        org.apache.thrift.transport.TMemoryInputTransport memoryTransport = new org.apache.thrift.transport.TMemoryInputTransport(getFrameBuffer().array());
        org.apache.thrift.protocol.TProtocol prot = client.getProtocolFactory().getProtocol(memoryTransport);
        return (new Client(prot)).recv_connection_getSchemas();
      }
    }

    public void connection_getTables(RConnection connection, String catalog, String schemaPattern, String tableNamePattern, List<String> types, org.apache.thrift.async.AsyncMethodCallback resultHandler) throws org.apache.thrift.TException {
      checkReady();
      connection_getTables_call method_call = new connection_getTables_call(connection, catalog, schemaPattern, tableNamePattern, types, resultHandler, this, ___protocolFactory, ___transport);
      this.___currentMethod = method_call;
      ___manager.call(method_call);
    }

    public static class connection_getTables_call extends org.apache.thrift.async.TAsyncMethodCall {
      private RConnection connection;
      private String catalog;
      private String schemaPattern;
      private String tableNamePattern;
      private List<String> types;
      public connection_getTables_call(RConnection connection, String catalog, String schemaPattern, String tableNamePattern, List<String> types, org.apache.thrift.async.AsyncMethodCallback resultHandler, org.apache.thrift.async.TAsyncClient client, org.apache.thrift.protocol.TProtocolFactory protocolFactory, org.apache.thrift.transport.TNonblockingTransport transport) throws org.apache.thrift.TException {
        super(client, protocolFactory, transport, resultHandler, false);
        this.connection = connection;
        this.catalog = catalog;
        this.schemaPattern = schemaPattern;
        this.tableNamePattern = tableNamePattern;
        this.types = types;
      }

      public void write_args(org.apache.thrift.protocol.TProtocol prot) throws org.apache.thrift.TException {
        prot.writeMessageBegin(new org.apache.thrift.protocol.TMessage("connection_getTables", org.apache.thrift.protocol.TMessageType.CALL, 0));
        connection_getTables_args args = new connection_getTables_args();
        args.setConnection(connection);
        args.setCatalog(catalog);
        args.setSchemaPattern(schemaPattern);
        args.setTableNamePattern(tableNamePattern);
        args.setTypes(types);
        args.write(prot);
        prot.writeMessageEnd();
      }

      public RResultSet getResult() throws RSQLException, org.apache.thrift.TException {
        if (getState() != org.apache.thrift.async.TAsyncMethodCall.State.RESPONSE_READ) {
          throw new IllegalStateException("Method call not finished!");
        }
        org.apache.thrift.transport.TMemoryInputTransport memoryTransport = new org.apache.thrift.transport.TMemoryInputTransport(getFrameBuffer().array());
        org.apache.thrift.protocol.TProtocol prot = client.getProtocolFactory().getProtocol(memoryTransport);
        return (new Client(prot)).recv_connection_getTables();
      }
    }

    public void connection_getColumns(RConnection connection, String catalog, String schemaPattern, String tableNamePattern, String columnNamePattern, org.apache.thrift.async.AsyncMethodCallback resultHandler) throws org.apache.thrift.TException {
      checkReady();
      connection_getColumns_call method_call = new connection_getColumns_call(connection, catalog, schemaPattern, tableNamePattern, columnNamePattern, resultHandler, this, ___protocolFactory, ___transport);
      this.___currentMethod = method_call;
      ___manager.call(method_call);
    }

    public static class connection_getColumns_call extends org.apache.thrift.async.TAsyncMethodCall {
      private RConnection connection;
      private String catalog;
      private String schemaPattern;
      private String tableNamePattern;
      private String columnNamePattern;
      public connection_getColumns_call(RConnection connection, String catalog, String schemaPattern, String tableNamePattern, String columnNamePattern, org.apache.thrift.async.AsyncMethodCallback resultHandler, org.apache.thrift.async.TAsyncClient client, org.apache.thrift.protocol.TProtocolFactory protocolFactory, org.apache.thrift.transport.TNonblockingTransport transport) throws org.apache.thrift.TException {
        super(client, protocolFactory, transport, resultHandler, false);
        this.connection = connection;
        this.catalog = catalog;
        this.schemaPattern = schemaPattern;
        this.tableNamePattern = tableNamePattern;
        this.columnNamePattern = columnNamePattern;
      }

      public void write_args(org.apache.thrift.protocol.TProtocol prot) throws org.apache.thrift.TException {
        prot.writeMessageBegin(new org.apache.thrift.protocol.TMessage("connection_getColumns", org.apache.thrift.protocol.TMessageType.CALL, 0));
        connection_getColumns_args args = new connection_getColumns_args();
        args.setConnection(connection);
        args.setCatalog(catalog);
        args.setSchemaPattern(schemaPattern);
        args.setTableNamePattern(tableNamePattern);
        args.setColumnNamePattern(columnNamePattern);
        args.write(prot);
        prot.writeMessageEnd();
      }

      public RResultSet getResult() throws RSQLException, org.apache.thrift.TException {
        if (getState() != org.apache.thrift.async.TAsyncMethodCall.State.RESPONSE_READ) {
          throw new IllegalStateException("Method call not finished!");
        }
        org.apache.thrift.transport.TMemoryInputTransport memoryTransport = new org.apache.thrift.transport.TMemoryInputTransport(getFrameBuffer().array());
        org.apache.thrift.protocol.TProtocol prot = client.getProtocolFactory().getProtocol(memoryTransport);
        return (new Client(prot)).recv_connection_getColumns();
      }
    }

    public void connection_getSQLKeywords(RConnection connection, org.apache.thrift.async.AsyncMethodCallback resultHandler) throws org.apache.thrift.TException {
      checkReady();
      connection_getSQLKeywords_call method_call = new connection_getSQLKeywords_call(connection, resultHandler, this, ___protocolFactory, ___transport);
      this.___currentMethod = method_call;
      ___manager.call(method_call);
    }

    public static class connection_getSQLKeywords_call extends org.apache.thrift.async.TAsyncMethodCall {
      private RConnection connection;
      public connection_getSQLKeywords_call(RConnection connection, org.apache.thrift.async.AsyncMethodCallback resultHandler, org.apache.thrift.async.TAsyncClient client, org.apache.thrift.protocol.TProtocolFactory protocolFactory, org.apache.thrift.transport.TNonblockingTransport transport) throws org.apache.thrift.TException {
        super(client, protocolFactory, transport, resultHandler, false);
        this.connection = connection;
      }

      public void write_args(org.apache.thrift.protocol.TProtocol prot) throws org.apache.thrift.TException {
        prot.writeMessageBegin(new org.apache.thrift.protocol.TMessage("connection_getSQLKeywords", org.apache.thrift.protocol.TMessageType.CALL, 0));
        connection_getSQLKeywords_args args = new connection_getSQLKeywords_args();
        args.setConnection(connection);
        args.write(prot);
        prot.writeMessageEnd();
      }

      public String getResult() throws RSQLException, org.apache.thrift.TException {
        if (getState() != org.apache.thrift.async.TAsyncMethodCall.State.RESPONSE_READ) {
          throw new IllegalStateException("Method call not finished!");
        }
        org.apache.thrift.transport.TMemoryInputTransport memoryTransport = new org.apache.thrift.transport.TMemoryInputTransport(getFrameBuffer().array());
        org.apache.thrift.protocol.TProtocol prot = client.getProtocolFactory().getProtocol(memoryTransport);
        return (new Client(prot)).recv_connection_getSQLKeywords();
      }
    }

    public void connection_getTableTypes(RConnection connection, org.apache.thrift.async.AsyncMethodCallback resultHandler) throws org.apache.thrift.TException {
      checkReady();
      connection_getTableTypes_call method_call = new connection_getTableTypes_call(connection, resultHandler, this, ___protocolFactory, ___transport);
      this.___currentMethod = method_call;
      ___manager.call(method_call);
    }

    public static class connection_getTableTypes_call extends org.apache.thrift.async.TAsyncMethodCall {
      private RConnection connection;
      public connection_getTableTypes_call(RConnection connection, org.apache.thrift.async.AsyncMethodCallback resultHandler, org.apache.thrift.async.TAsyncClient client, org.apache.thrift.protocol.TProtocolFactory protocolFactory, org.apache.thrift.transport.TNonblockingTransport transport) throws org.apache.thrift.TException {
        super(client, protocolFactory, transport, resultHandler, false);
        this.connection = connection;
      }

      public void write_args(org.apache.thrift.protocol.TProtocol prot) throws org.apache.thrift.TException {
        prot.writeMessageBegin(new org.apache.thrift.protocol.TMessage("connection_getTableTypes", org.apache.thrift.protocol.TMessageType.CALL, 0));
        connection_getTableTypes_args args = new connection_getTableTypes_args();
        args.setConnection(connection);
        args.write(prot);
        prot.writeMessageEnd();
      }

      public RResultSet getResult() throws RSQLException, org.apache.thrift.TException {
        if (getState() != org.apache.thrift.async.TAsyncMethodCall.State.RESPONSE_READ) {
          throw new IllegalStateException("Method call not finished!");
        }
        org.apache.thrift.transport.TMemoryInputTransport memoryTransport = new org.apache.thrift.transport.TMemoryInputTransport(getFrameBuffer().array());
        org.apache.thrift.protocol.TProtocol prot = client.getProtocolFactory().getProtocol(memoryTransport);
        return (new Client(prot)).recv_connection_getTableTypes();
      }
    }

    public void connection_getTypeInfo(RConnection connection, org.apache.thrift.async.AsyncMethodCallback resultHandler) throws org.apache.thrift.TException {
      checkReady();
      connection_getTypeInfo_call method_call = new connection_getTypeInfo_call(connection, resultHandler, this, ___protocolFactory, ___transport);
      this.___currentMethod = method_call;
      ___manager.call(method_call);
    }

    public static class connection_getTypeInfo_call extends org.apache.thrift.async.TAsyncMethodCall {
      private RConnection connection;
      public connection_getTypeInfo_call(RConnection connection, org.apache.thrift.async.AsyncMethodCallback resultHandler, org.apache.thrift.async.TAsyncClient client, org.apache.thrift.protocol.TProtocolFactory protocolFactory, org.apache.thrift.transport.TNonblockingTransport transport) throws org.apache.thrift.TException {
        super(client, protocolFactory, transport, resultHandler, false);
        this.connection = connection;
      }

      public void write_args(org.apache.thrift.protocol.TProtocol prot) throws org.apache.thrift.TException {
        prot.writeMessageBegin(new org.apache.thrift.protocol.TMessage("connection_getTypeInfo", org.apache.thrift.protocol.TMessageType.CALL, 0));
        connection_getTypeInfo_args args = new connection_getTypeInfo_args();
        args.setConnection(connection);
        args.write(prot);
        prot.writeMessageEnd();
      }

      public RResultSet getResult() throws RSQLException, org.apache.thrift.TException {
        if (getState() != org.apache.thrift.async.TAsyncMethodCall.State.RESPONSE_READ) {
          throw new IllegalStateException("Method call not finished!");
        }
        org.apache.thrift.transport.TMemoryInputTransport memoryTransport = new org.apache.thrift.transport.TMemoryInputTransport(getFrameBuffer().array());
        org.apache.thrift.protocol.TProtocol prot = client.getProtocolFactory().getProtocol(memoryTransport);
        return (new Client(prot)).recv_connection_getTypeInfo();
      }
    }

    public void closeConnection(RConnection connection, org.apache.thrift.async.AsyncMethodCallback resultHandler) throws org.apache.thrift.TException {
      checkReady();
      closeConnection_call method_call = new closeConnection_call(connection, resultHandler, this, ___protocolFactory, ___transport);
      this.___currentMethod = method_call;
      ___manager.call(method_call);
    }

    public static class closeConnection_call extends org.apache.thrift.async.TAsyncMethodCall {
      private RConnection connection;
      public closeConnection_call(RConnection connection, org.apache.thrift.async.AsyncMethodCallback resultHandler, org.apache.thrift.async.TAsyncClient client, org.apache.thrift.protocol.TProtocolFactory protocolFactory, org.apache.thrift.transport.TNonblockingTransport transport) throws org.apache.thrift.TException {
        super(client, protocolFactory, transport, resultHandler, false);
        this.connection = connection;
      }

      public void write_args(org.apache.thrift.protocol.TProtocol prot) throws org.apache.thrift.TException {
        prot.writeMessageBegin(new org.apache.thrift.protocol.TMessage("closeConnection", org.apache.thrift.protocol.TMessageType.CALL, 0));
        closeConnection_args args = new closeConnection_args();
        args.setConnection(connection);
        args.write(prot);
        prot.writeMessageEnd();
      }

      public void getResult() throws RSQLException, org.apache.thrift.TException {
        if (getState() != org.apache.thrift.async.TAsyncMethodCall.State.RESPONSE_READ) {
          throw new IllegalStateException("Method call not finished!");
        }
        org.apache.thrift.transport.TMemoryInputTransport memoryTransport = new org.apache.thrift.transport.TMemoryInputTransport(getFrameBuffer().array());
        org.apache.thrift.protocol.TProtocol prot = client.getProtocolFactory().getProtocol(memoryTransport);
        (new Client(prot)).recv_closeConnection();
      }
    }

    public void statement_close(RStatement statement, org.apache.thrift.async.AsyncMethodCallback resultHandler) throws org.apache.thrift.TException {
      checkReady();
      statement_close_call method_call = new statement_close_call(statement, resultHandler, this, ___protocolFactory, ___transport);
      this.___currentMethod = method_call;
      ___manager.call(method_call);
    }

    public static class statement_close_call extends org.apache.thrift.async.TAsyncMethodCall {
      private RStatement statement;
      public statement_close_call(RStatement statement, org.apache.thrift.async.AsyncMethodCallback resultHandler, org.apache.thrift.async.TAsyncClient client, org.apache.thrift.protocol.TProtocolFactory protocolFactory, org.apache.thrift.transport.TNonblockingTransport transport) throws org.apache.thrift.TException {
        super(client, protocolFactory, transport, resultHandler, false);
        this.statement = statement;
      }

      public void write_args(org.apache.thrift.protocol.TProtocol prot) throws org.apache.thrift.TException {
        prot.writeMessageBegin(new org.apache.thrift.protocol.TMessage("statement_close", org.apache.thrift.protocol.TMessageType.CALL, 0));
        statement_close_args args = new statement_close_args();
        args.setStatement(statement);
        args.write(prot);
        prot.writeMessageEnd();
      }

      public void getResult() throws RSQLException, org.apache.thrift.TException {
        if (getState() != org.apache.thrift.async.TAsyncMethodCall.State.RESPONSE_READ) {
          throw new IllegalStateException("Method call not finished!");
        }
        org.apache.thrift.transport.TMemoryInputTransport memoryTransport = new org.apache.thrift.transport.TMemoryInputTransport(getFrameBuffer().array());
        org.apache.thrift.protocol.TProtocol prot = client.getProtocolFactory().getProtocol(memoryTransport);
        (new Client(prot)).recv_statement_close();
      }
    }

    public void statement_execute(RStatement statement, String sql, org.apache.thrift.async.AsyncMethodCallback resultHandler) throws org.apache.thrift.TException {
      checkReady();
      statement_execute_call method_call = new statement_execute_call(statement, sql, resultHandler, this, ___protocolFactory, ___transport);
      this.___currentMethod = method_call;
      ___manager.call(method_call);
    }

    public static class statement_execute_call extends org.apache.thrift.async.TAsyncMethodCall {
      private RStatement statement;
      private String sql;
      public statement_execute_call(RStatement statement, String sql, org.apache.thrift.async.AsyncMethodCallback resultHandler, org.apache.thrift.async.TAsyncClient client, org.apache.thrift.protocol.TProtocolFactory protocolFactory, org.apache.thrift.transport.TNonblockingTransport transport) throws org.apache.thrift.TException {
        super(client, protocolFactory, transport, resultHandler, false);
        this.statement = statement;
        this.sql = sql;
      }

      public void write_args(org.apache.thrift.protocol.TProtocol prot) throws org.apache.thrift.TException {
        prot.writeMessageBegin(new org.apache.thrift.protocol.TMessage("statement_execute", org.apache.thrift.protocol.TMessageType.CALL, 0));
        statement_execute_args args = new statement_execute_args();
        args.setStatement(statement);
        args.setSql(sql);
        args.write(prot);
        prot.writeMessageEnd();
      }

      public boolean getResult() throws RSQLException, org.apache.thrift.TException {
        if (getState() != org.apache.thrift.async.TAsyncMethodCall.State.RESPONSE_READ) {
          throw new IllegalStateException("Method call not finished!");
        }
        org.apache.thrift.transport.TMemoryInputTransport memoryTransport = new org.apache.thrift.transport.TMemoryInputTransport(getFrameBuffer().array());
        org.apache.thrift.protocol.TProtocol prot = client.getProtocolFactory().getProtocol(memoryTransport);
        return (new Client(prot)).recv_statement_execute();
      }
    }

    public void statement_executeQuery(RStatement statement, String sql, org.apache.thrift.async.AsyncMethodCallback resultHandler) throws org.apache.thrift.TException {
      checkReady();
      statement_executeQuery_call method_call = new statement_executeQuery_call(statement, sql, resultHandler, this, ___protocolFactory, ___transport);
      this.___currentMethod = method_call;
      ___manager.call(method_call);
    }

    public static class statement_executeQuery_call extends org.apache.thrift.async.TAsyncMethodCall {
      private RStatement statement;
      private String sql;
      public statement_executeQuery_call(RStatement statement, String sql, org.apache.thrift.async.AsyncMethodCallback resultHandler, org.apache.thrift.async.TAsyncClient client, org.apache.thrift.protocol.TProtocolFactory protocolFactory, org.apache.thrift.transport.TNonblockingTransport transport) throws org.apache.thrift.TException {
        super(client, protocolFactory, transport, resultHandler, false);
        this.statement = statement;
        this.sql = sql;
      }

      public void write_args(org.apache.thrift.protocol.TProtocol prot) throws org.apache.thrift.TException {
        prot.writeMessageBegin(new org.apache.thrift.protocol.TMessage("statement_executeQuery", org.apache.thrift.protocol.TMessageType.CALL, 0));
        statement_executeQuery_args args = new statement_executeQuery_args();
        args.setStatement(statement);
        args.setSql(sql);
        args.write(prot);
        prot.writeMessageEnd();
      }

      public RResultSet getResult() throws RSQLException, org.apache.thrift.TException {
        if (getState() != org.apache.thrift.async.TAsyncMethodCall.State.RESPONSE_READ) {
          throw new IllegalStateException("Method call not finished!");
        }
        org.apache.thrift.transport.TMemoryInputTransport memoryTransport = new org.apache.thrift.transport.TMemoryInputTransport(getFrameBuffer().array());
        org.apache.thrift.protocol.TProtocol prot = client.getProtocolFactory().getProtocol(memoryTransport);
        return (new Client(prot)).recv_statement_executeQuery();
      }
    }

    public void statement_executeUpdate(RStatement statement, String sql, org.apache.thrift.async.AsyncMethodCallback resultHandler) throws org.apache.thrift.TException {
      checkReady();
      statement_executeUpdate_call method_call = new statement_executeUpdate_call(statement, sql, resultHandler, this, ___protocolFactory, ___transport);
      this.___currentMethod = method_call;
      ___manager.call(method_call);
    }

    public static class statement_executeUpdate_call extends org.apache.thrift.async.TAsyncMethodCall {
      private RStatement statement;
      private String sql;
      public statement_executeUpdate_call(RStatement statement, String sql, org.apache.thrift.async.AsyncMethodCallback resultHandler, org.apache.thrift.async.TAsyncClient client, org.apache.thrift.protocol.TProtocolFactory protocolFactory, org.apache.thrift.transport.TNonblockingTransport transport) throws org.apache.thrift.TException {
        super(client, protocolFactory, transport, resultHandler, false);
        this.statement = statement;
        this.sql = sql;
      }

      public void write_args(org.apache.thrift.protocol.TProtocol prot) throws org.apache.thrift.TException {
        prot.writeMessageBegin(new org.apache.thrift.protocol.TMessage("statement_executeUpdate", org.apache.thrift.protocol.TMessageType.CALL, 0));
        statement_executeUpdate_args args = new statement_executeUpdate_args();
        args.setStatement(statement);
        args.setSql(sql);
        args.write(prot);
        prot.writeMessageEnd();
      }

      public int getResult() throws RSQLException, org.apache.thrift.TException {
        if (getState() != org.apache.thrift.async.TAsyncMethodCall.State.RESPONSE_READ) {
          throw new IllegalStateException("Method call not finished!");
        }
        org.apache.thrift.transport.TMemoryInputTransport memoryTransport = new org.apache.thrift.transport.TMemoryInputTransport(getFrameBuffer().array());
        org.apache.thrift.protocol.TProtocol prot = client.getProtocolFactory().getProtocol(memoryTransport);
        return (new Client(prot)).recv_statement_executeUpdate();
      }
    }

    public void statement_getResultSet(RStatement statement, org.apache.thrift.async.AsyncMethodCallback resultHandler) throws org.apache.thrift.TException {
      checkReady();
      statement_getResultSet_call method_call = new statement_getResultSet_call(statement, resultHandler, this, ___protocolFactory, ___transport);
      this.___currentMethod = method_call;
      ___manager.call(method_call);
    }

    public static class statement_getResultSet_call extends org.apache.thrift.async.TAsyncMethodCall {
      private RStatement statement;
      public statement_getResultSet_call(RStatement statement, org.apache.thrift.async.AsyncMethodCallback resultHandler, org.apache.thrift.async.TAsyncClient client, org.apache.thrift.protocol.TProtocolFactory protocolFactory, org.apache.thrift.transport.TNonblockingTransport transport) throws org.apache.thrift.TException {
        super(client, protocolFactory, transport, resultHandler, false);
        this.statement = statement;
      }

      public void write_args(org.apache.thrift.protocol.TProtocol prot) throws org.apache.thrift.TException {
        prot.writeMessageBegin(new org.apache.thrift.protocol.TMessage("statement_getResultSet", org.apache.thrift.protocol.TMessageType.CALL, 0));
        statement_getResultSet_args args = new statement_getResultSet_args();
        args.setStatement(statement);
        args.write(prot);
        prot.writeMessageEnd();
      }

      public RResultSet getResult() throws RSQLException, org.apache.thrift.TException {
        if (getState() != org.apache.thrift.async.TAsyncMethodCall.State.RESPONSE_READ) {
          throw new IllegalStateException("Method call not finished!");
        }
        org.apache.thrift.transport.TMemoryInputTransport memoryTransport = new org.apache.thrift.transport.TMemoryInputTransport(getFrameBuffer().array());
        org.apache.thrift.protocol.TProtocol prot = client.getProtocolFactory().getProtocol(memoryTransport);
        return (new Client(prot)).recv_statement_getResultSet();
      }
    }

    public void statement_getUpdateCount(RStatement statement, org.apache.thrift.async.AsyncMethodCallback resultHandler) throws org.apache.thrift.TException {
      checkReady();
      statement_getUpdateCount_call method_call = new statement_getUpdateCount_call(statement, resultHandler, this, ___protocolFactory, ___transport);
      this.___currentMethod = method_call;
      ___manager.call(method_call);
    }

    public static class statement_getUpdateCount_call extends org.apache.thrift.async.TAsyncMethodCall {
      private RStatement statement;
      public statement_getUpdateCount_call(RStatement statement, org.apache.thrift.async.AsyncMethodCallback resultHandler, org.apache.thrift.async.TAsyncClient client, org.apache.thrift.protocol.TProtocolFactory protocolFactory, org.apache.thrift.transport.TNonblockingTransport transport) throws org.apache.thrift.TException {
        super(client, protocolFactory, transport, resultHandler, false);
        this.statement = statement;
      }

      public void write_args(org.apache.thrift.protocol.TProtocol prot) throws org.apache.thrift.TException {
        prot.writeMessageBegin(new org.apache.thrift.protocol.TMessage("statement_getUpdateCount", org.apache.thrift.protocol.TMessageType.CALL, 0));
        statement_getUpdateCount_args args = new statement_getUpdateCount_args();
        args.setStatement(statement);
        args.write(prot);
        prot.writeMessageEnd();
      }

      public int getResult() throws RSQLException, org.apache.thrift.TException {
        if (getState() != org.apache.thrift.async.TAsyncMethodCall.State.RESPONSE_READ) {
          throw new IllegalStateException("Method call not finished!");
        }
        org.apache.thrift.transport.TMemoryInputTransport memoryTransport = new org.apache.thrift.transport.TMemoryInputTransport(getFrameBuffer().array());
        org.apache.thrift.protocol.TProtocol prot = client.getProtocolFactory().getProtocol(memoryTransport);
        return (new Client(prot)).recv_statement_getUpdateCount();
      }
    }

    public void statement_getResultSetType(RStatement statement, org.apache.thrift.async.AsyncMethodCallback resultHandler) throws org.apache.thrift.TException {
      checkReady();
      statement_getResultSetType_call method_call = new statement_getResultSetType_call(statement, resultHandler, this, ___protocolFactory, ___transport);
      this.___currentMethod = method_call;
      ___manager.call(method_call);
    }

    public static class statement_getResultSetType_call extends org.apache.thrift.async.TAsyncMethodCall {
      private RStatement statement;
      public statement_getResultSetType_call(RStatement statement, org.apache.thrift.async.AsyncMethodCallback resultHandler, org.apache.thrift.async.TAsyncClient client, org.apache.thrift.protocol.TProtocolFactory protocolFactory, org.apache.thrift.transport.TNonblockingTransport transport) throws org.apache.thrift.TException {
        super(client, protocolFactory, transport, resultHandler, false);
        this.statement = statement;
      }

      public void write_args(org.apache.thrift.protocol.TProtocol prot) throws org.apache.thrift.TException {
        prot.writeMessageBegin(new org.apache.thrift.protocol.TMessage("statement_getResultSetType", org.apache.thrift.protocol.TMessageType.CALL, 0));
        statement_getResultSetType_args args = new statement_getResultSetType_args();
        args.setStatement(statement);
        args.write(prot);
        prot.writeMessageEnd();
      }

      public int getResult() throws RSQLException, org.apache.thrift.TException {
        if (getState() != org.apache.thrift.async.TAsyncMethodCall.State.RESPONSE_READ) {
          throw new IllegalStateException("Method call not finished!");
        }
        org.apache.thrift.transport.TMemoryInputTransport memoryTransport = new org.apache.thrift.transport.TMemoryInputTransport(getFrameBuffer().array());
        org.apache.thrift.protocol.TProtocol prot = client.getProtocolFactory().getProtocol(memoryTransport);
        return (new Client(prot)).recv_statement_getResultSetType();
      }
    }

    public void statement_cancel(RStatement statement, org.apache.thrift.async.AsyncMethodCallback resultHandler) throws org.apache.thrift.TException {
      checkReady();
      statement_cancel_call method_call = new statement_cancel_call(statement, resultHandler, this, ___protocolFactory, ___transport);
      this.___currentMethod = method_call;
      ___manager.call(method_call);
    }

    public static class statement_cancel_call extends org.apache.thrift.async.TAsyncMethodCall {
      private RStatement statement;
      public statement_cancel_call(RStatement statement, org.apache.thrift.async.AsyncMethodCallback resultHandler, org.apache.thrift.async.TAsyncClient client, org.apache.thrift.protocol.TProtocolFactory protocolFactory, org.apache.thrift.transport.TNonblockingTransport transport) throws org.apache.thrift.TException {
        super(client, protocolFactory, transport, resultHandler, false);
        this.statement = statement;
      }

      public void write_args(org.apache.thrift.protocol.TProtocol prot) throws org.apache.thrift.TException {
        prot.writeMessageBegin(new org.apache.thrift.protocol.TMessage("statement_cancel", org.apache.thrift.protocol.TMessageType.CALL, 0));
        statement_cancel_args args = new statement_cancel_args();
        args.setStatement(statement);
        args.write(prot);
        prot.writeMessageEnd();
      }

      public void getResult() throws RSQLException, org.apache.thrift.TException {
        if (getState() != org.apache.thrift.async.TAsyncMethodCall.State.RESPONSE_READ) {
          throw new IllegalStateException("Method call not finished!");
        }
        org.apache.thrift.transport.TMemoryInputTransport memoryTransport = new org.apache.thrift.transport.TMemoryInputTransport(getFrameBuffer().array());
        org.apache.thrift.protocol.TProtocol prot = client.getProtocolFactory().getProtocol(memoryTransport);
        (new Client(prot)).recv_statement_cancel();
      }
    }

    public void statement_addBatch(RStatement statement, String sql, org.apache.thrift.async.AsyncMethodCallback resultHandler) throws org.apache.thrift.TException {
      checkReady();
      statement_addBatch_call method_call = new statement_addBatch_call(statement, sql, resultHandler, this, ___protocolFactory, ___transport);
      this.___currentMethod = method_call;
      ___manager.call(method_call);
    }

    public static class statement_addBatch_call extends org.apache.thrift.async.TAsyncMethodCall {
      private RStatement statement;
      private String sql;
      public statement_addBatch_call(RStatement statement, String sql, org.apache.thrift.async.AsyncMethodCallback resultHandler, org.apache.thrift.async.TAsyncClient client, org.apache.thrift.protocol.TProtocolFactory protocolFactory, org.apache.thrift.transport.TNonblockingTransport transport) throws org.apache.thrift.TException {
        super(client, protocolFactory, transport, resultHandler, false);
        this.statement = statement;
        this.sql = sql;
      }

      public void write_args(org.apache.thrift.protocol.TProtocol prot) throws org.apache.thrift.TException {
        prot.writeMessageBegin(new org.apache.thrift.protocol.TMessage("statement_addBatch", org.apache.thrift.protocol.TMessageType.CALL, 0));
        statement_addBatch_args args = new statement_addBatch_args();
        args.setStatement(statement);
        args.setSql(sql);
        args.write(prot);
        prot.writeMessageEnd();
      }

      public void getResult() throws RSQLException, org.apache.thrift.TException {
        if (getState() != org.apache.thrift.async.TAsyncMethodCall.State.RESPONSE_READ) {
          throw new IllegalStateException("Method call not finished!");
        }
        org.apache.thrift.transport.TMemoryInputTransport memoryTransport = new org.apache.thrift.transport.TMemoryInputTransport(getFrameBuffer().array());
        org.apache.thrift.protocol.TProtocol prot = client.getProtocolFactory().getProtocol(memoryTransport);
        (new Client(prot)).recv_statement_addBatch();
      }
    }

    public void statement_addBatches(RStatement statement, List<String> sqlList, org.apache.thrift.async.AsyncMethodCallback resultHandler) throws org.apache.thrift.TException {
      checkReady();
      statement_addBatches_call method_call = new statement_addBatches_call(statement, sqlList, resultHandler, this, ___protocolFactory, ___transport);
      this.___currentMethod = method_call;
      ___manager.call(method_call);
    }

    public static class statement_addBatches_call extends org.apache.thrift.async.TAsyncMethodCall {
      private RStatement statement;
      private List<String> sqlList;
      public statement_addBatches_call(RStatement statement, List<String> sqlList, org.apache.thrift.async.AsyncMethodCallback resultHandler, org.apache.thrift.async.TAsyncClient client, org.apache.thrift.protocol.TProtocolFactory protocolFactory, org.apache.thrift.transport.TNonblockingTransport transport) throws org.apache.thrift.TException {
        super(client, protocolFactory, transport, resultHandler, false);
        this.statement = statement;
        this.sqlList = sqlList;
      }

      public void write_args(org.apache.thrift.protocol.TProtocol prot) throws org.apache.thrift.TException {
        prot.writeMessageBegin(new org.apache.thrift.protocol.TMessage("statement_addBatches", org.apache.thrift.protocol.TMessageType.CALL, 0));
        statement_addBatches_args args = new statement_addBatches_args();
        args.setStatement(statement);
        args.setSqlList(sqlList);
        args.write(prot);
        prot.writeMessageEnd();
      }

      public void getResult() throws RSQLException, org.apache.thrift.TException {
        if (getState() != org.apache.thrift.async.TAsyncMethodCall.State.RESPONSE_READ) {
          throw new IllegalStateException("Method call not finished!");
        }
        org.apache.thrift.transport.TMemoryInputTransport memoryTransport = new org.apache.thrift.transport.TMemoryInputTransport(getFrameBuffer().array());
        org.apache.thrift.protocol.TProtocol prot = client.getProtocolFactory().getProtocol(memoryTransport);
        (new Client(prot)).recv_statement_addBatches();
      }
    }

    public void statement_clearBatch(RStatement statement, org.apache.thrift.async.AsyncMethodCallback resultHandler) throws org.apache.thrift.TException {
      checkReady();
      statement_clearBatch_call method_call = new statement_clearBatch_call(statement, resultHandler, this, ___protocolFactory, ___transport);
      this.___currentMethod = method_call;
      ___manager.call(method_call);
    }

    public static class statement_clearBatch_call extends org.apache.thrift.async.TAsyncMethodCall {
      private RStatement statement;
      public statement_clearBatch_call(RStatement statement, org.apache.thrift.async.AsyncMethodCallback resultHandler, org.apache.thrift.async.TAsyncClient client, org.apache.thrift.protocol.TProtocolFactory protocolFactory, org.apache.thrift.transport.TNonblockingTransport transport) throws org.apache.thrift.TException {
        super(client, protocolFactory, transport, resultHandler, false);
        this.statement = statement;
      }

      public void write_args(org.apache.thrift.protocol.TProtocol prot) throws org.apache.thrift.TException {
        prot.writeMessageBegin(new org.apache.thrift.protocol.TMessage("statement_clearBatch", org.apache.thrift.protocol.TMessageType.CALL, 0));
        statement_clearBatch_args args = new statement_clearBatch_args();
        args.setStatement(statement);
        args.write(prot);
        prot.writeMessageEnd();
      }

      public void getResult() throws RSQLException, org.apache.thrift.TException {
        if (getState() != org.apache.thrift.async.TAsyncMethodCall.State.RESPONSE_READ) {
          throw new IllegalStateException("Method call not finished!");
        }
        org.apache.thrift.transport.TMemoryInputTransport memoryTransport = new org.apache.thrift.transport.TMemoryInputTransport(getFrameBuffer().array());
        org.apache.thrift.protocol.TProtocol prot = client.getProtocolFactory().getProtocol(memoryTransport);
        (new Client(prot)).recv_statement_clearBatch();
      }
    }

    public void statement_executeBatch(RStatement statement, org.apache.thrift.async.AsyncMethodCallback resultHandler) throws org.apache.thrift.TException {
      checkReady();
      statement_executeBatch_call method_call = new statement_executeBatch_call(statement, resultHandler, this, ___protocolFactory, ___transport);
      this.___currentMethod = method_call;
      ___manager.call(method_call);
    }

    public static class statement_executeBatch_call extends org.apache.thrift.async.TAsyncMethodCall {
      private RStatement statement;
      public statement_executeBatch_call(RStatement statement, org.apache.thrift.async.AsyncMethodCallback resultHandler, org.apache.thrift.async.TAsyncClient client, org.apache.thrift.protocol.TProtocolFactory protocolFactory, org.apache.thrift.transport.TNonblockingTransport transport) throws org.apache.thrift.TException {
        super(client, protocolFactory, transport, resultHandler, false);
        this.statement = statement;
      }

      public void write_args(org.apache.thrift.protocol.TProtocol prot) throws org.apache.thrift.TException {
        prot.writeMessageBegin(new org.apache.thrift.protocol.TMessage("statement_executeBatch", org.apache.thrift.protocol.TMessageType.CALL, 0));
        statement_executeBatch_args args = new statement_executeBatch_args();
        args.setStatement(statement);
        args.write(prot);
        prot.writeMessageEnd();
      }

      public List<Integer> getResult() throws RSQLException, org.apache.thrift.TException {
        if (getState() != org.apache.thrift.async.TAsyncMethodCall.State.RESPONSE_READ) {
          throw new IllegalStateException("Method call not finished!");
        }
        org.apache.thrift.transport.TMemoryInputTransport memoryTransport = new org.apache.thrift.transport.TMemoryInputTransport(getFrameBuffer().array());
        org.apache.thrift.protocol.TProtocol prot = client.getProtocolFactory().getProtocol(memoryTransport);
        return (new Client(prot)).recv_statement_executeBatch();
      }
    }

    public void preparedstatement_execute(RStatement preparedstatement, org.apache.thrift.async.AsyncMethodCallback resultHandler) throws org.apache.thrift.TException {
      checkReady();
      preparedstatement_execute_call method_call = new preparedstatement_execute_call(preparedstatement, resultHandler, this, ___protocolFactory, ___transport);
      this.___currentMethod = method_call;
      ___manager.call(method_call);
    }

    public static class preparedstatement_execute_call extends org.apache.thrift.async.TAsyncMethodCall {
      private RStatement preparedstatement;
      public preparedstatement_execute_call(RStatement preparedstatement, org.apache.thrift.async.AsyncMethodCallback resultHandler, org.apache.thrift.async.TAsyncClient client, org.apache.thrift.protocol.TProtocolFactory protocolFactory, org.apache.thrift.transport.TNonblockingTransport transport) throws org.apache.thrift.TException {
        super(client, protocolFactory, transport, resultHandler, false);
        this.preparedstatement = preparedstatement;
      }

      public void write_args(org.apache.thrift.protocol.TProtocol prot) throws org.apache.thrift.TException {
        prot.writeMessageBegin(new org.apache.thrift.protocol.TMessage("preparedstatement_execute", org.apache.thrift.protocol.TMessageType.CALL, 0));
        preparedstatement_execute_args args = new preparedstatement_execute_args();
        args.setPreparedstatement(preparedstatement);
        args.write(prot);
        prot.writeMessageEnd();
      }

      public boolean getResult() throws RSQLException, org.apache.thrift.TException {
        if (getState() != org.apache.thrift.async.TAsyncMethodCall.State.RESPONSE_READ) {
          throw new IllegalStateException("Method call not finished!");
        }
        org.apache.thrift.transport.TMemoryInputTransport memoryTransport = new org.apache.thrift.transport.TMemoryInputTransport(getFrameBuffer().array());
        org.apache.thrift.protocol.TProtocol prot = client.getProtocolFactory().getProtocol(memoryTransport);
        return (new Client(prot)).recv_preparedstatement_execute();
      }
    }

    public void preparedstatement_executeQuery(RStatement preparedstatement, org.apache.thrift.async.AsyncMethodCallback resultHandler) throws org.apache.thrift.TException {
      checkReady();
      preparedstatement_executeQuery_call method_call = new preparedstatement_executeQuery_call(preparedstatement, resultHandler, this, ___protocolFactory, ___transport);
      this.___currentMethod = method_call;
      ___manager.call(method_call);
    }

    public static class preparedstatement_executeQuery_call extends org.apache.thrift.async.TAsyncMethodCall {
      private RStatement preparedstatement;
      public preparedstatement_executeQuery_call(RStatement preparedstatement, org.apache.thrift.async.AsyncMethodCallback resultHandler, org.apache.thrift.async.TAsyncClient client, org.apache.thrift.protocol.TProtocolFactory protocolFactory, org.apache.thrift.transport.TNonblockingTransport transport) throws org.apache.thrift.TException {
        super(client, protocolFactory, transport, resultHandler, false);
        this.preparedstatement = preparedstatement;
      }

      public void write_args(org.apache.thrift.protocol.TProtocol prot) throws org.apache.thrift.TException {
        prot.writeMessageBegin(new org.apache.thrift.protocol.TMessage("preparedstatement_executeQuery", org.apache.thrift.protocol.TMessageType.CALL, 0));
        preparedstatement_executeQuery_args args = new preparedstatement_executeQuery_args();
        args.setPreparedstatement(preparedstatement);
        args.write(prot);
        prot.writeMessageEnd();
      }

      public RResultSet getResult() throws RSQLException, org.apache.thrift.TException {
        if (getState() != org.apache.thrift.async.TAsyncMethodCall.State.RESPONSE_READ) {
          throw new IllegalStateException("Method call not finished!");
        }
        org.apache.thrift.transport.TMemoryInputTransport memoryTransport = new org.apache.thrift.transport.TMemoryInputTransport(getFrameBuffer().array());
        org.apache.thrift.protocol.TProtocol prot = client.getProtocolFactory().getProtocol(memoryTransport);
        return (new Client(prot)).recv_preparedstatement_executeQuery();
      }
    }

    public void preparedstatement_executeUpdate(RStatement preparedstatement, org.apache.thrift.async.AsyncMethodCallback resultHandler) throws org.apache.thrift.TException {
      checkReady();
      preparedstatement_executeUpdate_call method_call = new preparedstatement_executeUpdate_call(preparedstatement, resultHandler, this, ___protocolFactory, ___transport);
      this.___currentMethod = method_call;
      ___manager.call(method_call);
    }

    public static class preparedstatement_executeUpdate_call extends org.apache.thrift.async.TAsyncMethodCall {
      private RStatement preparedstatement;
      public preparedstatement_executeUpdate_call(RStatement preparedstatement, org.apache.thrift.async.AsyncMethodCallback resultHandler, org.apache.thrift.async.TAsyncClient client, org.apache.thrift.protocol.TProtocolFactory protocolFactory, org.apache.thrift.transport.TNonblockingTransport transport) throws org.apache.thrift.TException {
        super(client, protocolFactory, transport, resultHandler, false);
        this.preparedstatement = preparedstatement;
      }

      public void write_args(org.apache.thrift.protocol.TProtocol prot) throws org.apache.thrift.TException {
        prot.writeMessageBegin(new org.apache.thrift.protocol.TMessage("preparedstatement_executeUpdate", org.apache.thrift.protocol.TMessageType.CALL, 0));
        preparedstatement_executeUpdate_args args = new preparedstatement_executeUpdate_args();
        args.setPreparedstatement(preparedstatement);
        args.write(prot);
        prot.writeMessageEnd();
      }

      public int getResult() throws RSQLException, org.apache.thrift.TException {
        if (getState() != org.apache.thrift.async.TAsyncMethodCall.State.RESPONSE_READ) {
          throw new IllegalStateException("Method call not finished!");
        }
        org.apache.thrift.transport.TMemoryInputTransport memoryTransport = new org.apache.thrift.transport.TMemoryInputTransport(getFrameBuffer().array());
        org.apache.thrift.protocol.TProtocol prot = client.getProtocolFactory().getProtocol(memoryTransport);
        return (new Client(prot)).recv_preparedstatement_executeUpdate();
      }
    }

    public void preparedstatement_setParametersThenExecute(RStatement preparedstatement, List<RValueSQL> parameters, org.apache.thrift.async.AsyncMethodCallback resultHandler) throws org.apache.thrift.TException {
      checkReady();
      preparedstatement_setParametersThenExecute_call method_call = new preparedstatement_setParametersThenExecute_call(preparedstatement, parameters, resultHandler, this, ___protocolFactory, ___transport);
      this.___currentMethod = method_call;
      ___manager.call(method_call);
    }

    public static class preparedstatement_setParametersThenExecute_call extends org.apache.thrift.async.TAsyncMethodCall {
      private RStatement preparedstatement;
      private List<RValueSQL> parameters;
      public preparedstatement_setParametersThenExecute_call(RStatement preparedstatement, List<RValueSQL> parameters, org.apache.thrift.async.AsyncMethodCallback resultHandler, org.apache.thrift.async.TAsyncClient client, org.apache.thrift.protocol.TProtocolFactory protocolFactory, org.apache.thrift.transport.TNonblockingTransport transport) throws org.apache.thrift.TException {
        super(client, protocolFactory, transport, resultHandler, false);
        this.preparedstatement = preparedstatement;
        this.parameters = parameters;
      }

      public void write_args(org.apache.thrift.protocol.TProtocol prot) throws org.apache.thrift.TException {
        prot.writeMessageBegin(new org.apache.thrift.protocol.TMessage("preparedstatement_setParametersThenExecute", org.apache.thrift.protocol.TMessageType.CALL, 0));
        preparedstatement_setParametersThenExecute_args args = new preparedstatement_setParametersThenExecute_args();
        args.setPreparedstatement(preparedstatement);
        args.setParameters(parameters);
        args.write(prot);
        prot.writeMessageEnd();
      }

      public boolean getResult() throws RSQLException, org.apache.thrift.TException {
        if (getState() != org.apache.thrift.async.TAsyncMethodCall.State.RESPONSE_READ) {
          throw new IllegalStateException("Method call not finished!");
        }
        org.apache.thrift.transport.TMemoryInputTransport memoryTransport = new org.apache.thrift.transport.TMemoryInputTransport(getFrameBuffer().array());
        org.apache.thrift.protocol.TProtocol prot = client.getProtocolFactory().getProtocol(memoryTransport);
        return (new Client(prot)).recv_preparedstatement_setParametersThenExecute();
      }
    }

    public void preparedstatement_setParametersThenExecuteQuery(RStatement preparedstatement, List<RValueSQL> parameters, org.apache.thrift.async.AsyncMethodCallback resultHandler) throws org.apache.thrift.TException {
      checkReady();
      preparedstatement_setParametersThenExecuteQuery_call method_call = new preparedstatement_setParametersThenExecuteQuery_call(preparedstatement, parameters, resultHandler, this, ___protocolFactory, ___transport);
      this.___currentMethod = method_call;
      ___manager.call(method_call);
    }

    public static class preparedstatement_setParametersThenExecuteQuery_call extends org.apache.thrift.async.TAsyncMethodCall {
      private RStatement preparedstatement;
      private List<RValueSQL> parameters;
      public preparedstatement_setParametersThenExecuteQuery_call(RStatement preparedstatement, List<RValueSQL> parameters, org.apache.thrift.async.AsyncMethodCallback resultHandler, org.apache.thrift.async.TAsyncClient client, org.apache.thrift.protocol.TProtocolFactory protocolFactory, org.apache.thrift.transport.TNonblockingTransport transport) throws org.apache.thrift.TException {
        super(client, protocolFactory, transport, resultHandler, false);
        this.preparedstatement = preparedstatement;
        this.parameters = parameters;
      }

      public void write_args(org.apache.thrift.protocol.TProtocol prot) throws org.apache.thrift.TException {
        prot.writeMessageBegin(new org.apache.thrift.protocol.TMessage("preparedstatement_setParametersThenExecuteQuery", org.apache.thrift.protocol.TMessageType.CALL, 0));
        preparedstatement_setParametersThenExecuteQuery_args args = new preparedstatement_setParametersThenExecuteQuery_args();
        args.setPreparedstatement(preparedstatement);
        args.setParameters(parameters);
        args.write(prot);
        prot.writeMessageEnd();
      }

      public RResultSet getResult() throws RSQLException, org.apache.thrift.TException {
        if (getState() != org.apache.thrift.async.TAsyncMethodCall.State.RESPONSE_READ) {
          throw new IllegalStateException("Method call not finished!");
        }
        org.apache.thrift.transport.TMemoryInputTransport memoryTransport = new org.apache.thrift.transport.TMemoryInputTransport(getFrameBuffer().array());
        org.apache.thrift.protocol.TProtocol prot = client.getProtocolFactory().getProtocol(memoryTransport);
        return (new Client(prot)).recv_preparedstatement_setParametersThenExecuteQuery();
      }
    }

    public void preparedstatement_setParametersThenExecuteUpdate(RStatement preparedstatement, List<RValueSQL> parameters, org.apache.thrift.async.AsyncMethodCallback resultHandler) throws org.apache.thrift.TException {
      checkReady();
      preparedstatement_setParametersThenExecuteUpdate_call method_call = new preparedstatement_setParametersThenExecuteUpdate_call(preparedstatement, parameters, resultHandler, this, ___protocolFactory, ___transport);
      this.___currentMethod = method_call;
      ___manager.call(method_call);
    }

    public static class preparedstatement_setParametersThenExecuteUpdate_call extends org.apache.thrift.async.TAsyncMethodCall {
      private RStatement preparedstatement;
      private List<RValueSQL> parameters;
      public preparedstatement_setParametersThenExecuteUpdate_call(RStatement preparedstatement, List<RValueSQL> parameters, org.apache.thrift.async.AsyncMethodCallback resultHandler, org.apache.thrift.async.TAsyncClient client, org.apache.thrift.protocol.TProtocolFactory protocolFactory, org.apache.thrift.transport.TNonblockingTransport transport) throws org.apache.thrift.TException {
        super(client, protocolFactory, transport, resultHandler, false);
        this.preparedstatement = preparedstatement;
        this.parameters = parameters;
      }

      public void write_args(org.apache.thrift.protocol.TProtocol prot) throws org.apache.thrift.TException {
        prot.writeMessageBegin(new org.apache.thrift.protocol.TMessage("preparedstatement_setParametersThenExecuteUpdate", org.apache.thrift.protocol.TMessageType.CALL, 0));
        preparedstatement_setParametersThenExecuteUpdate_args args = new preparedstatement_setParametersThenExecuteUpdate_args();
        args.setPreparedstatement(preparedstatement);
        args.setParameters(parameters);
        args.write(prot);
        prot.writeMessageEnd();
      }

      public int getResult() throws RSQLException, org.apache.thrift.TException {
        if (getState() != org.apache.thrift.async.TAsyncMethodCall.State.RESPONSE_READ) {
          throw new IllegalStateException("Method call not finished!");
        }
        org.apache.thrift.transport.TMemoryInputTransport memoryTransport = new org.apache.thrift.transport.TMemoryInputTransport(getFrameBuffer().array());
        org.apache.thrift.protocol.TProtocol prot = client.getProtocolFactory().getProtocol(memoryTransport);
        return (new Client(prot)).recv_preparedstatement_setParametersThenExecuteUpdate();
      }
    }

    public void preparedstatement_setParameters(RStatement preparedStatement, List<RValueSQL> parameters, org.apache.thrift.async.AsyncMethodCallback resultHandler) throws org.apache.thrift.TException {
      checkReady();
      preparedstatement_setParameters_call method_call = new preparedstatement_setParameters_call(preparedStatement, parameters, resultHandler, this, ___protocolFactory, ___transport);
      this.___currentMethod = method_call;
      ___manager.call(method_call);
    }

    public static class preparedstatement_setParameters_call extends org.apache.thrift.async.TAsyncMethodCall {
      private RStatement preparedStatement;
      private List<RValueSQL> parameters;
      public preparedstatement_setParameters_call(RStatement preparedStatement, List<RValueSQL> parameters, org.apache.thrift.async.AsyncMethodCallback resultHandler, org.apache.thrift.async.TAsyncClient client, org.apache.thrift.protocol.TProtocolFactory protocolFactory, org.apache.thrift.transport.TNonblockingTransport transport) throws org.apache.thrift.TException {
        super(client, protocolFactory, transport, resultHandler, false);
        this.preparedStatement = preparedStatement;
        this.parameters = parameters;
      }

      public void write_args(org.apache.thrift.protocol.TProtocol prot) throws org.apache.thrift.TException {
        prot.writeMessageBegin(new org.apache.thrift.protocol.TMessage("preparedstatement_setParameters", org.apache.thrift.protocol.TMessageType.CALL, 0));
        preparedstatement_setParameters_args args = new preparedstatement_setParameters_args();
        args.setPreparedStatement(preparedStatement);
        args.setParameters(parameters);
        args.write(prot);
        prot.writeMessageEnd();
      }

      public void getResult() throws RSQLException, org.apache.thrift.TException {
        if (getState() != org.apache.thrift.async.TAsyncMethodCall.State.RESPONSE_READ) {
          throw new IllegalStateException("Method call not finished!");
        }
        org.apache.thrift.transport.TMemoryInputTransport memoryTransport = new org.apache.thrift.transport.TMemoryInputTransport(getFrameBuffer().array());
        org.apache.thrift.protocol.TProtocol prot = client.getProtocolFactory().getProtocol(memoryTransport);
        (new Client(prot)).recv_preparedstatement_setParameters();
      }
    }

    public void preparedstatement_setParameter(RStatement preparedStatement, RValueSQL parameter, int position, org.apache.thrift.async.AsyncMethodCallback resultHandler) throws org.apache.thrift.TException {
      checkReady();
      preparedstatement_setParameter_call method_call = new preparedstatement_setParameter_call(preparedStatement, parameter, position, resultHandler, this, ___protocolFactory, ___transport);
      this.___currentMethod = method_call;
      ___manager.call(method_call);
    }

    public static class preparedstatement_setParameter_call extends org.apache.thrift.async.TAsyncMethodCall {
      private RStatement preparedStatement;
      private RValueSQL parameter;
      private int position;
      public preparedstatement_setParameter_call(RStatement preparedStatement, RValueSQL parameter, int position, org.apache.thrift.async.AsyncMethodCallback resultHandler, org.apache.thrift.async.TAsyncClient client, org.apache.thrift.protocol.TProtocolFactory protocolFactory, org.apache.thrift.transport.TNonblockingTransport transport) throws org.apache.thrift.TException {
        super(client, protocolFactory, transport, resultHandler, false);
        this.preparedStatement = preparedStatement;
        this.parameter = parameter;
        this.position = position;
      }

      public void write_args(org.apache.thrift.protocol.TProtocol prot) throws org.apache.thrift.TException {
        prot.writeMessageBegin(new org.apache.thrift.protocol.TMessage("preparedstatement_setParameter", org.apache.thrift.protocol.TMessageType.CALL, 0));
        preparedstatement_setParameter_args args = new preparedstatement_setParameter_args();
        args.setPreparedStatement(preparedStatement);
        args.setParameter(parameter);
        args.setPosition(position);
        args.write(prot);
        prot.writeMessageEnd();
      }

      public void getResult() throws RSQLException, org.apache.thrift.TException {
        if (getState() != org.apache.thrift.async.TAsyncMethodCall.State.RESPONSE_READ) {
          throw new IllegalStateException("Method call not finished!");
        }
        org.apache.thrift.transport.TMemoryInputTransport memoryTransport = new org.apache.thrift.transport.TMemoryInputTransport(getFrameBuffer().array());
        org.apache.thrift.protocol.TProtocol prot = client.getProtocolFactory().getProtocol(memoryTransport);
        (new Client(prot)).recv_preparedstatement_setParameter();
      }
    }

    public void preparedstatement_clearParameters(RStatement preparedStatement, org.apache.thrift.async.AsyncMethodCallback resultHandler) throws org.apache.thrift.TException {
      checkReady();
      preparedstatement_clearParameters_call method_call = new preparedstatement_clearParameters_call(preparedStatement, resultHandler, this, ___protocolFactory, ___transport);
      this.___currentMethod = method_call;
      ___manager.call(method_call);
    }

    public static class preparedstatement_clearParameters_call extends org.apache.thrift.async.TAsyncMethodCall {
      private RStatement preparedStatement;
      public preparedstatement_clearParameters_call(RStatement preparedStatement, org.apache.thrift.async.AsyncMethodCallback resultHandler, org.apache.thrift.async.TAsyncClient client, org.apache.thrift.protocol.TProtocolFactory protocolFactory, org.apache.thrift.transport.TNonblockingTransport transport) throws org.apache.thrift.TException {
        super(client, protocolFactory, transport, resultHandler, false);
        this.preparedStatement = preparedStatement;
      }

      public void write_args(org.apache.thrift.protocol.TProtocol prot) throws org.apache.thrift.TException {
        prot.writeMessageBegin(new org.apache.thrift.protocol.TMessage("preparedstatement_clearParameters", org.apache.thrift.protocol.TMessageType.CALL, 0));
        preparedstatement_clearParameters_args args = new preparedstatement_clearParameters_args();
        args.setPreparedStatement(preparedStatement);
        args.write(prot);
        prot.writeMessageEnd();
      }

      public void getResult() throws RSQLException, org.apache.thrift.TException {
        if (getState() != org.apache.thrift.async.TAsyncMethodCall.State.RESPONSE_READ) {
          throw new IllegalStateException("Method call not finished!");
        }
        org.apache.thrift.transport.TMemoryInputTransport memoryTransport = new org.apache.thrift.transport.TMemoryInputTransport(getFrameBuffer().array());
        org.apache.thrift.protocol.TProtocol prot = client.getProtocolFactory().getProtocol(memoryTransport);
        (new Client(prot)).recv_preparedstatement_clearParameters();
      }
    }

    public void preparedstatement_addBatchWithParameters(RStatement preparedStatement, List<RValueSQL> parameters, org.apache.thrift.async.AsyncMethodCallback resultHandler) throws org.apache.thrift.TException {
      checkReady();
      preparedstatement_addBatchWithParameters_call method_call = new preparedstatement_addBatchWithParameters_call(preparedStatement, parameters, resultHandler, this, ___protocolFactory, ___transport);
      this.___currentMethod = method_call;
      ___manager.call(method_call);
    }

    public static class preparedstatement_addBatchWithParameters_call extends org.apache.thrift.async.TAsyncMethodCall {
      private RStatement preparedStatement;
      private List<RValueSQL> parameters;
      public preparedstatement_addBatchWithParameters_call(RStatement preparedStatement, List<RValueSQL> parameters, org.apache.thrift.async.AsyncMethodCallback resultHandler, org.apache.thrift.async.TAsyncClient client, org.apache.thrift.protocol.TProtocolFactory protocolFactory, org.apache.thrift.transport.TNonblockingTransport transport) throws org.apache.thrift.TException {
        super(client, protocolFactory, transport, resultHandler, false);
        this.preparedStatement = preparedStatement;
        this.parameters = parameters;
      }

      public void write_args(org.apache.thrift.protocol.TProtocol prot) throws org.apache.thrift.TException {
        prot.writeMessageBegin(new org.apache.thrift.protocol.TMessage("preparedstatement_addBatchWithParameters", org.apache.thrift.protocol.TMessageType.CALL, 0));
        preparedstatement_addBatchWithParameters_args args = new preparedstatement_addBatchWithParameters_args();
        args.setPreparedStatement(preparedStatement);
        args.setParameters(parameters);
        args.write(prot);
        prot.writeMessageEnd();
      }

      public void getResult() throws RSQLException, org.apache.thrift.TException {
        if (getState() != org.apache.thrift.async.TAsyncMethodCall.State.RESPONSE_READ) {
          throw new IllegalStateException("Method call not finished!");
        }
        org.apache.thrift.transport.TMemoryInputTransport memoryTransport = new org.apache.thrift.transport.TMemoryInputTransport(getFrameBuffer().array());
        org.apache.thrift.protocol.TProtocol prot = client.getProtocolFactory().getProtocol(memoryTransport);
        (new Client(prot)).recv_preparedstatement_addBatchWithParameters();
      }
    }

    public void preparedstatement_addBatch(RStatement preparedStatement, org.apache.thrift.async.AsyncMethodCallback resultHandler) throws org.apache.thrift.TException {
      checkReady();
      preparedstatement_addBatch_call method_call = new preparedstatement_addBatch_call(preparedStatement, resultHandler, this, ___protocolFactory, ___transport);
      this.___currentMethod = method_call;
      ___manager.call(method_call);
    }

    public static class preparedstatement_addBatch_call extends org.apache.thrift.async.TAsyncMethodCall {
      private RStatement preparedStatement;
      public preparedstatement_addBatch_call(RStatement preparedStatement, org.apache.thrift.async.AsyncMethodCallback resultHandler, org.apache.thrift.async.TAsyncClient client, org.apache.thrift.protocol.TProtocolFactory protocolFactory, org.apache.thrift.transport.TNonblockingTransport transport) throws org.apache.thrift.TException {
        super(client, protocolFactory, transport, resultHandler, false);
        this.preparedStatement = preparedStatement;
      }

      public void write_args(org.apache.thrift.protocol.TProtocol prot) throws org.apache.thrift.TException {
        prot.writeMessageBegin(new org.apache.thrift.protocol.TMessage("preparedstatement_addBatch", org.apache.thrift.protocol.TMessageType.CALL, 0));
        preparedstatement_addBatch_args args = new preparedstatement_addBatch_args();
        args.setPreparedStatement(preparedStatement);
        args.write(prot);
        prot.writeMessageEnd();
      }

      public void getResult() throws RSQLException, org.apache.thrift.TException {
        if (getState() != org.apache.thrift.async.TAsyncMethodCall.State.RESPONSE_READ) {
          throw new IllegalStateException("Method call not finished!");
        }
        org.apache.thrift.transport.TMemoryInputTransport memoryTransport = new org.apache.thrift.transport.TMemoryInputTransport(getFrameBuffer().array());
        org.apache.thrift.protocol.TProtocol prot = client.getProtocolFactory().getProtocol(memoryTransport);
        (new Client(prot)).recv_preparedstatement_addBatch();
      }
    }

    public void preparedstatement_executeBatch(RStatement statement, List<List<RValueSQL>> parameters, org.apache.thrift.async.AsyncMethodCallback resultHandler) throws org.apache.thrift.TException {
      checkReady();
      preparedstatement_executeBatch_call method_call = new preparedstatement_executeBatch_call(statement, parameters, resultHandler, this, ___protocolFactory, ___transport);
      this.___currentMethod = method_call;
      ___manager.call(method_call);
    }

    public static class preparedstatement_executeBatch_call extends org.apache.thrift.async.TAsyncMethodCall {
      private RStatement statement;
      private List<List<RValueSQL>> parameters;
      public preparedstatement_executeBatch_call(RStatement statement, List<List<RValueSQL>> parameters, org.apache.thrift.async.AsyncMethodCallback resultHandler, org.apache.thrift.async.TAsyncClient client, org.apache.thrift.protocol.TProtocolFactory protocolFactory, org.apache.thrift.transport.TNonblockingTransport transport) throws org.apache.thrift.TException {
        super(client, protocolFactory, transport, resultHandler, false);
        this.statement = statement;
        this.parameters = parameters;
      }

      public void write_args(org.apache.thrift.protocol.TProtocol prot) throws org.apache.thrift.TException {
        prot.writeMessageBegin(new org.apache.thrift.protocol.TMessage("preparedstatement_executeBatch", org.apache.thrift.protocol.TMessageType.CALL, 0));
        preparedstatement_executeBatch_args args = new preparedstatement_executeBatch_args();
        args.setStatement(statement);
        args.setParameters(parameters);
        args.write(prot);
        prot.writeMessageEnd();
      }

      public List<Integer> getResult() throws RSQLException, org.apache.thrift.TException {
        if (getState() != org.apache.thrift.async.TAsyncMethodCall.State.RESPONSE_READ) {
          throw new IllegalStateException("Method call not finished!");
        }
        org.apache.thrift.transport.TMemoryInputTransport memoryTransport = new org.apache.thrift.transport.TMemoryInputTransport(getFrameBuffer().array());
        org.apache.thrift.protocol.TProtocol prot = client.getProtocolFactory().getProtocol(memoryTransport);
        return (new Client(prot)).recv_preparedstatement_executeBatch();
      }
    }

    public void statement_getWarnings(RStatement statement, org.apache.thrift.async.AsyncMethodCallback resultHandler) throws org.apache.thrift.TException {
      checkReady();
      statement_getWarnings_call method_call = new statement_getWarnings_call(statement, resultHandler, this, ___protocolFactory, ___transport);
      this.___currentMethod = method_call;
      ___manager.call(method_call);
    }

    public static class statement_getWarnings_call extends org.apache.thrift.async.TAsyncMethodCall {
      private RStatement statement;
      public statement_getWarnings_call(RStatement statement, org.apache.thrift.async.AsyncMethodCallback resultHandler, org.apache.thrift.async.TAsyncClient client, org.apache.thrift.protocol.TProtocolFactory protocolFactory, org.apache.thrift.transport.TNonblockingTransport transport) throws org.apache.thrift.TException {
        super(client, protocolFactory, transport, resultHandler, false);
        this.statement = statement;
      }

      public void write_args(org.apache.thrift.protocol.TProtocol prot) throws org.apache.thrift.TException {
        prot.writeMessageBegin(new org.apache.thrift.protocol.TMessage("statement_getWarnings", org.apache.thrift.protocol.TMessageType.CALL, 0));
        statement_getWarnings_args args = new statement_getWarnings_args();
        args.setStatement(statement);
        args.write(prot);
        prot.writeMessageEnd();
      }

      public statement_getWarnings_return getResult() throws RSQLException, org.apache.thrift.TException {
        if (getState() != org.apache.thrift.async.TAsyncMethodCall.State.RESPONSE_READ) {
          throw new IllegalStateException("Method call not finished!");
        }
        org.apache.thrift.transport.TMemoryInputTransport memoryTransport = new org.apache.thrift.transport.TMemoryInputTransport(getFrameBuffer().array());
        org.apache.thrift.protocol.TProtocol prot = client.getProtocolFactory().getProtocol(memoryTransport);
        return (new Client(prot)).recv_statement_getWarnings();
      }
    }

    public void statement_clearWarnings(RStatement statement, org.apache.thrift.async.AsyncMethodCallback resultHandler) throws org.apache.thrift.TException {
      checkReady();
      statement_clearWarnings_call method_call = new statement_clearWarnings_call(statement, resultHandler, this, ___protocolFactory, ___transport);
      this.___currentMethod = method_call;
      ___manager.call(method_call);
    }

    public static class statement_clearWarnings_call extends org.apache.thrift.async.TAsyncMethodCall {
      private RStatement statement;
      public statement_clearWarnings_call(RStatement statement, org.apache.thrift.async.AsyncMethodCallback resultHandler, org.apache.thrift.async.TAsyncClient client, org.apache.thrift.protocol.TProtocolFactory protocolFactory, org.apache.thrift.transport.TNonblockingTransport transport) throws org.apache.thrift.TException {
        super(client, protocolFactory, transport, resultHandler, false);
        this.statement = statement;
      }

      public void write_args(org.apache.thrift.protocol.TProtocol prot) throws org.apache.thrift.TException {
        prot.writeMessageBegin(new org.apache.thrift.protocol.TMessage("statement_clearWarnings", org.apache.thrift.protocol.TMessageType.CALL, 0));
        statement_clearWarnings_args args = new statement_clearWarnings_args();
        args.setStatement(statement);
        args.write(prot);
        prot.writeMessageEnd();
      }

      public void getResult() throws RSQLException, org.apache.thrift.TException {
        if (getState() != org.apache.thrift.async.TAsyncMethodCall.State.RESPONSE_READ) {
          throw new IllegalStateException("Method call not finished!");
        }
        org.apache.thrift.transport.TMemoryInputTransport memoryTransport = new org.apache.thrift.transport.TMemoryInputTransport(getFrameBuffer().array());
        org.apache.thrift.protocol.TProtocol prot = client.getProtocolFactory().getProtocol(memoryTransport);
        (new Client(prot)).recv_statement_clearWarnings();
      }
    }

    public void statement_getMaxRows(RStatement statement, org.apache.thrift.async.AsyncMethodCallback resultHandler) throws org.apache.thrift.TException {
      checkReady();
      statement_getMaxRows_call method_call = new statement_getMaxRows_call(statement, resultHandler, this, ___protocolFactory, ___transport);
      this.___currentMethod = method_call;
      ___manager.call(method_call);
    }

    public static class statement_getMaxRows_call extends org.apache.thrift.async.TAsyncMethodCall {
      private RStatement statement;
      public statement_getMaxRows_call(RStatement statement, org.apache.thrift.async.AsyncMethodCallback resultHandler, org.apache.thrift.async.TAsyncClient client, org.apache.thrift.protocol.TProtocolFactory protocolFactory, org.apache.thrift.transport.TNonblockingTransport transport) throws org.apache.thrift.TException {
        super(client, protocolFactory, transport, resultHandler, false);
        this.statement = statement;
      }

      public void write_args(org.apache.thrift.protocol.TProtocol prot) throws org.apache.thrift.TException {
        prot.writeMessageBegin(new org.apache.thrift.protocol.TMessage("statement_getMaxRows", org.apache.thrift.protocol.TMessageType.CALL, 0));
        statement_getMaxRows_args args = new statement_getMaxRows_args();
        args.setStatement(statement);
        args.write(prot);
        prot.writeMessageEnd();
      }

      public int getResult() throws RSQLException, org.apache.thrift.TException {
        if (getState() != org.apache.thrift.async.TAsyncMethodCall.State.RESPONSE_READ) {
          throw new IllegalStateException("Method call not finished!");
        }
        org.apache.thrift.transport.TMemoryInputTransport memoryTransport = new org.apache.thrift.transport.TMemoryInputTransport(getFrameBuffer().array());
        org.apache.thrift.protocol.TProtocol prot = client.getProtocolFactory().getProtocol(memoryTransport);
        return (new Client(prot)).recv_statement_getMaxRows();
      }
    }

    public void statement_setMaxRows(RStatement statement, int max, org.apache.thrift.async.AsyncMethodCallback resultHandler) throws org.apache.thrift.TException {
      checkReady();
      statement_setMaxRows_call method_call = new statement_setMaxRows_call(statement, max, resultHandler, this, ___protocolFactory, ___transport);
      this.___currentMethod = method_call;
      ___manager.call(method_call);
    }

    public static class statement_setMaxRows_call extends org.apache.thrift.async.TAsyncMethodCall {
      private RStatement statement;
      private int max;
      public statement_setMaxRows_call(RStatement statement, int max, org.apache.thrift.async.AsyncMethodCallback resultHandler, org.apache.thrift.async.TAsyncClient client, org.apache.thrift.protocol.TProtocolFactory protocolFactory, org.apache.thrift.transport.TNonblockingTransport transport) throws org.apache.thrift.TException {
        super(client, protocolFactory, transport, resultHandler, false);
        this.statement = statement;
        this.max = max;
      }

      public void write_args(org.apache.thrift.protocol.TProtocol prot) throws org.apache.thrift.TException {
        prot.writeMessageBegin(new org.apache.thrift.protocol.TMessage("statement_setMaxRows", org.apache.thrift.protocol.TMessageType.CALL, 0));
        statement_setMaxRows_args args = new statement_setMaxRows_args();
        args.setStatement(statement);
        args.setMax(max);
        args.write(prot);
        prot.writeMessageEnd();
      }

      public void getResult() throws RSQLException, org.apache.thrift.TException {
        if (getState() != org.apache.thrift.async.TAsyncMethodCall.State.RESPONSE_READ) {
          throw new IllegalStateException("Method call not finished!");
        }
        org.apache.thrift.transport.TMemoryInputTransport memoryTransport = new org.apache.thrift.transport.TMemoryInputTransport(getFrameBuffer().array());
        org.apache.thrift.protocol.TProtocol prot = client.getProtocolFactory().getProtocol(memoryTransport);
        (new Client(prot)).recv_statement_setMaxRows();
      }
    }

    public void statement_getQueryTimeout(RStatement statement, org.apache.thrift.async.AsyncMethodCallback resultHandler) throws org.apache.thrift.TException {
      checkReady();
      statement_getQueryTimeout_call method_call = new statement_getQueryTimeout_call(statement, resultHandler, this, ___protocolFactory, ___transport);
      this.___currentMethod = method_call;
      ___manager.call(method_call);
    }

    public static class statement_getQueryTimeout_call extends org.apache.thrift.async.TAsyncMethodCall {
      private RStatement statement;
      public statement_getQueryTimeout_call(RStatement statement, org.apache.thrift.async.AsyncMethodCallback resultHandler, org.apache.thrift.async.TAsyncClient client, org.apache.thrift.protocol.TProtocolFactory protocolFactory, org.apache.thrift.transport.TNonblockingTransport transport) throws org.apache.thrift.TException {
        super(client, protocolFactory, transport, resultHandler, false);
        this.statement = statement;
      }

      public void write_args(org.apache.thrift.protocol.TProtocol prot) throws org.apache.thrift.TException {
        prot.writeMessageBegin(new org.apache.thrift.protocol.TMessage("statement_getQueryTimeout", org.apache.thrift.protocol.TMessageType.CALL, 0));
        statement_getQueryTimeout_args args = new statement_getQueryTimeout_args();
        args.setStatement(statement);
        args.write(prot);
        prot.writeMessageEnd();
      }

      public int getResult() throws RSQLException, org.apache.thrift.TException {
        if (getState() != org.apache.thrift.async.TAsyncMethodCall.State.RESPONSE_READ) {
          throw new IllegalStateException("Method call not finished!");
        }
        org.apache.thrift.transport.TMemoryInputTransport memoryTransport = new org.apache.thrift.transport.TMemoryInputTransport(getFrameBuffer().array());
        org.apache.thrift.protocol.TProtocol prot = client.getProtocolFactory().getProtocol(memoryTransport);
        return (new Client(prot)).recv_statement_getQueryTimeout();
      }
    }

    public void statement_setQueryTimeout(RStatement statement, int seconds, org.apache.thrift.async.AsyncMethodCallback resultHandler) throws org.apache.thrift.TException {
      checkReady();
      statement_setQueryTimeout_call method_call = new statement_setQueryTimeout_call(statement, seconds, resultHandler, this, ___protocolFactory, ___transport);
      this.___currentMethod = method_call;
      ___manager.call(method_call);
    }

    public static class statement_setQueryTimeout_call extends org.apache.thrift.async.TAsyncMethodCall {
      private RStatement statement;
      private int seconds;
      public statement_setQueryTimeout_call(RStatement statement, int seconds, org.apache.thrift.async.AsyncMethodCallback resultHandler, org.apache.thrift.async.TAsyncClient client, org.apache.thrift.protocol.TProtocolFactory protocolFactory, org.apache.thrift.transport.TNonblockingTransport transport) throws org.apache.thrift.TException {
        super(client, protocolFactory, transport, resultHandler, false);
        this.statement = statement;
        this.seconds = seconds;
      }

      public void write_args(org.apache.thrift.protocol.TProtocol prot) throws org.apache.thrift.TException {
        prot.writeMessageBegin(new org.apache.thrift.protocol.TMessage("statement_setQueryTimeout", org.apache.thrift.protocol.TMessageType.CALL, 0));
        statement_setQueryTimeout_args args = new statement_setQueryTimeout_args();
        args.setStatement(statement);
        args.setSeconds(seconds);
        args.write(prot);
        prot.writeMessageEnd();
      }

      public void getResult() throws RSQLException, org.apache.thrift.TException {
        if (getState() != org.apache.thrift.async.TAsyncMethodCall.State.RESPONSE_READ) {
          throw new IllegalStateException("Method call not finished!");
        }
        org.apache.thrift.transport.TMemoryInputTransport memoryTransport = new org.apache.thrift.transport.TMemoryInputTransport(getFrameBuffer().array());
        org.apache.thrift.protocol.TProtocol prot = client.getProtocolFactory().getProtocol(memoryTransport);
        (new Client(prot)).recv_statement_setQueryTimeout();
      }
    }

  }

  public static class Processor<I extends Iface> extends org.apache.thrift.TBaseProcessor<I> implements org.apache.thrift.TProcessor {
    private static final Logger LOGGER = LoggerFactory.getLogger(Processor.class.getName());
    public Processor(I iface) {
      super(iface, getProcessMap(new HashMap<String, org.apache.thrift.ProcessFunction<I, ? extends org.apache.thrift.TBase>>()));
    }

    protected Processor(I iface, Map<String,  org.apache.thrift.ProcessFunction<I, ? extends  org.apache.thrift.TBase>> processMap) {
      super(iface, getProcessMap(processMap));
    }

    private static <I extends Iface> Map<String,  org.apache.thrift.ProcessFunction<I, ? extends  org.apache.thrift.TBase>> getProcessMap(Map<String,  org.apache.thrift.ProcessFunction<I, ? extends  org.apache.thrift.TBase>> processMap) {
      processMap.put("createConnection", new createConnection());
      processMap.put("createStatement", new createStatement());
      processMap.put("prepareStatement", new prepareStatement());
      processMap.put("prepareCall", new prepareCall());
      processMap.put("connection_getstaticmetadata", new connection_getstaticmetadata());
      processMap.put("connection_isvalid", new connection_isvalid());
      processMap.put("connection_commit", new connection_commit());
      processMap.put("connection_rollback", new connection_rollback());
      processMap.put("connection_setAutoCommit", new connection_setAutoCommit());
      processMap.put("connection_getAutoCommit", new connection_getAutoCommit());
      processMap.put("connection_setTransactionIsolation", new connection_setTransactionIsolation());
      processMap.put("connection_getTransactionIsolation", new connection_getTransactionIsolation());
      processMap.put("connection_setReadOnly", new connection_setReadOnly());
      processMap.put("connection_getReadOnly", new connection_getReadOnly());
      processMap.put("connection_setCatalog", new connection_setCatalog());
      processMap.put("connection_getCatalog", new connection_getCatalog());
      processMap.put("connection_setSchema", new connection_setSchema());
      processMap.put("connection_getSchema", new connection_getSchema());
      processMap.put("connection_getCatalogSeparator", new connection_getCatalogSeparator());
      processMap.put("connection_getCatalogTerm", new connection_getCatalogTerm());
      processMap.put("connection_getSchemaTerm", new connection_getSchemaTerm());
      processMap.put("connection_getCatalogs", new connection_getCatalogs());
      processMap.put("connection_getSchemas", new connection_getSchemas());
      processMap.put("connection_getTables", new connection_getTables());
      processMap.put("connection_getColumns", new connection_getColumns());
      processMap.put("connection_getSQLKeywords", new connection_getSQLKeywords());
      processMap.put("connection_getTableTypes", new connection_getTableTypes());
      processMap.put("connection_getTypeInfo", new connection_getTypeInfo());
      processMap.put("closeConnection", new closeConnection());
      processMap.put("statement_close", new statement_close());
      processMap.put("statement_execute", new statement_execute());
      processMap.put("statement_executeQuery", new statement_executeQuery());
      processMap.put("statement_executeUpdate", new statement_executeUpdate());
      processMap.put("statement_getResultSet", new statement_getResultSet());
      processMap.put("statement_getUpdateCount", new statement_getUpdateCount());
      processMap.put("statement_getResultSetType", new statement_getResultSetType());
      processMap.put("statement_cancel", new statement_cancel());
      processMap.put("statement_addBatch", new statement_addBatch());
      processMap.put("statement_addBatches", new statement_addBatches());
      processMap.put("statement_clearBatch", new statement_clearBatch());
      processMap.put("statement_executeBatch", new statement_executeBatch());
      processMap.put("preparedstatement_execute", new preparedstatement_execute());
      processMap.put("preparedstatement_executeQuery", new preparedstatement_executeQuery());
      processMap.put("preparedstatement_executeUpdate", new preparedstatement_executeUpdate());
      processMap.put("preparedstatement_setParametersThenExecute", new preparedstatement_setParametersThenExecute());
      processMap.put("preparedstatement_setParametersThenExecuteQuery", new preparedstatement_setParametersThenExecuteQuery());
      processMap.put("preparedstatement_setParametersThenExecuteUpdate", new preparedstatement_setParametersThenExecuteUpdate());
      processMap.put("preparedstatement_setParameters", new preparedstatement_setParameters());
      processMap.put("preparedstatement_setParameter", new preparedstatement_setParameter());
      processMap.put("preparedstatement_clearParameters", new preparedstatement_clearParameters());
      processMap.put("preparedstatement_addBatchWithParameters", new preparedstatement_addBatchWithParameters());
      processMap.put("preparedstatement_addBatch", new preparedstatement_addBatch());
      processMap.put("preparedstatement_executeBatch", new preparedstatement_executeBatch());
      processMap.put("statement_getWarnings", new statement_getWarnings());
      processMap.put("statement_clearWarnings", new statement_clearWarnings());
      processMap.put("statement_getMaxRows", new statement_getMaxRows());
      processMap.put("statement_setMaxRows", new statement_setMaxRows());
      processMap.put("statement_getQueryTimeout", new statement_getQueryTimeout());
      processMap.put("statement_setQueryTimeout", new statement_setQueryTimeout());
      return processMap;
    }

    public static class createConnection<I extends Iface> extends org.apache.thrift.ProcessFunction<I, createConnection_args> {
      public createConnection() {
        super("createConnection");
      }

      public createConnection_args getEmptyArgsInstance() {
        return new createConnection_args();
      }

      protected boolean isOneway() {
        return false;
      }

      public createConnection_result getResult(I iface, createConnection_args args) throws org.apache.thrift.TException {
        createConnection_result result = new createConnection_result();
        try {
          result.success = iface.createConnection(args.url, args.properties);
        } catch (RSQLException sqlException) {
          result.sqlException = sqlException;
        }
        return result;
      }
    }

    public static class createStatement<I extends Iface> extends org.apache.thrift.ProcessFunction<I, createStatement_args> {
      public createStatement() {
        super("createStatement");
      }

      public createStatement_args getEmptyArgsInstance() {
        return new createStatement_args();
      }

      protected boolean isOneway() {
        return false;
      }

      public createStatement_result getResult(I iface, createStatement_args args) throws org.apache.thrift.TException {
        createStatement_result result = new createStatement_result();
        try {
          result.success = iface.createStatement(args.connection);
        } catch (RSQLException sqlException) {
          result.sqlException = sqlException;
        }
        return result;
      }
    }

    public static class prepareStatement<I extends Iface> extends org.apache.thrift.ProcessFunction<I, prepareStatement_args> {
      public prepareStatement() {
        super("prepareStatement");
      }

      public prepareStatement_args getEmptyArgsInstance() {
        return new prepareStatement_args();
      }

      protected boolean isOneway() {
        return false;
      }

      public prepareStatement_result getResult(I iface, prepareStatement_args args) throws org.apache.thrift.TException {
        prepareStatement_result result = new prepareStatement_result();
        try {
          result.success = iface.prepareStatement(args.connection, args.sql);
        } catch (RSQLException sqlException) {
          result.sqlException = sqlException;
        }
        return result;
      }
    }

    public static class prepareCall<I extends Iface> extends org.apache.thrift.ProcessFunction<I, prepareCall_args> {
      public prepareCall() {
        super("prepareCall");
      }

      public prepareCall_args getEmptyArgsInstance() {
        return new prepareCall_args();
      }

      protected boolean isOneway() {
        return false;
      }

      public prepareCall_result getResult(I iface, prepareCall_args args) throws org.apache.thrift.TException {
        prepareCall_result result = new prepareCall_result();
        try {
          result.success = iface.prepareCall(args.connection, args.sql);
        } catch (RSQLException sqlException) {
          result.sqlException = sqlException;
        }
        return result;
      }
    }

    public static class connection_getstaticmetadata<I extends Iface> extends org.apache.thrift.ProcessFunction<I, connection_getstaticmetadata_args> {
      public connection_getstaticmetadata() {
        super("connection_getstaticmetadata");
      }

      public connection_getstaticmetadata_args getEmptyArgsInstance() {
        return new connection_getstaticmetadata_args();
      }

      protected boolean isOneway() {
        return false;
      }

      public connection_getstaticmetadata_result getResult(I iface, connection_getstaticmetadata_args args) throws org.apache.thrift.TException {
        connection_getstaticmetadata_result result = new connection_getstaticmetadata_result();
        try {
          result.success = iface.connection_getstaticmetadata(args.connection);
        } catch (RSQLException sqlException) {
          result.sqlException = sqlException;
        }
        return result;
      }
    }

    public static class connection_isvalid<I extends Iface> extends org.apache.thrift.ProcessFunction<I, connection_isvalid_args> {
      public connection_isvalid() {
        super("connection_isvalid");
      }

      public connection_isvalid_args getEmptyArgsInstance() {
        return new connection_isvalid_args();
      }

      protected boolean isOneway() {
        return false;
      }

      public connection_isvalid_result getResult(I iface, connection_isvalid_args args) throws org.apache.thrift.TException {
        connection_isvalid_result result = new connection_isvalid_result();
        try {
          result.success = iface.connection_isvalid(args.connection, args.timeout);
          result.setSuccessIsSet(true);
        } catch (RSQLException sqlException) {
          result.sqlException = sqlException;
        }
        return result;
      }
    }

    public static class connection_commit<I extends Iface> extends org.apache.thrift.ProcessFunction<I, connection_commit_args> {
      public connection_commit() {
        super("connection_commit");
      }

      public connection_commit_args getEmptyArgsInstance() {
        return new connection_commit_args();
      }

      protected boolean isOneway() {
        return false;
      }

      public connection_commit_result getResult(I iface, connection_commit_args args) throws org.apache.thrift.TException {
        connection_commit_result result = new connection_commit_result();
        try {
          iface.connection_commit(args.connection);
        } catch (RSQLException sqlException) {
          result.sqlException = sqlException;
        }
        return result;
      }
    }

    public static class connection_rollback<I extends Iface> extends org.apache.thrift.ProcessFunction<I, connection_rollback_args> {
      public connection_rollback() {
        super("connection_rollback");
      }

      public connection_rollback_args getEmptyArgsInstance() {
        return new connection_rollback_args();
      }

      protected boolean isOneway() {
        return false;
      }

      public connection_rollback_result getResult(I iface, connection_rollback_args args) throws org.apache.thrift.TException {
        connection_rollback_result result = new connection_rollback_result();
        try {
          iface.connection_rollback(args.connection);
        } catch (RSQLException sqlException) {
          result.sqlException = sqlException;
        }
        return result;
      }
    }

    public static class connection_setAutoCommit<I extends Iface> extends org.apache.thrift.ProcessFunction<I, connection_setAutoCommit_args> {
      public connection_setAutoCommit() {
        super("connection_setAutoCommit");
      }

      public connection_setAutoCommit_args getEmptyArgsInstance() {
        return new connection_setAutoCommit_args();
      }

      protected boolean isOneway() {
        return false;
      }

      public connection_setAutoCommit_result getResult(I iface, connection_setAutoCommit_args args) throws org.apache.thrift.TException {
        connection_setAutoCommit_result result = new connection_setAutoCommit_result();
        try {
          iface.connection_setAutoCommit(args.connection, args.autoCommit);
        } catch (RSQLException sqlException) {
          result.sqlException = sqlException;
        }
        return result;
      }
    }

    public static class connection_getAutoCommit<I extends Iface> extends org.apache.thrift.ProcessFunction<I, connection_getAutoCommit_args> {
      public connection_getAutoCommit() {
        super("connection_getAutoCommit");
      }

      public connection_getAutoCommit_args getEmptyArgsInstance() {
        return new connection_getAutoCommit_args();
      }

      protected boolean isOneway() {
        return false;
      }

      public connection_getAutoCommit_result getResult(I iface, connection_getAutoCommit_args args) throws org.apache.thrift.TException {
        connection_getAutoCommit_result result = new connection_getAutoCommit_result();
        try {
          result.success = iface.connection_getAutoCommit(args.connection);
          result.setSuccessIsSet(true);
        } catch (RSQLException sqlException) {
          result.sqlException = sqlException;
        }
        return result;
      }
    }

    public static class connection_setTransactionIsolation<I extends Iface> extends org.apache.thrift.ProcessFunction<I, connection_setTransactionIsolation_args> {
      public connection_setTransactionIsolation() {
        super("connection_setTransactionIsolation");
      }

      public connection_setTransactionIsolation_args getEmptyArgsInstance() {
        return new connection_setTransactionIsolation_args();
      }

      protected boolean isOneway() {
        return false;
      }

      public connection_setTransactionIsolation_result getResult(I iface, connection_setTransactionIsolation_args args) throws org.apache.thrift.TException {
        connection_setTransactionIsolation_result result = new connection_setTransactionIsolation_result();
        try {
          iface.connection_setTransactionIsolation(args.connection, args.level);
        } catch (RSQLException sqlException) {
          result.sqlException = sqlException;
        }
        return result;
      }
    }

    public static class connection_getTransactionIsolation<I extends Iface> extends org.apache.thrift.ProcessFunction<I, connection_getTransactionIsolation_args> {
      public connection_getTransactionIsolation() {
        super("connection_getTransactionIsolation");
      }

      public connection_getTransactionIsolation_args getEmptyArgsInstance() {
        return new connection_getTransactionIsolation_args();
      }

      protected boolean isOneway() {
        return false;
      }

      public connection_getTransactionIsolation_result getResult(I iface, connection_getTransactionIsolation_args args) throws org.apache.thrift.TException {
        connection_getTransactionIsolation_result result = new connection_getTransactionIsolation_result();
        try {
          result.success = iface.connection_getTransactionIsolation(args.connection);
          result.setSuccessIsSet(true);
        } catch (RSQLException sqlException) {
          result.sqlException = sqlException;
        }
        return result;
      }
    }

    public static class connection_setReadOnly<I extends Iface> extends org.apache.thrift.ProcessFunction<I, connection_setReadOnly_args> {
      public connection_setReadOnly() {
        super("connection_setReadOnly");
      }

      public connection_setReadOnly_args getEmptyArgsInstance() {
        return new connection_setReadOnly_args();
      }

      protected boolean isOneway() {
        return false;
      }

      public connection_setReadOnly_result getResult(I iface, connection_setReadOnly_args args) throws org.apache.thrift.TException {
        connection_setReadOnly_result result = new connection_setReadOnly_result();
        try {
          iface.connection_setReadOnly(args.connection, args.readOnly);
        } catch (RSQLException sqlException) {
          result.sqlException = sqlException;
        }
        return result;
      }
    }

    public static class connection_getReadOnly<I extends Iface> extends org.apache.thrift.ProcessFunction<I, connection_getReadOnly_args> {
      public connection_getReadOnly() {
        super("connection_getReadOnly");
      }

      public connection_getReadOnly_args getEmptyArgsInstance() {
        return new connection_getReadOnly_args();
      }

      protected boolean isOneway() {
        return false;
      }

      public connection_getReadOnly_result getResult(I iface, connection_getReadOnly_args args) throws org.apache.thrift.TException {
        connection_getReadOnly_result result = new connection_getReadOnly_result();
        try {
          result.success = iface.connection_getReadOnly(args.connection);
          result.setSuccessIsSet(true);
        } catch (RSQLException sqlException) {
          result.sqlException = sqlException;
        }
        return result;
      }
    }

    public static class connection_setCatalog<I extends Iface> extends org.apache.thrift.ProcessFunction<I, connection_setCatalog_args> {
      public connection_setCatalog() {
        super("connection_setCatalog");
      }

      public connection_setCatalog_args getEmptyArgsInstance() {
        return new connection_setCatalog_args();
      }

      protected boolean isOneway() {
        return false;
      }

      public connection_setCatalog_result getResult(I iface, connection_setCatalog_args args) throws org.apache.thrift.TException {
        connection_setCatalog_result result = new connection_setCatalog_result();
        try {
          iface.connection_setCatalog(args.connection, args.catalog);
        } catch (RSQLException sqlException) {
          result.sqlException = sqlException;
        }
        return result;
      }
    }

    public static class connection_getCatalog<I extends Iface> extends org.apache.thrift.ProcessFunction<I, connection_getCatalog_args> {
      public connection_getCatalog() {
        super("connection_getCatalog");
      }

      public connection_getCatalog_args getEmptyArgsInstance() {
        return new connection_getCatalog_args();
      }

      protected boolean isOneway() {
        return false;
      }

      public connection_getCatalog_result getResult(I iface, connection_getCatalog_args args) throws org.apache.thrift.TException {
        connection_getCatalog_result result = new connection_getCatalog_result();
        try {
          result.success = iface.connection_getCatalog(args.connection);
        } catch (RSQLException sqlException) {
          result.sqlException = sqlException;
        }
        return result;
      }
    }

    public static class connection_setSchema<I extends Iface> extends org.apache.thrift.ProcessFunction<I, connection_setSchema_args> {
      public connection_setSchema() {
        super("connection_setSchema");
      }

      public connection_setSchema_args getEmptyArgsInstance() {
        return new connection_setSchema_args();
      }

      protected boolean isOneway() {
        return false;
      }

      public connection_setSchema_result getResult(I iface, connection_setSchema_args args) throws org.apache.thrift.TException {
        connection_setSchema_result result = new connection_setSchema_result();
        try {
          iface.connection_setSchema(args.connection, args.schema);
        } catch (RSQLException sqlException) {
          result.sqlException = sqlException;
        }
        return result;
      }
    }

    public static class connection_getSchema<I extends Iface> extends org.apache.thrift.ProcessFunction<I, connection_getSchema_args> {
      public connection_getSchema() {
        super("connection_getSchema");
      }

      public connection_getSchema_args getEmptyArgsInstance() {
        return new connection_getSchema_args();
      }

      protected boolean isOneway() {
        return false;
      }

      public connection_getSchema_result getResult(I iface, connection_getSchema_args args) throws org.apache.thrift.TException {
        connection_getSchema_result result = new connection_getSchema_result();
        try {
          result.success = iface.connection_getSchema(args.connection);
        } catch (RSQLException sqlException) {
          result.sqlException = sqlException;
        }
        return result;
      }
    }

    public static class connection_getCatalogSeparator<I extends Iface> extends org.apache.thrift.ProcessFunction<I, connection_getCatalogSeparator_args> {
      public connection_getCatalogSeparator() {
        super("connection_getCatalogSeparator");
      }

      public connection_getCatalogSeparator_args getEmptyArgsInstance() {
        return new connection_getCatalogSeparator_args();
      }

      protected boolean isOneway() {
        return false;
      }

      public connection_getCatalogSeparator_result getResult(I iface, connection_getCatalogSeparator_args args) throws org.apache.thrift.TException {
        connection_getCatalogSeparator_result result = new connection_getCatalogSeparator_result();
        try {
          result.success = iface.connection_getCatalogSeparator(args.connection);
        } catch (RSQLException sqlException) {
          result.sqlException = sqlException;
        }
        return result;
      }
    }

    public static class connection_getCatalogTerm<I extends Iface> extends org.apache.thrift.ProcessFunction<I, connection_getCatalogTerm_args> {
      public connection_getCatalogTerm() {
        super("connection_getCatalogTerm");
      }

      public connection_getCatalogTerm_args getEmptyArgsInstance() {
        return new connection_getCatalogTerm_args();
      }

      protected boolean isOneway() {
        return false;
      }

      public connection_getCatalogTerm_result getResult(I iface, connection_getCatalogTerm_args args) throws org.apache.thrift.TException {
        connection_getCatalogTerm_result result = new connection_getCatalogTerm_result();
        try {
          result.success = iface.connection_getCatalogTerm(args.connection);
        } catch (RSQLException sqlException) {
          result.sqlException = sqlException;
        }
        return result;
      }
    }

    public static class connection_getSchemaTerm<I extends Iface> extends org.apache.thrift.ProcessFunction<I, connection_getSchemaTerm_args> {
      public connection_getSchemaTerm() {
        super("connection_getSchemaTerm");
      }

      public connection_getSchemaTerm_args getEmptyArgsInstance() {
        return new connection_getSchemaTerm_args();
      }

      protected boolean isOneway() {
        return false;
      }

      public connection_getSchemaTerm_result getResult(I iface, connection_getSchemaTerm_args args) throws org.apache.thrift.TException {
        connection_getSchemaTerm_result result = new connection_getSchemaTerm_result();
        try {
          result.success = iface.connection_getSchemaTerm(args.connection);
        } catch (RSQLException sqlException) {
          result.sqlException = sqlException;
        }
        return result;
      }
    }

    public static class connection_getCatalogs<I extends Iface> extends org.apache.thrift.ProcessFunction<I, connection_getCatalogs_args> {
      public connection_getCatalogs() {
        super("connection_getCatalogs");
      }

      public connection_getCatalogs_args getEmptyArgsInstance() {
        return new connection_getCatalogs_args();
      }

      protected boolean isOneway() {
        return false;
      }

      public connection_getCatalogs_result getResult(I iface, connection_getCatalogs_args args) throws org.apache.thrift.TException {
        connection_getCatalogs_result result = new connection_getCatalogs_result();
        try {
          result.success = iface.connection_getCatalogs(args.connection);
        } catch (RSQLException sqlException) {
          result.sqlException = sqlException;
        }
        return result;
      }
    }

    public static class connection_getSchemas<I extends Iface> extends org.apache.thrift.ProcessFunction<I, connection_getSchemas_args> {
      public connection_getSchemas() {
        super("connection_getSchemas");
      }

      public connection_getSchemas_args getEmptyArgsInstance() {
        return new connection_getSchemas_args();
      }

      protected boolean isOneway() {
        return false;
      }

      public connection_getSchemas_result getResult(I iface, connection_getSchemas_args args) throws org.apache.thrift.TException {
        connection_getSchemas_result result = new connection_getSchemas_result();
        try {
          result.success = iface.connection_getSchemas(args.connection, args.catalog, args.schemaPattern);
        } catch (RSQLException sqlException) {
          result.sqlException = sqlException;
        }
        return result;
      }
    }

    public static class connection_getTables<I extends Iface> extends org.apache.thrift.ProcessFunction<I, connection_getTables_args> {
      public connection_getTables() {
        super("connection_getTables");
      }

      public connection_getTables_args getEmptyArgsInstance() {
        return new connection_getTables_args();
      }

      protected boolean isOneway() {
        return false;
      }

      public connection_getTables_result getResult(I iface, connection_getTables_args args) throws org.apache.thrift.TException {
        connection_getTables_result result = new connection_getTables_result();
        try {
          result.success = iface.connection_getTables(args.connection, args.catalog, args.schemaPattern, args.tableNamePattern, args.types);
        } catch (RSQLException sqlException) {
          result.sqlException = sqlException;
        }
        return result;
      }
    }

    public static class connection_getColumns<I extends Iface> extends org.apache.thrift.ProcessFunction<I, connection_getColumns_args> {
      public connection_getColumns() {
        super("connection_getColumns");
      }

      public connection_getColumns_args getEmptyArgsInstance() {
        return new connection_getColumns_args();
      }

      protected boolean isOneway() {
        return false;
      }

      public connection_getColumns_result getResult(I iface, connection_getColumns_args args) throws org.apache.thrift.TException {
        connection_getColumns_result result = new connection_getColumns_result();
        try {
          result.success = iface.connection_getColumns(args.connection, args.catalog, args.schemaPattern, args.tableNamePattern, args.columnNamePattern);
        } catch (RSQLException sqlException) {
          result.sqlException = sqlException;
        }
        return result;
      }
    }

    public static class connection_getSQLKeywords<I extends Iface> extends org.apache.thrift.ProcessFunction<I, connection_getSQLKeywords_args> {
      public connection_getSQLKeywords() {
        super("connection_getSQLKeywords");
      }

      public connection_getSQLKeywords_args getEmptyArgsInstance() {
        return new connection_getSQLKeywords_args();
      }

      protected boolean isOneway() {
        return false;
      }

      public connection_getSQLKeywords_result getResult(I iface, connection_getSQLKeywords_args args) throws org.apache.thrift.TException {
        connection_getSQLKeywords_result result = new connection_getSQLKeywords_result();
        try {
          result.success = iface.connection_getSQLKeywords(args.connection);
        } catch (RSQLException sqlException) {
          result.sqlException = sqlException;
        }
        return result;
      }
    }

    public static class connection_getTableTypes<I extends Iface> extends org.apache.thrift.ProcessFunction<I, connection_getTableTypes_args> {
      public connection_getTableTypes() {
        super("connection_getTableTypes");
      }

      public connection_getTableTypes_args getEmptyArgsInstance() {
        return new connection_getTableTypes_args();
      }

      protected boolean isOneway() {
        return false;
      }

      public connection_getTableTypes_result getResult(I iface, connection_getTableTypes_args args) throws org.apache.thrift.TException {
        connection_getTableTypes_result result = new connection_getTableTypes_result();
        try {
          result.success = iface.connection_getTableTypes(args.connection);
        } catch (RSQLException sqlException) {
          result.sqlException = sqlException;
        }
        return result;
      }
    }

    public static class connection_getTypeInfo<I extends Iface> extends org.apache.thrift.ProcessFunction<I, connection_getTypeInfo_args> {
      public connection_getTypeInfo() {
        super("connection_getTypeInfo");
      }

      public connection_getTypeInfo_args getEmptyArgsInstance() {
        return new connection_getTypeInfo_args();
      }

      protected boolean isOneway() {
        return false;
      }

      public connection_getTypeInfo_result getResult(I iface, connection_getTypeInfo_args args) throws org.apache.thrift.TException {
        connection_getTypeInfo_result result = new connection_getTypeInfo_result();
        try {
          result.success = iface.connection_getTypeInfo(args.connection);
        } catch (RSQLException sqlException) {
          result.sqlException = sqlException;
        }
        return result;
      }
    }

    public static class closeConnection<I extends Iface> extends org.apache.thrift.ProcessFunction<I, closeConnection_args> {
      public closeConnection() {
        super("closeConnection");
      }

      public closeConnection_args getEmptyArgsInstance() {
        return new closeConnection_args();
      }

      protected boolean isOneway() {
        return false;
      }

      public closeConnection_result getResult(I iface, closeConnection_args args) throws org.apache.thrift.TException {
        closeConnection_result result = new closeConnection_result();
        try {
          iface.closeConnection(args.connection);
        } catch (RSQLException sqlException) {
          result.sqlException = sqlException;
        }
        return result;
      }
    }

    public static class statement_close<I extends Iface> extends org.apache.thrift.ProcessFunction<I, statement_close_args> {
      public statement_close() {
        super("statement_close");
      }

      public statement_close_args getEmptyArgsInstance() {
        return new statement_close_args();
      }

      protected boolean isOneway() {
        return false;
      }

      public statement_close_result getResult(I iface, statement_close_args args) throws org.apache.thrift.TException {
        statement_close_result result = new statement_close_result();
        try {
          iface.statement_close(args.statement);
        } catch (RSQLException sqlException) {
          result.sqlException = sqlException;
        }
        return result;
      }
    }

    public static class statement_execute<I extends Iface> extends org.apache.thrift.ProcessFunction<I, statement_execute_args> {
      public statement_execute() {
        super("statement_execute");
      }

      public statement_execute_args getEmptyArgsInstance() {
        return new statement_execute_args();
      }

      protected boolean isOneway() {
        return false;
      }

      public statement_execute_result getResult(I iface, statement_execute_args args) throws org.apache.thrift.TException {
        statement_execute_result result = new statement_execute_result();
        try {
          result.success = iface.statement_execute(args.statement, args.sql);
          result.setSuccessIsSet(true);
        } catch (RSQLException sqlException) {
          result.sqlException = sqlException;
        }
        return result;
      }
    }

    public static class statement_executeQuery<I extends Iface> extends org.apache.thrift.ProcessFunction<I, statement_executeQuery_args> {
      public statement_executeQuery() {
        super("statement_executeQuery");
      }

      public statement_executeQuery_args getEmptyArgsInstance() {
        return new statement_executeQuery_args();
      }

      protected boolean isOneway() {
        return false;
      }

      public statement_executeQuery_result getResult(I iface, statement_executeQuery_args args) throws org.apache.thrift.TException {
        statement_executeQuery_result result = new statement_executeQuery_result();
        try {
          result.success = iface.statement_executeQuery(args.statement, args.sql);
        } catch (RSQLException sqlException) {
          result.sqlException = sqlException;
        }
        return result;
      }
    }

    public static class statement_executeUpdate<I extends Iface> extends org.apache.thrift.ProcessFunction<I, statement_executeUpdate_args> {
      public statement_executeUpdate() {
        super("statement_executeUpdate");
      }

      public statement_executeUpdate_args getEmptyArgsInstance() {
        return new statement_executeUpdate_args();
      }

      protected boolean isOneway() {
        return false;
      }

      public statement_executeUpdate_result getResult(I iface, statement_executeUpdate_args args) throws org.apache.thrift.TException {
        statement_executeUpdate_result result = new statement_executeUpdate_result();
        try {
          result.success = iface.statement_executeUpdate(args.statement, args.sql);
          result.setSuccessIsSet(true);
        } catch (RSQLException sqlException) {
          result.sqlException = sqlException;
        }
        return result;
      }
    }

    public static class statement_getResultSet<I extends Iface> extends org.apache.thrift.ProcessFunction<I, statement_getResultSet_args> {
      public statement_getResultSet() {
        super("statement_getResultSet");
      }

      public statement_getResultSet_args getEmptyArgsInstance() {
        return new statement_getResultSet_args();
      }

      protected boolean isOneway() {
        return false;
      }

      public statement_getResultSet_result getResult(I iface, statement_getResultSet_args args) throws org.apache.thrift.TException {
        statement_getResultSet_result result = new statement_getResultSet_result();
        try {
          result.success = iface.statement_getResultSet(args.statement);
        } catch (RSQLException sqlException) {
          result.sqlException = sqlException;
        }
        return result;
      }
    }

    public static class statement_getUpdateCount<I extends Iface> extends org.apache.thrift.ProcessFunction<I, statement_getUpdateCount_args> {
      public statement_getUpdateCount() {
        super("statement_getUpdateCount");
      }

      public statement_getUpdateCount_args getEmptyArgsInstance() {
        return new statement_getUpdateCount_args();
      }

      protected boolean isOneway() {
        return false;
      }

      public statement_getUpdateCount_result getResult(I iface, statement_getUpdateCount_args args) throws org.apache.thrift.TException {
        statement_getUpdateCount_result result = new statement_getUpdateCount_result();
        try {
          result.success = iface.statement_getUpdateCount(args.statement);
          result.setSuccessIsSet(true);
        } catch (RSQLException sqlException) {
          result.sqlException = sqlException;
        }
        return result;
      }
    }

    public static class statement_getResultSetType<I extends Iface> extends org.apache.thrift.ProcessFunction<I, statement_getResultSetType_args> {
      public statement_getResultSetType() {
        super("statement_getResultSetType");
      }

      public statement_getResultSetType_args getEmptyArgsInstance() {
        return new statement_getResultSetType_args();
      }

      protected boolean isOneway() {
        return false;
      }

      public statement_getResultSetType_result getResult(I iface, statement_getResultSetType_args args) throws org.apache.thrift.TException {
        statement_getResultSetType_result result = new statement_getResultSetType_result();
        try {
          result.success = iface.statement_getResultSetType(args.statement);
          result.setSuccessIsSet(true);
        } catch (RSQLException sqlException) {
          result.sqlException = sqlException;
        }
        return result;
      }
    }

    public static class statement_cancel<I extends Iface> extends org.apache.thrift.ProcessFunction<I, statement_cancel_args> {
      public statement_cancel() {
        super("statement_cancel");
      }

      public statement_cancel_args getEmptyArgsInstance() {
        return new statement_cancel_args();
      }

      protected boolean isOneway() {
        return false;
      }

      public statement_cancel_result getResult(I iface, statement_cancel_args args) throws org.apache.thrift.TException {
        statement_cancel_result result = new statement_cancel_result();
        try {
          iface.statement_cancel(args.statement);
        } catch (RSQLException sqlException) {
          result.sqlException = sqlException;
        }
        return result;
      }
    }

    public static class statement_addBatch<I extends Iface> extends org.apache.thrift.ProcessFunction<I, statement_addBatch_args> {
      public statement_addBatch() {
        super("statement_addBatch");
      }

      public statement_addBatch_args getEmptyArgsInstance() {
        return new statement_addBatch_args();
      }

      protected boolean isOneway() {
        return false;
      }

      public statement_addBatch_result getResult(I iface, statement_addBatch_args args) throws org.apache.thrift.TException {
        statement_addBatch_result result = new statement_addBatch_result();
        try {
          iface.statement_addBatch(args.statement, args.sql);
        } catch (RSQLException sqlException) {
          result.sqlException = sqlException;
        }
        return result;
      }
    }

    public static class statement_addBatches<I extends Iface> extends org.apache.thrift.ProcessFunction<I, statement_addBatches_args> {
      public statement_addBatches() {
        super("statement_addBatches");
      }

      public statement_addBatches_args getEmptyArgsInstance() {
        return new statement_addBatches_args();
      }

      protected boolean isOneway() {
        return false;
      }

      public statement_addBatches_result getResult(I iface, statement_addBatches_args args) throws org.apache.thrift.TException {
        statement_addBatches_result result = new statement_addBatches_result();
        try {
          iface.statement_addBatches(args.statement, args.sqlList);
        } catch (RSQLException sqlException) {
          result.sqlException = sqlException;
        }
        return result;
      }
    }

    public static class statement_clearBatch<I extends Iface> extends org.apache.thrift.ProcessFunction<I, statement_clearBatch_args> {
      public statement_clearBatch() {
        super("statement_clearBatch");
      }

      public statement_clearBatch_args getEmptyArgsInstance() {
        return new statement_clearBatch_args();
      }

      protected boolean isOneway() {
        return false;
      }

      public statement_clearBatch_result getResult(I iface, statement_clearBatch_args args) throws org.apache.thrift.TException {
        statement_clearBatch_result result = new statement_clearBatch_result();
        try {
          iface.statement_clearBatch(args.statement);
        } catch (RSQLException sqlException) {
          result.sqlException = sqlException;
        }
        return result;
      }
    }

    public static class statement_executeBatch<I extends Iface> extends org.apache.thrift.ProcessFunction<I, statement_executeBatch_args> {
      public statement_executeBatch() {
        super("statement_executeBatch");
      }

      public statement_executeBatch_args getEmptyArgsInstance() {
        return new statement_executeBatch_args();
      }

      protected boolean isOneway() {
        return false;
      }

      public statement_executeBatch_result getResult(I iface, statement_executeBatch_args args) throws org.apache.thrift.TException {
        statement_executeBatch_result result = new statement_executeBatch_result();
        try {
          result.success = iface.statement_executeBatch(args.statement);
        } catch (RSQLException sqlException) {
          result.sqlException = sqlException;
        }
        return result;
      }
    }

    public static class preparedstatement_execute<I extends Iface> extends org.apache.thrift.ProcessFunction<I, preparedstatement_execute_args> {
      public preparedstatement_execute() {
        super("preparedstatement_execute");
      }

      public preparedstatement_execute_args getEmptyArgsInstance() {
        return new preparedstatement_execute_args();
      }

      protected boolean isOneway() {
        return false;
      }

      public preparedstatement_execute_result getResult(I iface, preparedstatement_execute_args args) throws org.apache.thrift.TException {
        preparedstatement_execute_result result = new preparedstatement_execute_result();
        try {
          result.success = iface.preparedstatement_execute(args.preparedstatement);
          result.setSuccessIsSet(true);
        } catch (RSQLException sqlException) {
          result.sqlException = sqlException;
        }
        return result;
      }
    }

    public static class preparedstatement_executeQuery<I extends Iface> extends org.apache.thrift.ProcessFunction<I, preparedstatement_executeQuery_args> {
      public preparedstatement_executeQuery() {
        super("preparedstatement_executeQuery");
      }

      public preparedstatement_executeQuery_args getEmptyArgsInstance() {
        return new preparedstatement_executeQuery_args();
      }

      protected boolean isOneway() {
        return false;
      }

      public preparedstatement_executeQuery_result getResult(I iface, preparedstatement_executeQuery_args args) throws org.apache.thrift.TException {
        preparedstatement_executeQuery_result result = new preparedstatement_executeQuery_result();
        try {
          result.success = iface.preparedstatement_executeQuery(args.preparedstatement);
        } catch (RSQLException sqlException) {
          result.sqlException = sqlException;
        }
        return result;
      }
    }

    public static class preparedstatement_executeUpdate<I extends Iface> extends org.apache.thrift.ProcessFunction<I, preparedstatement_executeUpdate_args> {
      public preparedstatement_executeUpdate() {
        super("preparedstatement_executeUpdate");
      }

      public preparedstatement_executeUpdate_args getEmptyArgsInstance() {
        return new preparedstatement_executeUpdate_args();
      }

      protected boolean isOneway() {
        return false;
      }

      public preparedstatement_executeUpdate_result getResult(I iface, preparedstatement_executeUpdate_args args) throws org.apache.thrift.TException {
        preparedstatement_executeUpdate_result result = new preparedstatement_executeUpdate_result();
        try {
          result.success = iface.preparedstatement_executeUpdate(args.preparedstatement);
          result.setSuccessIsSet(true);
        } catch (RSQLException sqlException) {
          result.sqlException = sqlException;
        }
        return result;
      }
    }

    public static class preparedstatement_setParametersThenExecute<I extends Iface> extends org.apache.thrift.ProcessFunction<I, preparedstatement_setParametersThenExecute_args> {
      public preparedstatement_setParametersThenExecute() {
        super("preparedstatement_setParametersThenExecute");
      }

      public preparedstatement_setParametersThenExecute_args getEmptyArgsInstance() {
        return new preparedstatement_setParametersThenExecute_args();
      }

      protected boolean isOneway() {
        return false;
      }

      public preparedstatement_setParametersThenExecute_result getResult(I iface, preparedstatement_setParametersThenExecute_args args) throws org.apache.thrift.TException {
        preparedstatement_setParametersThenExecute_result result = new preparedstatement_setParametersThenExecute_result();
        try {
          result.success = iface.preparedstatement_setParametersThenExecute(args.preparedstatement, args.parameters);
          result.setSuccessIsSet(true);
        } catch (RSQLException sqlException) {
          result.sqlException = sqlException;
        }
        return result;
      }
    }

    public static class preparedstatement_setParametersThenExecuteQuery<I extends Iface> extends org.apache.thrift.ProcessFunction<I, preparedstatement_setParametersThenExecuteQuery_args> {
      public preparedstatement_setParametersThenExecuteQuery() {
        super("preparedstatement_setParametersThenExecuteQuery");
      }

      public preparedstatement_setParametersThenExecuteQuery_args getEmptyArgsInstance() {
        return new preparedstatement_setParametersThenExecuteQuery_args();
      }

      protected boolean isOneway() {
        return false;
      }

      public preparedstatement_setParametersThenExecuteQuery_result getResult(I iface, preparedstatement_setParametersThenExecuteQuery_args args) throws org.apache.thrift.TException {
        preparedstatement_setParametersThenExecuteQuery_result result = new preparedstatement_setParametersThenExecuteQuery_result();
        try {
          result.success = iface.preparedstatement_setParametersThenExecuteQuery(args.preparedstatement, args.parameters);
        } catch (RSQLException sqlException) {
          result.sqlException = sqlException;
        }
        return result;
      }
    }

    public static class preparedstatement_setParametersThenExecuteUpdate<I extends Iface> extends org.apache.thrift.ProcessFunction<I, preparedstatement_setParametersThenExecuteUpdate_args> {
      public preparedstatement_setParametersThenExecuteUpdate() {
        super("preparedstatement_setParametersThenExecuteUpdate");
      }

      public preparedstatement_setParametersThenExecuteUpdate_args getEmptyArgsInstance() {
        return new preparedstatement_setParametersThenExecuteUpdate_args();
      }

      protected boolean isOneway() {
        return false;
      }

      public preparedstatement_setParametersThenExecuteUpdate_result getResult(I iface, preparedstatement_setParametersThenExecuteUpdate_args args) throws org.apache.thrift.TException {
        preparedstatement_setParametersThenExecuteUpdate_result result = new preparedstatement_setParametersThenExecuteUpdate_result();
        try {
          result.success = iface.preparedstatement_setParametersThenExecuteUpdate(args.preparedstatement, args.parameters);
          result.setSuccessIsSet(true);
        } catch (RSQLException sqlException) {
          result.sqlException = sqlException;
        }
        return result;
      }
    }

    public static class preparedstatement_setParameters<I extends Iface> extends org.apache.thrift.ProcessFunction<I, preparedstatement_setParameters_args> {
      public preparedstatement_setParameters() {
        super("preparedstatement_setParameters");
      }

      public preparedstatement_setParameters_args getEmptyArgsInstance() {
        return new preparedstatement_setParameters_args();
      }

      protected boolean isOneway() {
        return false;
      }

      public preparedstatement_setParameters_result getResult(I iface, preparedstatement_setParameters_args args) throws org.apache.thrift.TException {
        preparedstatement_setParameters_result result = new preparedstatement_setParameters_result();
        try {
          iface.preparedstatement_setParameters(args.preparedStatement, args.parameters);
        } catch (RSQLException sqlException) {
          result.sqlException = sqlException;
        }
        return result;
      }
    }

    public static class preparedstatement_setParameter<I extends Iface> extends org.apache.thrift.ProcessFunction<I, preparedstatement_setParameter_args> {
      public preparedstatement_setParameter() {
        super("preparedstatement_setParameter");
      }

      public preparedstatement_setParameter_args getEmptyArgsInstance() {
        return new preparedstatement_setParameter_args();
      }

      protected boolean isOneway() {
        return false;
      }

      public preparedstatement_setParameter_result getResult(I iface, preparedstatement_setParameter_args args) throws org.apache.thrift.TException {
        preparedstatement_setParameter_result result = new preparedstatement_setParameter_result();
        try {
          iface.preparedstatement_setParameter(args.preparedStatement, args.parameter, args.position);
        } catch (RSQLException sqlException) {
          result.sqlException = sqlException;
        }
        return result;
      }
    }

    public static class preparedstatement_clearParameters<I extends Iface> extends org.apache.thrift.ProcessFunction<I, preparedstatement_clearParameters_args> {
      public preparedstatement_clearParameters() {
        super("preparedstatement_clearParameters");
      }

      public preparedstatement_clearParameters_args getEmptyArgsInstance() {
        return new preparedstatement_clearParameters_args();
      }

      protected boolean isOneway() {
        return false;
      }

      public preparedstatement_clearParameters_result getResult(I iface, preparedstatement_clearParameters_args args) throws org.apache.thrift.TException {
        preparedstatement_clearParameters_result result = new preparedstatement_clearParameters_result();
        try {
          iface.preparedstatement_clearParameters(args.preparedStatement);
        } catch (RSQLException sqlException) {
          result.sqlException = sqlException;
        }
        return result;
      }
    }

    public static class preparedstatement_addBatchWithParameters<I extends Iface> extends org.apache.thrift.ProcessFunction<I, preparedstatement_addBatchWithParameters_args> {
      public preparedstatement_addBatchWithParameters() {
        super("preparedstatement_addBatchWithParameters");
      }

      public preparedstatement_addBatchWithParameters_args getEmptyArgsInstance() {
        return new preparedstatement_addBatchWithParameters_args();
      }

      protected boolean isOneway() {
        return false;
      }

      public preparedstatement_addBatchWithParameters_result getResult(I iface, preparedstatement_addBatchWithParameters_args args) throws org.apache.thrift.TException {
        preparedstatement_addBatchWithParameters_result result = new preparedstatement_addBatchWithParameters_result();
        try {
          iface.preparedstatement_addBatchWithParameters(args.preparedStatement, args.parameters);
        } catch (RSQLException sqlException) {
          result.sqlException = sqlException;
        }
        return result;
      }
    }

    public static class preparedstatement_addBatch<I extends Iface> extends org.apache.thrift.ProcessFunction<I, preparedstatement_addBatch_args> {
      public preparedstatement_addBatch() {
        super("preparedstatement_addBatch");
      }

      public preparedstatement_addBatch_args getEmptyArgsInstance() {
        return new preparedstatement_addBatch_args();
      }

      protected boolean isOneway() {
        return false;
      }

      public preparedstatement_addBatch_result getResult(I iface, preparedstatement_addBatch_args args) throws org.apache.thrift.TException {
        preparedstatement_addBatch_result result = new preparedstatement_addBatch_result();
        try {
          iface.preparedstatement_addBatch(args.preparedStatement);
        } catch (RSQLException sqlException) {
          result.sqlException = sqlException;
        }
        return result;
      }
    }

    public static class preparedstatement_executeBatch<I extends Iface> extends org.apache.thrift.ProcessFunction<I, preparedstatement_executeBatch_args> {
      public preparedstatement_executeBatch() {
        super("preparedstatement_executeBatch");
      }

      public preparedstatement_executeBatch_args getEmptyArgsInstance() {
        return new preparedstatement_executeBatch_args();
      }

      protected boolean isOneway() {
        return false;
      }

      public preparedstatement_executeBatch_result getResult(I iface, preparedstatement_executeBatch_args args) throws org.apache.thrift.TException {
        preparedstatement_executeBatch_result result = new preparedstatement_executeBatch_result();
        try {
          result.success = iface.preparedstatement_executeBatch(args.statement, args.parameters);
        } catch (RSQLException sqlException) {
          result.sqlException = sqlException;
        }
        return result;
      }
    }

    public static class statement_getWarnings<I extends Iface> extends org.apache.thrift.ProcessFunction<I, statement_getWarnings_args> {
      public statement_getWarnings() {
        super("statement_getWarnings");
      }

      public statement_getWarnings_args getEmptyArgsInstance() {
        return new statement_getWarnings_args();
      }

      protected boolean isOneway() {
        return false;
      }

      public statement_getWarnings_result getResult(I iface, statement_getWarnings_args args) throws org.apache.thrift.TException {
        statement_getWarnings_result result = new statement_getWarnings_result();
        try {
          result.success = iface.statement_getWarnings(args.statement);
        } catch (RSQLException sqlException) {
          result.sqlException = sqlException;
        }
        return result;
      }
    }

    public static class statement_clearWarnings<I extends Iface> extends org.apache.thrift.ProcessFunction<I, statement_clearWarnings_args> {
      public statement_clearWarnings() {
        super("statement_clearWarnings");
      }

      public statement_clearWarnings_args getEmptyArgsInstance() {
        return new statement_clearWarnings_args();
      }

      protected boolean isOneway() {
        return false;
      }

      public statement_clearWarnings_result getResult(I iface, statement_clearWarnings_args args) throws org.apache.thrift.TException {
        statement_clearWarnings_result result = new statement_clearWarnings_result();
        try {
          iface.statement_clearWarnings(args.statement);
        } catch (RSQLException sqlException) {
          result.sqlException = sqlException;
        }
        return result;
      }
    }

    public static class statement_getMaxRows<I extends Iface> extends org.apache.thrift.ProcessFunction<I, statement_getMaxRows_args> {
      public statement_getMaxRows() {
        super("statement_getMaxRows");
      }

      public statement_getMaxRows_args getEmptyArgsInstance() {
        return new statement_getMaxRows_args();
      }

      protected boolean isOneway() {
        return false;
      }

      public statement_getMaxRows_result getResult(I iface, statement_getMaxRows_args args) throws org.apache.thrift.TException {
        statement_getMaxRows_result result = new statement_getMaxRows_result();
        try {
          result.success = iface.statement_getMaxRows(args.statement);
          result.setSuccessIsSet(true);
        } catch (RSQLException sqlException) {
          result.sqlException = sqlException;
        }
        return result;
      }
    }

    public static class statement_setMaxRows<I extends Iface> extends org.apache.thrift.ProcessFunction<I, statement_setMaxRows_args> {
      public statement_setMaxRows() {
        super("statement_setMaxRows");
      }

      public statement_setMaxRows_args getEmptyArgsInstance() {
        return new statement_setMaxRows_args();
      }

      protected boolean isOneway() {
        return false;
      }

      public statement_setMaxRows_result getResult(I iface, statement_setMaxRows_args args) throws org.apache.thrift.TException {
        statement_setMaxRows_result result = new statement_setMaxRows_result();
        try {
          iface.statement_setMaxRows(args.statement, args.max);
        } catch (RSQLException sqlException) {
          result.sqlException = sqlException;
        }
        return result;
      }
    }

    public static class statement_getQueryTimeout<I extends Iface> extends org.apache.thrift.ProcessFunction<I, statement_getQueryTimeout_args> {
      public statement_getQueryTimeout() {
        super("statement_getQueryTimeout");
      }

      public statement_getQueryTimeout_args getEmptyArgsInstance() {
        return new statement_getQueryTimeout_args();
      }

      protected boolean isOneway() {
        return false;
      }

      public statement_getQueryTimeout_result getResult(I iface, statement_getQueryTimeout_args args) throws org.apache.thrift.TException {
        statement_getQueryTimeout_result result = new statement_getQueryTimeout_result();
        try {
          result.success = iface.statement_getQueryTimeout(args.statement);
          result.setSuccessIsSet(true);
        } catch (RSQLException sqlException) {
          result.sqlException = sqlException;
        }
        return result;
      }
    }

    public static class statement_setQueryTimeout<I extends Iface> extends org.apache.thrift.ProcessFunction<I, statement_setQueryTimeout_args> {
      public statement_setQueryTimeout() {
        super("statement_setQueryTimeout");
      }

      public statement_setQueryTimeout_args getEmptyArgsInstance() {
        return new statement_setQueryTimeout_args();
      }

      protected boolean isOneway() {
        return false;
      }

      public statement_setQueryTimeout_result getResult(I iface, statement_setQueryTimeout_args args) throws org.apache.thrift.TException {
        statement_setQueryTimeout_result result = new statement_setQueryTimeout_result();
        try {
          iface.statement_setQueryTimeout(args.statement, args.seconds);
        } catch (RSQLException sqlException) {
          result.sqlException = sqlException;
        }
        return result;
      }
    }

  }

  public static class AsyncProcessor<I extends AsyncIface> extends org.apache.thrift.TBaseAsyncProcessor<I> {
    private static final Logger LOGGER = LoggerFactory.getLogger(AsyncProcessor.class.getName());
    public AsyncProcessor(I iface) {
      super(iface, getProcessMap(new HashMap<String, org.apache.thrift.AsyncProcessFunction<I, ? extends org.apache.thrift.TBase, ?>>()));
    }

    protected AsyncProcessor(I iface, Map<String,  org.apache.thrift.AsyncProcessFunction<I, ? extends  org.apache.thrift.TBase, ?>> processMap) {
      super(iface, getProcessMap(processMap));
    }

    private static <I extends AsyncIface> Map<String,  org.apache.thrift.AsyncProcessFunction<I, ? extends  org.apache.thrift.TBase,?>> getProcessMap(Map<String,  org.apache.thrift.AsyncProcessFunction<I, ? extends  org.apache.thrift.TBase, ?>> processMap) {
      processMap.put("createConnection", new createConnection());
      processMap.put("createStatement", new createStatement());
      processMap.put("prepareStatement", new prepareStatement());
      processMap.put("prepareCall", new prepareCall());
      processMap.put("connection_getstaticmetadata", new connection_getstaticmetadata());
      processMap.put("connection_isvalid", new connection_isvalid());
      processMap.put("connection_commit", new connection_commit());
      processMap.put("connection_rollback", new connection_rollback());
      processMap.put("connection_setAutoCommit", new connection_setAutoCommit());
      processMap.put("connection_getAutoCommit", new connection_getAutoCommit());
      processMap.put("connection_setTransactionIsolation", new connection_setTransactionIsolation());
      processMap.put("connection_getTransactionIsolation", new connection_getTransactionIsolation());
      processMap.put("connection_setReadOnly", new connection_setReadOnly());
      processMap.put("connection_getReadOnly", new connection_getReadOnly());
      processMap.put("connection_setCatalog", new connection_setCatalog());
      processMap.put("connection_getCatalog", new connection_getCatalog());
      processMap.put("connection_setSchema", new connection_setSchema());
      processMap.put("connection_getSchema", new connection_getSchema());
      processMap.put("connection_getCatalogSeparator", new connection_getCatalogSeparator());
      processMap.put("connection_getCatalogTerm", new connection_getCatalogTerm());
      processMap.put("connection_getSchemaTerm", new connection_getSchemaTerm());
      processMap.put("connection_getCatalogs", new connection_getCatalogs());
      processMap.put("connection_getSchemas", new connection_getSchemas());
      processMap.put("connection_getTables", new connection_getTables());
      processMap.put("connection_getColumns", new connection_getColumns());
      processMap.put("connection_getSQLKeywords", new connection_getSQLKeywords());
      processMap.put("connection_getTableTypes", new connection_getTableTypes());
      processMap.put("connection_getTypeInfo", new connection_getTypeInfo());
      processMap.put("closeConnection", new closeConnection());
      processMap.put("statement_close", new statement_close());
      processMap.put("statement_execute", new statement_execute());
      processMap.put("statement_executeQuery", new statement_executeQuery());
      processMap.put("statement_executeUpdate", new statement_executeUpdate());
      processMap.put("statement_getResultSet", new statement_getResultSet());
      processMap.put("statement_getUpdateCount", new statement_getUpdateCount());
      processMap.put("statement_getResultSetType", new statement_getResultSetType());
      processMap.put("statement_cancel", new statement_cancel());
      processMap.put("statement_addBatch", new statement_addBatch());
      processMap.put("statement_addBatches", new statement_addBatches());
      processMap.put("statement_clearBatch", new statement_clearBatch());
      processMap.put("statement_executeBatch", new statement_executeBatch());
      processMap.put("preparedstatement_execute", new preparedstatement_execute());
      processMap.put("preparedstatement_executeQuery", new preparedstatement_executeQuery());
      processMap.put("preparedstatement_executeUpdate", new preparedstatement_executeUpdate());
      processMap.put("preparedstatement_setParametersThenExecute", new preparedstatement_setParametersThenExecute());
      processMap.put("preparedstatement_setParametersThenExecuteQuery", new preparedstatement_setParametersThenExecuteQuery());
      processMap.put("preparedstatement_setParametersThenExecuteUpdate", new preparedstatement_setParametersThenExecuteUpdate());
      processMap.put("preparedstatement_setParameters", new preparedstatement_setParameters());
      processMap.put("preparedstatement_setParameter", new preparedstatement_setParameter());
      processMap.put("preparedstatement_clearParameters", new preparedstatement_clearParameters());
      processMap.put("preparedstatement_addBatchWithParameters", new preparedstatement_addBatchWithParameters());
      processMap.put("preparedstatement_addBatch", new preparedstatement_addBatch());
      processMap.put("preparedstatement_executeBatch", new preparedstatement_executeBatch());
      processMap.put("statement_getWarnings", new statement_getWarnings());
      processMap.put("statement_clearWarnings", new statement_clearWarnings());
      processMap.put("statement_getMaxRows", new statement_getMaxRows());
      processMap.put("statement_setMaxRows", new statement_setMaxRows());
      processMap.put("statement_getQueryTimeout", new statement_getQueryTimeout());
      processMap.put("statement_setQueryTimeout", new statement_setQueryTimeout());
      return processMap;
    }

    public static class createConnection<I extends AsyncIface> extends org.apache.thrift.AsyncProcessFunction<I, createConnection_args, RConnection> {
      public createConnection() {
        super("createConnection");
      }

      public createConnection_args getEmptyArgsInstance() {
        return new createConnection_args();
      }

      public AsyncMethodCallback<RConnection> getResultHandler(final AsyncFrameBuffer fb, final int seqid) {
        final org.apache.thrift.AsyncProcessFunction fcall = this;
        return new AsyncMethodCallback<RConnection>() { 
          public void onComplete(RConnection o) {
            createConnection_result result = new createConnection_result();
            result.success = o;
            try {
              fcall.sendResponse(fb,result, org.apache.thrift.protocol.TMessageType.REPLY,seqid);
              return;
            } catch (Exception e) {
              LOGGER.error("Exception writing to internal frame buffer", e);
            }
            fb.close();
          }
          public void onError(Exception e) {
            byte msgType = org.apache.thrift.protocol.TMessageType.REPLY;
            org.apache.thrift.TBase msg;
            createConnection_result result = new createConnection_result();
            if (e instanceof RSQLException) {
                        result.sqlException = (RSQLException) e;
                        result.setSqlExceptionIsSet(true);
                        msg = result;
            }
             else 
            {
              msgType = org.apache.thrift.protocol.TMessageType.EXCEPTION;
              msg = (org.apache.thrift.TBase)new org.apache.thrift.TApplicationException(org.apache.thrift.TApplicationException.INTERNAL_ERROR, e.getMessage());
            }
            try {
              fcall.sendResponse(fb,msg,msgType,seqid);
              return;
            } catch (Exception ex) {
              LOGGER.error("Exception writing to internal frame buffer", ex);
            }
            fb.close();
          }
        };
      }

      protected boolean isOneway() {
        return false;
      }

      public void start(I iface, createConnection_args args, org.apache.thrift.async.AsyncMethodCallback<RConnection> resultHandler) throws TException {
        iface.createConnection(args.url, args.properties,resultHandler);
      }
    }

    public static class createStatement<I extends AsyncIface> extends org.apache.thrift.AsyncProcessFunction<I, createStatement_args, RStatement> {
      public createStatement() {
        super("createStatement");
      }

      public createStatement_args getEmptyArgsInstance() {
        return new createStatement_args();
      }

      public AsyncMethodCallback<RStatement> getResultHandler(final AsyncFrameBuffer fb, final int seqid) {
        final org.apache.thrift.AsyncProcessFunction fcall = this;
        return new AsyncMethodCallback<RStatement>() { 
          public void onComplete(RStatement o) {
            createStatement_result result = new createStatement_result();
            result.success = o;
            try {
              fcall.sendResponse(fb,result, org.apache.thrift.protocol.TMessageType.REPLY,seqid);
              return;
            } catch (Exception e) {
              LOGGER.error("Exception writing to internal frame buffer", e);
            }
            fb.close();
          }
          public void onError(Exception e) {
            byte msgType = org.apache.thrift.protocol.TMessageType.REPLY;
            org.apache.thrift.TBase msg;
            createStatement_result result = new createStatement_result();
            if (e instanceof RSQLException) {
                        result.sqlException = (RSQLException) e;
                        result.setSqlExceptionIsSet(true);
                        msg = result;
            }
             else 
            {
              msgType = org.apache.thrift.protocol.TMessageType.EXCEPTION;
              msg = (org.apache.thrift.TBase)new org.apache.thrift.TApplicationException(org.apache.thrift.TApplicationException.INTERNAL_ERROR, e.getMessage());
            }
            try {
              fcall.sendResponse(fb,msg,msgType,seqid);
              return;
            } catch (Exception ex) {
              LOGGER.error("Exception writing to internal frame buffer", ex);
            }
            fb.close();
          }
        };
      }

      protected boolean isOneway() {
        return false;
      }

      public void start(I iface, createStatement_args args, org.apache.thrift.async.AsyncMethodCallback<RStatement> resultHandler) throws TException {
        iface.createStatement(args.connection,resultHandler);
      }
    }

    public static class prepareStatement<I extends AsyncIface> extends org.apache.thrift.AsyncProcessFunction<I, prepareStatement_args, RStatement> {
      public prepareStatement() {
        super("prepareStatement");
      }

      public prepareStatement_args getEmptyArgsInstance() {
        return new prepareStatement_args();
      }

      public AsyncMethodCallback<RStatement> getResultHandler(final AsyncFrameBuffer fb, final int seqid) {
        final org.apache.thrift.AsyncProcessFunction fcall = this;
        return new AsyncMethodCallback<RStatement>() { 
          public void onComplete(RStatement o) {
            prepareStatement_result result = new prepareStatement_result();
            result.success = o;
            try {
              fcall.sendResponse(fb,result, org.apache.thrift.protocol.TMessageType.REPLY,seqid);
              return;
            } catch (Exception e) {
              LOGGER.error("Exception writing to internal frame buffer", e);
            }
            fb.close();
          }
          public void onError(Exception e) {
            byte msgType = org.apache.thrift.protocol.TMessageType.REPLY;
            org.apache.thrift.TBase msg;
            prepareStatement_result result = new prepareStatement_result();
            if (e instanceof RSQLException) {
                        result.sqlException = (RSQLException) e;
                        result.setSqlExceptionIsSet(true);
                        msg = result;
            }
             else 
            {
              msgType = org.apache.thrift.protocol.TMessageType.EXCEPTION;
              msg = (org.apache.thrift.TBase)new org.apache.thrift.TApplicationException(org.apache.thrift.TApplicationException.INTERNAL_ERROR, e.getMessage());
            }
            try {
              fcall.sendResponse(fb,msg,msgType,seqid);
              return;
            } catch (Exception ex) {
              LOGGER.error("Exception writing to internal frame buffer", ex);
            }
            fb.close();
          }
        };
      }

      protected boolean isOneway() {
        return false;
      }

      public void start(I iface, prepareStatement_args args, org.apache.thrift.async.AsyncMethodCallback<RStatement> resultHandler) throws TException {
        iface.prepareStatement(args.connection, args.sql,resultHandler);
      }
    }

    public static class prepareCall<I extends AsyncIface> extends org.apache.thrift.AsyncProcessFunction<I, prepareCall_args, RStatement> {
      public prepareCall() {
        super("prepareCall");
      }

      public prepareCall_args getEmptyArgsInstance() {
        return new prepareCall_args();
      }

      public AsyncMethodCallback<RStatement> getResultHandler(final AsyncFrameBuffer fb, final int seqid) {
        final org.apache.thrift.AsyncProcessFunction fcall = this;
        return new AsyncMethodCallback<RStatement>() { 
          public void onComplete(RStatement o) {
            prepareCall_result result = new prepareCall_result();
            result.success = o;
            try {
              fcall.sendResponse(fb,result, org.apache.thrift.protocol.TMessageType.REPLY,seqid);
              return;
            } catch (Exception e) {
              LOGGER.error("Exception writing to internal frame buffer", e);
            }
            fb.close();
          }
          public void onError(Exception e) {
            byte msgType = org.apache.thrift.protocol.TMessageType.REPLY;
            org.apache.thrift.TBase msg;
            prepareCall_result result = new prepareCall_result();
            if (e instanceof RSQLException) {
                        result.sqlException = (RSQLException) e;
                        result.setSqlExceptionIsSet(true);
                        msg = result;
            }
             else 
            {
              msgType = org.apache.thrift.protocol.TMessageType.EXCEPTION;
              msg = (org.apache.thrift.TBase)new org.apache.thrift.TApplicationException(org.apache.thrift.TApplicationException.INTERNAL_ERROR, e.getMessage());
            }
            try {
              fcall.sendResponse(fb,msg,msgType,seqid);
              return;
            } catch (Exception ex) {
              LOGGER.error("Exception writing to internal frame buffer", ex);
            }
            fb.close();
          }
        };
      }

      protected boolean isOneway() {
        return false;
      }

      public void start(I iface, prepareCall_args args, org.apache.thrift.async.AsyncMethodCallback<RStatement> resultHandler) throws TException {
        iface.prepareCall(args.connection, args.sql,resultHandler);
      }
    }

    public static class connection_getstaticmetadata<I extends AsyncIface> extends org.apache.thrift.AsyncProcessFunction<I, connection_getstaticmetadata_args, RStaticMetaData> {
      public connection_getstaticmetadata() {
        super("connection_getstaticmetadata");
      }

      public connection_getstaticmetadata_args getEmptyArgsInstance() {
        return new connection_getstaticmetadata_args();
      }

      public AsyncMethodCallback<RStaticMetaData> getResultHandler(final AsyncFrameBuffer fb, final int seqid) {
        final org.apache.thrift.AsyncProcessFunction fcall = this;
        return new AsyncMethodCallback<RStaticMetaData>() { 
          public void onComplete(RStaticMetaData o) {
            connection_getstaticmetadata_result result = new connection_getstaticmetadata_result();
            result.success = o;
            try {
              fcall.sendResponse(fb,result, org.apache.thrift.protocol.TMessageType.REPLY,seqid);
              return;
            } catch (Exception e) {
              LOGGER.error("Exception writing to internal frame buffer", e);
            }
            fb.close();
          }
          public void onError(Exception e) {
            byte msgType = org.apache.thrift.protocol.TMessageType.REPLY;
            org.apache.thrift.TBase msg;
            connection_getstaticmetadata_result result = new connection_getstaticmetadata_result();
            if (e instanceof RSQLException) {
                        result.sqlException = (RSQLException) e;
                        result.setSqlExceptionIsSet(true);
                        msg = result;
            }
             else 
            {
              msgType = org.apache.thrift.protocol.TMessageType.EXCEPTION;
              msg = (org.apache.thrift.TBase)new org.apache.thrift.TApplicationException(org.apache.thrift.TApplicationException.INTERNAL_ERROR, e.getMessage());
            }
            try {
              fcall.sendResponse(fb,msg,msgType,seqid);
              return;
            } catch (Exception ex) {
              LOGGER.error("Exception writing to internal frame buffer", ex);
            }
            fb.close();
          }
        };
      }

      protected boolean isOneway() {
        return false;
      }

      public void start(I iface, connection_getstaticmetadata_args args, org.apache.thrift.async.AsyncMethodCallback<RStaticMetaData> resultHandler) throws TException {
        iface.connection_getstaticmetadata(args.connection,resultHandler);
      }
    }

    public static class connection_isvalid<I extends AsyncIface> extends org.apache.thrift.AsyncProcessFunction<I, connection_isvalid_args, Boolean> {
      public connection_isvalid() {
        super("connection_isvalid");
      }

      public connection_isvalid_args getEmptyArgsInstance() {
        return new connection_isvalid_args();
      }

      public AsyncMethodCallback<Boolean> getResultHandler(final AsyncFrameBuffer fb, final int seqid) {
        final org.apache.thrift.AsyncProcessFunction fcall = this;
        return new AsyncMethodCallback<Boolean>() { 
          public void onComplete(Boolean o) {
            connection_isvalid_result result = new connection_isvalid_result();
            result.success = o;
            result.setSuccessIsSet(true);
            try {
              fcall.sendResponse(fb,result, org.apache.thrift.protocol.TMessageType.REPLY,seqid);
              return;
            } catch (Exception e) {
              LOGGER.error("Exception writing to internal frame buffer", e);
            }
            fb.close();
          }
          public void onError(Exception e) {
            byte msgType = org.apache.thrift.protocol.TMessageType.REPLY;
            org.apache.thrift.TBase msg;
            connection_isvalid_result result = new connection_isvalid_result();
            if (e instanceof RSQLException) {
                        result.sqlException = (RSQLException) e;
                        result.setSqlExceptionIsSet(true);
                        msg = result;
            }
             else 
            {
              msgType = org.apache.thrift.protocol.TMessageType.EXCEPTION;
              msg = (org.apache.thrift.TBase)new org.apache.thrift.TApplicationException(org.apache.thrift.TApplicationException.INTERNAL_ERROR, e.getMessage());
            }
            try {
              fcall.sendResponse(fb,msg,msgType,seqid);
              return;
            } catch (Exception ex) {
              LOGGER.error("Exception writing to internal frame buffer", ex);
            }
            fb.close();
          }
        };
      }

      protected boolean isOneway() {
        return false;
      }

      public void start(I iface, connection_isvalid_args args, org.apache.thrift.async.AsyncMethodCallback<Boolean> resultHandler) throws TException {
        iface.connection_isvalid(args.connection, args.timeout,resultHandler);
      }
    }

    public static class connection_commit<I extends AsyncIface> extends org.apache.thrift.AsyncProcessFunction<I, connection_commit_args, Void> {
      public connection_commit() {
        super("connection_commit");
      }

      public connection_commit_args getEmptyArgsInstance() {
        return new connection_commit_args();
      }

      public AsyncMethodCallback<Void> getResultHandler(final AsyncFrameBuffer fb, final int seqid) {
        final org.apache.thrift.AsyncProcessFunction fcall = this;
        return new AsyncMethodCallback<Void>() { 
          public void onComplete(Void o) {
            connection_commit_result result = new connection_commit_result();
            try {
              fcall.sendResponse(fb,result, org.apache.thrift.protocol.TMessageType.REPLY,seqid);
              return;
            } catch (Exception e) {
              LOGGER.error("Exception writing to internal frame buffer", e);
            }
            fb.close();
          }
          public void onError(Exception e) {
            byte msgType = org.apache.thrift.protocol.TMessageType.REPLY;
            org.apache.thrift.TBase msg;
            connection_commit_result result = new connection_commit_result();
            if (e instanceof RSQLException) {
                        result.sqlException = (RSQLException) e;
                        result.setSqlExceptionIsSet(true);
                        msg = result;
            }
             else 
            {
              msgType = org.apache.thrift.protocol.TMessageType.EXCEPTION;
              msg = (org.apache.thrift.TBase)new org.apache.thrift.TApplicationException(org.apache.thrift.TApplicationException.INTERNAL_ERROR, e.getMessage());
            }
            try {
              fcall.sendResponse(fb,msg,msgType,seqid);
              return;
            } catch (Exception ex) {
              LOGGER.error("Exception writing to internal frame buffer", ex);
            }
            fb.close();
          }
        };
      }

      protected boolean isOneway() {
        return false;
      }

      public void start(I iface, connection_commit_args args, org.apache.thrift.async.AsyncMethodCallback<Void> resultHandler) throws TException {
        iface.connection_commit(args.connection,resultHandler);
      }
    }

    public static class connection_rollback<I extends AsyncIface> extends org.apache.thrift.AsyncProcessFunction<I, connection_rollback_args, Void> {
      public connection_rollback() {
        super("connection_rollback");
      }

      public connection_rollback_args getEmptyArgsInstance() {
        return new connection_rollback_args();
      }

      public AsyncMethodCallback<Void> getResultHandler(final AsyncFrameBuffer fb, final int seqid) {
        final org.apache.thrift.AsyncProcessFunction fcall = this;
        return new AsyncMethodCallback<Void>() { 
          public void onComplete(Void o) {
            connection_rollback_result result = new connection_rollback_result();
            try {
              fcall.sendResponse(fb,result, org.apache.thrift.protocol.TMessageType.REPLY,seqid);
              return;
            } catch (Exception e) {
              LOGGER.error("Exception writing to internal frame buffer", e);
            }
            fb.close();
          }
          public void onError(Exception e) {
            byte msgType = org.apache.thrift.protocol.TMessageType.REPLY;
            org.apache.thrift.TBase msg;
            connection_rollback_result result = new connection_rollback_result();
            if (e instanceof RSQLException) {
                        result.sqlException = (RSQLException) e;
                        result.setSqlExceptionIsSet(true);
                        msg = result;
            }
             else 
            {
              msgType = org.apache.thrift.protocol.TMessageType.EXCEPTION;
              msg = (org.apache.thrift.TBase)new org.apache.thrift.TApplicationException(org.apache.thrift.TApplicationException.INTERNAL_ERROR, e.getMessage());
            }
            try {
              fcall.sendResponse(fb,msg,msgType,seqid);
              return;
            } catch (Exception ex) {
              LOGGER.error("Exception writing to internal frame buffer", ex);
            }
            fb.close();
          }
        };
      }

      protected boolean isOneway() {
        return false;
      }

      public void start(I iface, connection_rollback_args args, org.apache.thrift.async.AsyncMethodCallback<Void> resultHandler) throws TException {
        iface.connection_rollback(args.connection,resultHandler);
      }
    }

    public static class connection_setAutoCommit<I extends AsyncIface> extends org.apache.thrift.AsyncProcessFunction<I, connection_setAutoCommit_args, Void> {
      public connection_setAutoCommit() {
        super("connection_setAutoCommit");
      }

      public connection_setAutoCommit_args getEmptyArgsInstance() {
        return new connection_setAutoCommit_args();
      }

      public AsyncMethodCallback<Void> getResultHandler(final AsyncFrameBuffer fb, final int seqid) {
        final org.apache.thrift.AsyncProcessFunction fcall = this;
        return new AsyncMethodCallback<Void>() { 
          public void onComplete(Void o) {
            connection_setAutoCommit_result result = new connection_setAutoCommit_result();
            try {
              fcall.sendResponse(fb,result, org.apache.thrift.protocol.TMessageType.REPLY,seqid);
              return;
            } catch (Exception e) {
              LOGGER.error("Exception writing to internal frame buffer", e);
            }
            fb.close();
          }
          public void onError(Exception e) {
            byte msgType = org.apache.thrift.protocol.TMessageType.REPLY;
            org.apache.thrift.TBase msg;
            connection_setAutoCommit_result result = new connection_setAutoCommit_result();
            if (e instanceof RSQLException) {
                        result.sqlException = (RSQLException) e;
                        result.setSqlExceptionIsSet(true);
                        msg = result;
            }
             else 
            {
              msgType = org.apache.thrift.protocol.TMessageType.EXCEPTION;
              msg = (org.apache.thrift.TBase)new org.apache.thrift.TApplicationException(org.apache.thrift.TApplicationException.INTERNAL_ERROR, e.getMessage());
            }
            try {
              fcall.sendResponse(fb,msg,msgType,seqid);
              return;
            } catch (Exception ex) {
              LOGGER.error("Exception writing to internal frame buffer", ex);
            }
            fb.close();
          }
        };
      }

      protected boolean isOneway() {
        return false;
      }

      public void start(I iface, connection_setAutoCommit_args args, org.apache.thrift.async.AsyncMethodCallback<Void> resultHandler) throws TException {
        iface.connection_setAutoCommit(args.connection, args.autoCommit,resultHandler);
      }
    }

    public static class connection_getAutoCommit<I extends AsyncIface> extends org.apache.thrift.AsyncProcessFunction<I, connection_getAutoCommit_args, Boolean> {
      public connection_getAutoCommit() {
        super("connection_getAutoCommit");
      }

      public connection_getAutoCommit_args getEmptyArgsInstance() {
        return new connection_getAutoCommit_args();
      }

      public AsyncMethodCallback<Boolean> getResultHandler(final AsyncFrameBuffer fb, final int seqid) {
        final org.apache.thrift.AsyncProcessFunction fcall = this;
        return new AsyncMethodCallback<Boolean>() { 
          public void onComplete(Boolean o) {
            connection_getAutoCommit_result result = new connection_getAutoCommit_result();
            result.success = o;
            result.setSuccessIsSet(true);
            try {
              fcall.sendResponse(fb,result, org.apache.thrift.protocol.TMessageType.REPLY,seqid);
              return;
            } catch (Exception e) {
              LOGGER.error("Exception writing to internal frame buffer", e);
            }
            fb.close();
          }
          public void onError(Exception e) {
            byte msgType = org.apache.thrift.protocol.TMessageType.REPLY;
            org.apache.thrift.TBase msg;
            connection_getAutoCommit_result result = new connection_getAutoCommit_result();
            if (e instanceof RSQLException) {
                        result.sqlException = (RSQLException) e;
                        result.setSqlExceptionIsSet(true);
                        msg = result;
            }
             else 
            {
              msgType = org.apache.thrift.protocol.TMessageType.EXCEPTION;
              msg = (org.apache.thrift.TBase)new org.apache.thrift.TApplicationException(org.apache.thrift.TApplicationException.INTERNAL_ERROR, e.getMessage());
            }
            try {
              fcall.sendResponse(fb,msg,msgType,seqid);
              return;
            } catch (Exception ex) {
              LOGGER.error("Exception writing to internal frame buffer", ex);
            }
            fb.close();
          }
        };
      }

      protected boolean isOneway() {
        return false;
      }

      public void start(I iface, connection_getAutoCommit_args args, org.apache.thrift.async.AsyncMethodCallback<Boolean> resultHandler) throws TException {
        iface.connection_getAutoCommit(args.connection,resultHandler);
      }
    }

    public static class connection_setTransactionIsolation<I extends AsyncIface> extends org.apache.thrift.AsyncProcessFunction<I, connection_setTransactionIsolation_args, Void> {
      public connection_setTransactionIsolation() {
        super("connection_setTransactionIsolation");
      }

      public connection_setTransactionIsolation_args getEmptyArgsInstance() {
        return new connection_setTransactionIsolation_args();
      }

      public AsyncMethodCallback<Void> getResultHandler(final AsyncFrameBuffer fb, final int seqid) {
        final org.apache.thrift.AsyncProcessFunction fcall = this;
        return new AsyncMethodCallback<Void>() { 
          public void onComplete(Void o) {
            connection_setTransactionIsolation_result result = new connection_setTransactionIsolation_result();
            try {
              fcall.sendResponse(fb,result, org.apache.thrift.protocol.TMessageType.REPLY,seqid);
              return;
            } catch (Exception e) {
              LOGGER.error("Exception writing to internal frame buffer", e);
            }
            fb.close();
          }
          public void onError(Exception e) {
            byte msgType = org.apache.thrift.protocol.TMessageType.REPLY;
            org.apache.thrift.TBase msg;
            connection_setTransactionIsolation_result result = new connection_setTransactionIsolation_result();
            if (e instanceof RSQLException) {
                        result.sqlException = (RSQLException) e;
                        result.setSqlExceptionIsSet(true);
                        msg = result;
            }
             else 
            {
              msgType = org.apache.thrift.protocol.TMessageType.EXCEPTION;
              msg = (org.apache.thrift.TBase)new org.apache.thrift.TApplicationException(org.apache.thrift.TApplicationException.INTERNAL_ERROR, e.getMessage());
            }
            try {
              fcall.sendResponse(fb,msg,msgType,seqid);
              return;
            } catch (Exception ex) {
              LOGGER.error("Exception writing to internal frame buffer", ex);
            }
            fb.close();
          }
        };
      }

      protected boolean isOneway() {
        return false;
      }

      public void start(I iface, connection_setTransactionIsolation_args args, org.apache.thrift.async.AsyncMethodCallback<Void> resultHandler) throws TException {
        iface.connection_setTransactionIsolation(args.connection, args.level,resultHandler);
      }
    }

    public static class connection_getTransactionIsolation<I extends AsyncIface> extends org.apache.thrift.AsyncProcessFunction<I, connection_getTransactionIsolation_args, Integer> {
      public connection_getTransactionIsolation() {
        super("connection_getTransactionIsolation");
      }

      public connection_getTransactionIsolation_args getEmptyArgsInstance() {
        return new connection_getTransactionIsolation_args();
      }

      public AsyncMethodCallback<Integer> getResultHandler(final AsyncFrameBuffer fb, final int seqid) {
        final org.apache.thrift.AsyncProcessFunction fcall = this;
        return new AsyncMethodCallback<Integer>() { 
          public void onComplete(Integer o) {
            connection_getTransactionIsolation_result result = new connection_getTransactionIsolation_result();
            result.success = o;
            result.setSuccessIsSet(true);
            try {
              fcall.sendResponse(fb,result, org.apache.thrift.protocol.TMessageType.REPLY,seqid);
              return;
            } catch (Exception e) {
              LOGGER.error("Exception writing to internal frame buffer", e);
            }
            fb.close();
          }
          public void onError(Exception e) {
            byte msgType = org.apache.thrift.protocol.TMessageType.REPLY;
            org.apache.thrift.TBase msg;
            connection_getTransactionIsolation_result result = new connection_getTransactionIsolation_result();
            if (e instanceof RSQLException) {
                        result.sqlException = (RSQLException) e;
                        result.setSqlExceptionIsSet(true);
                        msg = result;
            }
             else 
            {
              msgType = org.apache.thrift.protocol.TMessageType.EXCEPTION;
              msg = (org.apache.thrift.TBase)new org.apache.thrift.TApplicationException(org.apache.thrift.TApplicationException.INTERNAL_ERROR, e.getMessage());
            }
            try {
              fcall.sendResponse(fb,msg,msgType,seqid);
              return;
            } catch (Exception ex) {
              LOGGER.error("Exception writing to internal frame buffer", ex);
            }
            fb.close();
          }
        };
      }

      protected boolean isOneway() {
        return false;
      }

      public void start(I iface, connection_getTransactionIsolation_args args, org.apache.thrift.async.AsyncMethodCallback<Integer> resultHandler) throws TException {
        iface.connection_getTransactionIsolation(args.connection,resultHandler);
      }
    }

    public static class connection_setReadOnly<I extends AsyncIface> extends org.apache.thrift.AsyncProcessFunction<I, connection_setReadOnly_args, Void> {
      public connection_setReadOnly() {
        super("connection_setReadOnly");
      }

      public connection_setReadOnly_args getEmptyArgsInstance() {
        return new connection_setReadOnly_args();
      }

      public AsyncMethodCallback<Void> getResultHandler(final AsyncFrameBuffer fb, final int seqid) {
        final org.apache.thrift.AsyncProcessFunction fcall = this;
        return new AsyncMethodCallback<Void>() { 
          public void onComplete(Void o) {
            connection_setReadOnly_result result = new connection_setReadOnly_result();
            try {
              fcall.sendResponse(fb,result, org.apache.thrift.protocol.TMessageType.REPLY,seqid);
              return;
            } catch (Exception e) {
              LOGGER.error("Exception writing to internal frame buffer", e);
            }
            fb.close();
          }
          public void onError(Exception e) {
            byte msgType = org.apache.thrift.protocol.TMessageType.REPLY;
            org.apache.thrift.TBase msg;
            connection_setReadOnly_result result = new connection_setReadOnly_result();
            if (e instanceof RSQLException) {
                        result.sqlException = (RSQLException) e;
                        result.setSqlExceptionIsSet(true);
                        msg = result;
            }
             else 
            {
              msgType = org.apache.thrift.protocol.TMessageType.EXCEPTION;
              msg = (org.apache.thrift.TBase)new org.apache.thrift.TApplicationException(org.apache.thrift.TApplicationException.INTERNAL_ERROR, e.getMessage());
            }
            try {
              fcall.sendResponse(fb,msg,msgType,seqid);
              return;
            } catch (Exception ex) {
              LOGGER.error("Exception writing to internal frame buffer", ex);
            }
            fb.close();
          }
        };
      }

      protected boolean isOneway() {
        return false;
      }

      public void start(I iface, connection_setReadOnly_args args, org.apache.thrift.async.AsyncMethodCallback<Void> resultHandler) throws TException {
        iface.connection_setReadOnly(args.connection, args.readOnly,resultHandler);
      }
    }

    public static class connection_getReadOnly<I extends AsyncIface> extends org.apache.thrift.AsyncProcessFunction<I, connection_getReadOnly_args, Boolean> {
      public connection_getReadOnly() {
        super("connection_getReadOnly");
      }

      public connection_getReadOnly_args getEmptyArgsInstance() {
        return new connection_getReadOnly_args();
      }

      public AsyncMethodCallback<Boolean> getResultHandler(final AsyncFrameBuffer fb, final int seqid) {
        final org.apache.thrift.AsyncProcessFunction fcall = this;
        return new AsyncMethodCallback<Boolean>() { 
          public void onComplete(Boolean o) {
            connection_getReadOnly_result result = new connection_getReadOnly_result();
            result.success = o;
            result.setSuccessIsSet(true);
            try {
              fcall.sendResponse(fb,result, org.apache.thrift.protocol.TMessageType.REPLY,seqid);
              return;
            } catch (Exception e) {
              LOGGER.error("Exception writing to internal frame buffer", e);
            }
            fb.close();
          }
          public void onError(Exception e) {
            byte msgType = org.apache.thrift.protocol.TMessageType.REPLY;
            org.apache.thrift.TBase msg;
            connection_getReadOnly_result result = new connection_getReadOnly_result();
            if (e instanceof RSQLException) {
                        result.sqlException = (RSQLException) e;
                        result.setSqlExceptionIsSet(true);
                        msg = result;
            }
             else 
            {
              msgType = org.apache.thrift.protocol.TMessageType.EXCEPTION;
              msg = (org.apache.thrift.TBase)new org.apache.thrift.TApplicationException(org.apache.thrift.TApplicationException.INTERNAL_ERROR, e.getMessage());
            }
            try {
              fcall.sendResponse(fb,msg,msgType,seqid);
              return;
            } catch (Exception ex) {
              LOGGER.error("Exception writing to internal frame buffer", ex);
            }
            fb.close();
          }
        };
      }

      protected boolean isOneway() {
        return false;
      }

      public void start(I iface, connection_getReadOnly_args args, org.apache.thrift.async.AsyncMethodCallback<Boolean> resultHandler) throws TException {
        iface.connection_getReadOnly(args.connection,resultHandler);
      }
    }

    public static class connection_setCatalog<I extends AsyncIface> extends org.apache.thrift.AsyncProcessFunction<I, connection_setCatalog_args, Void> {
      public connection_setCatalog() {
        super("connection_setCatalog");
      }

      public connection_setCatalog_args getEmptyArgsInstance() {
        return new connection_setCatalog_args();
      }

      public AsyncMethodCallback<Void> getResultHandler(final AsyncFrameBuffer fb, final int seqid) {
        final org.apache.thrift.AsyncProcessFunction fcall = this;
        return new AsyncMethodCallback<Void>() { 
          public void onComplete(Void o) {
            connection_setCatalog_result result = new connection_setCatalog_result();
            try {
              fcall.sendResponse(fb,result, org.apache.thrift.protocol.TMessageType.REPLY,seqid);
              return;
            } catch (Exception e) {
              LOGGER.error("Exception writing to internal frame buffer", e);
            }
            fb.close();
          }
          public void onError(Exception e) {
            byte msgType = org.apache.thrift.protocol.TMessageType.REPLY;
            org.apache.thrift.TBase msg;
            connection_setCatalog_result result = new connection_setCatalog_result();
            if (e instanceof RSQLException) {
                        result.sqlException = (RSQLException) e;
                        result.setSqlExceptionIsSet(true);
                        msg = result;
            }
             else 
            {
              msgType = org.apache.thrift.protocol.TMessageType.EXCEPTION;
              msg = (org.apache.thrift.TBase)new org.apache.thrift.TApplicationException(org.apache.thrift.TApplicationException.INTERNAL_ERROR, e.getMessage());
            }
            try {
              fcall.sendResponse(fb,msg,msgType,seqid);
              return;
            } catch (Exception ex) {
              LOGGER.error("Exception writing to internal frame buffer", ex);
            }
            fb.close();
          }
        };
      }

      protected boolean isOneway() {
        return false;
      }

      public void start(I iface, connection_setCatalog_args args, org.apache.thrift.async.AsyncMethodCallback<Void> resultHandler) throws TException {
        iface.connection_setCatalog(args.connection, args.catalog,resultHandler);
      }
    }

    public static class connection_getCatalog<I extends AsyncIface> extends org.apache.thrift.AsyncProcessFunction<I, connection_getCatalog_args, String> {
      public connection_getCatalog() {
        super("connection_getCatalog");
      }

      public connection_getCatalog_args getEmptyArgsInstance() {
        return new connection_getCatalog_args();
      }

      public AsyncMethodCallback<String> getResultHandler(final AsyncFrameBuffer fb, final int seqid) {
        final org.apache.thrift.AsyncProcessFunction fcall = this;
        return new AsyncMethodCallback<String>() { 
          public void onComplete(String o) {
            connection_getCatalog_result result = new connection_getCatalog_result();
            result.success = o;
            try {
              fcall.sendResponse(fb,result, org.apache.thrift.protocol.TMessageType.REPLY,seqid);
              return;
            } catch (Exception e) {
              LOGGER.error("Exception writing to internal frame buffer", e);
            }
            fb.close();
          }
          public void onError(Exception e) {
            byte msgType = org.apache.thrift.protocol.TMessageType.REPLY;
            org.apache.thrift.TBase msg;
            connection_getCatalog_result result = new connection_getCatalog_result();
            if (e instanceof RSQLException) {
                        result.sqlException = (RSQLException) e;
                        result.setSqlExceptionIsSet(true);
                        msg = result;
            }
             else 
            {
              msgType = org.apache.thrift.protocol.TMessageType.EXCEPTION;
              msg = (org.apache.thrift.TBase)new org.apache.thrift.TApplicationException(org.apache.thrift.TApplicationException.INTERNAL_ERROR, e.getMessage());
            }
            try {
              fcall.sendResponse(fb,msg,msgType,seqid);
              return;
            } catch (Exception ex) {
              LOGGER.error("Exception writing to internal frame buffer", ex);
            }
            fb.close();
          }
        };
      }

      protected boolean isOneway() {
        return false;
      }

      public void start(I iface, connection_getCatalog_args args, org.apache.thrift.async.AsyncMethodCallback<String> resultHandler) throws TException {
        iface.connection_getCatalog(args.connection,resultHandler);
      }
    }

    public static class connection_setSchema<I extends AsyncIface> extends org.apache.thrift.AsyncProcessFunction<I, connection_setSchema_args, Void> {
      public connection_setSchema() {
        super("connection_setSchema");
      }

      public connection_setSchema_args getEmptyArgsInstance() {
        return new connection_setSchema_args();
      }

      public AsyncMethodCallback<Void> getResultHandler(final AsyncFrameBuffer fb, final int seqid) {
        final org.apache.thrift.AsyncProcessFunction fcall = this;
        return new AsyncMethodCallback<Void>() { 
          public void onComplete(Void o) {
            connection_setSchema_result result = new connection_setSchema_result();
            try {
              fcall.sendResponse(fb,result, org.apache.thrift.protocol.TMessageType.REPLY,seqid);
              return;
            } catch (Exception e) {
              LOGGER.error("Exception writing to internal frame buffer", e);
            }
            fb.close();
          }
          public void onError(Exception e) {
            byte msgType = org.apache.thrift.protocol.TMessageType.REPLY;
            org.apache.thrift.TBase msg;
            connection_setSchema_result result = new connection_setSchema_result();
            if (e instanceof RSQLException) {
                        result.sqlException = (RSQLException) e;
                        result.setSqlExceptionIsSet(true);
                        msg = result;
            }
             else 
            {
              msgType = org.apache.thrift.protocol.TMessageType.EXCEPTION;
              msg = (org.apache.thrift.TBase)new org.apache.thrift.TApplicationException(org.apache.thrift.TApplicationException.INTERNAL_ERROR, e.getMessage());
            }
            try {
              fcall.sendResponse(fb,msg,msgType,seqid);
              return;
            } catch (Exception ex) {
              LOGGER.error("Exception writing to internal frame buffer", ex);
            }
            fb.close();
          }
        };
      }

      protected boolean isOneway() {
        return false;
      }

      public void start(I iface, connection_setSchema_args args, org.apache.thrift.async.AsyncMethodCallback<Void> resultHandler) throws TException {
        iface.connection_setSchema(args.connection, args.schema,resultHandler);
      }
    }

    public static class connection_getSchema<I extends AsyncIface> extends org.apache.thrift.AsyncProcessFunction<I, connection_getSchema_args, String> {
      public connection_getSchema() {
        super("connection_getSchema");
      }

      public connection_getSchema_args getEmptyArgsInstance() {
        return new connection_getSchema_args();
      }

      public AsyncMethodCallback<String> getResultHandler(final AsyncFrameBuffer fb, final int seqid) {
        final org.apache.thrift.AsyncProcessFunction fcall = this;
        return new AsyncMethodCallback<String>() { 
          public void onComplete(String o) {
            connection_getSchema_result result = new connection_getSchema_result();
            result.success = o;
            try {
              fcall.sendResponse(fb,result, org.apache.thrift.protocol.TMessageType.REPLY,seqid);
              return;
            } catch (Exception e) {
              LOGGER.error("Exception writing to internal frame buffer", e);
            }
            fb.close();
          }
          public void onError(Exception e) {
            byte msgType = org.apache.thrift.protocol.TMessageType.REPLY;
            org.apache.thrift.TBase msg;
            connection_getSchema_result result = new connection_getSchema_result();
            if (e instanceof RSQLException) {
                        result.sqlException = (RSQLException) e;
                        result.setSqlExceptionIsSet(true);
                        msg = result;
            }
             else 
            {
              msgType = org.apache.thrift.protocol.TMessageType.EXCEPTION;
              msg = (org.apache.thrift.TBase)new org.apache.thrift.TApplicationException(org.apache.thrift.TApplicationException.INTERNAL_ERROR, e.getMessage());
            }
            try {
              fcall.sendResponse(fb,msg,msgType,seqid);
              return;
            } catch (Exception ex) {
              LOGGER.error("Exception writing to internal frame buffer", ex);
            }
            fb.close();
          }
        };
      }

      protected boolean isOneway() {
        return false;
      }

      public void start(I iface, connection_getSchema_args args, org.apache.thrift.async.AsyncMethodCallback<String> resultHandler) throws TException {
        iface.connection_getSchema(args.connection,resultHandler);
      }
    }

    public static class connection_getCatalogSeparator<I extends AsyncIface> extends org.apache.thrift.AsyncProcessFunction<I, connection_getCatalogSeparator_args, String> {
      public connection_getCatalogSeparator() {
        super("connection_getCatalogSeparator");
      }

      public connection_getCatalogSeparator_args getEmptyArgsInstance() {
        return new connection_getCatalogSeparator_args();
      }

      public AsyncMethodCallback<String> getResultHandler(final AsyncFrameBuffer fb, final int seqid) {
        final org.apache.thrift.AsyncProcessFunction fcall = this;
        return new AsyncMethodCallback<String>() { 
          public void onComplete(String o) {
            connection_getCatalogSeparator_result result = new connection_getCatalogSeparator_result();
            result.success = o;
            try {
              fcall.sendResponse(fb,result, org.apache.thrift.protocol.TMessageType.REPLY,seqid);
              return;
            } catch (Exception e) {
              LOGGER.error("Exception writing to internal frame buffer", e);
            }
            fb.close();
          }
          public void onError(Exception e) {
            byte msgType = org.apache.thrift.protocol.TMessageType.REPLY;
            org.apache.thrift.TBase msg;
            connection_getCatalogSeparator_result result = new connection_getCatalogSeparator_result();
            if (e instanceof RSQLException) {
                        result.sqlException = (RSQLException) e;
                        result.setSqlExceptionIsSet(true);
                        msg = result;
            }
             else 
            {
              msgType = org.apache.thrift.protocol.TMessageType.EXCEPTION;
              msg = (org.apache.thrift.TBase)new org.apache.thrift.TApplicationException(org.apache.thrift.TApplicationException.INTERNAL_ERROR, e.getMessage());
            }
            try {
              fcall.sendResponse(fb,msg,msgType,seqid);
              return;
            } catch (Exception ex) {
              LOGGER.error("Exception writing to internal frame buffer", ex);
            }
            fb.close();
          }
        };
      }

      protected boolean isOneway() {
        return false;
      }

      public void start(I iface, connection_getCatalogSeparator_args args, org.apache.thrift.async.AsyncMethodCallback<String> resultHandler) throws TException {
        iface.connection_getCatalogSeparator(args.connection,resultHandler);
      }
    }

    public static class connection_getCatalogTerm<I extends AsyncIface> extends org.apache.thrift.AsyncProcessFunction<I, connection_getCatalogTerm_args, String> {
      public connection_getCatalogTerm() {
        super("connection_getCatalogTerm");
      }

      public connection_getCatalogTerm_args getEmptyArgsInstance() {
        return new connection_getCatalogTerm_args();
      }

      public AsyncMethodCallback<String> getResultHandler(final AsyncFrameBuffer fb, final int seqid) {
        final org.apache.thrift.AsyncProcessFunction fcall = this;
        return new AsyncMethodCallback<String>() { 
          public void onComplete(String o) {
            connection_getCatalogTerm_result result = new connection_getCatalogTerm_result();
            result.success = o;
            try {
              fcall.sendResponse(fb,result, org.apache.thrift.protocol.TMessageType.REPLY,seqid);
              return;
            } catch (Exception e) {
              LOGGER.error("Exception writing to internal frame buffer", e);
            }
            fb.close();
          }
          public void onError(Exception e) {
            byte msgType = org.apache.thrift.protocol.TMessageType.REPLY;
            org.apache.thrift.TBase msg;
            connection_getCatalogTerm_result result = new connection_getCatalogTerm_result();
            if (e instanceof RSQLException) {
                        result.sqlException = (RSQLException) e;
                        result.setSqlExceptionIsSet(true);
                        msg = result;
            }
             else 
            {
              msgType = org.apache.thrift.protocol.TMessageType.EXCEPTION;
              msg = (org.apache.thrift.TBase)new org.apache.thrift.TApplicationException(org.apache.thrift.TApplicationException.INTERNAL_ERROR, e.getMessage());
            }
            try {
              fcall.sendResponse(fb,msg,msgType,seqid);
              return;
            } catch (Exception ex) {
              LOGGER.error("Exception writing to internal frame buffer", ex);
            }
            fb.close();
          }
        };
      }

      protected boolean isOneway() {
        return false;
      }

      public void start(I iface, connection_getCatalogTerm_args args, org.apache.thrift.async.AsyncMethodCallback<String> resultHandler) throws TException {
        iface.connection_getCatalogTerm(args.connection,resultHandler);
      }
    }

    public static class connection_getSchemaTerm<I extends AsyncIface> extends org.apache.thrift.AsyncProcessFunction<I, connection_getSchemaTerm_args, String> {
      public connection_getSchemaTerm() {
        super("connection_getSchemaTerm");
      }

      public connection_getSchemaTerm_args getEmptyArgsInstance() {
        return new connection_getSchemaTerm_args();
      }

      public AsyncMethodCallback<String> getResultHandler(final AsyncFrameBuffer fb, final int seqid) {
        final org.apache.thrift.AsyncProcessFunction fcall = this;
        return new AsyncMethodCallback<String>() { 
          public void onComplete(String o) {
            connection_getSchemaTerm_result result = new connection_getSchemaTerm_result();
            result.success = o;
            try {
              fcall.sendResponse(fb,result, org.apache.thrift.protocol.TMessageType.REPLY,seqid);
              return;
            } catch (Exception e) {
              LOGGER.error("Exception writing to internal frame buffer", e);
            }
            fb.close();
          }
          public void onError(Exception e) {
            byte msgType = org.apache.thrift.protocol.TMessageType.REPLY;
            org.apache.thrift.TBase msg;
            connection_getSchemaTerm_result result = new connection_getSchemaTerm_result();
            if (e instanceof RSQLException) {
                        result.sqlException = (RSQLException) e;
                        result.setSqlExceptionIsSet(true);
                        msg = result;
            }
             else 
            {
              msgType = org.apache.thrift.protocol.TMessageType.EXCEPTION;
              msg = (org.apache.thrift.TBase)new org.apache.thrift.TApplicationException(org.apache.thrift.TApplicationException.INTERNAL_ERROR, e.getMessage());
            }
            try {
              fcall.sendResponse(fb,msg,msgType,seqid);
              return;
            } catch (Exception ex) {
              LOGGER.error("Exception writing to internal frame buffer", ex);
            }
            fb.close();
          }
        };
      }

      protected boolean isOneway() {
        return false;
      }

      public void start(I iface, connection_getSchemaTerm_args args, org.apache.thrift.async.AsyncMethodCallback<String> resultHandler) throws TException {
        iface.connection_getSchemaTerm(args.connection,resultHandler);
      }
    }

    public static class connection_getCatalogs<I extends AsyncIface> extends org.apache.thrift.AsyncProcessFunction<I, connection_getCatalogs_args, RResultSet> {
      public connection_getCatalogs() {
        super("connection_getCatalogs");
      }

      public connection_getCatalogs_args getEmptyArgsInstance() {
        return new connection_getCatalogs_args();
      }

      public AsyncMethodCallback<RResultSet> getResultHandler(final AsyncFrameBuffer fb, final int seqid) {
        final org.apache.thrift.AsyncProcessFunction fcall = this;
        return new AsyncMethodCallback<RResultSet>() { 
          public void onComplete(RResultSet o) {
            connection_getCatalogs_result result = new connection_getCatalogs_result();
            result.success = o;
            try {
              fcall.sendResponse(fb,result, org.apache.thrift.protocol.TMessageType.REPLY,seqid);
              return;
            } catch (Exception e) {
              LOGGER.error("Exception writing to internal frame buffer", e);
            }
            fb.close();
          }
          public void onError(Exception e) {
            byte msgType = org.apache.thrift.protocol.TMessageType.REPLY;
            org.apache.thrift.TBase msg;
            connection_getCatalogs_result result = new connection_getCatalogs_result();
            if (e instanceof RSQLException) {
                        result.sqlException = (RSQLException) e;
                        result.setSqlExceptionIsSet(true);
                        msg = result;
            }
             else 
            {
              msgType = org.apache.thrift.protocol.TMessageType.EXCEPTION;
              msg = (org.apache.thrift.TBase)new org.apache.thrift.TApplicationException(org.apache.thrift.TApplicationException.INTERNAL_ERROR, e.getMessage());
            }
            try {
              fcall.sendResponse(fb,msg,msgType,seqid);
              return;
            } catch (Exception ex) {
              LOGGER.error("Exception writing to internal frame buffer", ex);
            }
            fb.close();
          }
        };
      }

      protected boolean isOneway() {
        return false;
      }

      public void start(I iface, connection_getCatalogs_args args, org.apache.thrift.async.AsyncMethodCallback<RResultSet> resultHandler) throws TException {
        iface.connection_getCatalogs(args.connection,resultHandler);
      }
    }

    public static class connection_getSchemas<I extends AsyncIface> extends org.apache.thrift.AsyncProcessFunction<I, connection_getSchemas_args, RResultSet> {
      public connection_getSchemas() {
        super("connection_getSchemas");
      }

      public connection_getSchemas_args getEmptyArgsInstance() {
        return new connection_getSchemas_args();
      }

      public AsyncMethodCallback<RResultSet> getResultHandler(final AsyncFrameBuffer fb, final int seqid) {
        final org.apache.thrift.AsyncProcessFunction fcall = this;
        return new AsyncMethodCallback<RResultSet>() { 
          public void onComplete(RResultSet o) {
            connection_getSchemas_result result = new connection_getSchemas_result();
            result.success = o;
            try {
              fcall.sendResponse(fb,result, org.apache.thrift.protocol.TMessageType.REPLY,seqid);
              return;
            } catch (Exception e) {
              LOGGER.error("Exception writing to internal frame buffer", e);
            }
            fb.close();
          }
          public void onError(Exception e) {
            byte msgType = org.apache.thrift.protocol.TMessageType.REPLY;
            org.apache.thrift.TBase msg;
            connection_getSchemas_result result = new connection_getSchemas_result();
            if (e instanceof RSQLException) {
                        result.sqlException = (RSQLException) e;
                        result.setSqlExceptionIsSet(true);
                        msg = result;
            }
             else 
            {
              msgType = org.apache.thrift.protocol.TMessageType.EXCEPTION;
              msg = (org.apache.thrift.TBase)new org.apache.thrift.TApplicationException(org.apache.thrift.TApplicationException.INTERNAL_ERROR, e.getMessage());
            }
            try {
              fcall.sendResponse(fb,msg,msgType,seqid);
              return;
            } catch (Exception ex) {
              LOGGER.error("Exception writing to internal frame buffer", ex);
            }
            fb.close();
          }
        };
      }

      protected boolean isOneway() {
        return false;
      }

      public void start(I iface, connection_getSchemas_args args, org.apache.thrift.async.AsyncMethodCallback<RResultSet> resultHandler) throws TException {
        iface.connection_getSchemas(args.connection, args.catalog, args.schemaPattern,resultHandler);
      }
    }

    public static class connection_getTables<I extends AsyncIface> extends org.apache.thrift.AsyncProcessFunction<I, connection_getTables_args, RResultSet> {
      public connection_getTables() {
        super("connection_getTables");
      }

      public connection_getTables_args getEmptyArgsInstance() {
        return new connection_getTables_args();
      }

      public AsyncMethodCallback<RResultSet> getResultHandler(final AsyncFrameBuffer fb, final int seqid) {
        final org.apache.thrift.AsyncProcessFunction fcall = this;
        return new AsyncMethodCallback<RResultSet>() { 
          public void onComplete(RResultSet o) {
            connection_getTables_result result = new connection_getTables_result();
            result.success = o;
            try {
              fcall.sendResponse(fb,result, org.apache.thrift.protocol.TMessageType.REPLY,seqid);
              return;
            } catch (Exception e) {
              LOGGER.error("Exception writing to internal frame buffer", e);
            }
            fb.close();
          }
          public void onError(Exception e) {
            byte msgType = org.apache.thrift.protocol.TMessageType.REPLY;
            org.apache.thrift.TBase msg;
            connection_getTables_result result = new connection_getTables_result();
            if (e instanceof RSQLException) {
                        result.sqlException = (RSQLException) e;
                        result.setSqlExceptionIsSet(true);
                        msg = result;
            }
             else 
            {
              msgType = org.apache.thrift.protocol.TMessageType.EXCEPTION;
              msg = (org.apache.thrift.TBase)new org.apache.thrift.TApplicationException(org.apache.thrift.TApplicationException.INTERNAL_ERROR, e.getMessage());
            }
            try {
              fcall.sendResponse(fb,msg,msgType,seqid);
              return;
            } catch (Exception ex) {
              LOGGER.error("Exception writing to internal frame buffer", ex);
            }
            fb.close();
          }
        };
      }

      protected boolean isOneway() {
        return false;
      }

      public void start(I iface, connection_getTables_args args, org.apache.thrift.async.AsyncMethodCallback<RResultSet> resultHandler) throws TException {
        iface.connection_getTables(args.connection, args.catalog, args.schemaPattern, args.tableNamePattern, args.types,resultHandler);
      }
    }

    public static class connection_getColumns<I extends AsyncIface> extends org.apache.thrift.AsyncProcessFunction<I, connection_getColumns_args, RResultSet> {
      public connection_getColumns() {
        super("connection_getColumns");
      }

      public connection_getColumns_args getEmptyArgsInstance() {
        return new connection_getColumns_args();
      }

      public AsyncMethodCallback<RResultSet> getResultHandler(final AsyncFrameBuffer fb, final int seqid) {
        final org.apache.thrift.AsyncProcessFunction fcall = this;
        return new AsyncMethodCallback<RResultSet>() { 
          public void onComplete(RResultSet o) {
            connection_getColumns_result result = new connection_getColumns_result();
            result.success = o;
            try {
              fcall.sendResponse(fb,result, org.apache.thrift.protocol.TMessageType.REPLY,seqid);
              return;
            } catch (Exception e) {
              LOGGER.error("Exception writing to internal frame buffer", e);
            }
            fb.close();
          }
          public void onError(Exception e) {
            byte msgType = org.apache.thrift.protocol.TMessageType.REPLY;
            org.apache.thrift.TBase msg;
            connection_getColumns_result result = new connection_getColumns_result();
            if (e instanceof RSQLException) {
                        result.sqlException = (RSQLException) e;
                        result.setSqlExceptionIsSet(true);
                        msg = result;
            }
             else 
            {
              msgType = org.apache.thrift.protocol.TMessageType.EXCEPTION;
              msg = (org.apache.thrift.TBase)new org.apache.thrift.TApplicationException(org.apache.thrift.TApplicationException.INTERNAL_ERROR, e.getMessage());
            }
            try {
              fcall.sendResponse(fb,msg,msgType,seqid);
              return;
            } catch (Exception ex) {
              LOGGER.error("Exception writing to internal frame buffer", ex);
            }
            fb.close();
          }
        };
      }

      protected boolean isOneway() {
        return false;
      }

      public void start(I iface, connection_getColumns_args args, org.apache.thrift.async.AsyncMethodCallback<RResultSet> resultHandler) throws TException {
        iface.connection_getColumns(args.connection, args.catalog, args.schemaPattern, args.tableNamePattern, args.columnNamePattern,resultHandler);
      }
    }

    public static class connection_getSQLKeywords<I extends AsyncIface> extends org.apache.thrift.AsyncProcessFunction<I, connection_getSQLKeywords_args, String> {
      public connection_getSQLKeywords() {
        super("connection_getSQLKeywords");
      }

      public connection_getSQLKeywords_args getEmptyArgsInstance() {
        return new connection_getSQLKeywords_args();
      }

      public AsyncMethodCallback<String> getResultHandler(final AsyncFrameBuffer fb, final int seqid) {
        final org.apache.thrift.AsyncProcessFunction fcall = this;
        return new AsyncMethodCallback<String>() { 
          public void onComplete(String o) {
            connection_getSQLKeywords_result result = new connection_getSQLKeywords_result();
            result.success = o;
            try {
              fcall.sendResponse(fb,result, org.apache.thrift.protocol.TMessageType.REPLY,seqid);
              return;
            } catch (Exception e) {
              LOGGER.error("Exception writing to internal frame buffer", e);
            }
            fb.close();
          }
          public void onError(Exception e) {
            byte msgType = org.apache.thrift.protocol.TMessageType.REPLY;
            org.apache.thrift.TBase msg;
            connection_getSQLKeywords_result result = new connection_getSQLKeywords_result();
            if (e instanceof RSQLException) {
                        result.sqlException = (RSQLException) e;
                        result.setSqlExceptionIsSet(true);
                        msg = result;
            }
             else 
            {
              msgType = org.apache.thrift.protocol.TMessageType.EXCEPTION;
              msg = (org.apache.thrift.TBase)new org.apache.thrift.TApplicationException(org.apache.thrift.TApplicationException.INTERNAL_ERROR, e.getMessage());
            }
            try {
              fcall.sendResponse(fb,msg,msgType,seqid);
              return;
            } catch (Exception ex) {
              LOGGER.error("Exception writing to internal frame buffer", ex);
            }
            fb.close();
          }
        };
      }

      protected boolean isOneway() {
        return false;
      }

      public void start(I iface, connection_getSQLKeywords_args args, org.apache.thrift.async.AsyncMethodCallback<String> resultHandler) throws TException {
        iface.connection_getSQLKeywords(args.connection,resultHandler);
      }
    }

    public static class connection_getTableTypes<I extends AsyncIface> extends org.apache.thrift.AsyncProcessFunction<I, connection_getTableTypes_args, RResultSet> {
      public connection_getTableTypes() {
        super("connection_getTableTypes");
      }

      public connection_getTableTypes_args getEmptyArgsInstance() {
        return new connection_getTableTypes_args();
      }

      public AsyncMethodCallback<RResultSet> getResultHandler(final AsyncFrameBuffer fb, final int seqid) {
        final org.apache.thrift.AsyncProcessFunction fcall = this;
        return new AsyncMethodCallback<RResultSet>() { 
          public void onComplete(RResultSet o) {
            connection_getTableTypes_result result = new connection_getTableTypes_result();
            result.success = o;
            try {
              fcall.sendResponse(fb,result, org.apache.thrift.protocol.TMessageType.REPLY,seqid);
              return;
            } catch (Exception e) {
              LOGGER.error("Exception writing to internal frame buffer", e);
            }
            fb.close();
          }
          public void onError(Exception e) {
            byte msgType = org.apache.thrift.protocol.TMessageType.REPLY;
            org.apache.thrift.TBase msg;
            connection_getTableTypes_result result = new connection_getTableTypes_result();
            if (e instanceof RSQLException) {
                        result.sqlException = (RSQLException) e;
                        result.setSqlExceptionIsSet(true);
                        msg = result;
            }
             else 
            {
              msgType = org.apache.thrift.protocol.TMessageType.EXCEPTION;
              msg = (org.apache.thrift.TBase)new org.apache.thrift.TApplicationException(org.apache.thrift.TApplicationException.INTERNAL_ERROR, e.getMessage());
            }
            try {
              fcall.sendResponse(fb,msg,msgType,seqid);
              return;
            } catch (Exception ex) {
              LOGGER.error("Exception writing to internal frame buffer", ex);
            }
            fb.close();
          }
        };
      }

      protected boolean isOneway() {
        return false;
      }

      public void start(I iface, connection_getTableTypes_args args, org.apache.thrift.async.AsyncMethodCallback<RResultSet> resultHandler) throws TException {
        iface.connection_getTableTypes(args.connection,resultHandler);
      }
    }

    public static class connection_getTypeInfo<I extends AsyncIface> extends org.apache.thrift.AsyncProcessFunction<I, connection_getTypeInfo_args, RResultSet> {
      public connection_getTypeInfo() {
        super("connection_getTypeInfo");
      }

      public connection_getTypeInfo_args getEmptyArgsInstance() {
        return new connection_getTypeInfo_args();
      }

      public AsyncMethodCallback<RResultSet> getResultHandler(final AsyncFrameBuffer fb, final int seqid) {
        final org.apache.thrift.AsyncProcessFunction fcall = this;
        return new AsyncMethodCallback<RResultSet>() { 
          public void onComplete(RResultSet o) {
            connection_getTypeInfo_result result = new connection_getTypeInfo_result();
            result.success = o;
            try {
              fcall.sendResponse(fb,result, org.apache.thrift.protocol.TMessageType.REPLY,seqid);
              return;
            } catch (Exception e) {
              LOGGER.error("Exception writing to internal frame buffer", e);
            }
            fb.close();
          }
          public void onError(Exception e) {
            byte msgType = org.apache.thrift.protocol.TMessageType.REPLY;
            org.apache.thrift.TBase msg;
            connection_getTypeInfo_result result = new connection_getTypeInfo_result();
            if (e instanceof RSQLException) {
                        result.sqlException = (RSQLException) e;
                        result.setSqlExceptionIsSet(true);
                        msg = result;
            }
             else 
            {
              msgType = org.apache.thrift.protocol.TMessageType.EXCEPTION;
              msg = (org.apache.thrift.TBase)new org.apache.thrift.TApplicationException(org.apache.thrift.TApplicationException.INTERNAL_ERROR, e.getMessage());
            }
            try {
              fcall.sendResponse(fb,msg,msgType,seqid);
              return;
            } catch (Exception ex) {
              LOGGER.error("Exception writing to internal frame buffer", ex);
            }
            fb.close();
          }
        };
      }

      protected boolean isOneway() {
        return false;
      }

      public void start(I iface, connection_getTypeInfo_args args, org.apache.thrift.async.AsyncMethodCallback<RResultSet> resultHandler) throws TException {
        iface.connection_getTypeInfo(args.connection,resultHandler);
      }
    }

    public static class closeConnection<I extends AsyncIface> extends org.apache.thrift.AsyncProcessFunction<I, closeConnection_args, Void> {
      public closeConnection() {
        super("closeConnection");
      }

      public closeConnection_args getEmptyArgsInstance() {
        return new closeConnection_args();
      }

      public AsyncMethodCallback<Void> getResultHandler(final AsyncFrameBuffer fb, final int seqid) {
        final org.apache.thrift.AsyncProcessFunction fcall = this;
        return new AsyncMethodCallback<Void>() { 
          public void onComplete(Void o) {
            closeConnection_result result = new closeConnection_result();
            try {
              fcall.sendResponse(fb,result, org.apache.thrift.protocol.TMessageType.REPLY,seqid);
              return;
            } catch (Exception e) {
              LOGGER.error("Exception writing to internal frame buffer", e);
            }
            fb.close();
          }
          public void onError(Exception e) {
            byte msgType = org.apache.thrift.protocol.TMessageType.REPLY;
            org.apache.thrift.TBase msg;
            closeConnection_result result = new closeConnection_result();
            if (e instanceof RSQLException) {
                        result.sqlException = (RSQLException) e;
                        result.setSqlExceptionIsSet(true);
                        msg = result;
            }
             else 
            {
              msgType = org.apache.thrift.protocol.TMessageType.EXCEPTION;
              msg = (org.apache.thrift.TBase)new org.apache.thrift.TApplicationException(org.apache.thrift.TApplicationException.INTERNAL_ERROR, e.getMessage());
            }
            try {
              fcall.sendResponse(fb,msg,msgType,seqid);
              return;
            } catch (Exception ex) {
              LOGGER.error("Exception writing to internal frame buffer", ex);
            }
            fb.close();
          }
        };
      }

      protected boolean isOneway() {
        return false;
      }

      public void start(I iface, closeConnection_args args, org.apache.thrift.async.AsyncMethodCallback<Void> resultHandler) throws TException {
        iface.closeConnection(args.connection,resultHandler);
      }
    }

    public static class statement_close<I extends AsyncIface> extends org.apache.thrift.AsyncProcessFunction<I, statement_close_args, Void> {
      public statement_close() {
        super("statement_close");
      }

      public statement_close_args getEmptyArgsInstance() {
        return new statement_close_args();
      }

      public AsyncMethodCallback<Void> getResultHandler(final AsyncFrameBuffer fb, final int seqid) {
        final org.apache.thrift.AsyncProcessFunction fcall = this;
        return new AsyncMethodCallback<Void>() { 
          public void onComplete(Void o) {
            statement_close_result result = new statement_close_result();
            try {
              fcall.sendResponse(fb,result, org.apache.thrift.protocol.TMessageType.REPLY,seqid);
              return;
            } catch (Exception e) {
              LOGGER.error("Exception writing to internal frame buffer", e);
            }
            fb.close();
          }
          public void onError(Exception e) {
            byte msgType = org.apache.thrift.protocol.TMessageType.REPLY;
            org.apache.thrift.TBase msg;
            statement_close_result result = new statement_close_result();
            if (e instanceof RSQLException) {
                        result.sqlException = (RSQLException) e;
                        result.setSqlExceptionIsSet(true);
                        msg = result;
            }
             else 
            {
              msgType = org.apache.thrift.protocol.TMessageType.EXCEPTION;
              msg = (org.apache.thrift.TBase)new org.apache.thrift.TApplicationException(org.apache.thrift.TApplicationException.INTERNAL_ERROR, e.getMessage());
            }
            try {
              fcall.sendResponse(fb,msg,msgType,seqid);
              return;
            } catch (Exception ex) {
              LOGGER.error("Exception writing to internal frame buffer", ex);
            }
            fb.close();
          }
        };
      }

      protected boolean isOneway() {
        return false;
      }

      public void start(I iface, statement_close_args args, org.apache.thrift.async.AsyncMethodCallback<Void> resultHandler) throws TException {
        iface.statement_close(args.statement,resultHandler);
      }
    }

    public static class statement_execute<I extends AsyncIface> extends org.apache.thrift.AsyncProcessFunction<I, statement_execute_args, Boolean> {
      public statement_execute() {
        super("statement_execute");
      }

      public statement_execute_args getEmptyArgsInstance() {
        return new statement_execute_args();
      }

      public AsyncMethodCallback<Boolean> getResultHandler(final AsyncFrameBuffer fb, final int seqid) {
        final org.apache.thrift.AsyncProcessFunction fcall = this;
        return new AsyncMethodCallback<Boolean>() { 
          public void onComplete(Boolean o) {
            statement_execute_result result = new statement_execute_result();
            result.success = o;
            result.setSuccessIsSet(true);
            try {
              fcall.sendResponse(fb,result, org.apache.thrift.protocol.TMessageType.REPLY,seqid);
              return;
            } catch (Exception e) {
              LOGGER.error("Exception writing to internal frame buffer", e);
            }
            fb.close();
          }
          public void onError(Exception e) {
            byte msgType = org.apache.thrift.protocol.TMessageType.REPLY;
            org.apache.thrift.TBase msg;
            statement_execute_result result = new statement_execute_result();
            if (e instanceof RSQLException) {
                        result.sqlException = (RSQLException) e;
                        result.setSqlExceptionIsSet(true);
                        msg = result;
            }
             else 
            {
              msgType = org.apache.thrift.protocol.TMessageType.EXCEPTION;
              msg = (org.apache.thrift.TBase)new org.apache.thrift.TApplicationException(org.apache.thrift.TApplicationException.INTERNAL_ERROR, e.getMessage());
            }
            try {
              fcall.sendResponse(fb,msg,msgType,seqid);
              return;
            } catch (Exception ex) {
              LOGGER.error("Exception writing to internal frame buffer", ex);
            }
            fb.close();
          }
        };
      }

      protected boolean isOneway() {
        return false;
      }

      public void start(I iface, statement_execute_args args, org.apache.thrift.async.AsyncMethodCallback<Boolean> resultHandler) throws TException {
        iface.statement_execute(args.statement, args.sql,resultHandler);
      }
    }

    public static class statement_executeQuery<I extends AsyncIface> extends org.apache.thrift.AsyncProcessFunction<I, statement_executeQuery_args, RResultSet> {
      public statement_executeQuery() {
        super("statement_executeQuery");
      }

      public statement_executeQuery_args getEmptyArgsInstance() {
        return new statement_executeQuery_args();
      }

      public AsyncMethodCallback<RResultSet> getResultHandler(final AsyncFrameBuffer fb, final int seqid) {
        final org.apache.thrift.AsyncProcessFunction fcall = this;
        return new AsyncMethodCallback<RResultSet>() { 
          public void onComplete(RResultSet o) {
            statement_executeQuery_result result = new statement_executeQuery_result();
            result.success = o;
            try {
              fcall.sendResponse(fb,result, org.apache.thrift.protocol.TMessageType.REPLY,seqid);
              return;
            } catch (Exception e) {
              LOGGER.error("Exception writing to internal frame buffer", e);
            }
            fb.close();
          }
          public void onError(Exception e) {
            byte msgType = org.apache.thrift.protocol.TMessageType.REPLY;
            org.apache.thrift.TBase msg;
            statement_executeQuery_result result = new statement_executeQuery_result();
            if (e instanceof RSQLException) {
                        result.sqlException = (RSQLException) e;
                        result.setSqlExceptionIsSet(true);
                        msg = result;
            }
             else 
            {
              msgType = org.apache.thrift.protocol.TMessageType.EXCEPTION;
              msg = (org.apache.thrift.TBase)new org.apache.thrift.TApplicationException(org.apache.thrift.TApplicationException.INTERNAL_ERROR, e.getMessage());
            }
            try {
              fcall.sendResponse(fb,msg,msgType,seqid);
              return;
            } catch (Exception ex) {
              LOGGER.error("Exception writing to internal frame buffer", ex);
            }
            fb.close();
          }
        };
      }

      protected boolean isOneway() {
        return false;
      }

      public void start(I iface, statement_executeQuery_args args, org.apache.thrift.async.AsyncMethodCallback<RResultSet> resultHandler) throws TException {
        iface.statement_executeQuery(args.statement, args.sql,resultHandler);
      }
    }

    public static class statement_executeUpdate<I extends AsyncIface> extends org.apache.thrift.AsyncProcessFunction<I, statement_executeUpdate_args, Integer> {
      public statement_executeUpdate() {
        super("statement_executeUpdate");
      }

      public statement_executeUpdate_args getEmptyArgsInstance() {
        return new statement_executeUpdate_args();
      }

      public AsyncMethodCallback<Integer> getResultHandler(final AsyncFrameBuffer fb, final int seqid) {
        final org.apache.thrift.AsyncProcessFunction fcall = this;
        return new AsyncMethodCallback<Integer>() { 
          public void onComplete(Integer o) {
            statement_executeUpdate_result result = new statement_executeUpdate_result();
            result.success = o;
            result.setSuccessIsSet(true);
            try {
              fcall.sendResponse(fb,result, org.apache.thrift.protocol.TMessageType.REPLY,seqid);
              return;
            } catch (Exception e) {
              LOGGER.error("Exception writing to internal frame buffer", e);
            }
            fb.close();
          }
          public void onError(Exception e) {
            byte msgType = org.apache.thrift.protocol.TMessageType.REPLY;
            org.apache.thrift.TBase msg;
            statement_executeUpdate_result result = new statement_executeUpdate_result();
            if (e instanceof RSQLException) {
                        result.sqlException = (RSQLException) e;
                        result.setSqlExceptionIsSet(true);
                        msg = result;
            }
             else 
            {
              msgType = org.apache.thrift.protocol.TMessageType.EXCEPTION;
              msg = (org.apache.thrift.TBase)new org.apache.thrift.TApplicationException(org.apache.thrift.TApplicationException.INTERNAL_ERROR, e.getMessage());
            }
            try {
              fcall.sendResponse(fb,msg,msgType,seqid);
              return;
            } catch (Exception ex) {
              LOGGER.error("Exception writing to internal frame buffer", ex);
            }
            fb.close();
          }
        };
      }

      protected boolean isOneway() {
        return false;
      }

      public void start(I iface, statement_executeUpdate_args args, org.apache.thrift.async.AsyncMethodCallback<Integer> resultHandler) throws TException {
        iface.statement_executeUpdate(args.statement, args.sql,resultHandler);
      }
    }

    public static class statement_getResultSet<I extends AsyncIface> extends org.apache.thrift.AsyncProcessFunction<I, statement_getResultSet_args, RResultSet> {
      public statement_getResultSet() {
        super("statement_getResultSet");
      }

      public statement_getResultSet_args getEmptyArgsInstance() {
        return new statement_getResultSet_args();
      }

      public AsyncMethodCallback<RResultSet> getResultHandler(final AsyncFrameBuffer fb, final int seqid) {
        final org.apache.thrift.AsyncProcessFunction fcall = this;
        return new AsyncMethodCallback<RResultSet>() { 
          public void onComplete(RResultSet o) {
            statement_getResultSet_result result = new statement_getResultSet_result();
            result.success = o;
            try {
              fcall.sendResponse(fb,result, org.apache.thrift.protocol.TMessageType.REPLY,seqid);
              return;
            } catch (Exception e) {
              LOGGER.error("Exception writing to internal frame buffer", e);
            }
            fb.close();
          }
          public void onError(Exception e) {
            byte msgType = org.apache.thrift.protocol.TMessageType.REPLY;
            org.apache.thrift.TBase msg;
            statement_getResultSet_result result = new statement_getResultSet_result();
            if (e instanceof RSQLException) {
                        result.sqlException = (RSQLException) e;
                        result.setSqlExceptionIsSet(true);
                        msg = result;
            }
             else 
            {
              msgType = org.apache.thrift.protocol.TMessageType.EXCEPTION;
              msg = (org.apache.thrift.TBase)new org.apache.thrift.TApplicationException(org.apache.thrift.TApplicationException.INTERNAL_ERROR, e.getMessage());
            }
            try {
              fcall.sendResponse(fb,msg,msgType,seqid);
              return;
            } catch (Exception ex) {
              LOGGER.error("Exception writing to internal frame buffer", ex);
            }
            fb.close();
          }
        };
      }

      protected boolean isOneway() {
        return false;
      }

      public void start(I iface, statement_getResultSet_args args, org.apache.thrift.async.AsyncMethodCallback<RResultSet> resultHandler) throws TException {
        iface.statement_getResultSet(args.statement,resultHandler);
      }
    }

    public static class statement_getUpdateCount<I extends AsyncIface> extends org.apache.thrift.AsyncProcessFunction<I, statement_getUpdateCount_args, Integer> {
      public statement_getUpdateCount() {
        super("statement_getUpdateCount");
      }

      public statement_getUpdateCount_args getEmptyArgsInstance() {
        return new statement_getUpdateCount_args();
      }

      public AsyncMethodCallback<Integer> getResultHandler(final AsyncFrameBuffer fb, final int seqid) {
        final org.apache.thrift.AsyncProcessFunction fcall = this;
        return new AsyncMethodCallback<Integer>() { 
          public void onComplete(Integer o) {
            statement_getUpdateCount_result result = new statement_getUpdateCount_result();
            result.success = o;
            result.setSuccessIsSet(true);
            try {
              fcall.sendResponse(fb,result, org.apache.thrift.protocol.TMessageType.REPLY,seqid);
              return;
            } catch (Exception e) {
              LOGGER.error("Exception writing to internal frame buffer", e);
            }
            fb.close();
          }
          public void onError(Exception e) {
            byte msgType = org.apache.thrift.protocol.TMessageType.REPLY;
            org.apache.thrift.TBase msg;
            statement_getUpdateCount_result result = new statement_getUpdateCount_result();
            if (e instanceof RSQLException) {
                        result.sqlException = (RSQLException) e;
                        result.setSqlExceptionIsSet(true);
                        msg = result;
            }
             else 
            {
              msgType = org.apache.thrift.protocol.TMessageType.EXCEPTION;
              msg = (org.apache.thrift.TBase)new org.apache.thrift.TApplicationException(org.apache.thrift.TApplicationException.INTERNAL_ERROR, e.getMessage());
            }
            try {
              fcall.sendResponse(fb,msg,msgType,seqid);
              return;
            } catch (Exception ex) {
              LOGGER.error("Exception writing to internal frame buffer", ex);
            }
            fb.close();
          }
        };
      }

      protected boolean isOneway() {
        return false;
      }

      public void start(I iface, statement_getUpdateCount_args args, org.apache.thrift.async.AsyncMethodCallback<Integer> resultHandler) throws TException {
        iface.statement_getUpdateCount(args.statement,resultHandler);
      }
    }

    public static class statement_getResultSetType<I extends AsyncIface> extends org.apache.thrift.AsyncProcessFunction<I, statement_getResultSetType_args, Integer> {
      public statement_getResultSetType() {
        super("statement_getResultSetType");
      }

      public statement_getResultSetType_args getEmptyArgsInstance() {
        return new statement_getResultSetType_args();
      }

      public AsyncMethodCallback<Integer> getResultHandler(final AsyncFrameBuffer fb, final int seqid) {
        final org.apache.thrift.AsyncProcessFunction fcall = this;
        return new AsyncMethodCallback<Integer>() { 
          public void onComplete(Integer o) {
            statement_getResultSetType_result result = new statement_getResultSetType_result();
            result.success = o;
            result.setSuccessIsSet(true);
            try {
              fcall.sendResponse(fb,result, org.apache.thrift.protocol.TMessageType.REPLY,seqid);
              return;
            } catch (Exception e) {
              LOGGER.error("Exception writing to internal frame buffer", e);
            }
            fb.close();
          }
          public void onError(Exception e) {
            byte msgType = org.apache.thrift.protocol.TMessageType.REPLY;
            org.apache.thrift.TBase msg;
            statement_getResultSetType_result result = new statement_getResultSetType_result();
            if (e instanceof RSQLException) {
                        result.sqlException = (RSQLException) e;
                        result.setSqlExceptionIsSet(true);
                        msg = result;
            }
             else 
            {
              msgType = org.apache.thrift.protocol.TMessageType.EXCEPTION;
              msg = (org.apache.thrift.TBase)new org.apache.thrift.TApplicationException(org.apache.thrift.TApplicationException.INTERNAL_ERROR, e.getMessage());
            }
            try {
              fcall.sendResponse(fb,msg,msgType,seqid);
              return;
            } catch (Exception ex) {
              LOGGER.error("Exception writing to internal frame buffer", ex);
            }
            fb.close();
          }
        };
      }

      protected boolean isOneway() {
        return false;
      }

      public void start(I iface, statement_getResultSetType_args args, org.apache.thrift.async.AsyncMethodCallback<Integer> resultHandler) throws TException {
        iface.statement_getResultSetType(args.statement,resultHandler);
      }
    }

    public static class statement_cancel<I extends AsyncIface> extends org.apache.thrift.AsyncProcessFunction<I, statement_cancel_args, Void> {
      public statement_cancel() {
        super("statement_cancel");
      }

      public statement_cancel_args getEmptyArgsInstance() {
        return new statement_cancel_args();
      }

      public AsyncMethodCallback<Void> getResultHandler(final AsyncFrameBuffer fb, final int seqid) {
        final org.apache.thrift.AsyncProcessFunction fcall = this;
        return new AsyncMethodCallback<Void>() { 
          public void onComplete(Void o) {
            statement_cancel_result result = new statement_cancel_result();
            try {
              fcall.sendResponse(fb,result, org.apache.thrift.protocol.TMessageType.REPLY,seqid);
              return;
            } catch (Exception e) {
              LOGGER.error("Exception writing to internal frame buffer", e);
            }
            fb.close();
          }
          public void onError(Exception e) {
            byte msgType = org.apache.thrift.protocol.TMessageType.REPLY;
            org.apache.thrift.TBase msg;
            statement_cancel_result result = new statement_cancel_result();
            if (e instanceof RSQLException) {
                        result.sqlException = (RSQLException) e;
                        result.setSqlExceptionIsSet(true);
                        msg = result;
            }
             else 
            {
              msgType = org.apache.thrift.protocol.TMessageType.EXCEPTION;
              msg = (org.apache.thrift.TBase)new org.apache.thrift.TApplicationException(org.apache.thrift.TApplicationException.INTERNAL_ERROR, e.getMessage());
            }
            try {
              fcall.sendResponse(fb,msg,msgType,seqid);
              return;
            } catch (Exception ex) {
              LOGGER.error("Exception writing to internal frame buffer", ex);
            }
            fb.close();
          }
        };
      }

      protected boolean isOneway() {
        return false;
      }

      public void start(I iface, statement_cancel_args args, org.apache.thrift.async.AsyncMethodCallback<Void> resultHandler) throws TException {
        iface.statement_cancel(args.statement,resultHandler);
      }
    }

    public static class statement_addBatch<I extends AsyncIface> extends org.apache.thrift.AsyncProcessFunction<I, statement_addBatch_args, Void> {
      public statement_addBatch() {
        super("statement_addBatch");
      }

      public statement_addBatch_args getEmptyArgsInstance() {
        return new statement_addBatch_args();
      }

      public AsyncMethodCallback<Void> getResultHandler(final AsyncFrameBuffer fb, final int seqid) {
        final org.apache.thrift.AsyncProcessFunction fcall = this;
        return new AsyncMethodCallback<Void>() { 
          public void onComplete(Void o) {
            statement_addBatch_result result = new statement_addBatch_result();
            try {
              fcall.sendResponse(fb,result, org.apache.thrift.protocol.TMessageType.REPLY,seqid);
              return;
            } catch (Exception e) {
              LOGGER.error("Exception writing to internal frame buffer", e);
            }
            fb.close();
          }
          public void onError(Exception e) {
            byte msgType = org.apache.thrift.protocol.TMessageType.REPLY;
            org.apache.thrift.TBase msg;
            statement_addBatch_result result = new statement_addBatch_result();
            if (e instanceof RSQLException) {
                        result.sqlException = (RSQLException) e;
                        result.setSqlExceptionIsSet(true);
                        msg = result;
            }
             else 
            {
              msgType = org.apache.thrift.protocol.TMessageType.EXCEPTION;
              msg = (org.apache.thrift.TBase)new org.apache.thrift.TApplicationException(org.apache.thrift.TApplicationException.INTERNAL_ERROR, e.getMessage());
            }
            try {
              fcall.sendResponse(fb,msg,msgType,seqid);
              return;
            } catch (Exception ex) {
              LOGGER.error("Exception writing to internal frame buffer", ex);
            }
            fb.close();
          }
        };
      }

      protected boolean isOneway() {
        return false;
      }

      public void start(I iface, statement_addBatch_args args, org.apache.thrift.async.AsyncMethodCallback<Void> resultHandler) throws TException {
        iface.statement_addBatch(args.statement, args.sql,resultHandler);
      }
    }

    public static class statement_addBatches<I extends AsyncIface> extends org.apache.thrift.AsyncProcessFunction<I, statement_addBatches_args, Void> {
      public statement_addBatches() {
        super("statement_addBatches");
      }

      public statement_addBatches_args getEmptyArgsInstance() {
        return new statement_addBatches_args();
      }

      public AsyncMethodCallback<Void> getResultHandler(final AsyncFrameBuffer fb, final int seqid) {
        final org.apache.thrift.AsyncProcessFunction fcall = this;
        return new AsyncMethodCallback<Void>() { 
          public void onComplete(Void o) {
            statement_addBatches_result result = new statement_addBatches_result();
            try {
              fcall.sendResponse(fb,result, org.apache.thrift.protocol.TMessageType.REPLY,seqid);
              return;
            } catch (Exception e) {
              LOGGER.error("Exception writing to internal frame buffer", e);
            }
            fb.close();
          }
          public void onError(Exception e) {
            byte msgType = org.apache.thrift.protocol.TMessageType.REPLY;
            org.apache.thrift.TBase msg;
            statement_addBatches_result result = new statement_addBatches_result();
            if (e instanceof RSQLException) {
                        result.sqlException = (RSQLException) e;
                        result.setSqlExceptionIsSet(true);
                        msg = result;
            }
             else 
            {
              msgType = org.apache.thrift.protocol.TMessageType.EXCEPTION;
              msg = (org.apache.thrift.TBase)new org.apache.thrift.TApplicationException(org.apache.thrift.TApplicationException.INTERNAL_ERROR, e.getMessage());
            }
            try {
              fcall.sendResponse(fb,msg,msgType,seqid);
              return;
            } catch (Exception ex) {
              LOGGER.error("Exception writing to internal frame buffer", ex);
            }
            fb.close();
          }
        };
      }

      protected boolean isOneway() {
        return false;
      }

      public void start(I iface, statement_addBatches_args args, org.apache.thrift.async.AsyncMethodCallback<Void> resultHandler) throws TException {
        iface.statement_addBatches(args.statement, args.sqlList,resultHandler);
      }
    }

    public static class statement_clearBatch<I extends AsyncIface> extends org.apache.thrift.AsyncProcessFunction<I, statement_clearBatch_args, Void> {
      public statement_clearBatch() {
        super("statement_clearBatch");
      }

      public statement_clearBatch_args getEmptyArgsInstance() {
        return new statement_clearBatch_args();
      }

      public AsyncMethodCallback<Void> getResultHandler(final AsyncFrameBuffer fb, final int seqid) {
        final org.apache.thrift.AsyncProcessFunction fcall = this;
        return new AsyncMethodCallback<Void>() { 
          public void onComplete(Void o) {
            statement_clearBatch_result result = new statement_clearBatch_result();
            try {
              fcall.sendResponse(fb,result, org.apache.thrift.protocol.TMessageType.REPLY,seqid);
              return;
            } catch (Exception e) {
              LOGGER.error("Exception writing to internal frame buffer", e);
            }
            fb.close();
          }
          public void onError(Exception e) {
            byte msgType = org.apache.thrift.protocol.TMessageType.REPLY;
            org.apache.thrift.TBase msg;
            statement_clearBatch_result result = new statement_clearBatch_result();
            if (e instanceof RSQLException) {
                        result.sqlException = (RSQLException) e;
                        result.setSqlExceptionIsSet(true);
                        msg = result;
            }
             else 
            {
              msgType = org.apache.thrift.protocol.TMessageType.EXCEPTION;
              msg = (org.apache.thrift.TBase)new org.apache.thrift.TApplicationException(org.apache.thrift.TApplicationException.INTERNAL_ERROR, e.getMessage());
            }
            try {
              fcall.sendResponse(fb,msg,msgType,seqid);
              return;
            } catch (Exception ex) {
              LOGGER.error("Exception writing to internal frame buffer", ex);
            }
            fb.close();
          }
        };
      }

      protected boolean isOneway() {
        return false;
      }

      public void start(I iface, statement_clearBatch_args args, org.apache.thrift.async.AsyncMethodCallback<Void> resultHandler) throws TException {
        iface.statement_clearBatch(args.statement,resultHandler);
      }
    }

    public static class statement_executeBatch<I extends AsyncIface> extends org.apache.thrift.AsyncProcessFunction<I, statement_executeBatch_args, List<Integer>> {
      public statement_executeBatch() {
        super("statement_executeBatch");
      }

      public statement_executeBatch_args getEmptyArgsInstance() {
        return new statement_executeBatch_args();
      }

      public AsyncMethodCallback<List<Integer>> getResultHandler(final AsyncFrameBuffer fb, final int seqid) {
        final org.apache.thrift.AsyncProcessFunction fcall = this;
        return new AsyncMethodCallback<List<Integer>>() { 
          public void onComplete(List<Integer> o) {
            statement_executeBatch_result result = new statement_executeBatch_result();
            result.success = o;
            try {
              fcall.sendResponse(fb,result, org.apache.thrift.protocol.TMessageType.REPLY,seqid);
              return;
            } catch (Exception e) {
              LOGGER.error("Exception writing to internal frame buffer", e);
            }
            fb.close();
          }
          public void onError(Exception e) {
            byte msgType = org.apache.thrift.protocol.TMessageType.REPLY;
            org.apache.thrift.TBase msg;
            statement_executeBatch_result result = new statement_executeBatch_result();
            if (e instanceof RSQLException) {
                        result.sqlException = (RSQLException) e;
                        result.setSqlExceptionIsSet(true);
                        msg = result;
            }
             else 
            {
              msgType = org.apache.thrift.protocol.TMessageType.EXCEPTION;
              msg = (org.apache.thrift.TBase)new org.apache.thrift.TApplicationException(org.apache.thrift.TApplicationException.INTERNAL_ERROR, e.getMessage());
            }
            try {
              fcall.sendResponse(fb,msg,msgType,seqid);
              return;
            } catch (Exception ex) {
              LOGGER.error("Exception writing to internal frame buffer", ex);
            }
            fb.close();
          }
        };
      }

      protected boolean isOneway() {
        return false;
      }

      public void start(I iface, statement_executeBatch_args args, org.apache.thrift.async.AsyncMethodCallback<List<Integer>> resultHandler) throws TException {
        iface.statement_executeBatch(args.statement,resultHandler);
      }
    }

    public static class preparedstatement_execute<I extends AsyncIface> extends org.apache.thrift.AsyncProcessFunction<I, preparedstatement_execute_args, Boolean> {
      public preparedstatement_execute() {
        super("preparedstatement_execute");
      }

      public preparedstatement_execute_args getEmptyArgsInstance() {
        return new preparedstatement_execute_args();
      }

      public AsyncMethodCallback<Boolean> getResultHandler(final AsyncFrameBuffer fb, final int seqid) {
        final org.apache.thrift.AsyncProcessFunction fcall = this;
        return new AsyncMethodCallback<Boolean>() { 
          public void onComplete(Boolean o) {
            preparedstatement_execute_result result = new preparedstatement_execute_result();
            result.success = o;
            result.setSuccessIsSet(true);
            try {
              fcall.sendResponse(fb,result, org.apache.thrift.protocol.TMessageType.REPLY,seqid);
              return;
            } catch (Exception e) {
              LOGGER.error("Exception writing to internal frame buffer", e);
            }
            fb.close();
          }
          public void onError(Exception e) {
            byte msgType = org.apache.thrift.protocol.TMessageType.REPLY;
            org.apache.thrift.TBase msg;
            preparedstatement_execute_result result = new preparedstatement_execute_result();
            if (e instanceof RSQLException) {
                        result.sqlException = (RSQLException) e;
                        result.setSqlExceptionIsSet(true);
                        msg = result;
            }
             else 
            {
              msgType = org.apache.thrift.protocol.TMessageType.EXCEPTION;
              msg = (org.apache.thrift.TBase)new org.apache.thrift.TApplicationException(org.apache.thrift.TApplicationException.INTERNAL_ERROR, e.getMessage());
            }
            try {
              fcall.sendResponse(fb,msg,msgType,seqid);
              return;
            } catch (Exception ex) {
              LOGGER.error("Exception writing to internal frame buffer", ex);
            }
            fb.close();
          }
        };
      }

      protected boolean isOneway() {
        return false;
      }

      public void start(I iface, preparedstatement_execute_args args, org.apache.thrift.async.AsyncMethodCallback<Boolean> resultHandler) throws TException {
        iface.preparedstatement_execute(args.preparedstatement,resultHandler);
      }
    }

    public static class preparedstatement_executeQuery<I extends AsyncIface> extends org.apache.thrift.AsyncProcessFunction<I, preparedstatement_executeQuery_args, RResultSet> {
      public preparedstatement_executeQuery() {
        super("preparedstatement_executeQuery");
      }

      public preparedstatement_executeQuery_args getEmptyArgsInstance() {
        return new preparedstatement_executeQuery_args();
      }

      public AsyncMethodCallback<RResultSet> getResultHandler(final AsyncFrameBuffer fb, final int seqid) {
        final org.apache.thrift.AsyncProcessFunction fcall = this;
        return new AsyncMethodCallback<RResultSet>() { 
          public void onComplete(RResultSet o) {
            preparedstatement_executeQuery_result result = new preparedstatement_executeQuery_result();
            result.success = o;
            try {
              fcall.sendResponse(fb,result, org.apache.thrift.protocol.TMessageType.REPLY,seqid);
              return;
            } catch (Exception e) {
              LOGGER.error("Exception writing to internal frame buffer", e);
            }
            fb.close();
          }
          public void onError(Exception e) {
            byte msgType = org.apache.thrift.protocol.TMessageType.REPLY;
            org.apache.thrift.TBase msg;
            preparedstatement_executeQuery_result result = new preparedstatement_executeQuery_result();
            if (e instanceof RSQLException) {
                        result.sqlException = (RSQLException) e;
                        result.setSqlExceptionIsSet(true);
                        msg = result;
            }
             else 
            {
              msgType = org.apache.thrift.protocol.TMessageType.EXCEPTION;
              msg = (org.apache.thrift.TBase)new org.apache.thrift.TApplicationException(org.apache.thrift.TApplicationException.INTERNAL_ERROR, e.getMessage());
            }
            try {
              fcall.sendResponse(fb,msg,msgType,seqid);
              return;
            } catch (Exception ex) {
              LOGGER.error("Exception writing to internal frame buffer", ex);
            }
            fb.close();
          }
        };
      }

      protected boolean isOneway() {
        return false;
      }

      public void start(I iface, preparedstatement_executeQuery_args args, org.apache.thrift.async.AsyncMethodCallback<RResultSet> resultHandler) throws TException {
        iface.preparedstatement_executeQuery(args.preparedstatement,resultHandler);
      }
    }

    public static class preparedstatement_executeUpdate<I extends AsyncIface> extends org.apache.thrift.AsyncProcessFunction<I, preparedstatement_executeUpdate_args, Integer> {
      public preparedstatement_executeUpdate() {
        super("preparedstatement_executeUpdate");
      }

      public preparedstatement_executeUpdate_args getEmptyArgsInstance() {
        return new preparedstatement_executeUpdate_args();
      }

      public AsyncMethodCallback<Integer> getResultHandler(final AsyncFrameBuffer fb, final int seqid) {
        final org.apache.thrift.AsyncProcessFunction fcall = this;
        return new AsyncMethodCallback<Integer>() { 
          public void onComplete(Integer o) {
            preparedstatement_executeUpdate_result result = new preparedstatement_executeUpdate_result();
            result.success = o;
            result.setSuccessIsSet(true);
            try {
              fcall.sendResponse(fb,result, org.apache.thrift.protocol.TMessageType.REPLY,seqid);
              return;
            } catch (Exception e) {
              LOGGER.error("Exception writing to internal frame buffer", e);
            }
            fb.close();
          }
          public void onError(Exception e) {
            byte msgType = org.apache.thrift.protocol.TMessageType.REPLY;
            org.apache.thrift.TBase msg;
            preparedstatement_executeUpdate_result result = new preparedstatement_executeUpdate_result();
            if (e instanceof RSQLException) {
                        result.sqlException = (RSQLException) e;
                        result.setSqlExceptionIsSet(true);
                        msg = result;
            }
             else 
            {
              msgType = org.apache.thrift.protocol.TMessageType.EXCEPTION;
              msg = (org.apache.thrift.TBase)new org.apache.thrift.TApplicationException(org.apache.thrift.TApplicationException.INTERNAL_ERROR, e.getMessage());
            }
            try {
              fcall.sendResponse(fb,msg,msgType,seqid);
              return;
            } catch (Exception ex) {
              LOGGER.error("Exception writing to internal frame buffer", ex);
            }
            fb.close();
          }
        };
      }

      protected boolean isOneway() {
        return false;
      }

      public void start(I iface, preparedstatement_executeUpdate_args args, org.apache.thrift.async.AsyncMethodCallback<Integer> resultHandler) throws TException {
        iface.preparedstatement_executeUpdate(args.preparedstatement,resultHandler);
      }
    }

    public static class preparedstatement_setParametersThenExecute<I extends AsyncIface> extends org.apache.thrift.AsyncProcessFunction<I, preparedstatement_setParametersThenExecute_args, Boolean> {
      public preparedstatement_setParametersThenExecute() {
        super("preparedstatement_setParametersThenExecute");
      }

      public preparedstatement_setParametersThenExecute_args getEmptyArgsInstance() {
        return new preparedstatement_setParametersThenExecute_args();
      }

      public AsyncMethodCallback<Boolean> getResultHandler(final AsyncFrameBuffer fb, final int seqid) {
        final org.apache.thrift.AsyncProcessFunction fcall = this;
        return new AsyncMethodCallback<Boolean>() { 
          public void onComplete(Boolean o) {
            preparedstatement_setParametersThenExecute_result result = new preparedstatement_setParametersThenExecute_result();
            result.success = o;
            result.setSuccessIsSet(true);
            try {
              fcall.sendResponse(fb,result, org.apache.thrift.protocol.TMessageType.REPLY,seqid);
              return;
            } catch (Exception e) {
              LOGGER.error("Exception writing to internal frame buffer", e);
            }
            fb.close();
          }
          public void onError(Exception e) {
            byte msgType = org.apache.thrift.protocol.TMessageType.REPLY;
            org.apache.thrift.TBase msg;
            preparedstatement_setParametersThenExecute_result result = new preparedstatement_setParametersThenExecute_result();
            if (e instanceof RSQLException) {
                        result.sqlException = (RSQLException) e;
                        result.setSqlExceptionIsSet(true);
                        msg = result;
            }
             else 
            {
              msgType = org.apache.thrift.protocol.TMessageType.EXCEPTION;
              msg = (org.apache.thrift.TBase)new org.apache.thrift.TApplicationException(org.apache.thrift.TApplicationException.INTERNAL_ERROR, e.getMessage());
            }
            try {
              fcall.sendResponse(fb,msg,msgType,seqid);
              return;
            } catch (Exception ex) {
              LOGGER.error("Exception writing to internal frame buffer", ex);
            }
            fb.close();
          }
        };
      }

      protected boolean isOneway() {
        return false;
      }

      public void start(I iface, preparedstatement_setParametersThenExecute_args args, org.apache.thrift.async.AsyncMethodCallback<Boolean> resultHandler) throws TException {
        iface.preparedstatement_setParametersThenExecute(args.preparedstatement, args.parameters,resultHandler);
      }
    }

    public static class preparedstatement_setParametersThenExecuteQuery<I extends AsyncIface> extends org.apache.thrift.AsyncProcessFunction<I, preparedstatement_setParametersThenExecuteQuery_args, RResultSet> {
      public preparedstatement_setParametersThenExecuteQuery() {
        super("preparedstatement_setParametersThenExecuteQuery");
      }

      public preparedstatement_setParametersThenExecuteQuery_args getEmptyArgsInstance() {
        return new preparedstatement_setParametersThenExecuteQuery_args();
      }

      public AsyncMethodCallback<RResultSet> getResultHandler(final AsyncFrameBuffer fb, final int seqid) {
        final org.apache.thrift.AsyncProcessFunction fcall = this;
        return new AsyncMethodCallback<RResultSet>() { 
          public void onComplete(RResultSet o) {
            preparedstatement_setParametersThenExecuteQuery_result result = new preparedstatement_setParametersThenExecuteQuery_result();
            result.success = o;
            try {
              fcall.sendResponse(fb,result, org.apache.thrift.protocol.TMessageType.REPLY,seqid);
              return;
            } catch (Exception e) {
              LOGGER.error("Exception writing to internal frame buffer", e);
            }
            fb.close();
          }
          public void onError(Exception e) {
            byte msgType = org.apache.thrift.protocol.TMessageType.REPLY;
            org.apache.thrift.TBase msg;
            preparedstatement_setParametersThenExecuteQuery_result result = new preparedstatement_setParametersThenExecuteQuery_result();
            if (e instanceof RSQLException) {
                        result.sqlException = (RSQLException) e;
                        result.setSqlExceptionIsSet(true);
                        msg = result;
            }
             else 
            {
              msgType = org.apache.thrift.protocol.TMessageType.EXCEPTION;
              msg = (org.apache.thrift.TBase)new org.apache.thrift.TApplicationException(org.apache.thrift.TApplicationException.INTERNAL_ERROR, e.getMessage());
            }
            try {
              fcall.sendResponse(fb,msg,msgType,seqid);
              return;
            } catch (Exception ex) {
              LOGGER.error("Exception writing to internal frame buffer", ex);
            }
            fb.close();
          }
        };
      }

      protected boolean isOneway() {
        return false;
      }

      public void start(I iface, preparedstatement_setParametersThenExecuteQuery_args args, org.apache.thrift.async.AsyncMethodCallback<RResultSet> resultHandler) throws TException {
        iface.preparedstatement_setParametersThenExecuteQuery(args.preparedstatement, args.parameters,resultHandler);
      }
    }

    public static class preparedstatement_setParametersThenExecuteUpdate<I extends AsyncIface> extends org.apache.thrift.AsyncProcessFunction<I, preparedstatement_setParametersThenExecuteUpdate_args, Integer> {
      public preparedstatement_setParametersThenExecuteUpdate() {
        super("preparedstatement_setParametersThenExecuteUpdate");
      }

      public preparedstatement_setParametersThenExecuteUpdate_args getEmptyArgsInstance() {
        return new preparedstatement_setParametersThenExecuteUpdate_args();
      }

      public AsyncMethodCallback<Integer> getResultHandler(final AsyncFrameBuffer fb, final int seqid) {
        final org.apache.thrift.AsyncProcessFunction fcall = this;
        return new AsyncMethodCallback<Integer>() { 
          public void onComplete(Integer o) {
            preparedstatement_setParametersThenExecuteUpdate_result result = new preparedstatement_setParametersThenExecuteUpdate_result();
            result.success = o;
            result.setSuccessIsSet(true);
            try {
              fcall.sendResponse(fb,result, org.apache.thrift.protocol.TMessageType.REPLY,seqid);
              return;
            } catch (Exception e) {
              LOGGER.error("Exception writing to internal frame buffer", e);
            }
            fb.close();
          }
          public void onError(Exception e) {
            byte msgType = org.apache.thrift.protocol.TMessageType.REPLY;
            org.apache.thrift.TBase msg;
            preparedstatement_setParametersThenExecuteUpdate_result result = new preparedstatement_setParametersThenExecuteUpdate_result();
            if (e instanceof RSQLException) {
                        result.sqlException = (RSQLException) e;
                        result.setSqlExceptionIsSet(true);
                        msg = result;
            }
             else 
            {
              msgType = org.apache.thrift.protocol.TMessageType.EXCEPTION;
              msg = (org.apache.thrift.TBase)new org.apache.thrift.TApplicationException(org.apache.thrift.TApplicationException.INTERNAL_ERROR, e.getMessage());
            }
            try {
              fcall.sendResponse(fb,msg,msgType,seqid);
              return;
            } catch (Exception ex) {
              LOGGER.error("Exception writing to internal frame buffer", ex);
            }
            fb.close();
          }
        };
      }

      protected boolean isOneway() {
        return false;
      }

      public void start(I iface, preparedstatement_setParametersThenExecuteUpdate_args args, org.apache.thrift.async.AsyncMethodCallback<Integer> resultHandler) throws TException {
        iface.preparedstatement_setParametersThenExecuteUpdate(args.preparedstatement, args.parameters,resultHandler);
      }
    }

    public static class preparedstatement_setParameters<I extends AsyncIface> extends org.apache.thrift.AsyncProcessFunction<I, preparedstatement_setParameters_args, Void> {
      public preparedstatement_setParameters() {
        super("preparedstatement_setParameters");
      }

      public preparedstatement_setParameters_args getEmptyArgsInstance() {
        return new preparedstatement_setParameters_args();
      }

      public AsyncMethodCallback<Void> getResultHandler(final AsyncFrameBuffer fb, final int seqid) {
        final org.apache.thrift.AsyncProcessFunction fcall = this;
        return new AsyncMethodCallback<Void>() { 
          public void onComplete(Void o) {
            preparedstatement_setParameters_result result = new preparedstatement_setParameters_result();
            try {
              fcall.sendResponse(fb,result, org.apache.thrift.protocol.TMessageType.REPLY,seqid);
              return;
            } catch (Exception e) {
              LOGGER.error("Exception writing to internal frame buffer", e);
            }
            fb.close();
          }
          public void onError(Exception e) {
            byte msgType = org.apache.thrift.protocol.TMessageType.REPLY;
            org.apache.thrift.TBase msg;
            preparedstatement_setParameters_result result = new preparedstatement_setParameters_result();
            if (e instanceof RSQLException) {
                        result.sqlException = (RSQLException) e;
                        result.setSqlExceptionIsSet(true);
                        msg = result;
            }
             else 
            {
              msgType = org.apache.thrift.protocol.TMessageType.EXCEPTION;
              msg = (org.apache.thrift.TBase)new org.apache.thrift.TApplicationException(org.apache.thrift.TApplicationException.INTERNAL_ERROR, e.getMessage());
            }
            try {
              fcall.sendResponse(fb,msg,msgType,seqid);
              return;
            } catch (Exception ex) {
              LOGGER.error("Exception writing to internal frame buffer", ex);
            }
            fb.close();
          }
        };
      }

      protected boolean isOneway() {
        return false;
      }

      public void start(I iface, preparedstatement_setParameters_args args, org.apache.thrift.async.AsyncMethodCallback<Void> resultHandler) throws TException {
        iface.preparedstatement_setParameters(args.preparedStatement, args.parameters,resultHandler);
      }
    }

    public static class preparedstatement_setParameter<I extends AsyncIface> extends org.apache.thrift.AsyncProcessFunction<I, preparedstatement_setParameter_args, Void> {
      public preparedstatement_setParameter() {
        super("preparedstatement_setParameter");
      }

      public preparedstatement_setParameter_args getEmptyArgsInstance() {
        return new preparedstatement_setParameter_args();
      }

      public AsyncMethodCallback<Void> getResultHandler(final AsyncFrameBuffer fb, final int seqid) {
        final org.apache.thrift.AsyncProcessFunction fcall = this;
        return new AsyncMethodCallback<Void>() { 
          public void onComplete(Void o) {
            preparedstatement_setParameter_result result = new preparedstatement_setParameter_result();
            try {
              fcall.sendResponse(fb,result, org.apache.thrift.protocol.TMessageType.REPLY,seqid);
              return;
            } catch (Exception e) {
              LOGGER.error("Exception writing to internal frame buffer", e);
            }
            fb.close();
          }
          public void onError(Exception e) {
            byte msgType = org.apache.thrift.protocol.TMessageType.REPLY;
            org.apache.thrift.TBase msg;
            preparedstatement_setParameter_result result = new preparedstatement_setParameter_result();
            if (e instanceof RSQLException) {
                        result.sqlException = (RSQLException) e;
                        result.setSqlExceptionIsSet(true);
                        msg = result;
            }
             else 
            {
              msgType = org.apache.thrift.protocol.TMessageType.EXCEPTION;
              msg = (org.apache.thrift.TBase)new org.apache.thrift.TApplicationException(org.apache.thrift.TApplicationException.INTERNAL_ERROR, e.getMessage());
            }
            try {
              fcall.sendResponse(fb,msg,msgType,seqid);
              return;
            } catch (Exception ex) {
              LOGGER.error("Exception writing to internal frame buffer", ex);
            }
            fb.close();
          }
        };
      }

      protected boolean isOneway() {
        return false;
      }

      public void start(I iface, preparedstatement_setParameter_args args, org.apache.thrift.async.AsyncMethodCallback<Void> resultHandler) throws TException {
        iface.preparedstatement_setParameter(args.preparedStatement, args.parameter, args.position,resultHandler);
      }
    }

    public static class preparedstatement_clearParameters<I extends AsyncIface> extends org.apache.thrift.AsyncProcessFunction<I, preparedstatement_clearParameters_args, Void> {
      public preparedstatement_clearParameters() {
        super("preparedstatement_clearParameters");
      }

      public preparedstatement_clearParameters_args getEmptyArgsInstance() {
        return new preparedstatement_clearParameters_args();
      }

      public AsyncMethodCallback<Void> getResultHandler(final AsyncFrameBuffer fb, final int seqid) {
        final org.apache.thrift.AsyncProcessFunction fcall = this;
        return new AsyncMethodCallback<Void>() { 
          public void onComplete(Void o) {
            preparedstatement_clearParameters_result result = new preparedstatement_clearParameters_result();
            try {
              fcall.sendResponse(fb,result, org.apache.thrift.protocol.TMessageType.REPLY,seqid);
              return;
            } catch (Exception e) {
              LOGGER.error("Exception writing to internal frame buffer", e);
            }
            fb.close();
          }
          public void onError(Exception e) {
            byte msgType = org.apache.thrift.protocol.TMessageType.REPLY;
            org.apache.thrift.TBase msg;
            preparedstatement_clearParameters_result result = new preparedstatement_clearParameters_result();
            if (e instanceof RSQLException) {
                        result.sqlException = (RSQLException) e;
                        result.setSqlExceptionIsSet(true);
                        msg = result;
            }
             else 
            {
              msgType = org.apache.thrift.protocol.TMessageType.EXCEPTION;
              msg = (org.apache.thrift.TBase)new org.apache.thrift.TApplicationException(org.apache.thrift.TApplicationException.INTERNAL_ERROR, e.getMessage());
            }
            try {
              fcall.sendResponse(fb,msg,msgType,seqid);
              return;
            } catch (Exception ex) {
              LOGGER.error("Exception writing to internal frame buffer", ex);
            }
            fb.close();
          }
        };
      }

      protected boolean isOneway() {
        return false;
      }

      public void start(I iface, preparedstatement_clearParameters_args args, org.apache.thrift.async.AsyncMethodCallback<Void> resultHandler) throws TException {
        iface.preparedstatement_clearParameters(args.preparedStatement,resultHandler);
      }
    }

    public static class preparedstatement_addBatchWithParameters<I extends AsyncIface> extends org.apache.thrift.AsyncProcessFunction<I, preparedstatement_addBatchWithParameters_args, Void> {
      public preparedstatement_addBatchWithParameters() {
        super("preparedstatement_addBatchWithParameters");
      }

      public preparedstatement_addBatchWithParameters_args getEmptyArgsInstance() {
        return new preparedstatement_addBatchWithParameters_args();
      }

      public AsyncMethodCallback<Void> getResultHandler(final AsyncFrameBuffer fb, final int seqid) {
        final org.apache.thrift.AsyncProcessFunction fcall = this;
        return new AsyncMethodCallback<Void>() { 
          public void onComplete(Void o) {
            preparedstatement_addBatchWithParameters_result result = new preparedstatement_addBatchWithParameters_result();
            try {
              fcall.sendResponse(fb,result, org.apache.thrift.protocol.TMessageType.REPLY,seqid);
              return;
            } catch (Exception e) {
              LOGGER.error("Exception writing to internal frame buffer", e);
            }
            fb.close();
          }
          public void onError(Exception e) {
            byte msgType = org.apache.thrift.protocol.TMessageType.REPLY;
            org.apache.thrift.TBase msg;
            preparedstatement_addBatchWithParameters_result result = new preparedstatement_addBatchWithParameters_result();
            if (e instanceof RSQLException) {
                        result.sqlException = (RSQLException) e;
                        result.setSqlExceptionIsSet(true);
                        msg = result;
            }
             else 
            {
              msgType = org.apache.thrift.protocol.TMessageType.EXCEPTION;
              msg = (org.apache.thrift.TBase)new org.apache.thrift.TApplicationException(org.apache.thrift.TApplicationException.INTERNAL_ERROR, e.getMessage());
            }
            try {
              fcall.sendResponse(fb,msg,msgType,seqid);
              return;
            } catch (Exception ex) {
              LOGGER.error("Exception writing to internal frame buffer", ex);
            }
            fb.close();
          }
        };
      }

      protected boolean isOneway() {
        return false;
      }

      public void start(I iface, preparedstatement_addBatchWithParameters_args args, org.apache.thrift.async.AsyncMethodCallback<Void> resultHandler) throws TException {
        iface.preparedstatement_addBatchWithParameters(args.preparedStatement, args.parameters,resultHandler);
      }
    }

    public static class preparedstatement_addBatch<I extends AsyncIface> extends org.apache.thrift.AsyncProcessFunction<I, preparedstatement_addBatch_args, Void> {
      public preparedstatement_addBatch() {
        super("preparedstatement_addBatch");
      }

      public preparedstatement_addBatch_args getEmptyArgsInstance() {
        return new preparedstatement_addBatch_args();
      }

      public AsyncMethodCallback<Void> getResultHandler(final AsyncFrameBuffer fb, final int seqid) {
        final org.apache.thrift.AsyncProcessFunction fcall = this;
        return new AsyncMethodCallback<Void>() { 
          public void onComplete(Void o) {
            preparedstatement_addBatch_result result = new preparedstatement_addBatch_result();
            try {
              fcall.sendResponse(fb,result, org.apache.thrift.protocol.TMessageType.REPLY,seqid);
              return;
            } catch (Exception e) {
              LOGGER.error("Exception writing to internal frame buffer", e);
            }
            fb.close();
          }
          public void onError(Exception e) {
            byte msgType = org.apache.thrift.protocol.TMessageType.REPLY;
            org.apache.thrift.TBase msg;
            preparedstatement_addBatch_result result = new preparedstatement_addBatch_result();
            if (e instanceof RSQLException) {
                        result.sqlException = (RSQLException) e;
                        result.setSqlExceptionIsSet(true);
                        msg = result;
            }
             else 
            {
              msgType = org.apache.thrift.protocol.TMessageType.EXCEPTION;
              msg = (org.apache.thrift.TBase)new org.apache.thrift.TApplicationException(org.apache.thrift.TApplicationException.INTERNAL_ERROR, e.getMessage());
            }
            try {
              fcall.sendResponse(fb,msg,msgType,seqid);
              return;
            } catch (Exception ex) {
              LOGGER.error("Exception writing to internal frame buffer", ex);
            }
            fb.close();
          }
        };
      }

      protected boolean isOneway() {
        return false;
      }

      public void start(I iface, preparedstatement_addBatch_args args, org.apache.thrift.async.AsyncMethodCallback<Void> resultHandler) throws TException {
        iface.preparedstatement_addBatch(args.preparedStatement,resultHandler);
      }
    }

    public static class preparedstatement_executeBatch<I extends AsyncIface> extends org.apache.thrift.AsyncProcessFunction<I, preparedstatement_executeBatch_args, List<Integer>> {
      public preparedstatement_executeBatch() {
        super("preparedstatement_executeBatch");
      }

      public preparedstatement_executeBatch_args getEmptyArgsInstance() {
        return new preparedstatement_executeBatch_args();
      }

      public AsyncMethodCallback<List<Integer>> getResultHandler(final AsyncFrameBuffer fb, final int seqid) {
        final org.apache.thrift.AsyncProcessFunction fcall = this;
        return new AsyncMethodCallback<List<Integer>>() { 
          public void onComplete(List<Integer> o) {
            preparedstatement_executeBatch_result result = new preparedstatement_executeBatch_result();
            result.success = o;
            try {
              fcall.sendResponse(fb,result, org.apache.thrift.protocol.TMessageType.REPLY,seqid);
              return;
            } catch (Exception e) {
              LOGGER.error("Exception writing to internal frame buffer", e);
            }
            fb.close();
          }
          public void onError(Exception e) {
            byte msgType = org.apache.thrift.protocol.TMessageType.REPLY;
            org.apache.thrift.TBase msg;
            preparedstatement_executeBatch_result result = new preparedstatement_executeBatch_result();
            if (e instanceof RSQLException) {
                        result.sqlException = (RSQLException) e;
                        result.setSqlExceptionIsSet(true);
                        msg = result;
            }
             else 
            {
              msgType = org.apache.thrift.protocol.TMessageType.EXCEPTION;
              msg = (org.apache.thrift.TBase)new org.apache.thrift.TApplicationException(org.apache.thrift.TApplicationException.INTERNAL_ERROR, e.getMessage());
            }
            try {
              fcall.sendResponse(fb,msg,msgType,seqid);
              return;
            } catch (Exception ex) {
              LOGGER.error("Exception writing to internal frame buffer", ex);
            }
            fb.close();
          }
        };
      }

      protected boolean isOneway() {
        return false;
      }

      public void start(I iface, preparedstatement_executeBatch_args args, org.apache.thrift.async.AsyncMethodCallback<List<Integer>> resultHandler) throws TException {
        iface.preparedstatement_executeBatch(args.statement, args.parameters,resultHandler);
      }
    }

    public static class statement_getWarnings<I extends AsyncIface> extends org.apache.thrift.AsyncProcessFunction<I, statement_getWarnings_args, statement_getWarnings_return> {
      public statement_getWarnings() {
        super("statement_getWarnings");
      }

      public statement_getWarnings_args getEmptyArgsInstance() {
        return new statement_getWarnings_args();
      }

      public AsyncMethodCallback<statement_getWarnings_return> getResultHandler(final AsyncFrameBuffer fb, final int seqid) {
        final org.apache.thrift.AsyncProcessFunction fcall = this;
        return new AsyncMethodCallback<statement_getWarnings_return>() { 
          public void onComplete(statement_getWarnings_return o) {
            statement_getWarnings_result result = new statement_getWarnings_result();
            result.success = o;
            try {
              fcall.sendResponse(fb,result, org.apache.thrift.protocol.TMessageType.REPLY,seqid);
              return;
            } catch (Exception e) {
              LOGGER.error("Exception writing to internal frame buffer", e);
            }
            fb.close();
          }
          public void onError(Exception e) {
            byte msgType = org.apache.thrift.protocol.TMessageType.REPLY;
            org.apache.thrift.TBase msg;
            statement_getWarnings_result result = new statement_getWarnings_result();
            if (e instanceof RSQLException) {
                        result.sqlException = (RSQLException) e;
                        result.setSqlExceptionIsSet(true);
                        msg = result;
            }
             else 
            {
              msgType = org.apache.thrift.protocol.TMessageType.EXCEPTION;
              msg = (org.apache.thrift.TBase)new org.apache.thrift.TApplicationException(org.apache.thrift.TApplicationException.INTERNAL_ERROR, e.getMessage());
            }
            try {
              fcall.sendResponse(fb,msg,msgType,seqid);
              return;
            } catch (Exception ex) {
              LOGGER.error("Exception writing to internal frame buffer", ex);
            }
            fb.close();
          }
        };
      }

      protected boolean isOneway() {
        return false;
      }

      public void start(I iface, statement_getWarnings_args args, org.apache.thrift.async.AsyncMethodCallback<statement_getWarnings_return> resultHandler) throws TException {
        iface.statement_getWarnings(args.statement,resultHandler);
      }
    }

    public static class statement_clearWarnings<I extends AsyncIface> extends org.apache.thrift.AsyncProcessFunction<I, statement_clearWarnings_args, Void> {
      public statement_clearWarnings() {
        super("statement_clearWarnings");
      }

      public statement_clearWarnings_args getEmptyArgsInstance() {
        return new statement_clearWarnings_args();
      }

      public AsyncMethodCallback<Void> getResultHandler(final AsyncFrameBuffer fb, final int seqid) {
        final org.apache.thrift.AsyncProcessFunction fcall = this;
        return new AsyncMethodCallback<Void>() { 
          public void onComplete(Void o) {
            statement_clearWarnings_result result = new statement_clearWarnings_result();
            try {
              fcall.sendResponse(fb,result, org.apache.thrift.protocol.TMessageType.REPLY,seqid);
              return;
            } catch (Exception e) {
              LOGGER.error("Exception writing to internal frame buffer", e);
            }
            fb.close();
          }
          public void onError(Exception e) {
            byte msgType = org.apache.thrift.protocol.TMessageType.REPLY;
            org.apache.thrift.TBase msg;
            statement_clearWarnings_result result = new statement_clearWarnings_result();
            if (e instanceof RSQLException) {
                        result.sqlException = (RSQLException) e;
                        result.setSqlExceptionIsSet(true);
                        msg = result;
            }
             else 
            {
              msgType = org.apache.thrift.protocol.TMessageType.EXCEPTION;
              msg = (org.apache.thrift.TBase)new org.apache.thrift.TApplicationException(org.apache.thrift.TApplicationException.INTERNAL_ERROR, e.getMessage());
            }
            try {
              fcall.sendResponse(fb,msg,msgType,seqid);
              return;
            } catch (Exception ex) {
              LOGGER.error("Exception writing to internal frame buffer", ex);
            }
            fb.close();
          }
        };
      }

      protected boolean isOneway() {
        return false;
      }

      public void start(I iface, statement_clearWarnings_args args, org.apache.thrift.async.AsyncMethodCallback<Void> resultHandler) throws TException {
        iface.statement_clearWarnings(args.statement,resultHandler);
      }
    }

    public static class statement_getMaxRows<I extends AsyncIface> extends org.apache.thrift.AsyncProcessFunction<I, statement_getMaxRows_args, Integer> {
      public statement_getMaxRows() {
        super("statement_getMaxRows");
      }

      public statement_getMaxRows_args getEmptyArgsInstance() {
        return new statement_getMaxRows_args();
      }

      public AsyncMethodCallback<Integer> getResultHandler(final AsyncFrameBuffer fb, final int seqid) {
        final org.apache.thrift.AsyncProcessFunction fcall = this;
        return new AsyncMethodCallback<Integer>() { 
          public void onComplete(Integer o) {
            statement_getMaxRows_result result = new statement_getMaxRows_result();
            result.success = o;
            result.setSuccessIsSet(true);
            try {
              fcall.sendResponse(fb,result, org.apache.thrift.protocol.TMessageType.REPLY,seqid);
              return;
            } catch (Exception e) {
              LOGGER.error("Exception writing to internal frame buffer", e);
            }
            fb.close();
          }
          public void onError(Exception e) {
            byte msgType = org.apache.thrift.protocol.TMessageType.REPLY;
            org.apache.thrift.TBase msg;
            statement_getMaxRows_result result = new statement_getMaxRows_result();
            if (e instanceof RSQLException) {
                        result.sqlException = (RSQLException) e;
                        result.setSqlExceptionIsSet(true);
                        msg = result;
            }
             else 
            {
              msgType = org.apache.thrift.protocol.TMessageType.EXCEPTION;
              msg = (org.apache.thrift.TBase)new org.apache.thrift.TApplicationException(org.apache.thrift.TApplicationException.INTERNAL_ERROR, e.getMessage());
            }
            try {
              fcall.sendResponse(fb,msg,msgType,seqid);
              return;
            } catch (Exception ex) {
              LOGGER.error("Exception writing to internal frame buffer", ex);
            }
            fb.close();
          }
        };
      }

      protected boolean isOneway() {
        return false;
      }

      public void start(I iface, statement_getMaxRows_args args, org.apache.thrift.async.AsyncMethodCallback<Integer> resultHandler) throws TException {
        iface.statement_getMaxRows(args.statement,resultHandler);
      }
    }

    public static class statement_setMaxRows<I extends AsyncIface> extends org.apache.thrift.AsyncProcessFunction<I, statement_setMaxRows_args, Void> {
      public statement_setMaxRows() {
        super("statement_setMaxRows");
      }

      public statement_setMaxRows_args getEmptyArgsInstance() {
        return new statement_setMaxRows_args();
      }

      public AsyncMethodCallback<Void> getResultHandler(final AsyncFrameBuffer fb, final int seqid) {
        final org.apache.thrift.AsyncProcessFunction fcall = this;
        return new AsyncMethodCallback<Void>() { 
          public void onComplete(Void o) {
            statement_setMaxRows_result result = new statement_setMaxRows_result();
            try {
              fcall.sendResponse(fb,result, org.apache.thrift.protocol.TMessageType.REPLY,seqid);
              return;
            } catch (Exception e) {
              LOGGER.error("Exception writing to internal frame buffer", e);
            }
            fb.close();
          }
          public void onError(Exception e) {
            byte msgType = org.apache.thrift.protocol.TMessageType.REPLY;
            org.apache.thrift.TBase msg;
            statement_setMaxRows_result result = new statement_setMaxRows_result();
            if (e instanceof RSQLException) {
                        result.sqlException = (RSQLException) e;
                        result.setSqlExceptionIsSet(true);
                        msg = result;
            }
             else 
            {
              msgType = org.apache.thrift.protocol.TMessageType.EXCEPTION;
              msg = (org.apache.thrift.TBase)new org.apache.thrift.TApplicationException(org.apache.thrift.TApplicationException.INTERNAL_ERROR, e.getMessage());
            }
            try {
              fcall.sendResponse(fb,msg,msgType,seqid);
              return;
            } catch (Exception ex) {
              LOGGER.error("Exception writing to internal frame buffer", ex);
            }
            fb.close();
          }
        };
      }

      protected boolean isOneway() {
        return false;
      }

      public void start(I iface, statement_setMaxRows_args args, org.apache.thrift.async.AsyncMethodCallback<Void> resultHandler) throws TException {
        iface.statement_setMaxRows(args.statement, args.max,resultHandler);
      }
    }

    public static class statement_getQueryTimeout<I extends AsyncIface> extends org.apache.thrift.AsyncProcessFunction<I, statement_getQueryTimeout_args, Integer> {
      public statement_getQueryTimeout() {
        super("statement_getQueryTimeout");
      }

      public statement_getQueryTimeout_args getEmptyArgsInstance() {
        return new statement_getQueryTimeout_args();
      }

      public AsyncMethodCallback<Integer> getResultHandler(final AsyncFrameBuffer fb, final int seqid) {
        final org.apache.thrift.AsyncProcessFunction fcall = this;
        return new AsyncMethodCallback<Integer>() { 
          public void onComplete(Integer o) {
            statement_getQueryTimeout_result result = new statement_getQueryTimeout_result();
            result.success = o;
            result.setSuccessIsSet(true);
            try {
              fcall.sendResponse(fb,result, org.apache.thrift.protocol.TMessageType.REPLY,seqid);
              return;
            } catch (Exception e) {
              LOGGER.error("Exception writing to internal frame buffer", e);
            }
            fb.close();
          }
          public void onError(Exception e) {
            byte msgType = org.apache.thrift.protocol.TMessageType.REPLY;
            org.apache.thrift.TBase msg;
            statement_getQueryTimeout_result result = new statement_getQueryTimeout_result();
            if (e instanceof RSQLException) {
                        result.sqlException = (RSQLException) e;
                        result.setSqlExceptionIsSet(true);
                        msg = result;
            }
             else 
            {
              msgType = org.apache.thrift.protocol.TMessageType.EXCEPTION;
              msg = (org.apache.thrift.TBase)new org.apache.thrift.TApplicationException(org.apache.thrift.TApplicationException.INTERNAL_ERROR, e.getMessage());
            }
            try {
              fcall.sendResponse(fb,msg,msgType,seqid);
              return;
            } catch (Exception ex) {
              LOGGER.error("Exception writing to internal frame buffer", ex);
            }
            fb.close();
          }
        };
      }

      protected boolean isOneway() {
        return false;
      }

      public void start(I iface, statement_getQueryTimeout_args args, org.apache.thrift.async.AsyncMethodCallback<Integer> resultHandler) throws TException {
        iface.statement_getQueryTimeout(args.statement,resultHandler);
      }
    }

    public static class statement_setQueryTimeout<I extends AsyncIface> extends org.apache.thrift.AsyncProcessFunction<I, statement_setQueryTimeout_args, Void> {
      public statement_setQueryTimeout() {
        super("statement_setQueryTimeout");
      }

      public statement_setQueryTimeout_args getEmptyArgsInstance() {
        return new statement_setQueryTimeout_args();
      }

      public AsyncMethodCallback<Void> getResultHandler(final AsyncFrameBuffer fb, final int seqid) {
        final org.apache.thrift.AsyncProcessFunction fcall = this;
        return new AsyncMethodCallback<Void>() { 
          public void onComplete(Void o) {
            statement_setQueryTimeout_result result = new statement_setQueryTimeout_result();
            try {
              fcall.sendResponse(fb,result, org.apache.thrift.protocol.TMessageType.REPLY,seqid);
              return;
            } catch (Exception e) {
              LOGGER.error("Exception writing to internal frame buffer", e);
            }
            fb.close();
          }
          public void onError(Exception e) {
            byte msgType = org.apache.thrift.protocol.TMessageType.REPLY;
            org.apache.thrift.TBase msg;
            statement_setQueryTimeout_result result = new statement_setQueryTimeout_result();
            if (e instanceof RSQLException) {
                        result.sqlException = (RSQLException) e;
                        result.setSqlExceptionIsSet(true);
                        msg = result;
            }
             else 
            {
              msgType = org.apache.thrift.protocol.TMessageType.EXCEPTION;
              msg = (org.apache.thrift.TBase)new org.apache.thrift.TApplicationException(org.apache.thrift.TApplicationException.INTERNAL_ERROR, e.getMessage());
            }
            try {
              fcall.sendResponse(fb,msg,msgType,seqid);
              return;
            } catch (Exception ex) {
              LOGGER.error("Exception writing to internal frame buffer", ex);
            }
            fb.close();
          }
        };
      }

      protected boolean isOneway() {
        return false;
      }

      public void start(I iface, statement_setQueryTimeout_args args, org.apache.thrift.async.AsyncMethodCallback<Void> resultHandler) throws TException {
        iface.statement_setQueryTimeout(args.statement, args.seconds,resultHandler);
      }
    }

  }

  public static class createConnection_args implements org.apache.thrift.TBase<createConnection_args, createConnection_args._Fields>, java.io.Serializable, Cloneable, Comparable<createConnection_args>   {
    private static final org.apache.thrift.protocol.TStruct STRUCT_DESC = new org.apache.thrift.protocol.TStruct("createConnection_args");

    private static final org.apache.thrift.protocol.TField URL_FIELD_DESC = new org.apache.thrift.protocol.TField("url", org.apache.thrift.protocol.TType.STRING, (short)1);
    private static final org.apache.thrift.protocol.TField PROPERTIES_FIELD_DESC = new org.apache.thrift.protocol.TField("properties", org.apache.thrift.protocol.TType.MAP, (short)2);

    private static final Map<Class<? extends IScheme>, SchemeFactory> schemes = new HashMap<Class<? extends IScheme>, SchemeFactory>();
    static {
      schemes.put(StandardScheme.class, new createConnection_argsStandardSchemeFactory());
      schemes.put(TupleScheme.class, new createConnection_argsTupleSchemeFactory());
    }

    public String url; // required
    public Map<String,String> properties; // required

    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements org.apache.thrift.TFieldIdEnum {
      URL((short)1, "url"),
      PROPERTIES((short)2, "properties");

      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        switch(fieldId) {
          case 1: // URL
            return URL;
          case 2: // PROPERTIES
            return PROPERTIES;
          default:
            return null;
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }

    // isset id assignments
    public static final Map<_Fields, org.apache.thrift.meta_data.FieldMetaData> metaDataMap;
    static {
      Map<_Fields, org.apache.thrift.meta_data.FieldMetaData> tmpMap = new EnumMap<_Fields, org.apache.thrift.meta_data.FieldMetaData>(_Fields.class);
      tmpMap.put(_Fields.URL, new org.apache.thrift.meta_data.FieldMetaData("url", org.apache.thrift.TFieldRequirementType.DEFAULT, 
          new org.apache.thrift.meta_data.FieldValueMetaData(org.apache.thrift.protocol.TType.STRING)));
      tmpMap.put(_Fields.PROPERTIES, new org.apache.thrift.meta_data.FieldMetaData("properties", org.apache.thrift.TFieldRequirementType.DEFAULT, 
          new org.apache.thrift.meta_data.MapMetaData(org.apache.thrift.protocol.TType.MAP, 
              new org.apache.thrift.meta_data.FieldValueMetaData(org.apache.thrift.protocol.TType.STRING), 
              new org.apache.thrift.meta_data.FieldValueMetaData(org.apache.thrift.protocol.TType.STRING))));
      metaDataMap = Collections.unmodifiableMap(tmpMap);
      org.apache.thrift.meta_data.FieldMetaData.addStructMetaDataMap(createConnection_args.class, metaDataMap);
    }

    public createConnection_args() {
    }

    public createConnection_args(
      String url,
      Map<String,String> properties)
    {
      this();
      this.url = url;
      this.properties = properties;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public createConnection_args(createConnection_args other) {
      if (other.isSetUrl()) {
        this.url = other.url;
      }
      if (other.isSetProperties()) {
        Map<String,String> __this__properties = new HashMap<String,String>(other.properties);
        this.properties = __this__properties;
      }
    }

    public createConnection_args deepCopy() {
      return new createConnection_args(this);
    }

    @Override
    public void clear() {
      this.url = null;
      this.properties = null;
    }

    public String getUrl() {
      return this.url;
    }

    public createConnection_args setUrl(String url) {
      this.url = url;
      return this;
    }

    public void unsetUrl() {
      this.url = null;
    }

    /** Returns true if field url is set (has been assigned a value) and false otherwise */
    public boolean isSetUrl() {
      return this.url != null;
    }

    public void setUrlIsSet(boolean value) {
      if (!value) {
        this.url = null;
      }
    }

    public int getPropertiesSize() {
      return (this.properties == null) ? 0 : this.properties.size();
    }

    public void putToProperties(String key, String val) {
      if (this.properties == null) {
        this.properties = new HashMap<String,String>();
      }
      this.properties.put(key, val);
    }

    public Map<String,String> getProperties() {
      return this.properties;
    }

    public createConnection_args setProperties(Map<String,String> properties) {
      this.properties = properties;
      return this;
    }

    public void unsetProperties() {
      this.properties = null;
    }

    /** Returns true if field properties is set (has been assigned a value) and false otherwise */
    public boolean isSetProperties() {
      return this.properties != null;
    }

    public void setPropertiesIsSet(boolean value) {
      if (!value) {
        this.properties = null;
      }
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      case URL:
        if (value == null) {
          unsetUrl();
        } else {
          setUrl((String)value);
        }
        break;

      case PROPERTIES:
        if (value == null) {
          unsetProperties();
        } else {
          setProperties((Map<String,String>)value);
        }
        break;

      }
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      case URL:
        return getUrl();

      case PROPERTIES:
        return getProperties();

      }
      throw new IllegalStateException();
    }

    /** Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      if (field == null) {
        throw new IllegalArgumentException();
      }

      switch (field) {
      case URL:
        return isSetUrl();
      case PROPERTIES:
        return isSetProperties();
      }
      throw new IllegalStateException();
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof createConnection_args)
        return this.equals((createConnection_args)that);
      return false;
    }

    public boolean equals(createConnection_args that) {
      if (that == null)
        return false;

      boolean this_present_url = true && this.isSetUrl();
      boolean that_present_url = true && that.isSetUrl();
      if (this_present_url || that_present_url) {
        if (!(this_present_url && that_present_url))
          return false;
        if (!this.url.equals(that.url))
          return false;
      }

      boolean this_present_properties = true && this.isSetProperties();
      boolean that_present_properties = true && that.isSetProperties();
      if (this_present_properties || that_present_properties) {
        if (!(this_present_properties && that_present_properties))
          return false;
        if (!this.properties.equals(that.properties))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      List<Object> list = new ArrayList<Object>();

      boolean present_url = true && (isSetUrl());
      list.add(present_url);
      if (present_url)
        list.add(url);

      boolean present_properties = true && (isSetProperties());
      list.add(present_properties);
      if (present_properties)
        list.add(properties);

      return list.hashCode();
    }

    @Override
    public int compareTo(createConnection_args other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetUrl()).compareTo(other.isSetUrl());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetUrl()) {
        lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.url, other.url);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      lastComparison = Boolean.valueOf(isSetProperties()).compareTo(other.isSetProperties());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetProperties()) {
        lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.properties, other.properties);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      return 0;
    }

    public _Fields fieldForId(int fieldId) {
      return _Fields.findByThriftId(fieldId);
    }

    public void read(org.apache.thrift.protocol.TProtocol iprot) throws org.apache.thrift.TException {
      schemes.get(iprot.getScheme()).getScheme().read(iprot, this);
    }

    public void write(org.apache.thrift.protocol.TProtocol oprot) throws org.apache.thrift.TException {
      schemes.get(oprot.getScheme()).getScheme().write(oprot, this);
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("createConnection_args(");
      boolean first = true;

      sb.append("url:");
      if (this.url == null) {
        sb.append("null");
      } else {
        sb.append(this.url);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("properties:");
      if (this.properties == null) {
        sb.append("null");
      } else {
        sb.append(this.properties);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws org.apache.thrift.TException {
      // check for required fields
      // check for sub-struct validity
    }

    private void writeObject(java.io.ObjectOutputStream out) throws java.io.IOException {
      try {
        write(new org.apache.thrift.protocol.TCompactProtocol(new org.apache.thrift.transport.TIOStreamTransport(out)));
      } catch (org.apache.thrift.TException te) {
        throw new java.io.IOException(te);
      }
    }

    private void readObject(java.io.ObjectInputStream in) throws java.io.IOException, ClassNotFoundException {
      try {
        read(new org.apache.thrift.protocol.TCompactProtocol(new org.apache.thrift.transport.TIOStreamTransport(in)));
      } catch (org.apache.thrift.TException te) {
        throw new java.io.IOException(te);
      }
    }

    private static class createConnection_argsStandardSchemeFactory implements SchemeFactory {
      public createConnection_argsStandardScheme getScheme() {
        return new createConnection_argsStandardScheme();
      }
    }

    private static class createConnection_argsStandardScheme extends StandardScheme<createConnection_args> {

      public void read(org.apache.thrift.protocol.TProtocol iprot, createConnection_args struct) throws org.apache.thrift.TException {
        org.apache.thrift.protocol.TField schemeField;
        iprot.readStructBegin();
        while (true)
        {
          schemeField = iprot.readFieldBegin();
          if (schemeField.type == org.apache.thrift.protocol.TType.STOP) { 
            break;
          }
          switch (schemeField.id) {
            case 1: // URL
              if (schemeField.type == org.apache.thrift.protocol.TType.STRING) {
                struct.url = iprot.readString();
                struct.setUrlIsSet(true);
              } else { 
                org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
              }
              break;
            case 2: // PROPERTIES
              if (schemeField.type == org.apache.thrift.protocol.TType.MAP) {
                {
                  org.apache.thrift.protocol.TMap _map40 = iprot.readMapBegin();
                  struct.properties = new HashMap<String,String>(2*_map40.size);
                  String _key41;
                  String _val42;
                  for (int _i43 = 0; _i43 < _map40.size; ++_i43)
                  {
                    _key41 = iprot.readString();
                    _val42 = iprot.readString();
                    struct.properties.put(_key41, _val42);
                  }
                  iprot.readMapEnd();
                }
                struct.setPropertiesIsSet(true);
              } else { 
                org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
              }
              break;
            default:
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
          }
          iprot.readFieldEnd();
        }
        iprot.readStructEnd();

        // check for required fields of primitive type, which can't be checked in the validate method
        struct.validate();
      }

      public void write(org.apache.thrift.protocol.TProtocol oprot, createConnection_args struct) throws org.apache.thrift.TException {
        struct.validate();

        oprot.writeStructBegin(STRUCT_DESC);
        if (struct.url != null) {
          oprot.writeFieldBegin(URL_FIELD_DESC);
          oprot.writeString(struct.url);
          oprot.writeFieldEnd();
        }
        if (struct.properties != null) {
          oprot.writeFieldBegin(PROPERTIES_FIELD_DESC);
          {
            oprot.writeMapBegin(new org.apache.thrift.protocol.TMap(org.apache.thrift.protocol.TType.STRING, org.apache.thrift.protocol.TType.STRING, struct.properties.size()));
            for (Map.Entry<String, String> _iter44 : struct.properties.entrySet())
            {
              oprot.writeString(_iter44.getKey());
              oprot.writeString(_iter44.getValue());
            }
            oprot.writeMapEnd();
          }
          oprot.writeFieldEnd();
        }
        oprot.writeFieldStop();
        oprot.writeStructEnd();
      }

    }

    private static class createConnection_argsTupleSchemeFactory implements SchemeFactory {
      public createConnection_argsTupleScheme getScheme() {
        return new createConnection_argsTupleScheme();
      }
    }

    private static class createConnection_argsTupleScheme extends TupleScheme<createConnection_args> {

      @Override
      public void write(org.apache.thrift.protocol.TProtocol prot, createConnection_args struct) throws org.apache.thrift.TException {
        TTupleProtocol oprot = (TTupleProtocol) prot;
        BitSet optionals = new BitSet();
        if (struct.isSetUrl()) {
          optionals.set(0);
        }
        if (struct.isSetProperties()) {
          optionals.set(1);
        }
        oprot.writeBitSet(optionals, 2);
        if (struct.isSetUrl()) {
          oprot.writeString(struct.url);
        }
        if (struct.isSetProperties()) {
          {
            oprot.writeI32(struct.properties.size());
            for (Map.Entry<String, String> _iter45 : struct.properties.entrySet())
            {
              oprot.writeString(_iter45.getKey());
              oprot.writeString(_iter45.getValue());
            }
          }
        }
      }

      @Override
      public void read(org.apache.thrift.protocol.TProtocol prot, createConnection_args struct) throws org.apache.thrift.TException {
        TTupleProtocol iprot = (TTupleProtocol) prot;
        BitSet incoming = iprot.readBitSet(2);
        if (incoming.get(0)) {
          struct.url = iprot.readString();
          struct.setUrlIsSet(true);
        }
        if (incoming.get(1)) {
          {
            org.apache.thrift.protocol.TMap _map46 = new org.apache.thrift.protocol.TMap(org.apache.thrift.protocol.TType.STRING, org.apache.thrift.protocol.TType.STRING, iprot.readI32());
            struct.properties = new HashMap<String,String>(2*_map46.size);
            String _key47;
            String _val48;
            for (int _i49 = 0; _i49 < _map46.size; ++_i49)
            {
              _key47 = iprot.readString();
              _val48 = iprot.readString();
              struct.properties.put(_key47, _val48);
            }
          }
          struct.setPropertiesIsSet(true);
        }
      }
    }

  }

  public static class createConnection_result implements org.apache.thrift.TBase<createConnection_result, createConnection_result._Fields>, java.io.Serializable, Cloneable, Comparable<createConnection_result>   {
    private static final org.apache.thrift.protocol.TStruct STRUCT_DESC = new org.apache.thrift.protocol.TStruct("createConnection_result");

    private static final org.apache.thrift.protocol.TField SUCCESS_FIELD_DESC = new org.apache.thrift.protocol.TField("success", org.apache.thrift.protocol.TType.STRUCT, (short)0);
    private static final org.apache.thrift.protocol.TField SQL_EXCEPTION_FIELD_DESC = new org.apache.thrift.protocol.TField("sqlException", org.apache.thrift.protocol.TType.STRUCT, (short)1);

    private static final Map<Class<? extends IScheme>, SchemeFactory> schemes = new HashMap<Class<? extends IScheme>, SchemeFactory>();
    static {
      schemes.put(StandardScheme.class, new createConnection_resultStandardSchemeFactory());
      schemes.put(TupleScheme.class, new createConnection_resultTupleSchemeFactory());
    }

    public RConnection success; // required
    public RSQLException sqlException; // required

    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements org.apache.thrift.TFieldIdEnum {
      SUCCESS((short)0, "success"),
      SQL_EXCEPTION((short)1, "sqlException");

      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        switch(fieldId) {
          case 0: // SUCCESS
            return SUCCESS;
          case 1: // SQL_EXCEPTION
            return SQL_EXCEPTION;
          default:
            return null;
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }

    // isset id assignments
    public static final Map<_Fields, org.apache.thrift.meta_data.FieldMetaData> metaDataMap;
    static {
      Map<_Fields, org.apache.thrift.meta_data.FieldMetaData> tmpMap = new EnumMap<_Fields, org.apache.thrift.meta_data.FieldMetaData>(_Fields.class);
      tmpMap.put(_Fields.SUCCESS, new org.apache.thrift.meta_data.FieldMetaData("success", org.apache.thrift.TFieldRequirementType.DEFAULT, 
          new org.apache.thrift.meta_data.StructMetaData(org.apache.thrift.protocol.TType.STRUCT, RConnection.class)));
      tmpMap.put(_Fields.SQL_EXCEPTION, new org.apache.thrift.meta_data.FieldMetaData("sqlException", org.apache.thrift.TFieldRequirementType.DEFAULT, 
          new org.apache.thrift.meta_data.FieldValueMetaData(org.apache.thrift.protocol.TType.STRUCT)));
      metaDataMap = Collections.unmodifiableMap(tmpMap);
      org.apache.thrift.meta_data.FieldMetaData.addStructMetaDataMap(createConnection_result.class, metaDataMap);
    }

    public createConnection_result() {
    }

    public createConnection_result(
      RConnection success,
      RSQLException sqlException)
    {
      this();
      this.success = success;
      this.sqlException = sqlException;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public createConnection_result(createConnection_result other) {
      if (other.isSetSuccess()) {
        this.success = new RConnection(other.success);
      }
      if (other.isSetSqlException()) {
        this.sqlException = new RSQLException(other.sqlException);
      }
    }

    public createConnection_result deepCopy() {
      return new createConnection_result(this);
    }

    @Override
    public void clear() {
      this.success = null;
      this.sqlException = null;
    }

    public RConnection getSuccess() {
      return this.success;
    }

    public createConnection_result setSuccess(RConnection success) {
      this.success = success;
      return this;
    }

    public void unsetSuccess() {
      this.success = null;
    }

    /** Returns true if field success is set (has been assigned a value) and false otherwise */
    public boolean isSetSuccess() {
      return this.success != null;
    }

    public void setSuccessIsSet(boolean value) {
      if (!value) {
        this.success = null;
      }
    }

    public RSQLException getSqlException() {
      return this.sqlException;
    }

    public createConnection_result setSqlException(RSQLException sqlException) {
      this.sqlException = sqlException;
      return this;
    }

    public void unsetSqlException() {
      this.sqlException = null;
    }

    /** Returns true if field sqlException is set (has been assigned a value) and false otherwise */
    public boolean isSetSqlException() {
      return this.sqlException != null;
    }

    public void setSqlExceptionIsSet(boolean value) {
      if (!value) {
        this.sqlException = null;
      }
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          setSuccess((RConnection)value);
        }
        break;

      case SQL_EXCEPTION:
        if (value == null) {
          unsetSqlException();
        } else {
          setSqlException((RSQLException)value);
        }
        break;

      }
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      case SUCCESS:
        return getSuccess();

      case SQL_EXCEPTION:
        return getSqlException();

      }
      throw new IllegalStateException();
    }

    /** Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      if (field == null) {
        throw new IllegalArgumentException();
      }

      switch (field) {
      case SUCCESS:
        return isSetSuccess();
      case SQL_EXCEPTION:
        return isSetSqlException();
      }
      throw new IllegalStateException();
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof createConnection_result)
        return this.equals((createConnection_result)that);
      return false;
    }

    public boolean equals(createConnection_result that) {
      if (that == null)
        return false;

      boolean this_present_success = true && this.isSetSuccess();
      boolean that_present_success = true && that.isSetSuccess();
      if (this_present_success || that_present_success) {
        if (!(this_present_success && that_present_success))
          return false;
        if (!this.success.equals(that.success))
          return false;
      }

      boolean this_present_sqlException = true && this.isSetSqlException();
      boolean that_present_sqlException = true && that.isSetSqlException();
      if (this_present_sqlException || that_present_sqlException) {
        if (!(this_present_sqlException && that_present_sqlException))
          return false;
        if (!this.sqlException.equals(that.sqlException))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      List<Object> list = new ArrayList<Object>();

      boolean present_success = true && (isSetSuccess());
      list.add(present_success);
      if (present_success)
        list.add(success);

      boolean present_sqlException = true && (isSetSqlException());
      list.add(present_sqlException);
      if (present_sqlException)
        list.add(sqlException);

      return list.hashCode();
    }

    @Override
    public int compareTo(createConnection_result other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetSuccess()).compareTo(other.isSetSuccess());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetSuccess()) {
        lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.success, other.success);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      lastComparison = Boolean.valueOf(isSetSqlException()).compareTo(other.isSetSqlException());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetSqlException()) {
        lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.sqlException, other.sqlException);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      return 0;
    }

    public _Fields fieldForId(int fieldId) {
      return _Fields.findByThriftId(fieldId);
    }

    public void read(org.apache.thrift.protocol.TProtocol iprot) throws org.apache.thrift.TException {
      schemes.get(iprot.getScheme()).getScheme().read(iprot, this);
    }

    public void write(org.apache.thrift.protocol.TProtocol oprot) throws org.apache.thrift.TException {
      schemes.get(oprot.getScheme()).getScheme().write(oprot, this);
      }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("createConnection_result(");
      boolean first = true;

      sb.append("success:");
      if (this.success == null) {
        sb.append("null");
      } else {
        sb.append(this.success);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("sqlException:");
      if (this.sqlException == null) {
        sb.append("null");
      } else {
        sb.append(this.sqlException);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws org.apache.thrift.TException {
      // check for required fields
      // check for sub-struct validity
      if (success != null) {
        success.validate();
      }
    }

    private void writeObject(java.io.ObjectOutputStream out) throws java.io.IOException {
      try {
        write(new org.apache.thrift.protocol.TCompactProtocol(new org.apache.thrift.transport.TIOStreamTransport(out)));
      } catch (org.apache.thrift.TException te) {
        throw new java.io.IOException(te);
      }
    }

    private void readObject(java.io.ObjectInputStream in) throws java.io.IOException, ClassNotFoundException {
      try {
        read(new org.apache.thrift.protocol.TCompactProtocol(new org.apache.thrift.transport.TIOStreamTransport(in)));
      } catch (org.apache.thrift.TException te) {
        throw new java.io.IOException(te);
      }
    }

    private static class createConnection_resultStandardSchemeFactory implements SchemeFactory {
      public createConnection_resultStandardScheme getScheme() {
        return new createConnection_resultStandardScheme();
      }
    }

    private static class createConnection_resultStandardScheme extends StandardScheme<createConnection_result> {

      public void read(org.apache.thrift.protocol.TProtocol iprot, createConnection_result struct) throws org.apache.thrift.TException {
        org.apache.thrift.protocol.TField schemeField;
        iprot.readStructBegin();
        while (true)
        {
          schemeField = iprot.readFieldBegin();
          if (schemeField.type == org.apache.thrift.protocol.TType.STOP) { 
            break;
          }
          switch (schemeField.id) {
            case 0: // SUCCESS
              if (schemeField.type == org.apache.thrift.protocol.TType.STRUCT) {
                struct.success = new RConnection();
                struct.success.read(iprot);
                struct.setSuccessIsSet(true);
              } else { 
                org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
              }
              break;
            case 1: // SQL_EXCEPTION
              if (schemeField.type == org.apache.thrift.protocol.TType.STRUCT) {
                struct.sqlException = new RSQLException();
                struct.sqlException.read(iprot);
                struct.setSqlExceptionIsSet(true);
              } else { 
                org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
              }
              break;
            default:
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
          }
          iprot.readFieldEnd();
        }
        iprot.readStructEnd();

        // check for required fields of primitive type, which can't be checked in the validate method
        struct.validate();
      }

      public void write(org.apache.thrift.protocol.TProtocol oprot, createConnection_result struct) throws org.apache.thrift.TException {
        struct.validate();

        oprot.writeStructBegin(STRUCT_DESC);
        if (struct.success != null) {
          oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
          struct.success.write(oprot);
          oprot.writeFieldEnd();
        }
        if (struct.sqlException != null) {
          oprot.writeFieldBegin(SQL_EXCEPTION_FIELD_DESC);
          struct.sqlException.write(oprot);
          oprot.writeFieldEnd();
        }
        oprot.writeFieldStop();
        oprot.writeStructEnd();
      }

    }

    private static class createConnection_resultTupleSchemeFactory implements SchemeFactory {
      public createConnection_resultTupleScheme getScheme() {
        return new createConnection_resultTupleScheme();
      }
    }

    private static class createConnection_resultTupleScheme extends TupleScheme<createConnection_result> {

      @Override
      public void write(org.apache.thrift.protocol.TProtocol prot, createConnection_result struct) throws org.apache.thrift.TException {
        TTupleProtocol oprot = (TTupleProtocol) prot;
        BitSet optionals = new BitSet();
        if (struct.isSetSuccess()) {
          optionals.set(0);
        }
        if (struct.isSetSqlException()) {
          optionals.set(1);
        }
        oprot.writeBitSet(optionals, 2);
        if (struct.isSetSuccess()) {
          struct.success.write(oprot);
        }
        if (struct.isSetSqlException()) {
          struct.sqlException.write(oprot);
        }
      }

      @Override
      public void read(org.apache.thrift.protocol.TProtocol prot, createConnection_result struct) throws org.apache.thrift.TException {
        TTupleProtocol iprot = (TTupleProtocol) prot;
        BitSet incoming = iprot.readBitSet(2);
        if (incoming.get(0)) {
          struct.success = new RConnection();
          struct.success.read(iprot);
          struct.setSuccessIsSet(true);
        }
        if (incoming.get(1)) {
          struct.sqlException = new RSQLException();
          struct.sqlException.read(iprot);
          struct.setSqlExceptionIsSet(true);
        }
      }
    }

  }

  public static class createStatement_args implements org.apache.thrift.TBase<createStatement_args, createStatement_args._Fields>, java.io.Serializable, Cloneable, Comparable<createStatement_args>   {
    private static final org.apache.thrift.protocol.TStruct STRUCT_DESC = new org.apache.thrift.protocol.TStruct("createStatement_args");

    private static final org.apache.thrift.protocol.TField CONNECTION_FIELD_DESC = new org.apache.thrift.protocol.TField("connection", org.apache.thrift.protocol.TType.STRUCT, (short)1);

    private static final Map<Class<? extends IScheme>, SchemeFactory> schemes = new HashMap<Class<? extends IScheme>, SchemeFactory>();
    static {
      schemes.put(StandardScheme.class, new createStatement_argsStandardSchemeFactory());
      schemes.put(TupleScheme.class, new createStatement_argsTupleSchemeFactory());
    }

    public RConnection connection; // required

    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements org.apache.thrift.TFieldIdEnum {
      CONNECTION((short)1, "connection");

      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        switch(fieldId) {
          case 1: // CONNECTION
            return CONNECTION;
          default:
            return null;
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }

    // isset id assignments
    public static final Map<_Fields, org.apache.thrift.meta_data.FieldMetaData> metaDataMap;
    static {
      Map<_Fields, org.apache.thrift.meta_data.FieldMetaData> tmpMap = new EnumMap<_Fields, org.apache.thrift.meta_data.FieldMetaData>(_Fields.class);
      tmpMap.put(_Fields.CONNECTION, new org.apache.thrift.meta_data.FieldMetaData("connection", org.apache.thrift.TFieldRequirementType.DEFAULT, 
          new org.apache.thrift.meta_data.StructMetaData(org.apache.thrift.protocol.TType.STRUCT, RConnection.class)));
      metaDataMap = Collections.unmodifiableMap(tmpMap);
      org.apache.thrift.meta_data.FieldMetaData.addStructMetaDataMap(createStatement_args.class, metaDataMap);
    }

    public createStatement_args() {
    }

    public createStatement_args(
      RConnection connection)
    {
      this();
      this.connection = connection;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public createStatement_args(createStatement_args other) {
      if (other.isSetConnection()) {
        this.connection = new RConnection(other.connection);
      }
    }

    public createStatement_args deepCopy() {
      return new createStatement_args(this);
    }

    @Override
    public void clear() {
      this.connection = null;
    }

    public RConnection getConnection() {
      return this.connection;
    }

    public createStatement_args setConnection(RConnection connection) {
      this.connection = connection;
      return this;
    }

    public void unsetConnection() {
      this.connection = null;
    }

    /** Returns true if field connection is set (has been assigned a value) and false otherwise */
    public boolean isSetConnection() {
      return this.connection != null;
    }

    public void setConnectionIsSet(boolean value) {
      if (!value) {
        this.connection = null;
      }
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      case CONNECTION:
        if (value == null) {
          unsetConnection();
        } else {
          setConnection((RConnection)value);
        }
        break;

      }
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      case CONNECTION:
        return getConnection();

      }
      throw new IllegalStateException();
    }

    /** Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      if (field == null) {
        throw new IllegalArgumentException();
      }

      switch (field) {
      case CONNECTION:
        return isSetConnection();
      }
      throw new IllegalStateException();
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof createStatement_args)
        return this.equals((createStatement_args)that);
      return false;
    }

    public boolean equals(createStatement_args that) {
      if (that == null)
        return false;

      boolean this_present_connection = true && this.isSetConnection();
      boolean that_present_connection = true && that.isSetConnection();
      if (this_present_connection || that_present_connection) {
        if (!(this_present_connection && that_present_connection))
          return false;
        if (!this.connection.equals(that.connection))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      List<Object> list = new ArrayList<Object>();

      boolean present_connection = true && (isSetConnection());
      list.add(present_connection);
      if (present_connection)
        list.add(connection);

      return list.hashCode();
    }

    @Override
    public int compareTo(createStatement_args other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetConnection()).compareTo(other.isSetConnection());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetConnection()) {
        lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.connection, other.connection);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      return 0;
    }

    public _Fields fieldForId(int fieldId) {
      return _Fields.findByThriftId(fieldId);
    }

    public void read(org.apache.thrift.protocol.TProtocol iprot) throws org.apache.thrift.TException {
      schemes.get(iprot.getScheme()).getScheme().read(iprot, this);
    }

    public void write(org.apache.thrift.protocol.TProtocol oprot) throws org.apache.thrift.TException {
      schemes.get(oprot.getScheme()).getScheme().write(oprot, this);
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("createStatement_args(");
      boolean first = true;

      sb.append("connection:");
      if (this.connection == null) {
        sb.append("null");
      } else {
        sb.append(this.connection);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws org.apache.thrift.TException {
      // check for required fields
      // check for sub-struct validity
      if (connection != null) {
        connection.validate();
      }
    }

    private void writeObject(java.io.ObjectOutputStream out) throws java.io.IOException {
      try {
        write(new org.apache.thrift.protocol.TCompactProtocol(new org.apache.thrift.transport.TIOStreamTransport(out)));
      } catch (org.apache.thrift.TException te) {
        throw new java.io.IOException(te);
      }
    }

    private void readObject(java.io.ObjectInputStream in) throws java.io.IOException, ClassNotFoundException {
      try {
        read(new org.apache.thrift.protocol.TCompactProtocol(new org.apache.thrift.transport.TIOStreamTransport(in)));
      } catch (org.apache.thrift.TException te) {
        throw new java.io.IOException(te);
      }
    }

    private static class createStatement_argsStandardSchemeFactory implements SchemeFactory {
      public createStatement_argsStandardScheme getScheme() {
        return new createStatement_argsStandardScheme();
      }
    }

    private static class createStatement_argsStandardScheme extends StandardScheme<createStatement_args> {

      public void read(org.apache.thrift.protocol.TProtocol iprot, createStatement_args struct) throws org.apache.thrift.TException {
        org.apache.thrift.protocol.TField schemeField;
        iprot.readStructBegin();
        while (true)
        {
          schemeField = iprot.readFieldBegin();
          if (schemeField.type == org.apache.thrift.protocol.TType.STOP) { 
            break;
          }
          switch (schemeField.id) {
            case 1: // CONNECTION
              if (schemeField.type == org.apache.thrift.protocol.TType.STRUCT) {
                struct.connection = new RConnection();
                struct.connection.read(iprot);
                struct.setConnectionIsSet(true);
              } else { 
                org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
              }
              break;
            default:
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
          }
          iprot.readFieldEnd();
        }
        iprot.readStructEnd();

        // check for required fields of primitive type, which can't be checked in the validate method
        struct.validate();
      }

      public void write(org.apache.thrift.protocol.TProtocol oprot, createStatement_args struct) throws org.apache.thrift.TException {
        struct.validate();

        oprot.writeStructBegin(STRUCT_DESC);
        if (struct.connection != null) {
          oprot.writeFieldBegin(CONNECTION_FIELD_DESC);
          struct.connection.write(oprot);
          oprot.writeFieldEnd();
        }
        oprot.writeFieldStop();
        oprot.writeStructEnd();
      }

    }

    private static class createStatement_argsTupleSchemeFactory implements SchemeFactory {
      public createStatement_argsTupleScheme getScheme() {
        return new createStatement_argsTupleScheme();
      }
    }

    private static class createStatement_argsTupleScheme extends TupleScheme<createStatement_args> {

      @Override
      public void write(org.apache.thrift.protocol.TProtocol prot, createStatement_args struct) throws org.apache.thrift.TException {
        TTupleProtocol oprot = (TTupleProtocol) prot;
        BitSet optionals = new BitSet();
        if (struct.isSetConnection()) {
          optionals.set(0);
        }
        oprot.writeBitSet(optionals, 1);
        if (struct.isSetConnection()) {
          struct.connection.write(oprot);
        }
      }

      @Override
      public void read(org.apache.thrift.protocol.TProtocol prot, createStatement_args struct) throws org.apache.thrift.TException {
        TTupleProtocol iprot = (TTupleProtocol) prot;
        BitSet incoming = iprot.readBitSet(1);
        if (incoming.get(0)) {
          struct.connection = new RConnection();
          struct.connection.read(iprot);
          struct.setConnectionIsSet(true);
        }
      }
    }

  }

  public static class createStatement_result implements org.apache.thrift.TBase<createStatement_result, createStatement_result._Fields>, java.io.Serializable, Cloneable, Comparable<createStatement_result>   {
    private static final org.apache.thrift.protocol.TStruct STRUCT_DESC = new org.apache.thrift.protocol.TStruct("createStatement_result");

    private static final org.apache.thrift.protocol.TField SUCCESS_FIELD_DESC = new org.apache.thrift.protocol.TField("success", org.apache.thrift.protocol.TType.STRUCT, (short)0);
    private static final org.apache.thrift.protocol.TField SQL_EXCEPTION_FIELD_DESC = new org.apache.thrift.protocol.TField("sqlException", org.apache.thrift.protocol.TType.STRUCT, (short)1);

    private static final Map<Class<? extends IScheme>, SchemeFactory> schemes = new HashMap<Class<? extends IScheme>, SchemeFactory>();
    static {
      schemes.put(StandardScheme.class, new createStatement_resultStandardSchemeFactory());
      schemes.put(TupleScheme.class, new createStatement_resultTupleSchemeFactory());
    }

    public RStatement success; // required
    public RSQLException sqlException; // required

    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements org.apache.thrift.TFieldIdEnum {
      SUCCESS((short)0, "success"),
      SQL_EXCEPTION((short)1, "sqlException");

      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        switch(fieldId) {
          case 0: // SUCCESS
            return SUCCESS;
          case 1: // SQL_EXCEPTION
            return SQL_EXCEPTION;
          default:
            return null;
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }

    // isset id assignments
    public static final Map<_Fields, org.apache.thrift.meta_data.FieldMetaData> metaDataMap;
    static {
      Map<_Fields, org.apache.thrift.meta_data.FieldMetaData> tmpMap = new EnumMap<_Fields, org.apache.thrift.meta_data.FieldMetaData>(_Fields.class);
      tmpMap.put(_Fields.SUCCESS, new org.apache.thrift.meta_data.FieldMetaData("success", org.apache.thrift.TFieldRequirementType.DEFAULT, 
          new org.apache.thrift.meta_data.StructMetaData(org.apache.thrift.protocol.TType.STRUCT, RStatement.class)));
      tmpMap.put(_Fields.SQL_EXCEPTION, new org.apache.thrift.meta_data.FieldMetaData("sqlException", org.apache.thrift.TFieldRequirementType.DEFAULT, 
          new org.apache.thrift.meta_data.FieldValueMetaData(org.apache.thrift.protocol.TType.STRUCT)));
      metaDataMap = Collections.unmodifiableMap(tmpMap);
      org.apache.thrift.meta_data.FieldMetaData.addStructMetaDataMap(createStatement_result.class, metaDataMap);
    }

    public createStatement_result() {
    }

    public createStatement_result(
      RStatement success,
      RSQLException sqlException)
    {
      this();
      this.success = success;
      this.sqlException = sqlException;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public createStatement_result(createStatement_result other) {
      if (other.isSetSuccess()) {
        this.success = new RStatement(other.success);
      }
      if (other.isSetSqlException()) {
        this.sqlException = new RSQLException(other.sqlException);
      }
    }

    public createStatement_result deepCopy() {
      return new createStatement_result(this);
    }

    @Override
    public void clear() {
      this.success = null;
      this.sqlException = null;
    }

    public RStatement getSuccess() {
      return this.success;
    }

    public createStatement_result setSuccess(RStatement success) {
      this.success = success;
      return this;
    }

    public void unsetSuccess() {
      this.success = null;
    }

    /** Returns true if field success is set (has been assigned a value) and false otherwise */
    public boolean isSetSuccess() {
      return this.success != null;
    }

    public void setSuccessIsSet(boolean value) {
      if (!value) {
        this.success = null;
      }
    }

    public RSQLException getSqlException() {
      return this.sqlException;
    }

    public createStatement_result setSqlException(RSQLException sqlException) {
      this.sqlException = sqlException;
      return this;
    }

    public void unsetSqlException() {
      this.sqlException = null;
    }

    /** Returns true if field sqlException is set (has been assigned a value) and false otherwise */
    public boolean isSetSqlException() {
      return this.sqlException != null;
    }

    public void setSqlExceptionIsSet(boolean value) {
      if (!value) {
        this.sqlException = null;
      }
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          setSuccess((RStatement)value);
        }
        break;

      case SQL_EXCEPTION:
        if (value == null) {
          unsetSqlException();
        } else {
          setSqlException((RSQLException)value);
        }
        break;

      }
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      case SUCCESS:
        return getSuccess();

      case SQL_EXCEPTION:
        return getSqlException();

      }
      throw new IllegalStateException();
    }

    /** Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      if (field == null) {
        throw new IllegalArgumentException();
      }

      switch (field) {
      case SUCCESS:
        return isSetSuccess();
      case SQL_EXCEPTION:
        return isSetSqlException();
      }
      throw new IllegalStateException();
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof createStatement_result)
        return this.equals((createStatement_result)that);
      return false;
    }

    public boolean equals(createStatement_result that) {
      if (that == null)
        return false;

      boolean this_present_success = true && this.isSetSuccess();
      boolean that_present_success = true && that.isSetSuccess();
      if (this_present_success || that_present_success) {
        if (!(this_present_success && that_present_success))
          return false;
        if (!this.success.equals(that.success))
          return false;
      }

      boolean this_present_sqlException = true && this.isSetSqlException();
      boolean that_present_sqlException = true && that.isSetSqlException();
      if (this_present_sqlException || that_present_sqlException) {
        if (!(this_present_sqlException && that_present_sqlException))
          return false;
        if (!this.sqlException.equals(that.sqlException))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      List<Object> list = new ArrayList<Object>();

      boolean present_success = true && (isSetSuccess());
      list.add(present_success);
      if (present_success)
        list.add(success);

      boolean present_sqlException = true && (isSetSqlException());
      list.add(present_sqlException);
      if (present_sqlException)
        list.add(sqlException);

      return list.hashCode();
    }

    @Override
    public int compareTo(createStatement_result other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetSuccess()).compareTo(other.isSetSuccess());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetSuccess()) {
        lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.success, other.success);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      lastComparison = Boolean.valueOf(isSetSqlException()).compareTo(other.isSetSqlException());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetSqlException()) {
        lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.sqlException, other.sqlException);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      return 0;
    }

    public _Fields fieldForId(int fieldId) {
      return _Fields.findByThriftId(fieldId);
    }

    public void read(org.apache.thrift.protocol.TProtocol iprot) throws org.apache.thrift.TException {
      schemes.get(iprot.getScheme()).getScheme().read(iprot, this);
    }

    public void write(org.apache.thrift.protocol.TProtocol oprot) throws org.apache.thrift.TException {
      schemes.get(oprot.getScheme()).getScheme().write(oprot, this);
      }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("createStatement_result(");
      boolean first = true;

      sb.append("success:");
      if (this.success == null) {
        sb.append("null");
      } else {
        sb.append(this.success);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("sqlException:");
      if (this.sqlException == null) {
        sb.append("null");
      } else {
        sb.append(this.sqlException);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws org.apache.thrift.TException {
      // check for required fields
      // check for sub-struct validity
      if (success != null) {
        success.validate();
      }
    }

    private void writeObject(java.io.ObjectOutputStream out) throws java.io.IOException {
      try {
        write(new org.apache.thrift.protocol.TCompactProtocol(new org.apache.thrift.transport.TIOStreamTransport(out)));
      } catch (org.apache.thrift.TException te) {
        throw new java.io.IOException(te);
      }
    }

    private void readObject(java.io.ObjectInputStream in) throws java.io.IOException, ClassNotFoundException {
      try {
        read(new org.apache.thrift.protocol.TCompactProtocol(new org.apache.thrift.transport.TIOStreamTransport(in)));
      } catch (org.apache.thrift.TException te) {
        throw new java.io.IOException(te);
      }
    }

    private static class createStatement_resultStandardSchemeFactory implements SchemeFactory {
      public createStatement_resultStandardScheme getScheme() {
        return new createStatement_resultStandardScheme();
      }
    }

    private static class createStatement_resultStandardScheme extends StandardScheme<createStatement_result> {

      public void read(org.apache.thrift.protocol.TProtocol iprot, createStatement_result struct) throws org.apache.thrift.TException {
        org.apache.thrift.protocol.TField schemeField;
        iprot.readStructBegin();
        while (true)
        {
          schemeField = iprot.readFieldBegin();
          if (schemeField.type == org.apache.thrift.protocol.TType.STOP) { 
            break;
          }
          switch (schemeField.id) {
            case 0: // SUCCESS
              if (schemeField.type == org.apache.thrift.protocol.TType.STRUCT) {
                struct.success = new RStatement();
                struct.success.read(iprot);
                struct.setSuccessIsSet(true);
              } else { 
                org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
              }
              break;
            case 1: // SQL_EXCEPTION
              if (schemeField.type == org.apache.thrift.protocol.TType.STRUCT) {
                struct.sqlException = new RSQLException();
                struct.sqlException.read(iprot);
                struct.setSqlExceptionIsSet(true);
              } else { 
                org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
              }
              break;
            default:
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
          }
          iprot.readFieldEnd();
        }
        iprot.readStructEnd();

        // check for required fields of primitive type, which can't be checked in the validate method
        struct.validate();
      }

      public void write(org.apache.thrift.protocol.TProtocol oprot, createStatement_result struct) throws org.apache.thrift.TException {
        struct.validate();

        oprot.writeStructBegin(STRUCT_DESC);
        if (struct.success != null) {
          oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
          struct.success.write(oprot);
          oprot.writeFieldEnd();
        }
        if (struct.sqlException != null) {
          oprot.writeFieldBegin(SQL_EXCEPTION_FIELD_DESC);
          struct.sqlException.write(oprot);
          oprot.writeFieldEnd();
        }
        oprot.writeFieldStop();
        oprot.writeStructEnd();
      }

    }

    private static class createStatement_resultTupleSchemeFactory implements SchemeFactory {
      public createStatement_resultTupleScheme getScheme() {
        return new createStatement_resultTupleScheme();
      }
    }

    private static class createStatement_resultTupleScheme extends TupleScheme<createStatement_result> {

      @Override
      public void write(org.apache.thrift.protocol.TProtocol prot, createStatement_result struct) throws org.apache.thrift.TException {
        TTupleProtocol oprot = (TTupleProtocol) prot;
        BitSet optionals = new BitSet();
        if (struct.isSetSuccess()) {
          optionals.set(0);
        }
        if (struct.isSetSqlException()) {
          optionals.set(1);
        }
        oprot.writeBitSet(optionals, 2);
        if (struct.isSetSuccess()) {
          struct.success.write(oprot);
        }
        if (struct.isSetSqlException()) {
          struct.sqlException.write(oprot);
        }
      }

      @Override
      public void read(org.apache.thrift.protocol.TProtocol prot, createStatement_result struct) throws org.apache.thrift.TException {
        TTupleProtocol iprot = (TTupleProtocol) prot;
        BitSet incoming = iprot.readBitSet(2);
        if (incoming.get(0)) {
          struct.success = new RStatement();
          struct.success.read(iprot);
          struct.setSuccessIsSet(true);
        }
        if (incoming.get(1)) {
          struct.sqlException = new RSQLException();
          struct.sqlException.read(iprot);
          struct.setSqlExceptionIsSet(true);
        }
      }
    }

  }

  public static class prepareStatement_args implements org.apache.thrift.TBase<prepareStatement_args, prepareStatement_args._Fields>, java.io.Serializable, Cloneable, Comparable<prepareStatement_args>   {
    private static final org.apache.thrift.protocol.TStruct STRUCT_DESC = new org.apache.thrift.protocol.TStruct("prepareStatement_args");

    private static final org.apache.thrift.protocol.TField CONNECTION_FIELD_DESC = new org.apache.thrift.protocol.TField("connection", org.apache.thrift.protocol.TType.STRUCT, (short)1);
    private static final org.apache.thrift.protocol.TField SQL_FIELD_DESC = new org.apache.thrift.protocol.TField("sql", org.apache.thrift.protocol.TType.STRING, (short)2);

    private static final Map<Class<? extends IScheme>, SchemeFactory> schemes = new HashMap<Class<? extends IScheme>, SchemeFactory>();
    static {
      schemes.put(StandardScheme.class, new prepareStatement_argsStandardSchemeFactory());
      schemes.put(TupleScheme.class, new prepareStatement_argsTupleSchemeFactory());
    }

    public RConnection connection; // required
    public String sql; // required

    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements org.apache.thrift.TFieldIdEnum {
      CONNECTION((short)1, "connection"),
      SQL((short)2, "sql");

      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        switch(fieldId) {
          case 1: // CONNECTION
            return CONNECTION;
          case 2: // SQL
            return SQL;
          default:
            return null;
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }

    // isset id assignments
    public static final Map<_Fields, org.apache.thrift.meta_data.FieldMetaData> metaDataMap;
    static {
      Map<_Fields, org.apache.thrift.meta_data.FieldMetaData> tmpMap = new EnumMap<_Fields, org.apache.thrift.meta_data.FieldMetaData>(_Fields.class);
      tmpMap.put(_Fields.CONNECTION, new org.apache.thrift.meta_data.FieldMetaData("connection", org.apache.thrift.TFieldRequirementType.DEFAULT, 
          new org.apache.thrift.meta_data.StructMetaData(org.apache.thrift.protocol.TType.STRUCT, RConnection.class)));
      tmpMap.put(_Fields.SQL, new org.apache.thrift.meta_data.FieldMetaData("sql", org.apache.thrift.TFieldRequirementType.DEFAULT, 
          new org.apache.thrift.meta_data.FieldValueMetaData(org.apache.thrift.protocol.TType.STRING)));
      metaDataMap = Collections.unmodifiableMap(tmpMap);
      org.apache.thrift.meta_data.FieldMetaData.addStructMetaDataMap(prepareStatement_args.class, metaDataMap);
    }

    public prepareStatement_args() {
    }

    public prepareStatement_args(
      RConnection connection,
      String sql)
    {
      this();
      this.connection = connection;
      this.sql = sql;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public prepareStatement_args(prepareStatement_args other) {
      if (other.isSetConnection()) {
        this.connection = new RConnection(other.connection);
      }
      if (other.isSetSql()) {
        this.sql = other.sql;
      }
    }

    public prepareStatement_args deepCopy() {
      return new prepareStatement_args(this);
    }

    @Override
    public void clear() {
      this.connection = null;
      this.sql = null;
    }

    public RConnection getConnection() {
      return this.connection;
    }

    public prepareStatement_args setConnection(RConnection connection) {
      this.connection = connection;
      return this;
    }

    public void unsetConnection() {
      this.connection = null;
    }

    /** Returns true if field connection is set (has been assigned a value) and false otherwise */
    public boolean isSetConnection() {
      return this.connection != null;
    }

    public void setConnectionIsSet(boolean value) {
      if (!value) {
        this.connection = null;
      }
    }

    public String getSql() {
      return this.sql;
    }

    public prepareStatement_args setSql(String sql) {
      this.sql = sql;
      return this;
    }

    public void unsetSql() {
      this.sql = null;
    }

    /** Returns true if field sql is set (has been assigned a value) and false otherwise */
    public boolean isSetSql() {
      return this.sql != null;
    }

    public void setSqlIsSet(boolean value) {
      if (!value) {
        this.sql = null;
      }
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      case CONNECTION:
        if (value == null) {
          unsetConnection();
        } else {
          setConnection((RConnection)value);
        }
        break;

      case SQL:
        if (value == null) {
          unsetSql();
        } else {
          setSql((String)value);
        }
        break;

      }
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      case CONNECTION:
        return getConnection();

      case SQL:
        return getSql();

      }
      throw new IllegalStateException();
    }

    /** Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      if (field == null) {
        throw new IllegalArgumentException();
      }

      switch (field) {
      case CONNECTION:
        return isSetConnection();
      case SQL:
        return isSetSql();
      }
      throw new IllegalStateException();
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof prepareStatement_args)
        return this.equals((prepareStatement_args)that);
      return false;
    }

    public boolean equals(prepareStatement_args that) {
      if (that == null)
        return false;

      boolean this_present_connection = true && this.isSetConnection();
      boolean that_present_connection = true && that.isSetConnection();
      if (this_present_connection || that_present_connection) {
        if (!(this_present_connection && that_present_connection))
          return false;
        if (!this.connection.equals(that.connection))
          return false;
      }

      boolean this_present_sql = true && this.isSetSql();
      boolean that_present_sql = true && that.isSetSql();
      if (this_present_sql || that_present_sql) {
        if (!(this_present_sql && that_present_sql))
          return false;
        if (!this.sql.equals(that.sql))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      List<Object> list = new ArrayList<Object>();

      boolean present_connection = true && (isSetConnection());
      list.add(present_connection);
      if (present_connection)
        list.add(connection);

      boolean present_sql = true && (isSetSql());
      list.add(present_sql);
      if (present_sql)
        list.add(sql);

      return list.hashCode();
    }

    @Override
    public int compareTo(prepareStatement_args other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetConnection()).compareTo(other.isSetConnection());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetConnection()) {
        lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.connection, other.connection);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      lastComparison = Boolean.valueOf(isSetSql()).compareTo(other.isSetSql());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetSql()) {
        lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.sql, other.sql);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      return 0;
    }

    public _Fields fieldForId(int fieldId) {
      return _Fields.findByThriftId(fieldId);
    }

    public void read(org.apache.thrift.protocol.TProtocol iprot) throws org.apache.thrift.TException {
      schemes.get(iprot.getScheme()).getScheme().read(iprot, this);
    }

    public void write(org.apache.thrift.protocol.TProtocol oprot) throws org.apache.thrift.TException {
      schemes.get(oprot.getScheme()).getScheme().write(oprot, this);
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("prepareStatement_args(");
      boolean first = true;

      sb.append("connection:");
      if (this.connection == null) {
        sb.append("null");
      } else {
        sb.append(this.connection);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("sql:");
      if (this.sql == null) {
        sb.append("null");
      } else {
        sb.append(this.sql);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws org.apache.thrift.TException {
      // check for required fields
      // check for sub-struct validity
      if (connection != null) {
        connection.validate();
      }
    }

    private void writeObject(java.io.ObjectOutputStream out) throws java.io.IOException {
      try {
        write(new org.apache.thrift.protocol.TCompactProtocol(new org.apache.thrift.transport.TIOStreamTransport(out)));
      } catch (org.apache.thrift.TException te) {
        throw new java.io.IOException(te);
      }
    }

    private void readObject(java.io.ObjectInputStream in) throws java.io.IOException, ClassNotFoundException {
      try {
        read(new org.apache.thrift.protocol.TCompactProtocol(new org.apache.thrift.transport.TIOStreamTransport(in)));
      } catch (org.apache.thrift.TException te) {
        throw new java.io.IOException(te);
      }
    }

    private static class prepareStatement_argsStandardSchemeFactory implements SchemeFactory {
      public prepareStatement_argsStandardScheme getScheme() {
        return new prepareStatement_argsStandardScheme();
      }
    }

    private static class prepareStatement_argsStandardScheme extends StandardScheme<prepareStatement_args> {

      public void read(org.apache.thrift.protocol.TProtocol iprot, prepareStatement_args struct) throws org.apache.thrift.TException {
        org.apache.thrift.protocol.TField schemeField;
        iprot.readStructBegin();
        while (true)
        {
          schemeField = iprot.readFieldBegin();
          if (schemeField.type == org.apache.thrift.protocol.TType.STOP) { 
            break;
          }
          switch (schemeField.id) {
            case 1: // CONNECTION
              if (schemeField.type == org.apache.thrift.protocol.TType.STRUCT) {
                struct.connection = new RConnection();
                struct.connection.read(iprot);
                struct.setConnectionIsSet(true);
              } else { 
                org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
              }
              break;
            case 2: // SQL
              if (schemeField.type == org.apache.thrift.protocol.TType.STRING) {
                struct.sql = iprot.readString();
                struct.setSqlIsSet(true);
              } else { 
                org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
              }
              break;
            default:
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
          }
          iprot.readFieldEnd();
        }
        iprot.readStructEnd();

        // check for required fields of primitive type, which can't be checked in the validate method
        struct.validate();
      }

      public void write(org.apache.thrift.protocol.TProtocol oprot, prepareStatement_args struct) throws org.apache.thrift.TException {
        struct.validate();

        oprot.writeStructBegin(STRUCT_DESC);
        if (struct.connection != null) {
          oprot.writeFieldBegin(CONNECTION_FIELD_DESC);
          struct.connection.write(oprot);
          oprot.writeFieldEnd();
        }
        if (struct.sql != null) {
          oprot.writeFieldBegin(SQL_FIELD_DESC);
          oprot.writeString(struct.sql);
          oprot.writeFieldEnd();
        }
        oprot.writeFieldStop();
        oprot.writeStructEnd();
      }

    }

    private static class prepareStatement_argsTupleSchemeFactory implements SchemeFactory {
      public prepareStatement_argsTupleScheme getScheme() {
        return new prepareStatement_argsTupleScheme();
      }
    }

    private static class prepareStatement_argsTupleScheme extends TupleScheme<prepareStatement_args> {

      @Override
      public void write(org.apache.thrift.protocol.TProtocol prot, prepareStatement_args struct) throws org.apache.thrift.TException {
        TTupleProtocol oprot = (TTupleProtocol) prot;
        BitSet optionals = new BitSet();
        if (struct.isSetConnection()) {
          optionals.set(0);
        }
        if (struct.isSetSql()) {
          optionals.set(1);
        }
        oprot.writeBitSet(optionals, 2);
        if (struct.isSetConnection()) {
          struct.connection.write(oprot);
        }
        if (struct.isSetSql()) {
          oprot.writeString(struct.sql);
        }
      }

      @Override
      public void read(org.apache.thrift.protocol.TProtocol prot, prepareStatement_args struct) throws org.apache.thrift.TException {
        TTupleProtocol iprot = (TTupleProtocol) prot;
        BitSet incoming = iprot.readBitSet(2);
        if (incoming.get(0)) {
          struct.connection = new RConnection();
          struct.connection.read(iprot);
          struct.setConnectionIsSet(true);
        }
        if (incoming.get(1)) {
          struct.sql = iprot.readString();
          struct.setSqlIsSet(true);
        }
      }
    }

  }

  public static class prepareStatement_result implements org.apache.thrift.TBase<prepareStatement_result, prepareStatement_result._Fields>, java.io.Serializable, Cloneable, Comparable<prepareStatement_result>   {
    private static final org.apache.thrift.protocol.TStruct STRUCT_DESC = new org.apache.thrift.protocol.TStruct("prepareStatement_result");

    private static final org.apache.thrift.protocol.TField SUCCESS_FIELD_DESC = new org.apache.thrift.protocol.TField("success", org.apache.thrift.protocol.TType.STRUCT, (short)0);
    private static final org.apache.thrift.protocol.TField SQL_EXCEPTION_FIELD_DESC = new org.apache.thrift.protocol.TField("sqlException", org.apache.thrift.protocol.TType.STRUCT, (short)1);

    private static final Map<Class<? extends IScheme>, SchemeFactory> schemes = new HashMap<Class<? extends IScheme>, SchemeFactory>();
    static {
      schemes.put(StandardScheme.class, new prepareStatement_resultStandardSchemeFactory());
      schemes.put(TupleScheme.class, new prepareStatement_resultTupleSchemeFactory());
    }

    public RStatement success; // required
    public RSQLException sqlException; // required

    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements org.apache.thrift.TFieldIdEnum {
      SUCCESS((short)0, "success"),
      SQL_EXCEPTION((short)1, "sqlException");

      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        switch(fieldId) {
          case 0: // SUCCESS
            return SUCCESS;
          case 1: // SQL_EXCEPTION
            return SQL_EXCEPTION;
          default:
            return null;
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }

    // isset id assignments
    public static final Map<_Fields, org.apache.thrift.meta_data.FieldMetaData> metaDataMap;
    static {
      Map<_Fields, org.apache.thrift.meta_data.FieldMetaData> tmpMap = new EnumMap<_Fields, org.apache.thrift.meta_data.FieldMetaData>(_Fields.class);
      tmpMap.put(_Fields.SUCCESS, new org.apache.thrift.meta_data.FieldMetaData("success", org.apache.thrift.TFieldRequirementType.DEFAULT, 
          new org.apache.thrift.meta_data.StructMetaData(org.apache.thrift.protocol.TType.STRUCT, RStatement.class)));
      tmpMap.put(_Fields.SQL_EXCEPTION, new org.apache.thrift.meta_data.FieldMetaData("sqlException", org.apache.thrift.TFieldRequirementType.DEFAULT, 
          new org.apache.thrift.meta_data.FieldValueMetaData(org.apache.thrift.protocol.TType.STRUCT)));
      metaDataMap = Collections.unmodifiableMap(tmpMap);
      org.apache.thrift.meta_data.FieldMetaData.addStructMetaDataMap(prepareStatement_result.class, metaDataMap);
    }

    public prepareStatement_result() {
    }

    public prepareStatement_result(
      RStatement success,
      RSQLException sqlException)
    {
      this();
      this.success = success;
      this.sqlException = sqlException;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public prepareStatement_result(prepareStatement_result other) {
      if (other.isSetSuccess()) {
        this.success = new RStatement(other.success);
      }
      if (other.isSetSqlException()) {
        this.sqlException = new RSQLException(other.sqlException);
      }
    }

    public prepareStatement_result deepCopy() {
      return new prepareStatement_result(this);
    }

    @Override
    public void clear() {
      this.success = null;
      this.sqlException = null;
    }

    public RStatement getSuccess() {
      return this.success;
    }

    public prepareStatement_result setSuccess(RStatement success) {
      this.success = success;
      return this;
    }

    public void unsetSuccess() {
      this.success = null;
    }

    /** Returns true if field success is set (has been assigned a value) and false otherwise */
    public boolean isSetSuccess() {
      return this.success != null;
    }

    public void setSuccessIsSet(boolean value) {
      if (!value) {
        this.success = null;
      }
    }

    public RSQLException getSqlException() {
      return this.sqlException;
    }

    public prepareStatement_result setSqlException(RSQLException sqlException) {
      this.sqlException = sqlException;
      return this;
    }

    public void unsetSqlException() {
      this.sqlException = null;
    }

    /** Returns true if field sqlException is set (has been assigned a value) and false otherwise */
    public boolean isSetSqlException() {
      return this.sqlException != null;
    }

    public void setSqlExceptionIsSet(boolean value) {
      if (!value) {
        this.sqlException = null;
      }
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          setSuccess((RStatement)value);
        }
        break;

      case SQL_EXCEPTION:
        if (value == null) {
          unsetSqlException();
        } else {
          setSqlException((RSQLException)value);
        }
        break;

      }
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      case SUCCESS:
        return getSuccess();

      case SQL_EXCEPTION:
        return getSqlException();

      }
      throw new IllegalStateException();
    }

    /** Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      if (field == null) {
        throw new IllegalArgumentException();
      }

      switch (field) {
      case SUCCESS:
        return isSetSuccess();
      case SQL_EXCEPTION:
        return isSetSqlException();
      }
      throw new IllegalStateException();
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof prepareStatement_result)
        return this.equals((prepareStatement_result)that);
      return false;
    }

    public boolean equals(prepareStatement_result that) {
      if (that == null)
        return false;

      boolean this_present_success = true && this.isSetSuccess();
      boolean that_present_success = true && that.isSetSuccess();
      if (this_present_success || that_present_success) {
        if (!(this_present_success && that_present_success))
          return false;
        if (!this.success.equals(that.success))
          return false;
      }

      boolean this_present_sqlException = true && this.isSetSqlException();
      boolean that_present_sqlException = true && that.isSetSqlException();
      if (this_present_sqlException || that_present_sqlException) {
        if (!(this_present_sqlException && that_present_sqlException))
          return false;
        if (!this.sqlException.equals(that.sqlException))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      List<Object> list = new ArrayList<Object>();

      boolean present_success = true && (isSetSuccess());
      list.add(present_success);
      if (present_success)
        list.add(success);

      boolean present_sqlException = true && (isSetSqlException());
      list.add(present_sqlException);
      if (present_sqlException)
        list.add(sqlException);

      return list.hashCode();
    }

    @Override
    public int compareTo(prepareStatement_result other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetSuccess()).compareTo(other.isSetSuccess());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetSuccess()) {
        lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.success, other.success);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      lastComparison = Boolean.valueOf(isSetSqlException()).compareTo(other.isSetSqlException());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetSqlException()) {
        lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.sqlException, other.sqlException);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      return 0;
    }

    public _Fields fieldForId(int fieldId) {
      return _Fields.findByThriftId(fieldId);
    }

    public void read(org.apache.thrift.protocol.TProtocol iprot) throws org.apache.thrift.TException {
      schemes.get(iprot.getScheme()).getScheme().read(iprot, this);
    }

    public void write(org.apache.thrift.protocol.TProtocol oprot) throws org.apache.thrift.TException {
      schemes.get(oprot.getScheme()).getScheme().write(oprot, this);
      }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("prepareStatement_result(");
      boolean first = true;

      sb.append("success:");
      if (this.success == null) {
        sb.append("null");
      } else {
        sb.append(this.success);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("sqlException:");
      if (this.sqlException == null) {
        sb.append("null");
      } else {
        sb.append(this.sqlException);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws org.apache.thrift.TException {
      // check for required fields
      // check for sub-struct validity
      if (success != null) {
        success.validate();
      }
    }

    private void writeObject(java.io.ObjectOutputStream out) throws java.io.IOException {
      try {
        write(new org.apache.thrift.protocol.TCompactProtocol(new org.apache.thrift.transport.TIOStreamTransport(out)));
      } catch (org.apache.thrift.TException te) {
        throw new java.io.IOException(te);
      }
    }

    private void readObject(java.io.ObjectInputStream in) throws java.io.IOException, ClassNotFoundException {
      try {
        read(new org.apache.thrift.protocol.TCompactProtocol(new org.apache.thrift.transport.TIOStreamTransport(in)));
      } catch (org.apache.thrift.TException te) {
        throw new java.io.IOException(te);
      }
    }

    private static class prepareStatement_resultStandardSchemeFactory implements SchemeFactory {
      public prepareStatement_resultStandardScheme getScheme() {
        return new prepareStatement_resultStandardScheme();
      }
    }

    private static class prepareStatement_resultStandardScheme extends StandardScheme<prepareStatement_result> {

      public void read(org.apache.thrift.protocol.TProtocol iprot, prepareStatement_result struct) throws org.apache.thrift.TException {
        org.apache.thrift.protocol.TField schemeField;
        iprot.readStructBegin();
        while (true)
        {
          schemeField = iprot.readFieldBegin();
          if (schemeField.type == org.apache.thrift.protocol.TType.STOP) { 
            break;
          }
          switch (schemeField.id) {
            case 0: // SUCCESS
              if (schemeField.type == org.apache.thrift.protocol.TType.STRUCT) {
                struct.success = new RStatement();
                struct.success.read(iprot);
                struct.setSuccessIsSet(true);
              } else { 
                org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
              }
              break;
            case 1: // SQL_EXCEPTION
              if (schemeField.type == org.apache.thrift.protocol.TType.STRUCT) {
                struct.sqlException = new RSQLException();
                struct.sqlException.read(iprot);
                struct.setSqlExceptionIsSet(true);
              } else { 
                org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
              }
              break;
            default:
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
          }
          iprot.readFieldEnd();
        }
        iprot.readStructEnd();

        // check for required fields of primitive type, which can't be checked in the validate method
        struct.validate();
      }

      public void write(org.apache.thrift.protocol.TProtocol oprot, prepareStatement_result struct) throws org.apache.thrift.TException {
        struct.validate();

        oprot.writeStructBegin(STRUCT_DESC);
        if (struct.success != null) {
          oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
          struct.success.write(oprot);
          oprot.writeFieldEnd();
        }
        if (struct.sqlException != null) {
          oprot.writeFieldBegin(SQL_EXCEPTION_FIELD_DESC);
          struct.sqlException.write(oprot);
          oprot.writeFieldEnd();
        }
        oprot.writeFieldStop();
        oprot.writeStructEnd();
      }

    }

    private static class prepareStatement_resultTupleSchemeFactory implements SchemeFactory {
      public prepareStatement_resultTupleScheme getScheme() {
        return new prepareStatement_resultTupleScheme();
      }
    }

    private static class prepareStatement_resultTupleScheme extends TupleScheme<prepareStatement_result> {

      @Override
      public void write(org.apache.thrift.protocol.TProtocol prot, prepareStatement_result struct) throws org.apache.thrift.TException {
        TTupleProtocol oprot = (TTupleProtocol) prot;
        BitSet optionals = new BitSet();
        if (struct.isSetSuccess()) {
          optionals.set(0);
        }
        if (struct.isSetSqlException()) {
          optionals.set(1);
        }
        oprot.writeBitSet(optionals, 2);
        if (struct.isSetSuccess()) {
          struct.success.write(oprot);
        }
        if (struct.isSetSqlException()) {
          struct.sqlException.write(oprot);
        }
      }

      @Override
      public void read(org.apache.thrift.protocol.TProtocol prot, prepareStatement_result struct) throws org.apache.thrift.TException {
        TTupleProtocol iprot = (TTupleProtocol) prot;
        BitSet incoming = iprot.readBitSet(2);
        if (incoming.get(0)) {
          struct.success = new RStatement();
          struct.success.read(iprot);
          struct.setSuccessIsSet(true);
        }
        if (incoming.get(1)) {
          struct.sqlException = new RSQLException();
          struct.sqlException.read(iprot);
          struct.setSqlExceptionIsSet(true);
        }
      }
    }

  }

  public static class prepareCall_args implements org.apache.thrift.TBase<prepareCall_args, prepareCall_args._Fields>, java.io.Serializable, Cloneable, Comparable<prepareCall_args>   {
    private static final org.apache.thrift.protocol.TStruct STRUCT_DESC = new org.apache.thrift.protocol.TStruct("prepareCall_args");

    private static final org.apache.thrift.protocol.TField CONNECTION_FIELD_DESC = new org.apache.thrift.protocol.TField("connection", org.apache.thrift.protocol.TType.STRUCT, (short)1);
    private static final org.apache.thrift.protocol.TField SQL_FIELD_DESC = new org.apache.thrift.protocol.TField("sql", org.apache.thrift.protocol.TType.STRING, (short)2);

    private static final Map<Class<? extends IScheme>, SchemeFactory> schemes = new HashMap<Class<? extends IScheme>, SchemeFactory>();
    static {
      schemes.put(StandardScheme.class, new prepareCall_argsStandardSchemeFactory());
      schemes.put(TupleScheme.class, new prepareCall_argsTupleSchemeFactory());
    }

    public RConnection connection; // required
    public String sql; // required

    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements org.apache.thrift.TFieldIdEnum {
      CONNECTION((short)1, "connection"),
      SQL((short)2, "sql");

      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        switch(fieldId) {
          case 1: // CONNECTION
            return CONNECTION;
          case 2: // SQL
            return SQL;
          default:
            return null;
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }

    // isset id assignments
    public static final Map<_Fields, org.apache.thrift.meta_data.FieldMetaData> metaDataMap;
    static {
      Map<_Fields, org.apache.thrift.meta_data.FieldMetaData> tmpMap = new EnumMap<_Fields, org.apache.thrift.meta_data.FieldMetaData>(_Fields.class);
      tmpMap.put(_Fields.CONNECTION, new org.apache.thrift.meta_data.FieldMetaData("connection", org.apache.thrift.TFieldRequirementType.DEFAULT, 
          new org.apache.thrift.meta_data.StructMetaData(org.apache.thrift.protocol.TType.STRUCT, RConnection.class)));
      tmpMap.put(_Fields.SQL, new org.apache.thrift.meta_data.FieldMetaData("sql", org.apache.thrift.TFieldRequirementType.DEFAULT, 
          new org.apache.thrift.meta_data.FieldValueMetaData(org.apache.thrift.protocol.TType.STRING)));
      metaDataMap = Collections.unmodifiableMap(tmpMap);
      org.apache.thrift.meta_data.FieldMetaData.addStructMetaDataMap(prepareCall_args.class, metaDataMap);
    }

    public prepareCall_args() {
    }

    public prepareCall_args(
      RConnection connection,
      String sql)
    {
      this();
      this.connection = connection;
      this.sql = sql;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public prepareCall_args(prepareCall_args other) {
      if (other.isSetConnection()) {
        this.connection = new RConnection(other.connection);
      }
      if (other.isSetSql()) {
        this.sql = other.sql;
      }
    }

    public prepareCall_args deepCopy() {
      return new prepareCall_args(this);
    }

    @Override
    public void clear() {
      this.connection = null;
      this.sql = null;
    }

    public RConnection getConnection() {
      return this.connection;
    }

    public prepareCall_args setConnection(RConnection connection) {
      this.connection = connection;
      return this;
    }

    public void unsetConnection() {
      this.connection = null;
    }

    /** Returns true if field connection is set (has been assigned a value) and false otherwise */
    public boolean isSetConnection() {
      return this.connection != null;
    }

    public void setConnectionIsSet(boolean value) {
      if (!value) {
        this.connection = null;
      }
    }

    public String getSql() {
      return this.sql;
    }

    public prepareCall_args setSql(String sql) {
      this.sql = sql;
      return this;
    }

    public void unsetSql() {
      this.sql = null;
    }

    /** Returns true if field sql is set (has been assigned a value) and false otherwise */
    public boolean isSetSql() {
      return this.sql != null;
    }

    public void setSqlIsSet(boolean value) {
      if (!value) {
        this.sql = null;
      }
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      case CONNECTION:
        if (value == null) {
          unsetConnection();
        } else {
          setConnection((RConnection)value);
        }
        break;

      case SQL:
        if (value == null) {
          unsetSql();
        } else {
          setSql((String)value);
        }
        break;

      }
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      case CONNECTION:
        return getConnection();

      case SQL:
        return getSql();

      }
      throw new IllegalStateException();
    }

    /** Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      if (field == null) {
        throw new IllegalArgumentException();
      }

      switch (field) {
      case CONNECTION:
        return isSetConnection();
      case SQL:
        return isSetSql();
      }
      throw new IllegalStateException();
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof prepareCall_args)
        return this.equals((prepareCall_args)that);
      return false;
    }

    public boolean equals(prepareCall_args that) {
      if (that == null)
        return false;

      boolean this_present_connection = true && this.isSetConnection();
      boolean that_present_connection = true && that.isSetConnection();
      if (this_present_connection || that_present_connection) {
        if (!(this_present_connection && that_present_connection))
          return false;
        if (!this.connection.equals(that.connection))
          return false;
      }

      boolean this_present_sql = true && this.isSetSql();
      boolean that_present_sql = true && that.isSetSql();
      if (this_present_sql || that_present_sql) {
        if (!(this_present_sql && that_present_sql))
          return false;
        if (!this.sql.equals(that.sql))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      List<Object> list = new ArrayList<Object>();

      boolean present_connection = true && (isSetConnection());
      list.add(present_connection);
      if (present_connection)
        list.add(connection);

      boolean present_sql = true && (isSetSql());
      list.add(present_sql);
      if (present_sql)
        list.add(sql);

      return list.hashCode();
    }

    @Override
    public int compareTo(prepareCall_args other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetConnection()).compareTo(other.isSetConnection());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetConnection()) {
        lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.connection, other.connection);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      lastComparison = Boolean.valueOf(isSetSql()).compareTo(other.isSetSql());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetSql()) {
        lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.sql, other.sql);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      return 0;
    }

    public _Fields fieldForId(int fieldId) {
      return _Fields.findByThriftId(fieldId);
    }

    public void read(org.apache.thrift.protocol.TProtocol iprot) throws org.apache.thrift.TException {
      schemes.get(iprot.getScheme()).getScheme().read(iprot, this);
    }

    public void write(org.apache.thrift.protocol.TProtocol oprot) throws org.apache.thrift.TException {
      schemes.get(oprot.getScheme()).getScheme().write(oprot, this);
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("prepareCall_args(");
      boolean first = true;

      sb.append("connection:");
      if (this.connection == null) {
        sb.append("null");
      } else {
        sb.append(this.connection);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("sql:");
      if (this.sql == null) {
        sb.append("null");
      } else {
        sb.append(this.sql);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws org.apache.thrift.TException {
      // check for required fields
      // check for sub-struct validity
      if (connection != null) {
        connection.validate();
      }
    }

    private void writeObject(java.io.ObjectOutputStream out) throws java.io.IOException {
      try {
        write(new org.apache.thrift.protocol.TCompactProtocol(new org.apache.thrift.transport.TIOStreamTransport(out)));
      } catch (org.apache.thrift.TException te) {
        throw new java.io.IOException(te);
      }
    }

    private void readObject(java.io.ObjectInputStream in) throws java.io.IOException, ClassNotFoundException {
      try {
        read(new org.apache.thrift.protocol.TCompactProtocol(new org.apache.thrift.transport.TIOStreamTransport(in)));
      } catch (org.apache.thrift.TException te) {
        throw new java.io.IOException(te);
      }
    }

    private static class prepareCall_argsStandardSchemeFactory implements SchemeFactory {
      public prepareCall_argsStandardScheme getScheme() {
        return new prepareCall_argsStandardScheme();
      }
    }

    private static class prepareCall_argsStandardScheme extends StandardScheme<prepareCall_args> {

      public void read(org.apache.thrift.protocol.TProtocol iprot, prepareCall_args struct) throws org.apache.thrift.TException {
        org.apache.thrift.protocol.TField schemeField;
        iprot.readStructBegin();
        while (true)
        {
          schemeField = iprot.readFieldBegin();
          if (schemeField.type == org.apache.thrift.protocol.TType.STOP) { 
            break;
          }
          switch (schemeField.id) {
            case 1: // CONNECTION
              if (schemeField.type == org.apache.thrift.protocol.TType.STRUCT) {
                struct.connection = new RConnection();
                struct.connection.read(iprot);
                struct.setConnectionIsSet(true);
              } else { 
                org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
              }
              break;
            case 2: // SQL
              if (schemeField.type == org.apache.thrift.protocol.TType.STRING) {
                struct.sql = iprot.readString();
                struct.setSqlIsSet(true);
              } else { 
                org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
              }
              break;
            default:
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
          }
          iprot.readFieldEnd();
        }
        iprot.readStructEnd();

        // check for required fields of primitive type, which can't be checked in the validate method
        struct.validate();
      }

      public void write(org.apache.thrift.protocol.TProtocol oprot, prepareCall_args struct) throws org.apache.thrift.TException {
        struct.validate();

        oprot.writeStructBegin(STRUCT_DESC);
        if (struct.connection != null) {
          oprot.writeFieldBegin(CONNECTION_FIELD_DESC);
          struct.connection.write(oprot);
          oprot.writeFieldEnd();
        }
        if (struct.sql != null) {
          oprot.writeFieldBegin(SQL_FIELD_DESC);
          oprot.writeString(struct.sql);
          oprot.writeFieldEnd();
        }
        oprot.writeFieldStop();
        oprot.writeStructEnd();
      }

    }

    private static class prepareCall_argsTupleSchemeFactory implements SchemeFactory {
      public prepareCall_argsTupleScheme getScheme() {
        return new prepareCall_argsTupleScheme();
      }
    }

    private static class prepareCall_argsTupleScheme extends TupleScheme<prepareCall_args> {

      @Override
      public void write(org.apache.thrift.protocol.TProtocol prot, prepareCall_args struct) throws org.apache.thrift.TException {
        TTupleProtocol oprot = (TTupleProtocol) prot;
        BitSet optionals = new BitSet();
        if (struct.isSetConnection()) {
          optionals.set(0);
        }
        if (struct.isSetSql()) {
          optionals.set(1);
        }
        oprot.writeBitSet(optionals, 2);
        if (struct.isSetConnection()) {
          struct.connection.write(oprot);
        }
        if (struct.isSetSql()) {
          oprot.writeString(struct.sql);
        }
      }

      @Override
      public void read(org.apache.thrift.protocol.TProtocol prot, prepareCall_args struct) throws org.apache.thrift.TException {
        TTupleProtocol iprot = (TTupleProtocol) prot;
        BitSet incoming = iprot.readBitSet(2);
        if (incoming.get(0)) {
          struct.connection = new RConnection();
          struct.connection.read(iprot);
          struct.setConnectionIsSet(true);
        }
        if (incoming.get(1)) {
          struct.sql = iprot.readString();
          struct.setSqlIsSet(true);
        }
      }
    }

  }

  public static class prepareCall_result implements org.apache.thrift.TBase<prepareCall_result, prepareCall_result._Fields>, java.io.Serializable, Cloneable, Comparable<prepareCall_result>   {
    private static final org.apache.thrift.protocol.TStruct STRUCT_DESC = new org.apache.thrift.protocol.TStruct("prepareCall_result");

    private static final org.apache.thrift.protocol.TField SUCCESS_FIELD_DESC = new org.apache.thrift.protocol.TField("success", org.apache.thrift.protocol.TType.STRUCT, (short)0);
    private static final org.apache.thrift.protocol.TField SQL_EXCEPTION_FIELD_DESC = new org.apache.thrift.protocol.TField("sqlException", org.apache.thrift.protocol.TType.STRUCT, (short)1);

    private static final Map<Class<? extends IScheme>, SchemeFactory> schemes = new HashMap<Class<? extends IScheme>, SchemeFactory>();
    static {
      schemes.put(StandardScheme.class, new prepareCall_resultStandardSchemeFactory());
      schemes.put(TupleScheme.class, new prepareCall_resultTupleSchemeFactory());
    }

    public RStatement success; // required
    public RSQLException sqlException; // required

    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements org.apache.thrift.TFieldIdEnum {
      SUCCESS((short)0, "success"),
      SQL_EXCEPTION((short)1, "sqlException");

      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        switch(fieldId) {
          case 0: // SUCCESS
            return SUCCESS;
          case 1: // SQL_EXCEPTION
            return SQL_EXCEPTION;
          default:
            return null;
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }

    // isset id assignments
    public static final Map<_Fields, org.apache.thrift.meta_data.FieldMetaData> metaDataMap;
    static {
      Map<_Fields, org.apache.thrift.meta_data.FieldMetaData> tmpMap = new EnumMap<_Fields, org.apache.thrift.meta_data.FieldMetaData>(_Fields.class);
      tmpMap.put(_Fields.SUCCESS, new org.apache.thrift.meta_data.FieldMetaData("success", org.apache.thrift.TFieldRequirementType.DEFAULT, 
          new org.apache.thrift.meta_data.StructMetaData(org.apache.thrift.protocol.TType.STRUCT, RStatement.class)));
      tmpMap.put(_Fields.SQL_EXCEPTION, new org.apache.thrift.meta_data.FieldMetaData("sqlException", org.apache.thrift.TFieldRequirementType.DEFAULT, 
          new org.apache.thrift.meta_data.FieldValueMetaData(org.apache.thrift.protocol.TType.STRUCT)));
      metaDataMap = Collections.unmodifiableMap(tmpMap);
      org.apache.thrift.meta_data.FieldMetaData.addStructMetaDataMap(prepareCall_result.class, metaDataMap);
    }

    public prepareCall_result() {
    }

    public prepareCall_result(
      RStatement success,
      RSQLException sqlException)
    {
      this();
      this.success = success;
      this.sqlException = sqlException;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public prepareCall_result(prepareCall_result other) {
      if (other.isSetSuccess()) {
        this.success = new RStatement(other.success);
      }
      if (other.isSetSqlException()) {
        this.sqlException = new RSQLException(other.sqlException);
      }
    }

    public prepareCall_result deepCopy() {
      return new prepareCall_result(this);
    }

    @Override
    public void clear() {
      this.success = null;
      this.sqlException = null;
    }

    public RStatement getSuccess() {
      return this.success;
    }

    public prepareCall_result setSuccess(RStatement success) {
      this.success = success;
      return this;
    }

    public void unsetSuccess() {
      this.success = null;
    }

    /** Returns true if field success is set (has been assigned a value) and false otherwise */
    public boolean isSetSuccess() {
      return this.success != null;
    }

    public void setSuccessIsSet(boolean value) {
      if (!value) {
        this.success = null;
      }
    }

    public RSQLException getSqlException() {
      return this.sqlException;
    }

    public prepareCall_result setSqlException(RSQLException sqlException) {
      this.sqlException = sqlException;
      return this;
    }

    public void unsetSqlException() {
      this.sqlException = null;
    }

    /** Returns true if field sqlException is set (has been assigned a value) and false otherwise */
    public boolean isSetSqlException() {
      return this.sqlException != null;
    }

    public void setSqlExceptionIsSet(boolean value) {
      if (!value) {
        this.sqlException = null;
      }
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          setSuccess((RStatement)value);
        }
        break;

      case SQL_EXCEPTION:
        if (value == null) {
          unsetSqlException();
        } else {
          setSqlException((RSQLException)value);
        }
        break;

      }
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      case SUCCESS:
        return getSuccess();

      case SQL_EXCEPTION:
        return getSqlException();

      }
      throw new IllegalStateException();
    }

    /** Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      if (field == null) {
        throw new IllegalArgumentException();
      }

      switch (field) {
      case SUCCESS:
        return isSetSuccess();
      case SQL_EXCEPTION:
        return isSetSqlException();
      }
      throw new IllegalStateException();
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof prepareCall_result)
        return this.equals((prepareCall_result)that);
      return false;
    }

    public boolean equals(prepareCall_result that) {
      if (that == null)
        return false;

      boolean this_present_success = true && this.isSetSuccess();
      boolean that_present_success = true && that.isSetSuccess();
      if (this_present_success || that_present_success) {
        if (!(this_present_success && that_present_success))
          return false;
        if (!this.success.equals(that.success))
          return false;
      }

      boolean this_present_sqlException = true && this.isSetSqlException();
      boolean that_present_sqlException = true && that.isSetSqlException();
      if (this_present_sqlException || that_present_sqlException) {
        if (!(this_present_sqlException && that_present_sqlException))
          return false;
        if (!this.sqlException.equals(that.sqlException))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      List<Object> list = new ArrayList<Object>();

      boolean present_success = true && (isSetSuccess());
      list.add(present_success);
      if (present_success)
        list.add(success);

      boolean present_sqlException = true && (isSetSqlException());
      list.add(present_sqlException);
      if (present_sqlException)
        list.add(sqlException);

      return list.hashCode();
    }

    @Override
    public int compareTo(prepareCall_result other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetSuccess()).compareTo(other.isSetSuccess());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetSuccess()) {
        lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.success, other.success);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      lastComparison = Boolean.valueOf(isSetSqlException()).compareTo(other.isSetSqlException());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetSqlException()) {
        lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.sqlException, other.sqlException);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      return 0;
    }

    public _Fields fieldForId(int fieldId) {
      return _Fields.findByThriftId(fieldId);
    }

    public void read(org.apache.thrift.protocol.TProtocol iprot) throws org.apache.thrift.TException {
      schemes.get(iprot.getScheme()).getScheme().read(iprot, this);
    }

    public void write(org.apache.thrift.protocol.TProtocol oprot) throws org.apache.thrift.TException {
      schemes.get(oprot.getScheme()).getScheme().write(oprot, this);
      }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("prepareCall_result(");
      boolean first = true;

      sb.append("success:");
      if (this.success == null) {
        sb.append("null");
      } else {
        sb.append(this.success);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("sqlException:");
      if (this.sqlException == null) {
        sb.append("null");
      } else {
        sb.append(this.sqlException);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws org.apache.thrift.TException {
      // check for required fields
      // check for sub-struct validity
      if (success != null) {
        success.validate();
      }
    }

    private void writeObject(java.io.ObjectOutputStream out) throws java.io.IOException {
      try {
        write(new org.apache.thrift.protocol.TCompactProtocol(new org.apache.thrift.transport.TIOStreamTransport(out)));
      } catch (org.apache.thrift.TException te) {
        throw new java.io.IOException(te);
      }
    }

    private void readObject(java.io.ObjectInputStream in) throws java.io.IOException, ClassNotFoundException {
      try {
        read(new org.apache.thrift.protocol.TCompactProtocol(new org.apache.thrift.transport.TIOStreamTransport(in)));
      } catch (org.apache.thrift.TException te) {
        throw new java.io.IOException(te);
      }
    }

    private static class prepareCall_resultStandardSchemeFactory implements SchemeFactory {
      public prepareCall_resultStandardScheme getScheme() {
        return new prepareCall_resultStandardScheme();
      }
    }

    private static class prepareCall_resultStandardScheme extends StandardScheme<prepareCall_result> {

      public void read(org.apache.thrift.protocol.TProtocol iprot, prepareCall_result struct) throws org.apache.thrift.TException {
        org.apache.thrift.protocol.TField schemeField;
        iprot.readStructBegin();
        while (true)
        {
          schemeField = iprot.readFieldBegin();
          if (schemeField.type == org.apache.thrift.protocol.TType.STOP) { 
            break;
          }
          switch (schemeField.id) {
            case 0: // SUCCESS
              if (schemeField.type == org.apache.thrift.protocol.TType.STRUCT) {
                struct.success = new RStatement();
                struct.success.read(iprot);
                struct.setSuccessIsSet(true);
              } else { 
                org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
              }
              break;
            case 1: // SQL_EXCEPTION
              if (schemeField.type == org.apache.thrift.protocol.TType.STRUCT) {
                struct.sqlException = new RSQLException();
                struct.sqlException.read(iprot);
                struct.setSqlExceptionIsSet(true);
              } else { 
                org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
              }
              break;
            default:
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
          }
          iprot.readFieldEnd();
        }
        iprot.readStructEnd();

        // check for required fields of primitive type, which can't be checked in the validate method
        struct.validate();
      }

      public void write(org.apache.thrift.protocol.TProtocol oprot, prepareCall_result struct) throws org.apache.thrift.TException {
        struct.validate();

        oprot.writeStructBegin(STRUCT_DESC);
        if (struct.success != null) {
          oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
          struct.success.write(oprot);
          oprot.writeFieldEnd();
        }
        if (struct.sqlException != null) {
          oprot.writeFieldBegin(SQL_EXCEPTION_FIELD_DESC);
          struct.sqlException.write(oprot);
          oprot.writeFieldEnd();
        }
        oprot.writeFieldStop();
        oprot.writeStructEnd();
      }

    }

    private static class prepareCall_resultTupleSchemeFactory implements SchemeFactory {
      public prepareCall_resultTupleScheme getScheme() {
        return new prepareCall_resultTupleScheme();
      }
    }

    private static class prepareCall_resultTupleScheme extends TupleScheme<prepareCall_result> {

      @Override
      public void write(org.apache.thrift.protocol.TProtocol prot, prepareCall_result struct) throws org.apache.thrift.TException {
        TTupleProtocol oprot = (TTupleProtocol) prot;
        BitSet optionals = new BitSet();
        if (struct.isSetSuccess()) {
          optionals.set(0);
        }
        if (struct.isSetSqlException()) {
          optionals.set(1);
        }
        oprot.writeBitSet(optionals, 2);
        if (struct.isSetSuccess()) {
          struct.success.write(oprot);
        }
        if (struct.isSetSqlException()) {
          struct.sqlException.write(oprot);
        }
      }

      @Override
      public void read(org.apache.thrift.protocol.TProtocol prot, prepareCall_result struct) throws org.apache.thrift.TException {
        TTupleProtocol iprot = (TTupleProtocol) prot;
        BitSet incoming = iprot.readBitSet(2);
        if (incoming.get(0)) {
          struct.success = new RStatement();
          struct.success.read(iprot);
          struct.setSuccessIsSet(true);
        }
        if (incoming.get(1)) {
          struct.sqlException = new RSQLException();
          struct.sqlException.read(iprot);
          struct.setSqlExceptionIsSet(true);
        }
      }
    }

  }

  public static class connection_getstaticmetadata_args implements org.apache.thrift.TBase<connection_getstaticmetadata_args, connection_getstaticmetadata_args._Fields>, java.io.Serializable, Cloneable, Comparable<connection_getstaticmetadata_args>   {
    private static final org.apache.thrift.protocol.TStruct STRUCT_DESC = new org.apache.thrift.protocol.TStruct("connection_getstaticmetadata_args");

    private static final org.apache.thrift.protocol.TField CONNECTION_FIELD_DESC = new org.apache.thrift.protocol.TField("connection", org.apache.thrift.protocol.TType.STRUCT, (short)1);

    private static final Map<Class<? extends IScheme>, SchemeFactory> schemes = new HashMap<Class<? extends IScheme>, SchemeFactory>();
    static {
      schemes.put(StandardScheme.class, new connection_getstaticmetadata_argsStandardSchemeFactory());
      schemes.put(TupleScheme.class, new connection_getstaticmetadata_argsTupleSchemeFactory());
    }

    public RConnection connection; // required

    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements org.apache.thrift.TFieldIdEnum {
      CONNECTION((short)1, "connection");

      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        switch(fieldId) {
          case 1: // CONNECTION
            return CONNECTION;
          default:
            return null;
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }

    // isset id assignments
    public static final Map<_Fields, org.apache.thrift.meta_data.FieldMetaData> metaDataMap;
    static {
      Map<_Fields, org.apache.thrift.meta_data.FieldMetaData> tmpMap = new EnumMap<_Fields, org.apache.thrift.meta_data.FieldMetaData>(_Fields.class);
      tmpMap.put(_Fields.CONNECTION, new org.apache.thrift.meta_data.FieldMetaData("connection", org.apache.thrift.TFieldRequirementType.DEFAULT, 
          new org.apache.thrift.meta_data.StructMetaData(org.apache.thrift.protocol.TType.STRUCT, RConnection.class)));
      metaDataMap = Collections.unmodifiableMap(tmpMap);
      org.apache.thrift.meta_data.FieldMetaData.addStructMetaDataMap(connection_getstaticmetadata_args.class, metaDataMap);
    }

    public connection_getstaticmetadata_args() {
    }

    public connection_getstaticmetadata_args(
      RConnection connection)
    {
      this();
      this.connection = connection;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public connection_getstaticmetadata_args(connection_getstaticmetadata_args other) {
      if (other.isSetConnection()) {
        this.connection = new RConnection(other.connection);
      }
    }

    public connection_getstaticmetadata_args deepCopy() {
      return new connection_getstaticmetadata_args(this);
    }

    @Override
    public void clear() {
      this.connection = null;
    }

    public RConnection getConnection() {
      return this.connection;
    }

    public connection_getstaticmetadata_args setConnection(RConnection connection) {
      this.connection = connection;
      return this;
    }

    public void unsetConnection() {
      this.connection = null;
    }

    /** Returns true if field connection is set (has been assigned a value) and false otherwise */
    public boolean isSetConnection() {
      return this.connection != null;
    }

    public void setConnectionIsSet(boolean value) {
      if (!value) {
        this.connection = null;
      }
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      case CONNECTION:
        if (value == null) {
          unsetConnection();
        } else {
          setConnection((RConnection)value);
        }
        break;

      }
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      case CONNECTION:
        return getConnection();

      }
      throw new IllegalStateException();
    }

    /** Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      if (field == null) {
        throw new IllegalArgumentException();
      }

      switch (field) {
      case CONNECTION:
        return isSetConnection();
      }
      throw new IllegalStateException();
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof connection_getstaticmetadata_args)
        return this.equals((connection_getstaticmetadata_args)that);
      return false;
    }

    public boolean equals(connection_getstaticmetadata_args that) {
      if (that == null)
        return false;

      boolean this_present_connection = true && this.isSetConnection();
      boolean that_present_connection = true && that.isSetConnection();
      if (this_present_connection || that_present_connection) {
        if (!(this_present_connection && that_present_connection))
          return false;
        if (!this.connection.equals(that.connection))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      List<Object> list = new ArrayList<Object>();

      boolean present_connection = true && (isSetConnection());
      list.add(present_connection);
      if (present_connection)
        list.add(connection);

      return list.hashCode();
    }

    @Override
    public int compareTo(connection_getstaticmetadata_args other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetConnection()).compareTo(other.isSetConnection());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetConnection()) {
        lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.connection, other.connection);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      return 0;
    }

    public _Fields fieldForId(int fieldId) {
      return _Fields.findByThriftId(fieldId);
    }

    public void read(org.apache.thrift.protocol.TProtocol iprot) throws org.apache.thrift.TException {
      schemes.get(iprot.getScheme()).getScheme().read(iprot, this);
    }

    public void write(org.apache.thrift.protocol.TProtocol oprot) throws org.apache.thrift.TException {
      schemes.get(oprot.getScheme()).getScheme().write(oprot, this);
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("connection_getstaticmetadata_args(");
      boolean first = true;

      sb.append("connection:");
      if (this.connection == null) {
        sb.append("null");
      } else {
        sb.append(this.connection);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws org.apache.thrift.TException {
      // check for required fields
      // check for sub-struct validity
      if (connection != null) {
        connection.validate();
      }
    }

    private void writeObject(java.io.ObjectOutputStream out) throws java.io.IOException {
      try {
        write(new org.apache.thrift.protocol.TCompactProtocol(new org.apache.thrift.transport.TIOStreamTransport(out)));
      } catch (org.apache.thrift.TException te) {
        throw new java.io.IOException(te);
      }
    }

    private void readObject(java.io.ObjectInputStream in) throws java.io.IOException, ClassNotFoundException {
      try {
        read(new org.apache.thrift.protocol.TCompactProtocol(new org.apache.thrift.transport.TIOStreamTransport(in)));
      } catch (org.apache.thrift.TException te) {
        throw new java.io.IOException(te);
      }
    }

    private static class connection_getstaticmetadata_argsStandardSchemeFactory implements SchemeFactory {
      public connection_getstaticmetadata_argsStandardScheme getScheme() {
        return new connection_getstaticmetadata_argsStandardScheme();
      }
    }

    private static class connection_getstaticmetadata_argsStandardScheme extends StandardScheme<connection_getstaticmetadata_args> {

      public void read(org.apache.thrift.protocol.TProtocol iprot, connection_getstaticmetadata_args struct) throws org.apache.thrift.TException {
        org.apache.thrift.protocol.TField schemeField;
        iprot.readStructBegin();
        while (true)
        {
          schemeField = iprot.readFieldBegin();
          if (schemeField.type == org.apache.thrift.protocol.TType.STOP) { 
            break;
          }
          switch (schemeField.id) {
            case 1: // CONNECTION
              if (schemeField.type == org.apache.thrift.protocol.TType.STRUCT) {
                struct.connection = new RConnection();
                struct.connection.read(iprot);
                struct.setConnectionIsSet(true);
              } else { 
                org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
              }
              break;
            default:
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
          }
          iprot.readFieldEnd();
        }
        iprot.readStructEnd();

        // check for required fields of primitive type, which can't be checked in the validate method
        struct.validate();
      }

      public void write(org.apache.thrift.protocol.TProtocol oprot, connection_getstaticmetadata_args struct) throws org.apache.thrift.TException {
        struct.validate();

        oprot.writeStructBegin(STRUCT_DESC);
        if (struct.connection != null) {
          oprot.writeFieldBegin(CONNECTION_FIELD_DESC);
          struct.connection.write(oprot);
          oprot.writeFieldEnd();
        }
        oprot.writeFieldStop();
        oprot.writeStructEnd();
      }

    }

    private static class connection_getstaticmetadata_argsTupleSchemeFactory implements SchemeFactory {
      public connection_getstaticmetadata_argsTupleScheme getScheme() {
        return new connection_getstaticmetadata_argsTupleScheme();
      }
    }

    private static class connection_getstaticmetadata_argsTupleScheme extends TupleScheme<connection_getstaticmetadata_args> {

      @Override
      public void write(org.apache.thrift.protocol.TProtocol prot, connection_getstaticmetadata_args struct) throws org.apache.thrift.TException {
        TTupleProtocol oprot = (TTupleProtocol) prot;
        BitSet optionals = new BitSet();
        if (struct.isSetConnection()) {
          optionals.set(0);
        }
        oprot.writeBitSet(optionals, 1);
        if (struct.isSetConnection()) {
          struct.connection.write(oprot);
        }
      }

      @Override
      public void read(org.apache.thrift.protocol.TProtocol prot, connection_getstaticmetadata_args struct) throws org.apache.thrift.TException {
        TTupleProtocol iprot = (TTupleProtocol) prot;
        BitSet incoming = iprot.readBitSet(1);
        if (incoming.get(0)) {
          struct.connection = new RConnection();
          struct.connection.read(iprot);
          struct.setConnectionIsSet(true);
        }
      }
    }

  }

  public static class connection_getstaticmetadata_result implements org.apache.thrift.TBase<connection_getstaticmetadata_result, connection_getstaticmetadata_result._Fields>, java.io.Serializable, Cloneable, Comparable<connection_getstaticmetadata_result>   {
    private static final org.apache.thrift.protocol.TStruct STRUCT_DESC = new org.apache.thrift.protocol.TStruct("connection_getstaticmetadata_result");

    private static final org.apache.thrift.protocol.TField SUCCESS_FIELD_DESC = new org.apache.thrift.protocol.TField("success", org.apache.thrift.protocol.TType.STRUCT, (short)0);
    private static final org.apache.thrift.protocol.TField SQL_EXCEPTION_FIELD_DESC = new org.apache.thrift.protocol.TField("sqlException", org.apache.thrift.protocol.TType.STRUCT, (short)1);

    private static final Map<Class<? extends IScheme>, SchemeFactory> schemes = new HashMap<Class<? extends IScheme>, SchemeFactory>();
    static {
      schemes.put(StandardScheme.class, new connection_getstaticmetadata_resultStandardSchemeFactory());
      schemes.put(TupleScheme.class, new connection_getstaticmetadata_resultTupleSchemeFactory());
    }

    public RStaticMetaData success; // required
    public RSQLException sqlException; // required

    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements org.apache.thrift.TFieldIdEnum {
      SUCCESS((short)0, "success"),
      SQL_EXCEPTION((short)1, "sqlException");

      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        switch(fieldId) {
          case 0: // SUCCESS
            return SUCCESS;
          case 1: // SQL_EXCEPTION
            return SQL_EXCEPTION;
          default:
            return null;
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }

    // isset id assignments
    public static final Map<_Fields, org.apache.thrift.meta_data.FieldMetaData> metaDataMap;
    static {
      Map<_Fields, org.apache.thrift.meta_data.FieldMetaData> tmpMap = new EnumMap<_Fields, org.apache.thrift.meta_data.FieldMetaData>(_Fields.class);
      tmpMap.put(_Fields.SUCCESS, new org.apache.thrift.meta_data.FieldMetaData("success", org.apache.thrift.TFieldRequirementType.DEFAULT, 
          new org.apache.thrift.meta_data.StructMetaData(org.apache.thrift.protocol.TType.STRUCT, RStaticMetaData.class)));
      tmpMap.put(_Fields.SQL_EXCEPTION, new org.apache.thrift.meta_data.FieldMetaData("sqlException", org.apache.thrift.TFieldRequirementType.DEFAULT, 
          new org.apache.thrift.meta_data.FieldValueMetaData(org.apache.thrift.protocol.TType.STRUCT)));
      metaDataMap = Collections.unmodifiableMap(tmpMap);
      org.apache.thrift.meta_data.FieldMetaData.addStructMetaDataMap(connection_getstaticmetadata_result.class, metaDataMap);
    }

    public connection_getstaticmetadata_result() {
    }

    public connection_getstaticmetadata_result(
      RStaticMetaData success,
      RSQLException sqlException)
    {
      this();
      this.success = success;
      this.sqlException = sqlException;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public connection_getstaticmetadata_result(connection_getstaticmetadata_result other) {
      if (other.isSetSuccess()) {
        this.success = new RStaticMetaData(other.success);
      }
      if (other.isSetSqlException()) {
        this.sqlException = new RSQLException(other.sqlException);
      }
    }

    public connection_getstaticmetadata_result deepCopy() {
      return new connection_getstaticmetadata_result(this);
    }

    @Override
    public void clear() {
      this.success = null;
      this.sqlException = null;
    }

    public RStaticMetaData getSuccess() {
      return this.success;
    }

    public connection_getstaticmetadata_result setSuccess(RStaticMetaData success) {
      this.success = success;
      return this;
    }

    public void unsetSuccess() {
      this.success = null;
    }

    /** Returns true if field success is set (has been assigned a value) and false otherwise */
    public boolean isSetSuccess() {
      return this.success != null;
    }

    public void setSuccessIsSet(boolean value) {
      if (!value) {
        this.success = null;
      }
    }

    public RSQLException getSqlException() {
      return this.sqlException;
    }

    public connection_getstaticmetadata_result setSqlException(RSQLException sqlException) {
      this.sqlException = sqlException;
      return this;
    }

    public void unsetSqlException() {
      this.sqlException = null;
    }

    /** Returns true if field sqlException is set (has been assigned a value) and false otherwise */
    public boolean isSetSqlException() {
      return this.sqlException != null;
    }

    public void setSqlExceptionIsSet(boolean value) {
      if (!value) {
        this.sqlException = null;
      }
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          setSuccess((RStaticMetaData)value);
        }
        break;

      case SQL_EXCEPTION:
        if (value == null) {
          unsetSqlException();
        } else {
          setSqlException((RSQLException)value);
        }
        break;

      }
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      case SUCCESS:
        return getSuccess();

      case SQL_EXCEPTION:
        return getSqlException();

      }
      throw new IllegalStateException();
    }

    /** Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      if (field == null) {
        throw new IllegalArgumentException();
      }

      switch (field) {
      case SUCCESS:
        return isSetSuccess();
      case SQL_EXCEPTION:
        return isSetSqlException();
      }
      throw new IllegalStateException();
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof connection_getstaticmetadata_result)
        return this.equals((connection_getstaticmetadata_result)that);
      return false;
    }

    public boolean equals(connection_getstaticmetadata_result that) {
      if (that == null)
        return false;

      boolean this_present_success = true && this.isSetSuccess();
      boolean that_present_success = true && that.isSetSuccess();
      if (this_present_success || that_present_success) {
        if (!(this_present_success && that_present_success))
          return false;
        if (!this.success.equals(that.success))
          return false;
      }

      boolean this_present_sqlException = true && this.isSetSqlException();
      boolean that_present_sqlException = true && that.isSetSqlException();
      if (this_present_sqlException || that_present_sqlException) {
        if (!(this_present_sqlException && that_present_sqlException))
          return false;
        if (!this.sqlException.equals(that.sqlException))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      List<Object> list = new ArrayList<Object>();

      boolean present_success = true && (isSetSuccess());
      list.add(present_success);
      if (present_success)
        list.add(success);

      boolean present_sqlException = true && (isSetSqlException());
      list.add(present_sqlException);
      if (present_sqlException)
        list.add(sqlException);

      return list.hashCode();
    }

    @Override
    public int compareTo(connection_getstaticmetadata_result other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetSuccess()).compareTo(other.isSetSuccess());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetSuccess()) {
        lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.success, other.success);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      lastComparison = Boolean.valueOf(isSetSqlException()).compareTo(other.isSetSqlException());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetSqlException()) {
        lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.sqlException, other.sqlException);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      return 0;
    }

    public _Fields fieldForId(int fieldId) {
      return _Fields.findByThriftId(fieldId);
    }

    public void read(org.apache.thrift.protocol.TProtocol iprot) throws org.apache.thrift.TException {
      schemes.get(iprot.getScheme()).getScheme().read(iprot, this);
    }

    public void write(org.apache.thrift.protocol.TProtocol oprot) throws org.apache.thrift.TException {
      schemes.get(oprot.getScheme()).getScheme().write(oprot, this);
      }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("connection_getstaticmetadata_result(");
      boolean first = true;

      sb.append("success:");
      if (this.success == null) {
        sb.append("null");
      } else {
        sb.append(this.success);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("sqlException:");
      if (this.sqlException == null) {
        sb.append("null");
      } else {
        sb.append(this.sqlException);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws org.apache.thrift.TException {
      // check for required fields
      // check for sub-struct validity
      if (success != null) {
        success.validate();
      }
    }

    private void writeObject(java.io.ObjectOutputStream out) throws java.io.IOException {
      try {
        write(new org.apache.thrift.protocol.TCompactProtocol(new org.apache.thrift.transport.TIOStreamTransport(out)));
      } catch (org.apache.thrift.TException te) {
        throw new java.io.IOException(te);
      }
    }

    private void readObject(java.io.ObjectInputStream in) throws java.io.IOException, ClassNotFoundException {
      try {
        read(new org.apache.thrift.protocol.TCompactProtocol(new org.apache.thrift.transport.TIOStreamTransport(in)));
      } catch (org.apache.thrift.TException te) {
        throw new java.io.IOException(te);
      }
    }

    private static class connection_getstaticmetadata_resultStandardSchemeFactory implements SchemeFactory {
      public connection_getstaticmetadata_resultStandardScheme getScheme() {
        return new connection_getstaticmetadata_resultStandardScheme();
      }
    }

    private static class connection_getstaticmetadata_resultStandardScheme extends StandardScheme<connection_getstaticmetadata_result> {

      public void read(org.apache.thrift.protocol.TProtocol iprot, connection_getstaticmetadata_result struct) throws org.apache.thrift.TException {
        org.apache.thrift.protocol.TField schemeField;
        iprot.readStructBegin();
        while (true)
        {
          schemeField = iprot.readFieldBegin();
          if (schemeField.type == org.apache.thrift.protocol.TType.STOP) { 
            break;
          }
          switch (schemeField.id) {
            case 0: // SUCCESS
              if (schemeField.type == org.apache.thrift.protocol.TType.STRUCT) {
                struct.success = new RStaticMetaData();
                struct.success.read(iprot);
                struct.setSuccessIsSet(true);
              } else { 
                org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
              }
              break;
            case 1: // SQL_EXCEPTION
              if (schemeField.type == org.apache.thrift.protocol.TType.STRUCT) {
                struct.sqlException = new RSQLException();
                struct.sqlException.read(iprot);
                struct.setSqlExceptionIsSet(true);
              } else { 
                org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
              }
              break;
            default:
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
          }
          iprot.readFieldEnd();
        }
        iprot.readStructEnd();

        // check for required fields of primitive type, which can't be checked in the validate method
        struct.validate();
      }

      public void write(org.apache.thrift.protocol.TProtocol oprot, connection_getstaticmetadata_result struct) throws org.apache.thrift.TException {
        struct.validate();

        oprot.writeStructBegin(STRUCT_DESC);
        if (struct.success != null) {
          oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
          struct.success.write(oprot);
          oprot.writeFieldEnd();
        }
        if (struct.sqlException != null) {
          oprot.writeFieldBegin(SQL_EXCEPTION_FIELD_DESC);
          struct.sqlException.write(oprot);
          oprot.writeFieldEnd();
        }
        oprot.writeFieldStop();
        oprot.writeStructEnd();
      }

    }

    private static class connection_getstaticmetadata_resultTupleSchemeFactory implements SchemeFactory {
      public connection_getstaticmetadata_resultTupleScheme getScheme() {
        return new connection_getstaticmetadata_resultTupleScheme();
      }
    }

    private static class connection_getstaticmetadata_resultTupleScheme extends TupleScheme<connection_getstaticmetadata_result> {

      @Override
      public void write(org.apache.thrift.protocol.TProtocol prot, connection_getstaticmetadata_result struct) throws org.apache.thrift.TException {
        TTupleProtocol oprot = (TTupleProtocol) prot;
        BitSet optionals = new BitSet();
        if (struct.isSetSuccess()) {
          optionals.set(0);
        }
        if (struct.isSetSqlException()) {
          optionals.set(1);
        }
        oprot.writeBitSet(optionals, 2);
        if (struct.isSetSuccess()) {
          struct.success.write(oprot);
        }
        if (struct.isSetSqlException()) {
          struct.sqlException.write(oprot);
        }
      }

      @Override
      public void read(org.apache.thrift.protocol.TProtocol prot, connection_getstaticmetadata_result struct) throws org.apache.thrift.TException {
        TTupleProtocol iprot = (TTupleProtocol) prot;
        BitSet incoming = iprot.readBitSet(2);
        if (incoming.get(0)) {
          struct.success = new RStaticMetaData();
          struct.success.read(iprot);
          struct.setSuccessIsSet(true);
        }
        if (incoming.get(1)) {
          struct.sqlException = new RSQLException();
          struct.sqlException.read(iprot);
          struct.setSqlExceptionIsSet(true);
        }
      }
    }

  }

  public static class connection_isvalid_args implements org.apache.thrift.TBase<connection_isvalid_args, connection_isvalid_args._Fields>, java.io.Serializable, Cloneable, Comparable<connection_isvalid_args>   {
    private static final org.apache.thrift.protocol.TStruct STRUCT_DESC = new org.apache.thrift.protocol.TStruct("connection_isvalid_args");

    private static final org.apache.thrift.protocol.TField CONNECTION_FIELD_DESC = new org.apache.thrift.protocol.TField("connection", org.apache.thrift.protocol.TType.STRUCT, (short)1);
    private static final org.apache.thrift.protocol.TField TIMEOUT_FIELD_DESC = new org.apache.thrift.protocol.TField("timeout", org.apache.thrift.protocol.TType.I32, (short)2);

    private static final Map<Class<? extends IScheme>, SchemeFactory> schemes = new HashMap<Class<? extends IScheme>, SchemeFactory>();
    static {
      schemes.put(StandardScheme.class, new connection_isvalid_argsStandardSchemeFactory());
      schemes.put(TupleScheme.class, new connection_isvalid_argsTupleSchemeFactory());
    }

    public RConnection connection; // required
    public int timeout; // required

    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements org.apache.thrift.TFieldIdEnum {
      CONNECTION((short)1, "connection"),
      TIMEOUT((short)2, "timeout");

      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        switch(fieldId) {
          case 1: // CONNECTION
            return CONNECTION;
          case 2: // TIMEOUT
            return TIMEOUT;
          default:
            return null;
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }

    // isset id assignments
    private static final int __TIMEOUT_ISSET_ID = 0;
    private byte __isset_bitfield = 0;
    public static final Map<_Fields, org.apache.thrift.meta_data.FieldMetaData> metaDataMap;
    static {
      Map<_Fields, org.apache.thrift.meta_data.FieldMetaData> tmpMap = new EnumMap<_Fields, org.apache.thrift.meta_data.FieldMetaData>(_Fields.class);
      tmpMap.put(_Fields.CONNECTION, new org.apache.thrift.meta_data.FieldMetaData("connection", org.apache.thrift.TFieldRequirementType.DEFAULT, 
          new org.apache.thrift.meta_data.StructMetaData(org.apache.thrift.protocol.TType.STRUCT, RConnection.class)));
      tmpMap.put(_Fields.TIMEOUT, new org.apache.thrift.meta_data.FieldMetaData("timeout", org.apache.thrift.TFieldRequirementType.DEFAULT, 
          new org.apache.thrift.meta_data.FieldValueMetaData(org.apache.thrift.protocol.TType.I32)));
      metaDataMap = Collections.unmodifiableMap(tmpMap);
      org.apache.thrift.meta_data.FieldMetaData.addStructMetaDataMap(connection_isvalid_args.class, metaDataMap);
    }

    public connection_isvalid_args() {
    }

    public connection_isvalid_args(
      RConnection connection,
      int timeout)
    {
      this();
      this.connection = connection;
      this.timeout = timeout;
      setTimeoutIsSet(true);
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public connection_isvalid_args(connection_isvalid_args other) {
      __isset_bitfield = other.__isset_bitfield;
      if (other.isSetConnection()) {
        this.connection = new RConnection(other.connection);
      }
      this.timeout = other.timeout;
    }

    public connection_isvalid_args deepCopy() {
      return new connection_isvalid_args(this);
    }

    @Override
    public void clear() {
      this.connection = null;
      setTimeoutIsSet(false);
      this.timeout = 0;
    }

    public RConnection getConnection() {
      return this.connection;
    }

    public connection_isvalid_args setConnection(RConnection connection) {
      this.connection = connection;
      return this;
    }

    public void unsetConnection() {
      this.connection = null;
    }

    /** Returns true if field connection is set (has been assigned a value) and false otherwise */
    public boolean isSetConnection() {
      return this.connection != null;
    }

    public void setConnectionIsSet(boolean value) {
      if (!value) {
        this.connection = null;
      }
    }

    public int getTimeout() {
      return this.timeout;
    }

    public connection_isvalid_args setTimeout(int timeout) {
      this.timeout = timeout;
      setTimeoutIsSet(true);
      return this;
    }

    public void unsetTimeout() {
      __isset_bitfield = EncodingUtils.clearBit(__isset_bitfield, __TIMEOUT_ISSET_ID);
    }

    /** Returns true if field timeout is set (has been assigned a value) and false otherwise */
    public boolean isSetTimeout() {
      return EncodingUtils.testBit(__isset_bitfield, __TIMEOUT_ISSET_ID);
    }

    public void setTimeoutIsSet(boolean value) {
      __isset_bitfield = EncodingUtils.setBit(__isset_bitfield, __TIMEOUT_ISSET_ID, value);
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      case CONNECTION:
        if (value == null) {
          unsetConnection();
        } else {
          setConnection((RConnection)value);
        }
        break;

      case TIMEOUT:
        if (value == null) {
          unsetTimeout();
        } else {
          setTimeout((Integer)value);
        }
        break;

      }
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      case CONNECTION:
        return getConnection();

      case TIMEOUT:
        return Integer.valueOf(getTimeout());

      }
      throw new IllegalStateException();
    }

    /** Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      if (field == null) {
        throw new IllegalArgumentException();
      }

      switch (field) {
      case CONNECTION:
        return isSetConnection();
      case TIMEOUT:
        return isSetTimeout();
      }
      throw new IllegalStateException();
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof connection_isvalid_args)
        return this.equals((connection_isvalid_args)that);
      return false;
    }

    public boolean equals(connection_isvalid_args that) {
      if (that == null)
        return false;

      boolean this_present_connection = true && this.isSetConnection();
      boolean that_present_connection = true && that.isSetConnection();
      if (this_present_connection || that_present_connection) {
        if (!(this_present_connection && that_present_connection))
          return false;
        if (!this.connection.equals(that.connection))
          return false;
      }

      boolean this_present_timeout = true;
      boolean that_present_timeout = true;
      if (this_present_timeout || that_present_timeout) {
        if (!(this_present_timeout && that_present_timeout))
          return false;
        if (this.timeout != that.timeout)
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      List<Object> list = new ArrayList<Object>();

      boolean present_connection = true && (isSetConnection());
      list.add(present_connection);
      if (present_connection)
        list.add(connection);

      boolean present_timeout = true;
      list.add(present_timeout);
      if (present_timeout)
        list.add(timeout);

      return list.hashCode();
    }

    @Override
    public int compareTo(connection_isvalid_args other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetConnection()).compareTo(other.isSetConnection());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetConnection()) {
        lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.connection, other.connection);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      lastComparison = Boolean.valueOf(isSetTimeout()).compareTo(other.isSetTimeout());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetTimeout()) {
        lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.timeout, other.timeout);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      return 0;
    }

    public _Fields fieldForId(int fieldId) {
      return _Fields.findByThriftId(fieldId);
    }

    public void read(org.apache.thrift.protocol.TProtocol iprot) throws org.apache.thrift.TException {
      schemes.get(iprot.getScheme()).getScheme().read(iprot, this);
    }

    public void write(org.apache.thrift.protocol.TProtocol oprot) throws org.apache.thrift.TException {
      schemes.get(oprot.getScheme()).getScheme().write(oprot, this);
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("connection_isvalid_args(");
      boolean first = true;

      sb.append("connection:");
      if (this.connection == null) {
        sb.append("null");
      } else {
        sb.append(this.connection);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("timeout:");
      sb.append(this.timeout);
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws org.apache.thrift.TException {
      // check for required fields
      // check for sub-struct validity
      if (connection != null) {
        connection.validate();
      }
    }

    private void writeObject(java.io.ObjectOutputStream out) throws java.io.IOException {
      try {
        write(new org.apache.thrift.protocol.TCompactProtocol(new org.apache.thrift.transport.TIOStreamTransport(out)));
      } catch (org.apache.thrift.TException te) {
        throw new java.io.IOException(te);
      }
    }

    private void readObject(java.io.ObjectInputStream in) throws java.io.IOException, ClassNotFoundException {
      try {
        // it doesn't seem like you should have to do this, but java serialization is wacky, and doesn't call the default constructor.
        __isset_bitfield = 0;
        read(new org.apache.thrift.protocol.TCompactProtocol(new org.apache.thrift.transport.TIOStreamTransport(in)));
      } catch (org.apache.thrift.TException te) {
        throw new java.io.IOException(te);
      }
    }

    private static class connection_isvalid_argsStandardSchemeFactory implements SchemeFactory {
      public connection_isvalid_argsStandardScheme getScheme() {
        return new connection_isvalid_argsStandardScheme();
      }
    }

    private static class connection_isvalid_argsStandardScheme extends StandardScheme<connection_isvalid_args> {

      public void read(org.apache.thrift.protocol.TProtocol iprot, connection_isvalid_args struct) throws org.apache.thrift.TException {
        org.apache.thrift.protocol.TField schemeField;
        iprot.readStructBegin();
        while (true)
        {
          schemeField = iprot.readFieldBegin();
          if (schemeField.type == org.apache.thrift.protocol.TType.STOP) { 
            break;
          }
          switch (schemeField.id) {
            case 1: // CONNECTION
              if (schemeField.type == org.apache.thrift.protocol.TType.STRUCT) {
                struct.connection = new RConnection();
                struct.connection.read(iprot);
                struct.setConnectionIsSet(true);
              } else { 
                org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
              }
              break;
            case 2: // TIMEOUT
              if (schemeField.type == org.apache.thrift.protocol.TType.I32) {
                struct.timeout = iprot.readI32();
                struct.setTimeoutIsSet(true);
              } else { 
                org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
              }
              break;
            default:
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
          }
          iprot.readFieldEnd();
        }
        iprot.readStructEnd();

        // check for required fields of primitive type, which can't be checked in the validate method
        struct.validate();
      }

      public void write(org.apache.thrift.protocol.TProtocol oprot, connection_isvalid_args struct) throws org.apache.thrift.TException {
        struct.validate();

        oprot.writeStructBegin(STRUCT_DESC);
        if (struct.connection != null) {
          oprot.writeFieldBegin(CONNECTION_FIELD_DESC);
          struct.connection.write(oprot);
          oprot.writeFieldEnd();
        }
        oprot.writeFieldBegin(TIMEOUT_FIELD_DESC);
        oprot.writeI32(struct.timeout);
        oprot.writeFieldEnd();
        oprot.writeFieldStop();
        oprot.writeStructEnd();
      }

    }

    private static class connection_isvalid_argsTupleSchemeFactory implements SchemeFactory {
      public connection_isvalid_argsTupleScheme getScheme() {
        return new connection_isvalid_argsTupleScheme();
      }
    }

    private static class connection_isvalid_argsTupleScheme extends TupleScheme<connection_isvalid_args> {

      @Override
      public void write(org.apache.thrift.protocol.TProtocol prot, connection_isvalid_args struct) throws org.apache.thrift.TException {
        TTupleProtocol oprot = (TTupleProtocol) prot;
        BitSet optionals = new BitSet();
        if (struct.isSetConnection()) {
          optionals.set(0);
        }
        if (struct.isSetTimeout()) {
          optionals.set(1);
        }
        oprot.writeBitSet(optionals, 2);
        if (struct.isSetConnection()) {
          struct.connection.write(oprot);
        }
        if (struct.isSetTimeout()) {
          oprot.writeI32(struct.timeout);
        }
      }

      @Override
      public void read(org.apache.thrift.protocol.TProtocol prot, connection_isvalid_args struct) throws org.apache.thrift.TException {
        TTupleProtocol iprot = (TTupleProtocol) prot;
        BitSet incoming = iprot.readBitSet(2);
        if (incoming.get(0)) {
          struct.connection = new RConnection();
          struct.connection.read(iprot);
          struct.setConnectionIsSet(true);
        }
        if (incoming.get(1)) {
          struct.timeout = iprot.readI32();
          struct.setTimeoutIsSet(true);
        }
      }
    }

  }

  public static class connection_isvalid_result implements org.apache.thrift.TBase<connection_isvalid_result, connection_isvalid_result._Fields>, java.io.Serializable, Cloneable, Comparable<connection_isvalid_result>   {
    private static final org.apache.thrift.protocol.TStruct STRUCT_DESC = new org.apache.thrift.protocol.TStruct("connection_isvalid_result");

    private static final org.apache.thrift.protocol.TField SUCCESS_FIELD_DESC = new org.apache.thrift.protocol.TField("success", org.apache.thrift.protocol.TType.BOOL, (short)0);
    private static final org.apache.thrift.protocol.TField SQL_EXCEPTION_FIELD_DESC = new org.apache.thrift.protocol.TField("sqlException", org.apache.thrift.protocol.TType.STRUCT, (short)1);

    private static final Map<Class<? extends IScheme>, SchemeFactory> schemes = new HashMap<Class<? extends IScheme>, SchemeFactory>();
    static {
      schemes.put(StandardScheme.class, new connection_isvalid_resultStandardSchemeFactory());
      schemes.put(TupleScheme.class, new connection_isvalid_resultTupleSchemeFactory());
    }

    public boolean success; // required
    public RSQLException sqlException; // required

    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements org.apache.thrift.TFieldIdEnum {
      SUCCESS((short)0, "success"),
      SQL_EXCEPTION((short)1, "sqlException");

      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        switch(fieldId) {
          case 0: // SUCCESS
            return SUCCESS;
          case 1: // SQL_EXCEPTION
            return SQL_EXCEPTION;
          default:
            return null;
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }

    // isset id assignments
    private static final int __SUCCESS_ISSET_ID = 0;
    private byte __isset_bitfield = 0;
    public static final Map<_Fields, org.apache.thrift.meta_data.FieldMetaData> metaDataMap;
    static {
      Map<_Fields, org.apache.thrift.meta_data.FieldMetaData> tmpMap = new EnumMap<_Fields, org.apache.thrift.meta_data.FieldMetaData>(_Fields.class);
      tmpMap.put(_Fields.SUCCESS, new org.apache.thrift.meta_data.FieldMetaData("success", org.apache.thrift.TFieldRequirementType.DEFAULT, 
          new org.apache.thrift.meta_data.FieldValueMetaData(org.apache.thrift.protocol.TType.BOOL)));
      tmpMap.put(_Fields.SQL_EXCEPTION, new org.apache.thrift.meta_data.FieldMetaData("sqlException", org.apache.thrift.TFieldRequirementType.DEFAULT, 
          new org.apache.thrift.meta_data.FieldValueMetaData(org.apache.thrift.protocol.TType.STRUCT)));
      metaDataMap = Collections.unmodifiableMap(tmpMap);
      org.apache.thrift.meta_data.FieldMetaData.addStructMetaDataMap(connection_isvalid_result.class, metaDataMap);
    }

    public connection_isvalid_result() {
    }

    public connection_isvalid_result(
      boolean success,
      RSQLException sqlException)
    {
      this();
      this.success = success;
      setSuccessIsSet(true);
      this.sqlException = sqlException;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public connection_isvalid_result(connection_isvalid_result other) {
      __isset_bitfield = other.__isset_bitfield;
      this.success = other.success;
      if (other.isSetSqlException()) {
        this.sqlException = new RSQLException(other.sqlException);
      }
    }

    public connection_isvalid_result deepCopy() {
      return new connection_isvalid_result(this);
    }

    @Override
    public void clear() {
      setSuccessIsSet(false);
      this.success = false;
      this.sqlException = null;
    }

    public boolean isSuccess() {
      return this.success;
    }

    public connection_isvalid_result setSuccess(boolean success) {
      this.success = success;
      setSuccessIsSet(true);
      return this;
    }

    public void unsetSuccess() {
      __isset_bitfield = EncodingUtils.clearBit(__isset_bitfield, __SUCCESS_ISSET_ID);
    }

    /** Returns true if field success is set (has been assigned a value) and false otherwise */
    public boolean isSetSuccess() {
      return EncodingUtils.testBit(__isset_bitfield, __SUCCESS_ISSET_ID);
    }

    public void setSuccessIsSet(boolean value) {
      __isset_bitfield = EncodingUtils.setBit(__isset_bitfield, __SUCCESS_ISSET_ID, value);
    }

    public RSQLException getSqlException() {
      return this.sqlException;
    }

    public connection_isvalid_result setSqlException(RSQLException sqlException) {
      this.sqlException = sqlException;
      return this;
    }

    public void unsetSqlException() {
      this.sqlException = null;
    }

    /** Returns true if field sqlException is set (has been assigned a value) and false otherwise */
    public boolean isSetSqlException() {
      return this.sqlException != null;
    }

    public void setSqlExceptionIsSet(boolean value) {
      if (!value) {
        this.sqlException = null;
      }
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          setSuccess((Boolean)value);
        }
        break;

      case SQL_EXCEPTION:
        if (value == null) {
          unsetSqlException();
        } else {
          setSqlException((RSQLException)value);
        }
        break;

      }
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      case SUCCESS:
        return Boolean.valueOf(isSuccess());

      case SQL_EXCEPTION:
        return getSqlException();

      }
      throw new IllegalStateException();
    }

    /** Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      if (field == null) {
        throw new IllegalArgumentException();
      }

      switch (field) {
      case SUCCESS:
        return isSetSuccess();
      case SQL_EXCEPTION:
        return isSetSqlException();
      }
      throw new IllegalStateException();
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof connection_isvalid_result)
        return this.equals((connection_isvalid_result)that);
      return false;
    }

    public boolean equals(connection_isvalid_result that) {
      if (that == null)
        return false;

      boolean this_present_success = true;
      boolean that_present_success = true;
      if (this_present_success || that_present_success) {
        if (!(this_present_success && that_present_success))
          return false;
        if (this.success != that.success)
          return false;
      }

      boolean this_present_sqlException = true && this.isSetSqlException();
      boolean that_present_sqlException = true && that.isSetSqlException();
      if (this_present_sqlException || that_present_sqlException) {
        if (!(this_present_sqlException && that_present_sqlException))
          return false;
        if (!this.sqlException.equals(that.sqlException))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      List<Object> list = new ArrayList<Object>();

      boolean present_success = true;
      list.add(present_success);
      if (present_success)
        list.add(success);

      boolean present_sqlException = true && (isSetSqlException());
      list.add(present_sqlException);
      if (present_sqlException)
        list.add(sqlException);

      return list.hashCode();
    }

    @Override
    public int compareTo(connection_isvalid_result other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetSuccess()).compareTo(other.isSetSuccess());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetSuccess()) {
        lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.success, other.success);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      lastComparison = Boolean.valueOf(isSetSqlException()).compareTo(other.isSetSqlException());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetSqlException()) {
        lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.sqlException, other.sqlException);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      return 0;
    }

    public _Fields fieldForId(int fieldId) {
      return _Fields.findByThriftId(fieldId);
    }

    public void read(org.apache.thrift.protocol.TProtocol iprot) throws org.apache.thrift.TException {
      schemes.get(iprot.getScheme()).getScheme().read(iprot, this);
    }

    public void write(org.apache.thrift.protocol.TProtocol oprot) throws org.apache.thrift.TException {
      schemes.get(oprot.getScheme()).getScheme().write(oprot, this);
      }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("connection_isvalid_result(");
      boolean first = true;

      sb.append("success:");
      sb.append(this.success);
      first = false;
      if (!first) sb.append(", ");
      sb.append("sqlException:");
      if (this.sqlException == null) {
        sb.append("null");
      } else {
        sb.append(this.sqlException);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws org.apache.thrift.TException {
      // check for required fields
      // check for sub-struct validity
    }

    private void writeObject(java.io.ObjectOutputStream out) throws java.io.IOException {
      try {
        write(new org.apache.thrift.protocol.TCompactProtocol(new org.apache.thrift.transport.TIOStreamTransport(out)));
      } catch (org.apache.thrift.TException te) {
        throw new java.io.IOException(te);
      }
    }

    private void readObject(java.io.ObjectInputStream in) throws java.io.IOException, ClassNotFoundException {
      try {
        // it doesn't seem like you should have to do this, but java serialization is wacky, and doesn't call the default constructor.
        __isset_bitfield = 0;
        read(new org.apache.thrift.protocol.TCompactProtocol(new org.apache.thrift.transport.TIOStreamTransport(in)));
      } catch (org.apache.thrift.TException te) {
        throw new java.io.IOException(te);
      }
    }

    private static class connection_isvalid_resultStandardSchemeFactory implements SchemeFactory {
      public connection_isvalid_resultStandardScheme getScheme() {
        return new connection_isvalid_resultStandardScheme();
      }
    }

    private static class connection_isvalid_resultStandardScheme extends StandardScheme<connection_isvalid_result> {

      public void read(org.apache.thrift.protocol.TProtocol iprot, connection_isvalid_result struct) throws org.apache.thrift.TException {
        org.apache.thrift.protocol.TField schemeField;
        iprot.readStructBegin();
        while (true)
        {
          schemeField = iprot.readFieldBegin();
          if (schemeField.type == org.apache.thrift.protocol.TType.STOP) { 
            break;
          }
          switch (schemeField.id) {
            case 0: // SUCCESS
              if (schemeField.type == org.apache.thrift.protocol.TType.BOOL) {
                struct.success = iprot.readBool();
                struct.setSuccessIsSet(true);
              } else { 
                org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
              }
              break;
            case 1: // SQL_EXCEPTION
              if (schemeField.type == org.apache.thrift.protocol.TType.STRUCT) {
                struct.sqlException = new RSQLException();
                struct.sqlException.read(iprot);
                struct.setSqlExceptionIsSet(true);
              } else { 
                org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
              }
              break;
            default:
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
          }
          iprot.readFieldEnd();
        }
        iprot.readStructEnd();

        // check for required fields of primitive type, which can't be checked in the validate method
        struct.validate();
      }

      public void write(org.apache.thrift.protocol.TProtocol oprot, connection_isvalid_result struct) throws org.apache.thrift.TException {
        struct.validate();

        oprot.writeStructBegin(STRUCT_DESC);
        if (struct.isSetSuccess()) {
          oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
          oprot.writeBool(struct.success);
          oprot.writeFieldEnd();
        }
        if (struct.sqlException != null) {
          oprot.writeFieldBegin(SQL_EXCEPTION_FIELD_DESC);
          struct.sqlException.write(oprot);
          oprot.writeFieldEnd();
        }
        oprot.writeFieldStop();
        oprot.writeStructEnd();
      }

    }

    private static class connection_isvalid_resultTupleSchemeFactory implements SchemeFactory {
      public connection_isvalid_resultTupleScheme getScheme() {
        return new connection_isvalid_resultTupleScheme();
      }
    }

    private static class connection_isvalid_resultTupleScheme extends TupleScheme<connection_isvalid_result> {

      @Override
      public void write(org.apache.thrift.protocol.TProtocol prot, connection_isvalid_result struct) throws org.apache.thrift.TException {
        TTupleProtocol oprot = (TTupleProtocol) prot;
        BitSet optionals = new BitSet();
        if (struct.isSetSuccess()) {
          optionals.set(0);
        }
        if (struct.isSetSqlException()) {
          optionals.set(1);
        }
        oprot.writeBitSet(optionals, 2);
        if (struct.isSetSuccess()) {
          oprot.writeBool(struct.success);
        }
        if (struct.isSetSqlException()) {
          struct.sqlException.write(oprot);
        }
      }

      @Override
      public void read(org.apache.thrift.protocol.TProtocol prot, connection_isvalid_result struct) throws org.apache.thrift.TException {
        TTupleProtocol iprot = (TTupleProtocol) prot;
        BitSet incoming = iprot.readBitSet(2);
        if (incoming.get(0)) {
          struct.success = iprot.readBool();
          struct.setSuccessIsSet(true);
        }
        if (incoming.get(1)) {
          struct.sqlException = new RSQLException();
          struct.sqlException.read(iprot);
          struct.setSqlExceptionIsSet(true);
        }
      }
    }

  }

  public static class connection_commit_args implements org.apache.thrift.TBase<connection_commit_args, connection_commit_args._Fields>, java.io.Serializable, Cloneable, Comparable<connection_commit_args>   {
    private static final org.apache.thrift.protocol.TStruct STRUCT_DESC = new org.apache.thrift.protocol.TStruct("connection_commit_args");

    private static final org.apache.thrift.protocol.TField CONNECTION_FIELD_DESC = new org.apache.thrift.protocol.TField("connection", org.apache.thrift.protocol.TType.STRUCT, (short)1);

    private static final Map<Class<? extends IScheme>, SchemeFactory> schemes = new HashMap<Class<? extends IScheme>, SchemeFactory>();
    static {
      schemes.put(StandardScheme.class, new connection_commit_argsStandardSchemeFactory());
      schemes.put(TupleScheme.class, new connection_commit_argsTupleSchemeFactory());
    }

    public RConnection connection; // required

    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements org.apache.thrift.TFieldIdEnum {
      CONNECTION((short)1, "connection");

      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        switch(fieldId) {
          case 1: // CONNECTION
            return CONNECTION;
          default:
            return null;
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }

    // isset id assignments
    public static final Map<_Fields, org.apache.thrift.meta_data.FieldMetaData> metaDataMap;
    static {
      Map<_Fields, org.apache.thrift.meta_data.FieldMetaData> tmpMap = new EnumMap<_Fields, org.apache.thrift.meta_data.FieldMetaData>(_Fields.class);
      tmpMap.put(_Fields.CONNECTION, new org.apache.thrift.meta_data.FieldMetaData("connection", org.apache.thrift.TFieldRequirementType.DEFAULT, 
          new org.apache.thrift.meta_data.StructMetaData(org.apache.thrift.protocol.TType.STRUCT, RConnection.class)));
      metaDataMap = Collections.unmodifiableMap(tmpMap);
      org.apache.thrift.meta_data.FieldMetaData.addStructMetaDataMap(connection_commit_args.class, metaDataMap);
    }

    public connection_commit_args() {
    }

    public connection_commit_args(
      RConnection connection)
    {
      this();
      this.connection = connection;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public connection_commit_args(connection_commit_args other) {
      if (other.isSetConnection()) {
        this.connection = new RConnection(other.connection);
      }
    }

    public connection_commit_args deepCopy() {
      return new connection_commit_args(this);
    }

    @Override
    public void clear() {
      this.connection = null;
    }

    public RConnection getConnection() {
      return this.connection;
    }

    public connection_commit_args setConnection(RConnection connection) {
      this.connection = connection;
      return this;
    }

    public void unsetConnection() {
      this.connection = null;
    }

    /** Returns true if field connection is set (has been assigned a value) and false otherwise */
    public boolean isSetConnection() {
      return this.connection != null;
    }

    public void setConnectionIsSet(boolean value) {
      if (!value) {
        this.connection = null;
      }
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      case CONNECTION:
        if (value == null) {
          unsetConnection();
        } else {
          setConnection((RConnection)value);
        }
        break;

      }
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      case CONNECTION:
        return getConnection();

      }
      throw new IllegalStateException();
    }

    /** Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      if (field == null) {
        throw new IllegalArgumentException();
      }

      switch (field) {
      case CONNECTION:
        return isSetConnection();
      }
      throw new IllegalStateException();
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof connection_commit_args)
        return this.equals((connection_commit_args)that);
      return false;
    }

    public boolean equals(connection_commit_args that) {
      if (that == null)
        return false;

      boolean this_present_connection = true && this.isSetConnection();
      boolean that_present_connection = true && that.isSetConnection();
      if (this_present_connection || that_present_connection) {
        if (!(this_present_connection && that_present_connection))
          return false;
        if (!this.connection.equals(that.connection))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      List<Object> list = new ArrayList<Object>();

      boolean present_connection = true && (isSetConnection());
      list.add(present_connection);
      if (present_connection)
        list.add(connection);

      return list.hashCode();
    }

    @Override
    public int compareTo(connection_commit_args other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetConnection()).compareTo(other.isSetConnection());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetConnection()) {
        lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.connection, other.connection);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      return 0;
    }

    public _Fields fieldForId(int fieldId) {
      return _Fields.findByThriftId(fieldId);
    }

    public void read(org.apache.thrift.protocol.TProtocol iprot) throws org.apache.thrift.TException {
      schemes.get(iprot.getScheme()).getScheme().read(iprot, this);
    }

    public void write(org.apache.thrift.protocol.TProtocol oprot) throws org.apache.thrift.TException {
      schemes.get(oprot.getScheme()).getScheme().write(oprot, this);
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("connection_commit_args(");
      boolean first = true;

      sb.append("connection:");
      if (this.connection == null) {
        sb.append("null");
      } else {
        sb.append(this.connection);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws org.apache.thrift.TException {
      // check for required fields
      // check for sub-struct validity
      if (connection != null) {
        connection.validate();
      }
    }

    private void writeObject(java.io.ObjectOutputStream out) throws java.io.IOException {
      try {
        write(new org.apache.thrift.protocol.TCompactProtocol(new org.apache.thrift.transport.TIOStreamTransport(out)));
      } catch (org.apache.thrift.TException te) {
        throw new java.io.IOException(te);
      }
    }

    private void readObject(java.io.ObjectInputStream in) throws java.io.IOException, ClassNotFoundException {
      try {
        read(new org.apache.thrift.protocol.TCompactProtocol(new org.apache.thrift.transport.TIOStreamTransport(in)));
      } catch (org.apache.thrift.TException te) {
        throw new java.io.IOException(te);
      }
    }

    private static class connection_commit_argsStandardSchemeFactory implements SchemeFactory {
      public connection_commit_argsStandardScheme getScheme() {
        return new connection_commit_argsStandardScheme();
      }
    }

    private static class connection_commit_argsStandardScheme extends StandardScheme<connection_commit_args> {

      public void read(org.apache.thrift.protocol.TProtocol iprot, connection_commit_args struct) throws org.apache.thrift.TException {
        org.apache.thrift.protocol.TField schemeField;
        iprot.readStructBegin();
        while (true)
        {
          schemeField = iprot.readFieldBegin();
          if (schemeField.type == org.apache.thrift.protocol.TType.STOP) { 
            break;
          }
          switch (schemeField.id) {
            case 1: // CONNECTION
              if (schemeField.type == org.apache.thrift.protocol.TType.STRUCT) {
                struct.connection = new RConnection();
                struct.connection.read(iprot);
                struct.setConnectionIsSet(true);
              } else { 
                org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
              }
              break;
            default:
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
          }
          iprot.readFieldEnd();
        }
        iprot.readStructEnd();

        // check for required fields of primitive type, which can't be checked in the validate method
        struct.validate();
      }

      public void write(org.apache.thrift.protocol.TProtocol oprot, connection_commit_args struct) throws org.apache.thrift.TException {
        struct.validate();

        oprot.writeStructBegin(STRUCT_DESC);
        if (struct.connection != null) {
          oprot.writeFieldBegin(CONNECTION_FIELD_DESC);
          struct.connection.write(oprot);
          oprot.writeFieldEnd();
        }
        oprot.writeFieldStop();
        oprot.writeStructEnd();
      }

    }

    private static class connection_commit_argsTupleSchemeFactory implements SchemeFactory {
      public connection_commit_argsTupleScheme getScheme() {
        return new connection_commit_argsTupleScheme();
      }
    }

    private static class connection_commit_argsTupleScheme extends TupleScheme<connection_commit_args> {

      @Override
      public void write(org.apache.thrift.protocol.TProtocol prot, connection_commit_args struct) throws org.apache.thrift.TException {
        TTupleProtocol oprot = (TTupleProtocol) prot;
        BitSet optionals = new BitSet();
        if (struct.isSetConnection()) {
          optionals.set(0);
        }
        oprot.writeBitSet(optionals, 1);
        if (struct.isSetConnection()) {
          struct.connection.write(oprot);
        }
      }

      @Override
      public void read(org.apache.thrift.protocol.TProtocol prot, connection_commit_args struct) throws org.apache.thrift.TException {
        TTupleProtocol iprot = (TTupleProtocol) prot;
        BitSet incoming = iprot.readBitSet(1);
        if (incoming.get(0)) {
          struct.connection = new RConnection();
          struct.connection.read(iprot);
          struct.setConnectionIsSet(true);
        }
      }
    }

  }

  public static class connection_commit_result implements org.apache.thrift.TBase<connection_commit_result, connection_commit_result._Fields>, java.io.Serializable, Cloneable, Comparable<connection_commit_result>   {
    private static final org.apache.thrift.protocol.TStruct STRUCT_DESC = new org.apache.thrift.protocol.TStruct("connection_commit_result");

    private static final org.apache.thrift.protocol.TField SQL_EXCEPTION_FIELD_DESC = new org.apache.thrift.protocol.TField("sqlException", org.apache.thrift.protocol.TType.STRUCT, (short)1);

    private static final Map<Class<? extends IScheme>, SchemeFactory> schemes = new HashMap<Class<? extends IScheme>, SchemeFactory>();
    static {
      schemes.put(StandardScheme.class, new connection_commit_resultStandardSchemeFactory());
      schemes.put(TupleScheme.class, new connection_commit_resultTupleSchemeFactory());
    }

    public RSQLException sqlException; // required

    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements org.apache.thrift.TFieldIdEnum {
      SQL_EXCEPTION((short)1, "sqlException");

      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        switch(fieldId) {
          case 1: // SQL_EXCEPTION
            return SQL_EXCEPTION;
          default:
            return null;
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }

    // isset id assignments
    public static final Map<_Fields, org.apache.thrift.meta_data.FieldMetaData> metaDataMap;
    static {
      Map<_Fields, org.apache.thrift.meta_data.FieldMetaData> tmpMap = new EnumMap<_Fields, org.apache.thrift.meta_data.FieldMetaData>(_Fields.class);
      tmpMap.put(_Fields.SQL_EXCEPTION, new org.apache.thrift.meta_data.FieldMetaData("sqlException", org.apache.thrift.TFieldRequirementType.DEFAULT, 
          new org.apache.thrift.meta_data.FieldValueMetaData(org.apache.thrift.protocol.TType.STRUCT)));
      metaDataMap = Collections.unmodifiableMap(tmpMap);
      org.apache.thrift.meta_data.FieldMetaData.addStructMetaDataMap(connection_commit_result.class, metaDataMap);
    }

    public connection_commit_result() {
    }

    public connection_commit_result(
      RSQLException sqlException)
    {
      this();
      this.sqlException = sqlException;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public connection_commit_result(connection_commit_result other) {
      if (other.isSetSqlException()) {
        this.sqlException = new RSQLException(other.sqlException);
      }
    }

    public connection_commit_result deepCopy() {
      return new connection_commit_result(this);
    }

    @Override
    public void clear() {
      this.sqlException = null;
    }

    public RSQLException getSqlException() {
      return this.sqlException;
    }

    public connection_commit_result setSqlException(RSQLException sqlException) {
      this.sqlException = sqlException;
      return this;
    }

    public void unsetSqlException() {
      this.sqlException = null;
    }

    /** Returns true if field sqlException is set (has been assigned a value) and false otherwise */
    public boolean isSetSqlException() {
      return this.sqlException != null;
    }

    public void setSqlExceptionIsSet(boolean value) {
      if (!value) {
        this.sqlException = null;
      }
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      case SQL_EXCEPTION:
        if (value == null) {
          unsetSqlException();
        } else {
          setSqlException((RSQLException)value);
        }
        break;

      }
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      case SQL_EXCEPTION:
        return getSqlException();

      }
      throw new IllegalStateException();
    }

    /** Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      if (field == null) {
        throw new IllegalArgumentException();
      }

      switch (field) {
      case SQL_EXCEPTION:
        return isSetSqlException();
      }
      throw new IllegalStateException();
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof connection_commit_result)
        return this.equals((connection_commit_result)that);
      return false;
    }

    public boolean equals(connection_commit_result that) {
      if (that == null)
        return false;

      boolean this_present_sqlException = true && this.isSetSqlException();
      boolean that_present_sqlException = true && that.isSetSqlException();
      if (this_present_sqlException || that_present_sqlException) {
        if (!(this_present_sqlException && that_present_sqlException))
          return false;
        if (!this.sqlException.equals(that.sqlException))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      List<Object> list = new ArrayList<Object>();

      boolean present_sqlException = true && (isSetSqlException());
      list.add(present_sqlException);
      if (present_sqlException)
        list.add(sqlException);

      return list.hashCode();
    }

    @Override
    public int compareTo(connection_commit_result other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetSqlException()).compareTo(other.isSetSqlException());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetSqlException()) {
        lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.sqlException, other.sqlException);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      return 0;
    }

    public _Fields fieldForId(int fieldId) {
      return _Fields.findByThriftId(fieldId);
    }

    public void read(org.apache.thrift.protocol.TProtocol iprot) throws org.apache.thrift.TException {
      schemes.get(iprot.getScheme()).getScheme().read(iprot, this);
    }

    public void write(org.apache.thrift.protocol.TProtocol oprot) throws org.apache.thrift.TException {
      schemes.get(oprot.getScheme()).getScheme().write(oprot, this);
      }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("connection_commit_result(");
      boolean first = true;

      sb.append("sqlException:");
      if (this.sqlException == null) {
        sb.append("null");
      } else {
        sb.append(this.sqlException);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws org.apache.thrift.TException {
      // check for required fields
      // check for sub-struct validity
    }

    private void writeObject(java.io.ObjectOutputStream out) throws java.io.IOException {
      try {
        write(new org.apache.thrift.protocol.TCompactProtocol(new org.apache.thrift.transport.TIOStreamTransport(out)));
      } catch (org.apache.thrift.TException te) {
        throw new java.io.IOException(te);
      }
    }

    private void readObject(java.io.ObjectInputStream in) throws java.io.IOException, ClassNotFoundException {
      try {
        read(new org.apache.thrift.protocol.TCompactProtocol(new org.apache.thrift.transport.TIOStreamTransport(in)));
      } catch (org.apache.thrift.TException te) {
        throw new java.io.IOException(te);
      }
    }

    private static class connection_commit_resultStandardSchemeFactory implements SchemeFactory {
      public connection_commit_resultStandardScheme getScheme() {
        return new connection_commit_resultStandardScheme();
      }
    }

    private static class connection_commit_resultStandardScheme extends StandardScheme<connection_commit_result> {

      public void read(org.apache.thrift.protocol.TProtocol iprot, connection_commit_result struct) throws org.apache.thrift.TException {
        org.apache.thrift.protocol.TField schemeField;
        iprot.readStructBegin();
        while (true)
        {
          schemeField = iprot.readFieldBegin();
          if (schemeField.type == org.apache.thrift.protocol.TType.STOP) { 
            break;
          }
          switch (schemeField.id) {
            case 1: // SQL_EXCEPTION
              if (schemeField.type == org.apache.thrift.protocol.TType.STRUCT) {
                struct.sqlException = new RSQLException();
                struct.sqlException.read(iprot);
                struct.setSqlExceptionIsSet(true);
              } else { 
                org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
              }
              break;
            default:
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
          }
          iprot.readFieldEnd();
        }
        iprot.readStructEnd();

        // check for required fields of primitive type, which can't be checked in the validate method
        struct.validate();
      }

      public void write(org.apache.thrift.protocol.TProtocol oprot, connection_commit_result struct) throws org.apache.thrift.TException {
        struct.validate();

        oprot.writeStructBegin(STRUCT_DESC);
        if (struct.sqlException != null) {
          oprot.writeFieldBegin(SQL_EXCEPTION_FIELD_DESC);
          struct.sqlException.write(oprot);
          oprot.writeFieldEnd();
        }
        oprot.writeFieldStop();
        oprot.writeStructEnd();
      }

    }

    private static class connection_commit_resultTupleSchemeFactory implements SchemeFactory {
      public connection_commit_resultTupleScheme getScheme() {
        return new connection_commit_resultTupleScheme();
      }
    }

    private static class connection_commit_resultTupleScheme extends TupleScheme<connection_commit_result> {

      @Override
      public void write(org.apache.thrift.protocol.TProtocol prot, connection_commit_result struct) throws org.apache.thrift.TException {
        TTupleProtocol oprot = (TTupleProtocol) prot;
        BitSet optionals = new BitSet();
        if (struct.isSetSqlException()) {
          optionals.set(0);
        }
        oprot.writeBitSet(optionals, 1);
        if (struct.isSetSqlException()) {
          struct.sqlException.write(oprot);
        }
      }

      @Override
      public void read(org.apache.thrift.protocol.TProtocol prot, connection_commit_result struct) throws org.apache.thrift.TException {
        TTupleProtocol iprot = (TTupleProtocol) prot;
        BitSet incoming = iprot.readBitSet(1);
        if (incoming.get(0)) {
          struct.sqlException = new RSQLException();
          struct.sqlException.read(iprot);
          struct.setSqlExceptionIsSet(true);
        }
      }
    }

  }

  public static class connection_rollback_args implements org.apache.thrift.TBase<connection_rollback_args, connection_rollback_args._Fields>, java.io.Serializable, Cloneable, Comparable<connection_rollback_args>   {
    private static final org.apache.thrift.protocol.TStruct STRUCT_DESC = new org.apache.thrift.protocol.TStruct("connection_rollback_args");

    private static final org.apache.thrift.protocol.TField CONNECTION_FIELD_DESC = new org.apache.thrift.protocol.TField("connection", org.apache.thrift.protocol.TType.STRUCT, (short)1);

    private static final Map<Class<? extends IScheme>, SchemeFactory> schemes = new HashMap<Class<? extends IScheme>, SchemeFactory>();
    static {
      schemes.put(StandardScheme.class, new connection_rollback_argsStandardSchemeFactory());
      schemes.put(TupleScheme.class, new connection_rollback_argsTupleSchemeFactory());
    }

    public RConnection connection; // required

    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements org.apache.thrift.TFieldIdEnum {
      CONNECTION((short)1, "connection");

      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        switch(fieldId) {
          case 1: // CONNECTION
            return CONNECTION;
          default:
            return null;
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }

    // isset id assignments
    public static final Map<_Fields, org.apache.thrift.meta_data.FieldMetaData> metaDataMap;
    static {
      Map<_Fields, org.apache.thrift.meta_data.FieldMetaData> tmpMap = new EnumMap<_Fields, org.apache.thrift.meta_data.FieldMetaData>(_Fields.class);
      tmpMap.put(_Fields.CONNECTION, new org.apache.thrift.meta_data.FieldMetaData("connection", org.apache.thrift.TFieldRequirementType.DEFAULT, 
          new org.apache.thrift.meta_data.StructMetaData(org.apache.thrift.protocol.TType.STRUCT, RConnection.class)));
      metaDataMap = Collections.unmodifiableMap(tmpMap);
      org.apache.thrift.meta_data.FieldMetaData.addStructMetaDataMap(connection_rollback_args.class, metaDataMap);
    }

    public connection_rollback_args() {
    }

    public connection_rollback_args(
      RConnection connection)
    {
      this();
      this.connection = connection;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public connection_rollback_args(connection_rollback_args other) {
      if (other.isSetConnection()) {
        this.connection = new RConnection(other.connection);
      }
    }

    public connection_rollback_args deepCopy() {
      return new connection_rollback_args(this);
    }

    @Override
    public void clear() {
      this.connection = null;
    }

    public RConnection getConnection() {
      return this.connection;
    }

    public connection_rollback_args setConnection(RConnection connection) {
      this.connection = connection;
      return this;
    }

    public void unsetConnection() {
      this.connection = null;
    }

    /** Returns true if field connection is set (has been assigned a value) and false otherwise */
    public boolean isSetConnection() {
      return this.connection != null;
    }

    public void setConnectionIsSet(boolean value) {
      if (!value) {
        this.connection = null;
      }
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      case CONNECTION:
        if (value == null) {
          unsetConnection();
        } else {
          setConnection((RConnection)value);
        }
        break;

      }
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      case CONNECTION:
        return getConnection();

      }
      throw new IllegalStateException();
    }

    /** Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      if (field == null) {
        throw new IllegalArgumentException();
      }

      switch (field) {
      case CONNECTION:
        return isSetConnection();
      }
      throw new IllegalStateException();
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof connection_rollback_args)
        return this.equals((connection_rollback_args)that);
      return false;
    }

    public boolean equals(connection_rollback_args that) {
      if (that == null)
        return false;

      boolean this_present_connection = true && this.isSetConnection();
      boolean that_present_connection = true && that.isSetConnection();
      if (this_present_connection || that_present_connection) {
        if (!(this_present_connection && that_present_connection))
          return false;
        if (!this.connection.equals(that.connection))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      List<Object> list = new ArrayList<Object>();

      boolean present_connection = true && (isSetConnection());
      list.add(present_connection);
      if (present_connection)
        list.add(connection);

      return list.hashCode();
    }

    @Override
    public int compareTo(connection_rollback_args other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetConnection()).compareTo(other.isSetConnection());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetConnection()) {
        lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.connection, other.connection);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      return 0;
    }

    public _Fields fieldForId(int fieldId) {
      return _Fields.findByThriftId(fieldId);
    }

    public void read(org.apache.thrift.protocol.TProtocol iprot) throws org.apache.thrift.TException {
      schemes.get(iprot.getScheme()).getScheme().read(iprot, this);
    }

    public void write(org.apache.thrift.protocol.TProtocol oprot) throws org.apache.thrift.TException {
      schemes.get(oprot.getScheme()).getScheme().write(oprot, this);
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("connection_rollback_args(");
      boolean first = true;

      sb.append("connection:");
      if (this.connection == null) {
        sb.append("null");
      } else {
        sb.append(this.connection);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws org.apache.thrift.TException {
      // check for required fields
      // check for sub-struct validity
      if (connection != null) {
        connection.validate();
      }
    }

    private void writeObject(java.io.ObjectOutputStream out) throws java.io.IOException {
      try {
        write(new org.apache.thrift.protocol.TCompactProtocol(new org.apache.thrift.transport.TIOStreamTransport(out)));
      } catch (org.apache.thrift.TException te) {
        throw new java.io.IOException(te);
      }
    }

    private void readObject(java.io.ObjectInputStream in) throws java.io.IOException, ClassNotFoundException {
      try {
        read(new org.apache.thrift.protocol.TCompactProtocol(new org.apache.thrift.transport.TIOStreamTransport(in)));
      } catch (org.apache.thrift.TException te) {
        throw new java.io.IOException(te);
      }
    }

    private static class connection_rollback_argsStandardSchemeFactory implements SchemeFactory {
      public connection_rollback_argsStandardScheme getScheme() {
        return new connection_rollback_argsStandardScheme();
      }
    }

    private static class connection_rollback_argsStandardScheme extends StandardScheme<connection_rollback_args> {

      public void read(org.apache.thrift.protocol.TProtocol iprot, connection_rollback_args struct) throws org.apache.thrift.TException {
        org.apache.thrift.protocol.TField schemeField;
        iprot.readStructBegin();
        while (true)
        {
          schemeField = iprot.readFieldBegin();
          if (schemeField.type == org.apache.thrift.protocol.TType.STOP) { 
            break;
          }
          switch (schemeField.id) {
            case 1: // CONNECTION
              if (schemeField.type == org.apache.thrift.protocol.TType.STRUCT) {
                struct.connection = new RConnection();
                struct.connection.read(iprot);
                struct.setConnectionIsSet(true);
              } else { 
                org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
              }
              break;
            default:
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
          }
          iprot.readFieldEnd();
        }
        iprot.readStructEnd();

        // check for required fields of primitive type, which can't be checked in the validate method
        struct.validate();
      }

      public void write(org.apache.thrift.protocol.TProtocol oprot, connection_rollback_args struct) throws org.apache.thrift.TException {
        struct.validate();

        oprot.writeStructBegin(STRUCT_DESC);
        if (struct.connection != null) {
          oprot.writeFieldBegin(CONNECTION_FIELD_DESC);
          struct.connection.write(oprot);
          oprot.writeFieldEnd();
        }
        oprot.writeFieldStop();
        oprot.writeStructEnd();
      }

    }

    private static class connection_rollback_argsTupleSchemeFactory implements SchemeFactory {
      public connection_rollback_argsTupleScheme getScheme() {
        return new connection_rollback_argsTupleScheme();
      }
    }

    private static class connection_rollback_argsTupleScheme extends TupleScheme<connection_rollback_args> {

      @Override
      public void write(org.apache.thrift.protocol.TProtocol prot, connection_rollback_args struct) throws org.apache.thrift.TException {
        TTupleProtocol oprot = (TTupleProtocol) prot;
        BitSet optionals = new BitSet();
        if (struct.isSetConnection()) {
          optionals.set(0);
        }
        oprot.writeBitSet(optionals, 1);
        if (struct.isSetConnection()) {
          struct.connection.write(oprot);
        }
      }

      @Override
      public void read(org.apache.thrift.protocol.TProtocol prot, connection_rollback_args struct) throws org.apache.thrift.TException {
        TTupleProtocol iprot = (TTupleProtocol) prot;
        BitSet incoming = iprot.readBitSet(1);
        if (incoming.get(0)) {
          struct.connection = new RConnection();
          struct.connection.read(iprot);
          struct.setConnectionIsSet(true);
        }
      }
    }

  }

  public static class connection_rollback_result implements org.apache.thrift.TBase<connection_rollback_result, connection_rollback_result._Fields>, java.io.Serializable, Cloneable, Comparable<connection_rollback_result>   {
    private static final org.apache.thrift.protocol.TStruct STRUCT_DESC = new org.apache.thrift.protocol.TStruct("connection_rollback_result");

    private static final org.apache.thrift.protocol.TField SQL_EXCEPTION_FIELD_DESC = new org.apache.thrift.protocol.TField("sqlException", org.apache.thrift.protocol.TType.STRUCT, (short)1);

    private static final Map<Class<? extends IScheme>, SchemeFactory> schemes = new HashMap<Class<? extends IScheme>, SchemeFactory>();
    static {
      schemes.put(StandardScheme.class, new connection_rollback_resultStandardSchemeFactory());
      schemes.put(TupleScheme.class, new connection_rollback_resultTupleSchemeFactory());
    }

    public RSQLException sqlException; // required

    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements org.apache.thrift.TFieldIdEnum {
      SQL_EXCEPTION((short)1, "sqlException");

      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        switch(fieldId) {
          case 1: // SQL_EXCEPTION
            return SQL_EXCEPTION;
          default:
            return null;
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }

    // isset id assignments
    public static final Map<_Fields, org.apache.thrift.meta_data.FieldMetaData> metaDataMap;
    static {
      Map<_Fields, org.apache.thrift.meta_data.FieldMetaData> tmpMap = new EnumMap<_Fields, org.apache.thrift.meta_data.FieldMetaData>(_Fields.class);
      tmpMap.put(_Fields.SQL_EXCEPTION, new org.apache.thrift.meta_data.FieldMetaData("sqlException", org.apache.thrift.TFieldRequirementType.DEFAULT, 
          new org.apache.thrift.meta_data.FieldValueMetaData(org.apache.thrift.protocol.TType.STRUCT)));
      metaDataMap = Collections.unmodifiableMap(tmpMap);
      org.apache.thrift.meta_data.FieldMetaData.addStructMetaDataMap(connection_rollback_result.class, metaDataMap);
    }

    public connection_rollback_result() {
    }

    public connection_rollback_result(
      RSQLException sqlException)
    {
      this();
      this.sqlException = sqlException;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public connection_rollback_result(connection_rollback_result other) {
      if (other.isSetSqlException()) {
        this.sqlException = new RSQLException(other.sqlException);
      }
    }

    public connection_rollback_result deepCopy() {
      return new connection_rollback_result(this);
    }

    @Override
    public void clear() {
      this.sqlException = null;
    }

    public RSQLException getSqlException() {
      return this.sqlException;
    }

    public connection_rollback_result setSqlException(RSQLException sqlException) {
      this.sqlException = sqlException;
      return this;
    }

    public void unsetSqlException() {
      this.sqlException = null;
    }

    /** Returns true if field sqlException is set (has been assigned a value) and false otherwise */
    public boolean isSetSqlException() {
      return this.sqlException != null;
    }

    public void setSqlExceptionIsSet(boolean value) {
      if (!value) {
        this.sqlException = null;
      }
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      case SQL_EXCEPTION:
        if (value == null) {
          unsetSqlException();
        } else {
          setSqlException((RSQLException)value);
        }
        break;

      }
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      case SQL_EXCEPTION:
        return getSqlException();

      }
      throw new IllegalStateException();
    }

    /** Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      if (field == null) {
        throw new IllegalArgumentException();
      }

      switch (field) {
      case SQL_EXCEPTION:
        return isSetSqlException();
      }
      throw new IllegalStateException();
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof connection_rollback_result)
        return this.equals((connection_rollback_result)that);
      return false;
    }

    public boolean equals(connection_rollback_result that) {
      if (that == null)
        return false;

      boolean this_present_sqlException = true && this.isSetSqlException();
      boolean that_present_sqlException = true && that.isSetSqlException();
      if (this_present_sqlException || that_present_sqlException) {
        if (!(this_present_sqlException && that_present_sqlException))
          return false;
        if (!this.sqlException.equals(that.sqlException))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      List<Object> list = new ArrayList<Object>();

      boolean present_sqlException = true && (isSetSqlException());
      list.add(present_sqlException);
      if (present_sqlException)
        list.add(sqlException);

      return list.hashCode();
    }

    @Override
    public int compareTo(connection_rollback_result other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetSqlException()).compareTo(other.isSetSqlException());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetSqlException()) {
        lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.sqlException, other.sqlException);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      return 0;
    }

    public _Fields fieldForId(int fieldId) {
      return _Fields.findByThriftId(fieldId);
    }

    public void read(org.apache.thrift.protocol.TProtocol iprot) throws org.apache.thrift.TException {
      schemes.get(iprot.getScheme()).getScheme().read(iprot, this);
    }

    public void write(org.apache.thrift.protocol.TProtocol oprot) throws org.apache.thrift.TException {
      schemes.get(oprot.getScheme()).getScheme().write(oprot, this);
      }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("connection_rollback_result(");
      boolean first = true;

      sb.append("sqlException:");
      if (this.sqlException == null) {
        sb.append("null");
      } else {
        sb.append(this.sqlException);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws org.apache.thrift.TException {
      // check for required fields
      // check for sub-struct validity
    }

    private void writeObject(java.io.ObjectOutputStream out) throws java.io.IOException {
      try {
        write(new org.apache.thrift.protocol.TCompactProtocol(new org.apache.thrift.transport.TIOStreamTransport(out)));
      } catch (org.apache.thrift.TException te) {
        throw new java.io.IOException(te);
      }
    }

    private void readObject(java.io.ObjectInputStream in) throws java.io.IOException, ClassNotFoundException {
      try {
        read(new org.apache.thrift.protocol.TCompactProtocol(new org.apache.thrift.transport.TIOStreamTransport(in)));
      } catch (org.apache.thrift.TException te) {
        throw new java.io.IOException(te);
      }
    }

    private static class connection_rollback_resultStandardSchemeFactory implements SchemeFactory {
      public connection_rollback_resultStandardScheme getScheme() {
        return new connection_rollback_resultStandardScheme();
      }
    }

    private static class connection_rollback_resultStandardScheme extends StandardScheme<connection_rollback_result> {

      public void read(org.apache.thrift.protocol.TProtocol iprot, connection_rollback_result struct) throws org.apache.thrift.TException {
        org.apache.thrift.protocol.TField schemeField;
        iprot.readStructBegin();
        while (true)
        {
          schemeField = iprot.readFieldBegin();
          if (schemeField.type == org.apache.thrift.protocol.TType.STOP) { 
            break;
          }
          switch (schemeField.id) {
            case 1: // SQL_EXCEPTION
              if (schemeField.type == org.apache.thrift.protocol.TType.STRUCT) {
                struct.sqlException = new RSQLException();
                struct.sqlException.read(iprot);
                struct.setSqlExceptionIsSet(true);
              } else { 
                org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
              }
              break;
            default:
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
          }
          iprot.readFieldEnd();
        }
        iprot.readStructEnd();

        // check for required fields of primitive type, which can't be checked in the validate method
        struct.validate();
      }

      public void write(org.apache.thrift.protocol.TProtocol oprot, connection_rollback_result struct) throws org.apache.thrift.TException {
        struct.validate();

        oprot.writeStructBegin(STRUCT_DESC);
        if (struct.sqlException != null) {
          oprot.writeFieldBegin(SQL_EXCEPTION_FIELD_DESC);
          struct.sqlException.write(oprot);
          oprot.writeFieldEnd();
        }
        oprot.writeFieldStop();
        oprot.writeStructEnd();
      }

    }

    private static class connection_rollback_resultTupleSchemeFactory implements SchemeFactory {
      public connection_rollback_resultTupleScheme getScheme() {
        return new connection_rollback_resultTupleScheme();
      }
    }

    private static class connection_rollback_resultTupleScheme extends TupleScheme<connection_rollback_result> {

      @Override
      public void write(org.apache.thrift.protocol.TProtocol prot, connection_rollback_result struct) throws org.apache.thrift.TException {
        TTupleProtocol oprot = (TTupleProtocol) prot;
        BitSet optionals = new BitSet();
        if (struct.isSetSqlException()) {
          optionals.set(0);
        }
        oprot.writeBitSet(optionals, 1);
        if (struct.isSetSqlException()) {
          struct.sqlException.write(oprot);
        }
      }

      @Override
      public void read(org.apache.thrift.protocol.TProtocol prot, connection_rollback_result struct) throws org.apache.thrift.TException {
        TTupleProtocol iprot = (TTupleProtocol) prot;
        BitSet incoming = iprot.readBitSet(1);
        if (incoming.get(0)) {
          struct.sqlException = new RSQLException();
          struct.sqlException.read(iprot);
          struct.setSqlExceptionIsSet(true);
        }
      }
    }

  }

  public static class connection_setAutoCommit_args implements org.apache.thrift.TBase<connection_setAutoCommit_args, connection_setAutoCommit_args._Fields>, java.io.Serializable, Cloneable, Comparable<connection_setAutoCommit_args>   {
    private static final org.apache.thrift.protocol.TStruct STRUCT_DESC = new org.apache.thrift.protocol.TStruct("connection_setAutoCommit_args");

    private static final org.apache.thrift.protocol.TField CONNECTION_FIELD_DESC = new org.apache.thrift.protocol.TField("connection", org.apache.thrift.protocol.TType.STRUCT, (short)1);
    private static final org.apache.thrift.protocol.TField AUTO_COMMIT_FIELD_DESC = new org.apache.thrift.protocol.TField("autoCommit", org.apache.thrift.protocol.TType.BOOL, (short)2);

    private static final Map<Class<? extends IScheme>, SchemeFactory> schemes = new HashMap<Class<? extends IScheme>, SchemeFactory>();
    static {
      schemes.put(StandardScheme.class, new connection_setAutoCommit_argsStandardSchemeFactory());
      schemes.put(TupleScheme.class, new connection_setAutoCommit_argsTupleSchemeFactory());
    }

    public RConnection connection; // required
    public boolean autoCommit; // required

    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements org.apache.thrift.TFieldIdEnum {
      CONNECTION((short)1, "connection"),
      AUTO_COMMIT((short)2, "autoCommit");

      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        switch(fieldId) {
          case 1: // CONNECTION
            return CONNECTION;
          case 2: // AUTO_COMMIT
            return AUTO_COMMIT;
          default:
            return null;
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }

    // isset id assignments
    private static final int __AUTOCOMMIT_ISSET_ID = 0;
    private byte __isset_bitfield = 0;
    public static final Map<_Fields, org.apache.thrift.meta_data.FieldMetaData> metaDataMap;
    static {
      Map<_Fields, org.apache.thrift.meta_data.FieldMetaData> tmpMap = new EnumMap<_Fields, org.apache.thrift.meta_data.FieldMetaData>(_Fields.class);
      tmpMap.put(_Fields.CONNECTION, new org.apache.thrift.meta_data.FieldMetaData("connection", org.apache.thrift.TFieldRequirementType.DEFAULT, 
          new org.apache.thrift.meta_data.StructMetaData(org.apache.thrift.protocol.TType.STRUCT, RConnection.class)));
      tmpMap.put(_Fields.AUTO_COMMIT, new org.apache.thrift.meta_data.FieldMetaData("autoCommit", org.apache.thrift.TFieldRequirementType.DEFAULT, 
          new org.apache.thrift.meta_data.FieldValueMetaData(org.apache.thrift.protocol.TType.BOOL)));
      metaDataMap = Collections.unmodifiableMap(tmpMap);
      org.apache.thrift.meta_data.FieldMetaData.addStructMetaDataMap(connection_setAutoCommit_args.class, metaDataMap);
    }

    public connection_setAutoCommit_args() {
    }

    public connection_setAutoCommit_args(
      RConnection connection,
      boolean autoCommit)
    {
      this();
      this.connection = connection;
      this.autoCommit = autoCommit;
      setAutoCommitIsSet(true);
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public connection_setAutoCommit_args(connection_setAutoCommit_args other) {
      __isset_bitfield = other.__isset_bitfield;
      if (other.isSetConnection()) {
        this.connection = new RConnection(other.connection);
      }
      this.autoCommit = other.autoCommit;
    }

    public connection_setAutoCommit_args deepCopy() {
      return new connection_setAutoCommit_args(this);
    }

    @Override
    public void clear() {
      this.connection = null;
      setAutoCommitIsSet(false);
      this.autoCommit = false;
    }

    public RConnection getConnection() {
      return this.connection;
    }

    public connection_setAutoCommit_args setConnection(RConnection connection) {
      this.connection = connection;
      return this;
    }

    public void unsetConnection() {
      this.connection = null;
    }

    /** Returns true if field connection is set (has been assigned a value) and false otherwise */
    public boolean isSetConnection() {
      return this.connection != null;
    }

    public void setConnectionIsSet(boolean value) {
      if (!value) {
        this.connection = null;
      }
    }

    public boolean isAutoCommit() {
      return this.autoCommit;
    }

    public connection_setAutoCommit_args setAutoCommit(boolean autoCommit) {
      this.autoCommit = autoCommit;
      setAutoCommitIsSet(true);
      return this;
    }

    public void unsetAutoCommit() {
      __isset_bitfield = EncodingUtils.clearBit(__isset_bitfield, __AUTOCOMMIT_ISSET_ID);
    }

    /** Returns true if field autoCommit is set (has been assigned a value) and false otherwise */
    public boolean isSetAutoCommit() {
      return EncodingUtils.testBit(__isset_bitfield, __AUTOCOMMIT_ISSET_ID);
    }

    public void setAutoCommitIsSet(boolean value) {
      __isset_bitfield = EncodingUtils.setBit(__isset_bitfield, __AUTOCOMMIT_ISSET_ID, value);
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      case CONNECTION:
        if (value == null) {
          unsetConnection();
        } else {
          setConnection((RConnection)value);
        }
        break;

      case AUTO_COMMIT:
        if (value == null) {
          unsetAutoCommit();
        } else {
          setAutoCommit((Boolean)value);
        }
        break;

      }
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      case CONNECTION:
        return getConnection();

      case AUTO_COMMIT:
        return Boolean.valueOf(isAutoCommit());

      }
      throw new IllegalStateException();
    }

    /** Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      if (field == null) {
        throw new IllegalArgumentException();
      }

      switch (field) {
      case CONNECTION:
        return isSetConnection();
      case AUTO_COMMIT:
        return isSetAutoCommit();
      }
      throw new IllegalStateException();
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof connection_setAutoCommit_args)
        return this.equals((connection_setAutoCommit_args)that);
      return false;
    }

    public boolean equals(connection_setAutoCommit_args that) {
      if (that == null)
        return false;

      boolean this_present_connection = true && this.isSetConnection();
      boolean that_present_connection = true && that.isSetConnection();
      if (this_present_connection || that_present_connection) {
        if (!(this_present_connection && that_present_connection))
          return false;
        if (!this.connection.equals(that.connection))
          return false;
      }

      boolean this_present_autoCommit = true;
      boolean that_present_autoCommit = true;
      if (this_present_autoCommit || that_present_autoCommit) {
        if (!(this_present_autoCommit && that_present_autoCommit))
          return false;
        if (this.autoCommit != that.autoCommit)
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      List<Object> list = new ArrayList<Object>();

      boolean present_connection = true && (isSetConnection());
      list.add(present_connection);
      if (present_connection)
        list.add(connection);

      boolean present_autoCommit = true;
      list.add(present_autoCommit);
      if (present_autoCommit)
        list.add(autoCommit);

      return list.hashCode();
    }

    @Override
    public int compareTo(connection_setAutoCommit_args other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetConnection()).compareTo(other.isSetConnection());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetConnection()) {
        lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.connection, other.connection);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      lastComparison = Boolean.valueOf(isSetAutoCommit()).compareTo(other.isSetAutoCommit());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetAutoCommit()) {
        lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.autoCommit, other.autoCommit);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      return 0;
    }

    public _Fields fieldForId(int fieldId) {
      return _Fields.findByThriftId(fieldId);
    }

    public void read(org.apache.thrift.protocol.TProtocol iprot) throws org.apache.thrift.TException {
      schemes.get(iprot.getScheme()).getScheme().read(iprot, this);
    }

    public void write(org.apache.thrift.protocol.TProtocol oprot) throws org.apache.thrift.TException {
      schemes.get(oprot.getScheme()).getScheme().write(oprot, this);
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("connection_setAutoCommit_args(");
      boolean first = true;

      sb.append("connection:");
      if (this.connection == null) {
        sb.append("null");
      } else {
        sb.append(this.connection);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("autoCommit:");
      sb.append(this.autoCommit);
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws org.apache.thrift.TException {
      // check for required fields
      // check for sub-struct validity
      if (connection != null) {
        connection.validate();
      }
    }

    private void writeObject(java.io.ObjectOutputStream out) throws java.io.IOException {
      try {
        write(new org.apache.thrift.protocol.TCompactProtocol(new org.apache.thrift.transport.TIOStreamTransport(out)));
      } catch (org.apache.thrift.TException te) {
        throw new java.io.IOException(te);
      }
    }

    private void readObject(java.io.ObjectInputStream in) throws java.io.IOException, ClassNotFoundException {
      try {
        // it doesn't seem like you should have to do this, but java serialization is wacky, and doesn't call the default constructor.
        __isset_bitfield = 0;
        read(new org.apache.thrift.protocol.TCompactProtocol(new org.apache.thrift.transport.TIOStreamTransport(in)));
      } catch (org.apache.thrift.TException te) {
        throw new java.io.IOException(te);
      }
    }

    private static class connection_setAutoCommit_argsStandardSchemeFactory implements SchemeFactory {
      public connection_setAutoCommit_argsStandardScheme getScheme() {
        return new connection_setAutoCommit_argsStandardScheme();
      }
    }

    private static class connection_setAutoCommit_argsStandardScheme extends StandardScheme<connection_setAutoCommit_args> {

      public void read(org.apache.thrift.protocol.TProtocol iprot, connection_setAutoCommit_args struct) throws org.apache.thrift.TException {
        org.apache.thrift.protocol.TField schemeField;
        iprot.readStructBegin();
        while (true)
        {
          schemeField = iprot.readFieldBegin();
          if (schemeField.type == org.apache.thrift.protocol.TType.STOP) { 
            break;
          }
          switch (schemeField.id) {
            case 1: // CONNECTION
              if (schemeField.type == org.apache.thrift.protocol.TType.STRUCT) {
                struct.connection = new RConnection();
                struct.connection.read(iprot);
                struct.setConnectionIsSet(true);
              } else { 
                org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
              }
              break;
            case 2: // AUTO_COMMIT
              if (schemeField.type == org.apache.thrift.protocol.TType.BOOL) {
                struct.autoCommit = iprot.readBool();
                struct.setAutoCommitIsSet(true);
              } else { 
                org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
              }
              break;
            default:
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
          }
          iprot.readFieldEnd();
        }
        iprot.readStructEnd();

        // check for required fields of primitive type, which can't be checked in the validate method
        struct.validate();
      }

      public void write(org.apache.thrift.protocol.TProtocol oprot, connection_setAutoCommit_args struct) throws org.apache.thrift.TException {
        struct.validate();

        oprot.writeStructBegin(STRUCT_DESC);
        if (struct.connection != null) {
          oprot.writeFieldBegin(CONNECTION_FIELD_DESC);
          struct.connection.write(oprot);
          oprot.writeFieldEnd();
        }
        oprot.writeFieldBegin(AUTO_COMMIT_FIELD_DESC);
        oprot.writeBool(struct.autoCommit);
        oprot.writeFieldEnd();
        oprot.writeFieldStop();
        oprot.writeStructEnd();
      }

    }

    private static class connection_setAutoCommit_argsTupleSchemeFactory implements SchemeFactory {
      public connection_setAutoCommit_argsTupleScheme getScheme() {
        return new connection_setAutoCommit_argsTupleScheme();
      }
    }

    private static class connection_setAutoCommit_argsTupleScheme extends TupleScheme<connection_setAutoCommit_args> {

      @Override
      public void write(org.apache.thrift.protocol.TProtocol prot, connection_setAutoCommit_args struct) throws org.apache.thrift.TException {
        TTupleProtocol oprot = (TTupleProtocol) prot;
        BitSet optionals = new BitSet();
        if (struct.isSetConnection()) {
          optionals.set(0);
        }
        if (struct.isSetAutoCommit()) {
          optionals.set(1);
        }
        oprot.writeBitSet(optionals, 2);
        if (struct.isSetConnection()) {
          struct.connection.write(oprot);
        }
        if (struct.isSetAutoCommit()) {
          oprot.writeBool(struct.autoCommit);
        }
      }

      @Override
      public void read(org.apache.thrift.protocol.TProtocol prot, connection_setAutoCommit_args struct) throws org.apache.thrift.TException {
        TTupleProtocol iprot = (TTupleProtocol) prot;
        BitSet incoming = iprot.readBitSet(2);
        if (incoming.get(0)) {
          struct.connection = new RConnection();
          struct.connection.read(iprot);
          struct.setConnectionIsSet(true);
        }
        if (incoming.get(1)) {
          struct.autoCommit = iprot.readBool();
          struct.setAutoCommitIsSet(true);
        }
      }
    }

  }

  public static class connection_setAutoCommit_result implements org.apache.thrift.TBase<connection_setAutoCommit_result, connection_setAutoCommit_result._Fields>, java.io.Serializable, Cloneable, Comparable<connection_setAutoCommit_result>   {
    private static final org.apache.thrift.protocol.TStruct STRUCT_DESC = new org.apache.thrift.protocol.TStruct("connection_setAutoCommit_result");

    private static final org.apache.thrift.protocol.TField SQL_EXCEPTION_FIELD_DESC = new org.apache.thrift.protocol.TField("sqlException", org.apache.thrift.protocol.TType.STRUCT, (short)1);

    private static final Map<Class<? extends IScheme>, SchemeFactory> schemes = new HashMap<Class<? extends IScheme>, SchemeFactory>();
    static {
      schemes.put(StandardScheme.class, new connection_setAutoCommit_resultStandardSchemeFactory());
      schemes.put(TupleScheme.class, new connection_setAutoCommit_resultTupleSchemeFactory());
    }

    public RSQLException sqlException; // required

    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements org.apache.thrift.TFieldIdEnum {
      SQL_EXCEPTION((short)1, "sqlException");

      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        switch(fieldId) {
          case 1: // SQL_EXCEPTION
            return SQL_EXCEPTION;
          default:
            return null;
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }

    // isset id assignments
    public static final Map<_Fields, org.apache.thrift.meta_data.FieldMetaData> metaDataMap;
    static {
      Map<_Fields, org.apache.thrift.meta_data.FieldMetaData> tmpMap = new EnumMap<_Fields, org.apache.thrift.meta_data.FieldMetaData>(_Fields.class);
      tmpMap.put(_Fields.SQL_EXCEPTION, new org.apache.thrift.meta_data.FieldMetaData("sqlException", org.apache.thrift.TFieldRequirementType.DEFAULT, 
          new org.apache.thrift.meta_data.FieldValueMetaData(org.apache.thrift.protocol.TType.STRUCT)));
      metaDataMap = Collections.unmodifiableMap(tmpMap);
      org.apache.thrift.meta_data.FieldMetaData.addStructMetaDataMap(connection_setAutoCommit_result.class, metaDataMap);
    }

    public connection_setAutoCommit_result() {
    }

    public connection_setAutoCommit_result(
      RSQLException sqlException)
    {
      this();
      this.sqlException = sqlException;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public connection_setAutoCommit_result(connection_setAutoCommit_result other) {
      if (other.isSetSqlException()) {
        this.sqlException = new RSQLException(other.sqlException);
      }
    }

    public connection_setAutoCommit_result deepCopy() {
      return new connection_setAutoCommit_result(this);
    }

    @Override
    public void clear() {
      this.sqlException = null;
    }

    public RSQLException getSqlException() {
      return this.sqlException;
    }

    public connection_setAutoCommit_result setSqlException(RSQLException sqlException) {
      this.sqlException = sqlException;
      return this;
    }

    public void unsetSqlException() {
      this.sqlException = null;
    }

    /** Returns true if field sqlException is set (has been assigned a value) and false otherwise */
    public boolean isSetSqlException() {
      return this.sqlException != null;
    }

    public void setSqlExceptionIsSet(boolean value) {
      if (!value) {
        this.sqlException = null;
      }
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      case SQL_EXCEPTION:
        if (value == null) {
          unsetSqlException();
        } else {
          setSqlException((RSQLException)value);
        }
        break;

      }
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      case SQL_EXCEPTION:
        return getSqlException();

      }
      throw new IllegalStateException();
    }

    /** Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      if (field == null) {
        throw new IllegalArgumentException();
      }

      switch (field) {
      case SQL_EXCEPTION:
        return isSetSqlException();
      }
      throw new IllegalStateException();
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof connection_setAutoCommit_result)
        return this.equals((connection_setAutoCommit_result)that);
      return false;
    }

    public boolean equals(connection_setAutoCommit_result that) {
      if (that == null)
        return false;

      boolean this_present_sqlException = true && this.isSetSqlException();
      boolean that_present_sqlException = true && that.isSetSqlException();
      if (this_present_sqlException || that_present_sqlException) {
        if (!(this_present_sqlException && that_present_sqlException))
          return false;
        if (!this.sqlException.equals(that.sqlException))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      List<Object> list = new ArrayList<Object>();

      boolean present_sqlException = true && (isSetSqlException());
      list.add(present_sqlException);
      if (present_sqlException)
        list.add(sqlException);

      return list.hashCode();
    }

    @Override
    public int compareTo(connection_setAutoCommit_result other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetSqlException()).compareTo(other.isSetSqlException());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetSqlException()) {
        lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.sqlException, other.sqlException);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      return 0;
    }

    public _Fields fieldForId(int fieldId) {
      return _Fields.findByThriftId(fieldId);
    }

    public void read(org.apache.thrift.protocol.TProtocol iprot) throws org.apache.thrift.TException {
      schemes.get(iprot.getScheme()).getScheme().read(iprot, this);
    }

    public void write(org.apache.thrift.protocol.TProtocol oprot) throws org.apache.thrift.TException {
      schemes.get(oprot.getScheme()).getScheme().write(oprot, this);
      }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("connection_setAutoCommit_result(");
      boolean first = true;

      sb.append("sqlException:");
      if (this.sqlException == null) {
        sb.append("null");
      } else {
        sb.append(this.sqlException);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws org.apache.thrift.TException {
      // check for required fields
      // check for sub-struct validity
    }

    private void writeObject(java.io.ObjectOutputStream out) throws java.io.IOException {
      try {
        write(new org.apache.thrift.protocol.TCompactProtocol(new org.apache.thrift.transport.TIOStreamTransport(out)));
      } catch (org.apache.thrift.TException te) {
        throw new java.io.IOException(te);
      }
    }

    private void readObject(java.io.ObjectInputStream in) throws java.io.IOException, ClassNotFoundException {
      try {
        read(new org.apache.thrift.protocol.TCompactProtocol(new org.apache.thrift.transport.TIOStreamTransport(in)));
      } catch (org.apache.thrift.TException te) {
        throw new java.io.IOException(te);
      }
    }

    private static class connection_setAutoCommit_resultStandardSchemeFactory implements SchemeFactory {
      public connection_setAutoCommit_resultStandardScheme getScheme() {
        return new connection_setAutoCommit_resultStandardScheme();
      }
    }

    private static class connection_setAutoCommit_resultStandardScheme extends StandardScheme<connection_setAutoCommit_result> {

      public void read(org.apache.thrift.protocol.TProtocol iprot, connection_setAutoCommit_result struct) throws org.apache.thrift.TException {
        org.apache.thrift.protocol.TField schemeField;
        iprot.readStructBegin();
        while (true)
        {
          schemeField = iprot.readFieldBegin();
          if (schemeField.type == org.apache.thrift.protocol.TType.STOP) { 
            break;
          }
          switch (schemeField.id) {
            case 1: // SQL_EXCEPTION
              if (schemeField.type == org.apache.thrift.protocol.TType.STRUCT) {
                struct.sqlException = new RSQLException();
                struct.sqlException.read(iprot);
                struct.setSqlExceptionIsSet(true);
              } else { 
                org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
              }
              break;
            default:
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
          }
          iprot.readFieldEnd();
        }
        iprot.readStructEnd();

        // check for required fields of primitive type, which can't be checked in the validate method
        struct.validate();
      }

      public void write(org.apache.thrift.protocol.TProtocol oprot, connection_setAutoCommit_result struct) throws org.apache.thrift.TException {
        struct.validate();

        oprot.writeStructBegin(STRUCT_DESC);
        if (struct.sqlException != null) {
          oprot.writeFieldBegin(SQL_EXCEPTION_FIELD_DESC);
          struct.sqlException.write(oprot);
          oprot.writeFieldEnd();
        }
        oprot.writeFieldStop();
        oprot.writeStructEnd();
      }

    }

    private static class connection_setAutoCommit_resultTupleSchemeFactory implements SchemeFactory {
      public connection_setAutoCommit_resultTupleScheme getScheme() {
        return new connection_setAutoCommit_resultTupleScheme();
      }
    }

    private static class connection_setAutoCommit_resultTupleScheme extends TupleScheme<connection_setAutoCommit_result> {

      @Override
      public void write(org.apache.thrift.protocol.TProtocol prot, connection_setAutoCommit_result struct) throws org.apache.thrift.TException {
        TTupleProtocol oprot = (TTupleProtocol) prot;
        BitSet optionals = new BitSet();
        if (struct.isSetSqlException()) {
          optionals.set(0);
        }
        oprot.writeBitSet(optionals, 1);
        if (struct.isSetSqlException()) {
          struct.sqlException.write(oprot);
        }
      }

      @Override
      public void read(org.apache.thrift.protocol.TProtocol prot, connection_setAutoCommit_result struct) throws org.apache.thrift.TException {
        TTupleProtocol iprot = (TTupleProtocol) prot;
        BitSet incoming = iprot.readBitSet(1);
        if (incoming.get(0)) {
          struct.sqlException = new RSQLException();
          struct.sqlException.read(iprot);
          struct.setSqlExceptionIsSet(true);
        }
      }
    }

  }

  public static class connection_getAutoCommit_args implements org.apache.thrift.TBase<connection_getAutoCommit_args, connection_getAutoCommit_args._Fields>, java.io.Serializable, Cloneable, Comparable<connection_getAutoCommit_args>   {
    private static final org.apache.thrift.protocol.TStruct STRUCT_DESC = new org.apache.thrift.protocol.TStruct("connection_getAutoCommit_args");

    private static final org.apache.thrift.protocol.TField CONNECTION_FIELD_DESC = new org.apache.thrift.protocol.TField("connection", org.apache.thrift.protocol.TType.STRUCT, (short)1);

    private static final Map<Class<? extends IScheme>, SchemeFactory> schemes = new HashMap<Class<? extends IScheme>, SchemeFactory>();
    static {
      schemes.put(StandardScheme.class, new connection_getAutoCommit_argsStandardSchemeFactory());
      schemes.put(TupleScheme.class, new connection_getAutoCommit_argsTupleSchemeFactory());
    }

    public RConnection connection; // required

    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements org.apache.thrift.TFieldIdEnum {
      CONNECTION((short)1, "connection");

      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        switch(fieldId) {
          case 1: // CONNECTION
            return CONNECTION;
          default:
            return null;
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }

    // isset id assignments
    public static final Map<_Fields, org.apache.thrift.meta_data.FieldMetaData> metaDataMap;
    static {
      Map<_Fields, org.apache.thrift.meta_data.FieldMetaData> tmpMap = new EnumMap<_Fields, org.apache.thrift.meta_data.FieldMetaData>(_Fields.class);
      tmpMap.put(_Fields.CONNECTION, new org.apache.thrift.meta_data.FieldMetaData("connection", org.apache.thrift.TFieldRequirementType.DEFAULT, 
          new org.apache.thrift.meta_data.StructMetaData(org.apache.thrift.protocol.TType.STRUCT, RConnection.class)));
      metaDataMap = Collections.unmodifiableMap(tmpMap);
      org.apache.thrift.meta_data.FieldMetaData.addStructMetaDataMap(connection_getAutoCommit_args.class, metaDataMap);
    }

    public connection_getAutoCommit_args() {
    }

    public connection_getAutoCommit_args(
      RConnection connection)
    {
      this();
      this.connection = connection;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public connection_getAutoCommit_args(connection_getAutoCommit_args other) {
      if (other.isSetConnection()) {
        this.connection = new RConnection(other.connection);
      }
    }

    public connection_getAutoCommit_args deepCopy() {
      return new connection_getAutoCommit_args(this);
    }

    @Override
    public void clear() {
      this.connection = null;
    }

    public RConnection getConnection() {
      return this.connection;
    }

    public connection_getAutoCommit_args setConnection(RConnection connection) {
      this.connection = connection;
      return this;
    }

    public void unsetConnection() {
      this.connection = null;
    }

    /** Returns true if field connection is set (has been assigned a value) and false otherwise */
    public boolean isSetConnection() {
      return this.connection != null;
    }

    public void setConnectionIsSet(boolean value) {
      if (!value) {
        this.connection = null;
      }
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      case CONNECTION:
        if (value == null) {
          unsetConnection();
        } else {
          setConnection((RConnection)value);
        }
        break;

      }
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      case CONNECTION:
        return getConnection();

      }
      throw new IllegalStateException();
    }

    /** Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      if (field == null) {
        throw new IllegalArgumentException();
      }

      switch (field) {
      case CONNECTION:
        return isSetConnection();
      }
      throw new IllegalStateException();
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof connection_getAutoCommit_args)
        return this.equals((connection_getAutoCommit_args)that);
      return false;
    }

    public boolean equals(connection_getAutoCommit_args that) {
      if (that == null)
        return false;

      boolean this_present_connection = true && this.isSetConnection();
      boolean that_present_connection = true && that.isSetConnection();
      if (this_present_connection || that_present_connection) {
        if (!(this_present_connection && that_present_connection))
          return false;
        if (!this.connection.equals(that.connection))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      List<Object> list = new ArrayList<Object>();

      boolean present_connection = true && (isSetConnection());
      list.add(present_connection);
      if (present_connection)
        list.add(connection);

      return list.hashCode();
    }

    @Override
    public int compareTo(connection_getAutoCommit_args other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetConnection()).compareTo(other.isSetConnection());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetConnection()) {
        lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.connection, other.connection);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      return 0;
    }

    public _Fields fieldForId(int fieldId) {
      return _Fields.findByThriftId(fieldId);
    }

    public void read(org.apache.thrift.protocol.TProtocol iprot) throws org.apache.thrift.TException {
      schemes.get(iprot.getScheme()).getScheme().read(iprot, this);
    }

    public void write(org.apache.thrift.protocol.TProtocol oprot) throws org.apache.thrift.TException {
      schemes.get(oprot.getScheme()).getScheme().write(oprot, this);
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("connection_getAutoCommit_args(");
      boolean first = true;

      sb.append("connection:");
      if (this.connection == null) {
        sb.append("null");
      } else {
        sb.append(this.connection);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws org.apache.thrift.TException {
      // check for required fields
      // check for sub-struct validity
      if (connection != null) {
        connection.validate();
      }
    }

    private void writeObject(java.io.ObjectOutputStream out) throws java.io.IOException {
      try {
        write(new org.apache.thrift.protocol.TCompactProtocol(new org.apache.thrift.transport.TIOStreamTransport(out)));
      } catch (org.apache.thrift.TException te) {
        throw new java.io.IOException(te);
      }
    }

    private void readObject(java.io.ObjectInputStream in) throws java.io.IOException, ClassNotFoundException {
      try {
        read(new org.apache.thrift.protocol.TCompactProtocol(new org.apache.thrift.transport.TIOStreamTransport(in)));
      } catch (org.apache.thrift.TException te) {
        throw new java.io.IOException(te);
      }
    }

    private static class connection_getAutoCommit_argsStandardSchemeFactory implements SchemeFactory {
      public connection_getAutoCommit_argsStandardScheme getScheme() {
        return new connection_getAutoCommit_argsStandardScheme();
      }
    }

    private static class connection_getAutoCommit_argsStandardScheme extends StandardScheme<connection_getAutoCommit_args> {

      public void read(org.apache.thrift.protocol.TProtocol iprot, connection_getAutoCommit_args struct) throws org.apache.thrift.TException {
        org.apache.thrift.protocol.TField schemeField;
        iprot.readStructBegin();
        while (true)
        {
          schemeField = iprot.readFieldBegin();
          if (schemeField.type == org.apache.thrift.protocol.TType.STOP) { 
            break;
          }
          switch (schemeField.id) {
            case 1: // CONNECTION
              if (schemeField.type == org.apache.thrift.protocol.TType.STRUCT) {
                struct.connection = new RConnection();
                struct.connection.read(iprot);
                struct.setConnectionIsSet(true);
              } else { 
                org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
              }
              break;
            default:
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
          }
          iprot.readFieldEnd();
        }
        iprot.readStructEnd();

        // check for required fields of primitive type, which can't be checked in the validate method
        struct.validate();
      }

      public void write(org.apache.thrift.protocol.TProtocol oprot, connection_getAutoCommit_args struct) throws org.apache.thrift.TException {
        struct.validate();

        oprot.writeStructBegin(STRUCT_DESC);
        if (struct.connection != null) {
          oprot.writeFieldBegin(CONNECTION_FIELD_DESC);
          struct.connection.write(oprot);
          oprot.writeFieldEnd();
        }
        oprot.writeFieldStop();
        oprot.writeStructEnd();
      }

    }

    private static class connection_getAutoCommit_argsTupleSchemeFactory implements SchemeFactory {
      public connection_getAutoCommit_argsTupleScheme getScheme() {
        return new connection_getAutoCommit_argsTupleScheme();
      }
    }

    private static class connection_getAutoCommit_argsTupleScheme extends TupleScheme<connection_getAutoCommit_args> {

      @Override
      public void write(org.apache.thrift.protocol.TProtocol prot, connection_getAutoCommit_args struct) throws org.apache.thrift.TException {
        TTupleProtocol oprot = (TTupleProtocol) prot;
        BitSet optionals = new BitSet();
        if (struct.isSetConnection()) {
          optionals.set(0);
        }
        oprot.writeBitSet(optionals, 1);
        if (struct.isSetConnection()) {
          struct.connection.write(oprot);
        }
      }

      @Override
      public void read(org.apache.thrift.protocol.TProtocol prot, connection_getAutoCommit_args struct) throws org.apache.thrift.TException {
        TTupleProtocol iprot = (TTupleProtocol) prot;
        BitSet incoming = iprot.readBitSet(1);
        if (incoming.get(0)) {
          struct.connection = new RConnection();
          struct.connection.read(iprot);
          struct.setConnectionIsSet(true);
        }
      }
    }

  }

  public static class connection_getAutoCommit_result implements org.apache.thrift.TBase<connection_getAutoCommit_result, connection_getAutoCommit_result._Fields>, java.io.Serializable, Cloneable, Comparable<connection_getAutoCommit_result>   {
    private static final org.apache.thrift.protocol.TStruct STRUCT_DESC = new org.apache.thrift.protocol.TStruct("connection_getAutoCommit_result");

    private static final org.apache.thrift.protocol.TField SUCCESS_FIELD_DESC = new org.apache.thrift.protocol.TField("success", org.apache.thrift.protocol.TType.BOOL, (short)0);
    private static final org.apache.thrift.protocol.TField SQL_EXCEPTION_FIELD_DESC = new org.apache.thrift.protocol.TField("sqlException", org.apache.thrift.protocol.TType.STRUCT, (short)1);

    private static final Map<Class<? extends IScheme>, SchemeFactory> schemes = new HashMap<Class<? extends IScheme>, SchemeFactory>();
    static {
      schemes.put(StandardScheme.class, new connection_getAutoCommit_resultStandardSchemeFactory());
      schemes.put(TupleScheme.class, new connection_getAutoCommit_resultTupleSchemeFactory());
    }

    public boolean success; // required
    public RSQLException sqlException; // required

    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements org.apache.thrift.TFieldIdEnum {
      SUCCESS((short)0, "success"),
      SQL_EXCEPTION((short)1, "sqlException");

      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        switch(fieldId) {
          case 0: // SUCCESS
            return SUCCESS;
          case 1: // SQL_EXCEPTION
            return SQL_EXCEPTION;
          default:
            return null;
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }

    // isset id assignments
    private static final int __SUCCESS_ISSET_ID = 0;
    private byte __isset_bitfield = 0;
    public static final Map<_Fields, org.apache.thrift.meta_data.FieldMetaData> metaDataMap;
    static {
      Map<_Fields, org.apache.thrift.meta_data.FieldMetaData> tmpMap = new EnumMap<_Fields, org.apache.thrift.meta_data.FieldMetaData>(_Fields.class);
      tmpMap.put(_Fields.SUCCESS, new org.apache.thrift.meta_data.FieldMetaData("success", org.apache.thrift.TFieldRequirementType.DEFAULT, 
          new org.apache.thrift.meta_data.FieldValueMetaData(org.apache.thrift.protocol.TType.BOOL)));
      tmpMap.put(_Fields.SQL_EXCEPTION, new org.apache.thrift.meta_data.FieldMetaData("sqlException", org.apache.thrift.TFieldRequirementType.DEFAULT, 
          new org.apache.thrift.meta_data.FieldValueMetaData(org.apache.thrift.protocol.TType.STRUCT)));
      metaDataMap = Collections.unmodifiableMap(tmpMap);
      org.apache.thrift.meta_data.FieldMetaData.addStructMetaDataMap(connection_getAutoCommit_result.class, metaDataMap);
    }

    public connection_getAutoCommit_result() {
    }

    public connection_getAutoCommit_result(
      boolean success,
      RSQLException sqlException)
    {
      this();
      this.success = success;
      setSuccessIsSet(true);
      this.sqlException = sqlException;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public connection_getAutoCommit_result(connection_getAutoCommit_result other) {
      __isset_bitfield = other.__isset_bitfield;
      this.success = other.success;
      if (other.isSetSqlException()) {
        this.sqlException = new RSQLException(other.sqlException);
      }
    }

    public connection_getAutoCommit_result deepCopy() {
      return new connection_getAutoCommit_result(this);
    }

    @Override
    public void clear() {
      setSuccessIsSet(false);
      this.success = false;
      this.sqlException = null;
    }

    public boolean isSuccess() {
      return this.success;
    }

    public connection_getAutoCommit_result setSuccess(boolean success) {
      this.success = success;
      setSuccessIsSet(true);
      return this;
    }

    public void unsetSuccess() {
      __isset_bitfield = EncodingUtils.clearBit(__isset_bitfield, __SUCCESS_ISSET_ID);
    }

    /** Returns true if field success is set (has been assigned a value) and false otherwise */
    public boolean isSetSuccess() {
      return EncodingUtils.testBit(__isset_bitfield, __SUCCESS_ISSET_ID);
    }

    public void setSuccessIsSet(boolean value) {
      __isset_bitfield = EncodingUtils.setBit(__isset_bitfield, __SUCCESS_ISSET_ID, value);
    }

    public RSQLException getSqlException() {
      return this.sqlException;
    }

    public connection_getAutoCommit_result setSqlException(RSQLException sqlException) {
      this.sqlException = sqlException;
      return this;
    }

    public void unsetSqlException() {
      this.sqlException = null;
    }

    /** Returns true if field sqlException is set (has been assigned a value) and false otherwise */
    public boolean isSetSqlException() {
      return this.sqlException != null;
    }

    public void setSqlExceptionIsSet(boolean value) {
      if (!value) {
        this.sqlException = null;
      }
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          setSuccess((Boolean)value);
        }
        break;

      case SQL_EXCEPTION:
        if (value == null) {
          unsetSqlException();
        } else {
          setSqlException((RSQLException)value);
        }
        break;

      }
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      case SUCCESS:
        return Boolean.valueOf(isSuccess());

      case SQL_EXCEPTION:
        return getSqlException();

      }
      throw new IllegalStateException();
    }

    /** Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      if (field == null) {
        throw new IllegalArgumentException();
      }

      switch (field) {
      case SUCCESS:
        return isSetSuccess();
      case SQL_EXCEPTION:
        return isSetSqlException();
      }
      throw new IllegalStateException();
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof connection_getAutoCommit_result)
        return this.equals((connection_getAutoCommit_result)that);
      return false;
    }

    public boolean equals(connection_getAutoCommit_result that) {
      if (that == null)
        return false;

      boolean this_present_success = true;
      boolean that_present_success = true;
      if (this_present_success || that_present_success) {
        if (!(this_present_success && that_present_success))
          return false;
        if (this.success != that.success)
          return false;
      }

      boolean this_present_sqlException = true && this.isSetSqlException();
      boolean that_present_sqlException = true && that.isSetSqlException();
      if (this_present_sqlException || that_present_sqlException) {
        if (!(this_present_sqlException && that_present_sqlException))
          return false;
        if (!this.sqlException.equals(that.sqlException))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      List<Object> list = new ArrayList<Object>();

      boolean present_success = true;
      list.add(present_success);
      if (present_success)
        list.add(success);

      boolean present_sqlException = true && (isSetSqlException());
      list.add(present_sqlException);
      if (present_sqlException)
        list.add(sqlException);

      return list.hashCode();
    }

    @Override
    public int compareTo(connection_getAutoCommit_result other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetSuccess()).compareTo(other.isSetSuccess());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetSuccess()) {
        lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.success, other.success);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      lastComparison = Boolean.valueOf(isSetSqlException()).compareTo(other.isSetSqlException());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetSqlException()) {
        lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.sqlException, other.sqlException);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      return 0;
    }

    public _Fields fieldForId(int fieldId) {
      return _Fields.findByThriftId(fieldId);
    }

    public void read(org.apache.thrift.protocol.TProtocol iprot) throws org.apache.thrift.TException {
      schemes.get(iprot.getScheme()).getScheme().read(iprot, this);
    }

    public void write(org.apache.thrift.protocol.TProtocol oprot) throws org.apache.thrift.TException {
      schemes.get(oprot.getScheme()).getScheme().write(oprot, this);
      }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("connection_getAutoCommit_result(");
      boolean first = true;

      sb.append("success:");
      sb.append(this.success);
      first = false;
      if (!first) sb.append(", ");
      sb.append("sqlException:");
      if (this.sqlException == null) {
        sb.append("null");
      } else {
        sb.append(this.sqlException);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws org.apache.thrift.TException {
      // check for required fields
      // check for sub-struct validity
    }

    private void writeObject(java.io.ObjectOutputStream out) throws java.io.IOException {
      try {
        write(new org.apache.thrift.protocol.TCompactProtocol(new org.apache.thrift.transport.TIOStreamTransport(out)));
      } catch (org.apache.thrift.TException te) {
        throw new java.io.IOException(te);
      }
    }

    private void readObject(java.io.ObjectInputStream in) throws java.io.IOException, ClassNotFoundException {
      try {
        // it doesn't seem like you should have to do this, but java serialization is wacky, and doesn't call the default constructor.
        __isset_bitfield = 0;
        read(new org.apache.thrift.protocol.TCompactProtocol(new org.apache.thrift.transport.TIOStreamTransport(in)));
      } catch (org.apache.thrift.TException te) {
        throw new java.io.IOException(te);
      }
    }

    private static class connection_getAutoCommit_resultStandardSchemeFactory implements SchemeFactory {
      public connection_getAutoCommit_resultStandardScheme getScheme() {
        return new connection_getAutoCommit_resultStandardScheme();
      }
    }

    private static class connection_getAutoCommit_resultStandardScheme extends StandardScheme<connection_getAutoCommit_result> {

      public void read(org.apache.thrift.protocol.TProtocol iprot, connection_getAutoCommit_result struct) throws org.apache.thrift.TException {
        org.apache.thrift.protocol.TField schemeField;
        iprot.readStructBegin();
        while (true)
        {
          schemeField = iprot.readFieldBegin();
          if (schemeField.type == org.apache.thrift.protocol.TType.STOP) { 
            break;
          }
          switch (schemeField.id) {
            case 0: // SUCCESS
              if (schemeField.type == org.apache.thrift.protocol.TType.BOOL) {
                struct.success = iprot.readBool();
                struct.setSuccessIsSet(true);
              } else { 
                org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
              }
              break;
            case 1: // SQL_EXCEPTION
              if (schemeField.type == org.apache.thrift.protocol.TType.STRUCT) {
                struct.sqlException = new RSQLException();
                struct.sqlException.read(iprot);
                struct.setSqlExceptionIsSet(true);
              } else { 
                org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
              }
              break;
            default:
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
          }
          iprot.readFieldEnd();
        }
        iprot.readStructEnd();

        // check for required fields of primitive type, which can't be checked in the validate method
        struct.validate();
      }

      public void write(org.apache.thrift.protocol.TProtocol oprot, connection_getAutoCommit_result struct) throws org.apache.thrift.TException {
        struct.validate();

        oprot.writeStructBegin(STRUCT_DESC);
        if (struct.isSetSuccess()) {
          oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
          oprot.writeBool(struct.success);
          oprot.writeFieldEnd();
        }
        if (struct.sqlException != null) {
          oprot.writeFieldBegin(SQL_EXCEPTION_FIELD_DESC);
          struct.sqlException.write(oprot);
          oprot.writeFieldEnd();
        }
        oprot.writeFieldStop();
        oprot.writeStructEnd();
      }

    }

    private static class connection_getAutoCommit_resultTupleSchemeFactory implements SchemeFactory {
      public connection_getAutoCommit_resultTupleScheme getScheme() {
        return new connection_getAutoCommit_resultTupleScheme();
      }
    }

    private static class connection_getAutoCommit_resultTupleScheme extends TupleScheme<connection_getAutoCommit_result> {

      @Override
      public void write(org.apache.thrift.protocol.TProtocol prot, connection_getAutoCommit_result struct) throws org.apache.thrift.TException {
        TTupleProtocol oprot = (TTupleProtocol) prot;
        BitSet optionals = new BitSet();
        if (struct.isSetSuccess()) {
          optionals.set(0);
        }
        if (struct.isSetSqlException()) {
          optionals.set(1);
        }
        oprot.writeBitSet(optionals, 2);
        if (struct.isSetSuccess()) {
          oprot.writeBool(struct.success);
        }
        if (struct.isSetSqlException()) {
          struct.sqlException.write(oprot);
        }
      }

      @Override
      public void read(org.apache.thrift.protocol.TProtocol prot, connection_getAutoCommit_result struct) throws org.apache.thrift.TException {
        TTupleProtocol iprot = (TTupleProtocol) prot;
        BitSet incoming = iprot.readBitSet(2);
        if (incoming.get(0)) {
          struct.success = iprot.readBool();
          struct.setSuccessIsSet(true);
        }
        if (incoming.get(1)) {
          struct.sqlException = new RSQLException();
          struct.sqlException.read(iprot);
          struct.setSqlExceptionIsSet(true);
        }
      }
    }

  }

  public static class connection_setTransactionIsolation_args implements org.apache.thrift.TBase<connection_setTransactionIsolation_args, connection_setTransactionIsolation_args._Fields>, java.io.Serializable, Cloneable, Comparable<connection_setTransactionIsolation_args>   {
    private static final org.apache.thrift.protocol.TStruct STRUCT_DESC = new org.apache.thrift.protocol.TStruct("connection_setTransactionIsolation_args");

    private static final org.apache.thrift.protocol.TField CONNECTION_FIELD_DESC = new org.apache.thrift.protocol.TField("connection", org.apache.thrift.protocol.TType.STRUCT, (short)1);
    private static final org.apache.thrift.protocol.TField LEVEL_FIELD_DESC = new org.apache.thrift.protocol.TField("level", org.apache.thrift.protocol.TType.I32, (short)2);

    private static final Map<Class<? extends IScheme>, SchemeFactory> schemes = new HashMap<Class<? extends IScheme>, SchemeFactory>();
    static {
      schemes.put(StandardScheme.class, new connection_setTransactionIsolation_argsStandardSchemeFactory());
      schemes.put(TupleScheme.class, new connection_setTransactionIsolation_argsTupleSchemeFactory());
    }

    public RConnection connection; // required
    public int level; // required

    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements org.apache.thrift.TFieldIdEnum {
      CONNECTION((short)1, "connection"),
      LEVEL((short)2, "level");

      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        switch(fieldId) {
          case 1: // CONNECTION
            return CONNECTION;
          case 2: // LEVEL
            return LEVEL;
          default:
            return null;
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }

    // isset id assignments
    private static final int __LEVEL_ISSET_ID = 0;
    private byte __isset_bitfield = 0;
    public static final Map<_Fields, org.apache.thrift.meta_data.FieldMetaData> metaDataMap;
    static {
      Map<_Fields, org.apache.thrift.meta_data.FieldMetaData> tmpMap = new EnumMap<_Fields, org.apache.thrift.meta_data.FieldMetaData>(_Fields.class);
      tmpMap.put(_Fields.CONNECTION, new org.apache.thrift.meta_data.FieldMetaData("connection", org.apache.thrift.TFieldRequirementType.DEFAULT, 
          new org.apache.thrift.meta_data.StructMetaData(org.apache.thrift.protocol.TType.STRUCT, RConnection.class)));
      tmpMap.put(_Fields.LEVEL, new org.apache.thrift.meta_data.FieldMetaData("level", org.apache.thrift.TFieldRequirementType.DEFAULT, 
          new org.apache.thrift.meta_data.FieldValueMetaData(org.apache.thrift.protocol.TType.I32)));
      metaDataMap = Collections.unmodifiableMap(tmpMap);
      org.apache.thrift.meta_data.FieldMetaData.addStructMetaDataMap(connection_setTransactionIsolation_args.class, metaDataMap);
    }

    public connection_setTransactionIsolation_args() {
    }

    public connection_setTransactionIsolation_args(
      RConnection connection,
      int level)
    {
      this();
      this.connection = connection;
      this.level = level;
      setLevelIsSet(true);
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public connection_setTransactionIsolation_args(connection_setTransactionIsolation_args other) {
      __isset_bitfield = other.__isset_bitfield;
      if (other.isSetConnection()) {
        this.connection = new RConnection(other.connection);
      }
      this.level = other.level;
    }

    public connection_setTransactionIsolation_args deepCopy() {
      return new connection_setTransactionIsolation_args(this);
    }

    @Override
    public void clear() {
      this.connection = null;
      setLevelIsSet(false);
      this.level = 0;
    }

    public RConnection getConnection() {
      return this.connection;
    }

    public connection_setTransactionIsolation_args setConnection(RConnection connection) {
      this.connection = connection;
      return this;
    }

    public void unsetConnection() {
      this.connection = null;
    }

    /** Returns true if field connection is set (has been assigned a value) and false otherwise */
    public boolean isSetConnection() {
      return this.connection != null;
    }

    public void setConnectionIsSet(boolean value) {
      if (!value) {
        this.connection = null;
      }
    }

    public int getLevel() {
      return this.level;
    }

    public connection_setTransactionIsolation_args setLevel(int level) {
      this.level = level;
      setLevelIsSet(true);
      return this;
    }

    public void unsetLevel() {
      __isset_bitfield = EncodingUtils.clearBit(__isset_bitfield, __LEVEL_ISSET_ID);
    }

    /** Returns true if field level is set (has been assigned a value) and false otherwise */
    public boolean isSetLevel() {
      return EncodingUtils.testBit(__isset_bitfield, __LEVEL_ISSET_ID);
    }

    public void setLevelIsSet(boolean value) {
      __isset_bitfield = EncodingUtils.setBit(__isset_bitfield, __LEVEL_ISSET_ID, value);
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      case CONNECTION:
        if (value == null) {
          unsetConnection();
        } else {
          setConnection((RConnection)value);
        }
        break;

      case LEVEL:
        if (value == null) {
          unsetLevel();
        } else {
          setLevel((Integer)value);
        }
        break;

      }
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      case CONNECTION:
        return getConnection();

      case LEVEL:
        return Integer.valueOf(getLevel());

      }
      throw new IllegalStateException();
    }

    /** Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      if (field == null) {
        throw new IllegalArgumentException();
      }

      switch (field) {
      case CONNECTION:
        return isSetConnection();
      case LEVEL:
        return isSetLevel();
      }
      throw new IllegalStateException();
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof connection_setTransactionIsolation_args)
        return this.equals((connection_setTransactionIsolation_args)that);
      return false;
    }

    public boolean equals(connection_setTransactionIsolation_args that) {
      if (that == null)
        return false;

      boolean this_present_connection = true && this.isSetConnection();
      boolean that_present_connection = true && that.isSetConnection();
      if (this_present_connection || that_present_connection) {
        if (!(this_present_connection && that_present_connection))
          return false;
        if (!this.connection.equals(that.connection))
          return false;
      }

      boolean this_present_level = true;
      boolean that_present_level = true;
      if (this_present_level || that_present_level) {
        if (!(this_present_level && that_present_level))
          return false;
        if (this.level != that.level)
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      List<Object> list = new ArrayList<Object>();

      boolean present_connection = true && (isSetConnection());
      list.add(present_connection);
      if (present_connection)
        list.add(connection);

      boolean present_level = true;
      list.add(present_level);
      if (present_level)
        list.add(level);

      return list.hashCode();
    }

    @Override
    public int compareTo(connection_setTransactionIsolation_args other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetConnection()).compareTo(other.isSetConnection());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetConnection()) {
        lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.connection, other.connection);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      lastComparison = Boolean.valueOf(isSetLevel()).compareTo(other.isSetLevel());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetLevel()) {
        lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.level, other.level);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      return 0;
    }

    public _Fields fieldForId(int fieldId) {
      return _Fields.findByThriftId(fieldId);
    }

    public void read(org.apache.thrift.protocol.TProtocol iprot) throws org.apache.thrift.TException {
      schemes.get(iprot.getScheme()).getScheme().read(iprot, this);
    }

    public void write(org.apache.thrift.protocol.TProtocol oprot) throws org.apache.thrift.TException {
      schemes.get(oprot.getScheme()).getScheme().write(oprot, this);
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("connection_setTransactionIsolation_args(");
      boolean first = true;

      sb.append("connection:");
      if (this.connection == null) {
        sb.append("null");
      } else {
        sb.append(this.connection);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("level:");
      sb.append(this.level);
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws org.apache.thrift.TException {
      // check for required fields
      // check for sub-struct validity
      if (connection != null) {
        connection.validate();
      }
    }

    private void writeObject(java.io.ObjectOutputStream out) throws java.io.IOException {
      try {
        write(new org.apache.thrift.protocol.TCompactProtocol(new org.apache.thrift.transport.TIOStreamTransport(out)));
      } catch (org.apache.thrift.TException te) {
        throw new java.io.IOException(te);
      }
    }

    private void readObject(java.io.ObjectInputStream in) throws java.io.IOException, ClassNotFoundException {
      try {
        // it doesn't seem like you should have to do this, but java serialization is wacky, and doesn't call the default constructor.
        __isset_bitfield = 0;
        read(new org.apache.thrift.protocol.TCompactProtocol(new org.apache.thrift.transport.TIOStreamTransport(in)));
      } catch (org.apache.thrift.TException te) {
        throw new java.io.IOException(te);
      }
    }

    private static class connection_setTransactionIsolation_argsStandardSchemeFactory implements SchemeFactory {
      public connection_setTransactionIsolation_argsStandardScheme getScheme() {
        return new connection_setTransactionIsolation_argsStandardScheme();
      }
    }

    private static class connection_setTransactionIsolation_argsStandardScheme extends StandardScheme<connection_setTransactionIsolation_args> {

      public void read(org.apache.thrift.protocol.TProtocol iprot, connection_setTransactionIsolation_args struct) throws org.apache.thrift.TException {
        org.apache.thrift.protocol.TField schemeField;
        iprot.readStructBegin();
        while (true)
        {
          schemeField = iprot.readFieldBegin();
          if (schemeField.type == org.apache.thrift.protocol.TType.STOP) { 
            break;
          }
          switch (schemeField.id) {
            case 1: // CONNECTION
              if (schemeField.type == org.apache.thrift.protocol.TType.STRUCT) {
                struct.connection = new RConnection();
                struct.connection.read(iprot);
                struct.setConnectionIsSet(true);
              } else { 
                org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
              }
              break;
            case 2: // LEVEL
              if (schemeField.type == org.apache.thrift.protocol.TType.I32) {
                struct.level = iprot.readI32();
                struct.setLevelIsSet(true);
              } else { 
                org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
              }
              break;
            default:
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
          }
          iprot.readFieldEnd();
        }
        iprot.readStructEnd();

        // check for required fields of primitive type, which can't be checked in the validate method
        struct.validate();
      }

      public void write(org.apache.thrift.protocol.TProtocol oprot, connection_setTransactionIsolation_args struct) throws org.apache.thrift.TException {
        struct.validate();

        oprot.writeStructBegin(STRUCT_DESC);
        if (struct.connection != null) {
          oprot.writeFieldBegin(CONNECTION_FIELD_DESC);
          struct.connection.write(oprot);
          oprot.writeFieldEnd();
        }
        oprot.writeFieldBegin(LEVEL_FIELD_DESC);
        oprot.writeI32(struct.level);
        oprot.writeFieldEnd();
        oprot.writeFieldStop();
        oprot.writeStructEnd();
      }

    }

    private static class connection_setTransactionIsolation_argsTupleSchemeFactory implements SchemeFactory {
      public connection_setTransactionIsolation_argsTupleScheme getScheme() {
        return new connection_setTransactionIsolation_argsTupleScheme();
      }
    }

    private static class connection_setTransactionIsolation_argsTupleScheme extends TupleScheme<connection_setTransactionIsolation_args> {

      @Override
      public void write(org.apache.thrift.protocol.TProtocol prot, connection_setTransactionIsolation_args struct) throws org.apache.thrift.TException {
        TTupleProtocol oprot = (TTupleProtocol) prot;
        BitSet optionals = new BitSet();
        if (struct.isSetConnection()) {
          optionals.set(0);
        }
        if (struct.isSetLevel()) {
          optionals.set(1);
        }
        oprot.writeBitSet(optionals, 2);
        if (struct.isSetConnection()) {
          struct.connection.write(oprot);
        }
        if (struct.isSetLevel()) {
          oprot.writeI32(struct.level);
        }
      }

      @Override
      public void read(org.apache.thrift.protocol.TProtocol prot, connection_setTransactionIsolation_args struct) throws org.apache.thrift.TException {
        TTupleProtocol iprot = (TTupleProtocol) prot;
        BitSet incoming = iprot.readBitSet(2);
        if (incoming.get(0)) {
          struct.connection = new RConnection();
          struct.connection.read(iprot);
          struct.setConnectionIsSet(true);
        }
        if (incoming.get(1)) {
          struct.level = iprot.readI32();
          struct.setLevelIsSet(true);
        }
      }
    }

  }

  public static class connection_setTransactionIsolation_result implements org.apache.thrift.TBase<connection_setTransactionIsolation_result, connection_setTransactionIsolation_result._Fields>, java.io.Serializable, Cloneable, Comparable<connection_setTransactionIsolation_result>   {
    private static final org.apache.thrift.protocol.TStruct STRUCT_DESC = new org.apache.thrift.protocol.TStruct("connection_setTransactionIsolation_result");

    private static final org.apache.thrift.protocol.TField SQL_EXCEPTION_FIELD_DESC = new org.apache.thrift.protocol.TField("sqlException", org.apache.thrift.protocol.TType.STRUCT, (short)1);

    private static final Map<Class<? extends IScheme>, SchemeFactory> schemes = new HashMap<Class<? extends IScheme>, SchemeFactory>();
    static {
      schemes.put(StandardScheme.class, new connection_setTransactionIsolation_resultStandardSchemeFactory());
      schemes.put(TupleScheme.class, new connection_setTransactionIsolation_resultTupleSchemeFactory());
    }

    public RSQLException sqlException; // required

    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements org.apache.thrift.TFieldIdEnum {
      SQL_EXCEPTION((short)1, "sqlException");

      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        switch(fieldId) {
          case 1: // SQL_EXCEPTION
            return SQL_EXCEPTION;
          default:
            return null;
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }

    // isset id assignments
    public static final Map<_Fields, org.apache.thrift.meta_data.FieldMetaData> metaDataMap;
    static {
      Map<_Fields, org.apache.thrift.meta_data.FieldMetaData> tmpMap = new EnumMap<_Fields, org.apache.thrift.meta_data.FieldMetaData>(_Fields.class);
      tmpMap.put(_Fields.SQL_EXCEPTION, new org.apache.thrift.meta_data.FieldMetaData("sqlException", org.apache.thrift.TFieldRequirementType.DEFAULT, 
          new org.apache.thrift.meta_data.FieldValueMetaData(org.apache.thrift.protocol.TType.STRUCT)));
      metaDataMap = Collections.unmodifiableMap(tmpMap);
      org.apache.thrift.meta_data.FieldMetaData.addStructMetaDataMap(connection_setTransactionIsolation_result.class, metaDataMap);
    }

    public connection_setTransactionIsolation_result() {
    }

    public connection_setTransactionIsolation_result(
      RSQLException sqlException)
    {
      this();
      this.sqlException = sqlException;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public connection_setTransactionIsolation_result(connection_setTransactionIsolation_result other) {
      if (other.isSetSqlException()) {
        this.sqlException = new RSQLException(other.sqlException);
      }
    }

    public connection_setTransactionIsolation_result deepCopy() {
      return new connection_setTransactionIsolation_result(this);
    }

    @Override
    public void clear() {
      this.sqlException = null;
    }

    public RSQLException getSqlException() {
      return this.sqlException;
    }

    public connection_setTransactionIsolation_result setSqlException(RSQLException sqlException) {
      this.sqlException = sqlException;
      return this;
    }

    public void unsetSqlException() {
      this.sqlException = null;
    }

    /** Returns true if field sqlException is set (has been assigned a value) and false otherwise */
    public boolean isSetSqlException() {
      return this.sqlException != null;
    }

    public void setSqlExceptionIsSet(boolean value) {
      if (!value) {
        this.sqlException = null;
      }
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      case SQL_EXCEPTION:
        if (value == null) {
          unsetSqlException();
        } else {
          setSqlException((RSQLException)value);
        }
        break;

      }
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      case SQL_EXCEPTION:
        return getSqlException();

      }
      throw new IllegalStateException();
    }

    /** Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      if (field == null) {
        throw new IllegalArgumentException();
      }

      switch (field) {
      case SQL_EXCEPTION:
        return isSetSqlException();
      }
      throw new IllegalStateException();
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof connection_setTransactionIsolation_result)
        return this.equals((connection_setTransactionIsolation_result)that);
      return false;
    }

    public boolean equals(connection_setTransactionIsolation_result that) {
      if (that == null)
        return false;

      boolean this_present_sqlException = true && this.isSetSqlException();
      boolean that_present_sqlException = true && that.isSetSqlException();
      if (this_present_sqlException || that_present_sqlException) {
        if (!(this_present_sqlException && that_present_sqlException))
          return false;
        if (!this.sqlException.equals(that.sqlException))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      List<Object> list = new ArrayList<Object>();

      boolean present_sqlException = true && (isSetSqlException());
      list.add(present_sqlException);
      if (present_sqlException)
        list.add(sqlException);

      return list.hashCode();
    }

    @Override
    public int compareTo(connection_setTransactionIsolation_result other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetSqlException()).compareTo(other.isSetSqlException());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetSqlException()) {
        lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.sqlException, other.sqlException);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      return 0;
    }

    public _Fields fieldForId(int fieldId) {
      return _Fields.findByThriftId(fieldId);
    }

    public void read(org.apache.thrift.protocol.TProtocol iprot) throws org.apache.thrift.TException {
      schemes.get(iprot.getScheme()).getScheme().read(iprot, this);
    }

    public void write(org.apache.thrift.protocol.TProtocol oprot) throws org.apache.thrift.TException {
      schemes.get(oprot.getScheme()).getScheme().write(oprot, this);
      }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("connection_setTransactionIsolation_result(");
      boolean first = true;

      sb.append("sqlException:");
      if (this.sqlException == null) {
        sb.append("null");
      } else {
        sb.append(this.sqlException);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws org.apache.thrift.TException {
      // check for required fields
      // check for sub-struct validity
    }

    private void writeObject(java.io.ObjectOutputStream out) throws java.io.IOException {
      try {
        write(new org.apache.thrift.protocol.TCompactProtocol(new org.apache.thrift.transport.TIOStreamTransport(out)));
      } catch (org.apache.thrift.TException te) {
        throw new java.io.IOException(te);
      }
    }

    private void readObject(java.io.ObjectInputStream in) throws java.io.IOException, ClassNotFoundException {
      try {
        read(new org.apache.thrift.protocol.TCompactProtocol(new org.apache.thrift.transport.TIOStreamTransport(in)));
      } catch (org.apache.thrift.TException te) {
        throw new java.io.IOException(te);
      }
    }

    private static class connection_setTransactionIsolation_resultStandardSchemeFactory implements SchemeFactory {
      public connection_setTransactionIsolation_resultStandardScheme getScheme() {
        return new connection_setTransactionIsolation_resultStandardScheme();
      }
    }

    private static class connection_setTransactionIsolation_resultStandardScheme extends StandardScheme<connection_setTransactionIsolation_result> {

      public void read(org.apache.thrift.protocol.TProtocol iprot, connection_setTransactionIsolation_result struct) throws org.apache.thrift.TException {
        org.apache.thrift.protocol.TField schemeField;
        iprot.readStructBegin();
        while (true)
        {
          schemeField = iprot.readFieldBegin();
          if (schemeField.type == org.apache.thrift.protocol.TType.STOP) { 
            break;
          }
          switch (schemeField.id) {
            case 1: // SQL_EXCEPTION
              if (schemeField.type == org.apache.thrift.protocol.TType.STRUCT) {
                struct.sqlException = new RSQLException();
                struct.sqlException.read(iprot);
                struct.setSqlExceptionIsSet(true);
              } else { 
                org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
              }
              break;
            default:
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
          }
          iprot.readFieldEnd();
        }
        iprot.readStructEnd();

        // check for required fields of primitive type, which can't be checked in the validate method
        struct.validate();
      }

      public void write(org.apache.thrift.protocol.TProtocol oprot, connection_setTransactionIsolation_result struct) throws org.apache.thrift.TException {
        struct.validate();

        oprot.writeStructBegin(STRUCT_DESC);
        if (struct.sqlException != null) {
          oprot.writeFieldBegin(SQL_EXCEPTION_FIELD_DESC);
          struct.sqlException.write(oprot);
          oprot.writeFieldEnd();
        }
        oprot.writeFieldStop();
        oprot.writeStructEnd();
      }

    }

    private static class connection_setTransactionIsolation_resultTupleSchemeFactory implements SchemeFactory {
      public connection_setTransactionIsolation_resultTupleScheme getScheme() {
        return new connection_setTransactionIsolation_resultTupleScheme();
      }
    }

    private static class connection_setTransactionIsolation_resultTupleScheme extends TupleScheme<connection_setTransactionIsolation_result> {

      @Override
      public void write(org.apache.thrift.protocol.TProtocol prot, connection_setTransactionIsolation_result struct) throws org.apache.thrift.TException {
        TTupleProtocol oprot = (TTupleProtocol) prot;
        BitSet optionals = new BitSet();
        if (struct.isSetSqlException()) {
          optionals.set(0);
        }
        oprot.writeBitSet(optionals, 1);
        if (struct.isSetSqlException()) {
          struct.sqlException.write(oprot);
        }
      }

      @Override
      public void read(org.apache.thrift.protocol.TProtocol prot, connection_setTransactionIsolation_result struct) throws org.apache.thrift.TException {
        TTupleProtocol iprot = (TTupleProtocol) prot;
        BitSet incoming = iprot.readBitSet(1);
        if (incoming.get(0)) {
          struct.sqlException = new RSQLException();
          struct.sqlException.read(iprot);
          struct.setSqlExceptionIsSet(true);
        }
      }
    }

  }

  public static class connection_getTransactionIsolation_args implements org.apache.thrift.TBase<connection_getTransactionIsolation_args, connection_getTransactionIsolation_args._Fields>, java.io.Serializable, Cloneable, Comparable<connection_getTransactionIsolation_args>   {
    private static final org.apache.thrift.protocol.TStruct STRUCT_DESC = new org.apache.thrift.protocol.TStruct("connection_getTransactionIsolation_args");

    private static final org.apache.thrift.protocol.TField CONNECTION_FIELD_DESC = new org.apache.thrift.protocol.TField("connection", org.apache.thrift.protocol.TType.STRUCT, (short)1);

    private static final Map<Class<? extends IScheme>, SchemeFactory> schemes = new HashMap<Class<? extends IScheme>, SchemeFactory>();
    static {
      schemes.put(StandardScheme.class, new connection_getTransactionIsolation_argsStandardSchemeFactory());
      schemes.put(TupleScheme.class, new connection_getTransactionIsolation_argsTupleSchemeFactory());
    }

    public RConnection connection; // required

    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements org.apache.thrift.TFieldIdEnum {
      CONNECTION((short)1, "connection");

      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        switch(fieldId) {
          case 1: // CONNECTION
            return CONNECTION;
          default:
            return null;
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }

    // isset id assignments
    public static final Map<_Fields, org.apache.thrift.meta_data.FieldMetaData> metaDataMap;
    static {
      Map<_Fields, org.apache.thrift.meta_data.FieldMetaData> tmpMap = new EnumMap<_Fields, org.apache.thrift.meta_data.FieldMetaData>(_Fields.class);
      tmpMap.put(_Fields.CONNECTION, new org.apache.thrift.meta_data.FieldMetaData("connection", org.apache.thrift.TFieldRequirementType.DEFAULT, 
          new org.apache.thrift.meta_data.StructMetaData(org.apache.thrift.protocol.TType.STRUCT, RConnection.class)));
      metaDataMap = Collections.unmodifiableMap(tmpMap);
      org.apache.thrift.meta_data.FieldMetaData.addStructMetaDataMap(connection_getTransactionIsolation_args.class, metaDataMap);
    }

    public connection_getTransactionIsolation_args() {
    }

    public connection_getTransactionIsolation_args(
      RConnection connection)
    {
      this();
      this.connection = connection;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public connection_getTransactionIsolation_args(connection_getTransactionIsolation_args other) {
      if (other.isSetConnection()) {
        this.connection = new RConnection(other.connection);
      }
    }

    public connection_getTransactionIsolation_args deepCopy() {
      return new connection_getTransactionIsolation_args(this);
    }

    @Override
    public void clear() {
      this.connection = null;
    }

    public RConnection getConnection() {
      return this.connection;
    }

    public connection_getTransactionIsolation_args setConnection(RConnection connection) {
      this.connection = connection;
      return this;
    }

    public void unsetConnection() {
      this.connection = null;
    }

    /** Returns true if field connection is set (has been assigned a value) and false otherwise */
    public boolean isSetConnection() {
      return this.connection != null;
    }

    public void setConnectionIsSet(boolean value) {
      if (!value) {
        this.connection = null;
      }
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      case CONNECTION:
        if (value == null) {
          unsetConnection();
        } else {
          setConnection((RConnection)value);
        }
        break;

      }
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      case CONNECTION:
        return getConnection();

      }
      throw new IllegalStateException();
    }

    /** Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      if (field == null) {
        throw new IllegalArgumentException();
      }

      switch (field) {
      case CONNECTION:
        return isSetConnection();
      }
      throw new IllegalStateException();
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof connection_getTransactionIsolation_args)
        return this.equals((connection_getTransactionIsolation_args)that);
      return false;
    }

    public boolean equals(connection_getTransactionIsolation_args that) {
      if (that == null)
        return false;

      boolean this_present_connection = true && this.isSetConnection();
      boolean that_present_connection = true && that.isSetConnection();
      if (this_present_connection || that_present_connection) {
        if (!(this_present_connection && that_present_connection))
          return false;
        if (!this.connection.equals(that.connection))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      List<Object> list = new ArrayList<Object>();

      boolean present_connection = true && (isSetConnection());
      list.add(present_connection);
      if (present_connection)
        list.add(connection);

      return list.hashCode();
    }

    @Override
    public int compareTo(connection_getTransactionIsolation_args other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetConnection()).compareTo(other.isSetConnection());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetConnection()) {
        lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.connection, other.connection);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      return 0;
    }

    public _Fields fieldForId(int fieldId) {
      return _Fields.findByThriftId(fieldId);
    }

    public void read(org.apache.thrift.protocol.TProtocol iprot) throws org.apache.thrift.TException {
      schemes.get(iprot.getScheme()).getScheme().read(iprot, this);
    }

    public void write(org.apache.thrift.protocol.TProtocol oprot) throws org.apache.thrift.TException {
      schemes.get(oprot.getScheme()).getScheme().write(oprot, this);
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("connection_getTransactionIsolation_args(");
      boolean first = true;

      sb.append("connection:");
      if (this.connection == null) {
        sb.append("null");
      } else {
        sb.append(this.connection);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws org.apache.thrift.TException {
      // check for required fields
      // check for sub-struct validity
      if (connection != null) {
        connection.validate();
      }
    }

    private void writeObject(java.io.ObjectOutputStream out) throws java.io.IOException {
      try {
        write(new org.apache.thrift.protocol.TCompactProtocol(new org.apache.thrift.transport.TIOStreamTransport(out)));
      } catch (org.apache.thrift.TException te) {
        throw new java.io.IOException(te);
      }
    }

    private void readObject(java.io.ObjectInputStream in) throws java.io.IOException, ClassNotFoundException {
      try {
        read(new org.apache.thrift.protocol.TCompactProtocol(new org.apache.thrift.transport.TIOStreamTransport(in)));
      } catch (org.apache.thrift.TException te) {
        throw new java.io.IOException(te);
      }
    }

    private static class connection_getTransactionIsolation_argsStandardSchemeFactory implements SchemeFactory {
      public connection_getTransactionIsolation_argsStandardScheme getScheme() {
        return new connection_getTransactionIsolation_argsStandardScheme();
      }
    }

    private static class connection_getTransactionIsolation_argsStandardScheme extends StandardScheme<connection_getTransactionIsolation_args> {

      public void read(org.apache.thrift.protocol.TProtocol iprot, connection_getTransactionIsolation_args struct) throws org.apache.thrift.TException {
        org.apache.thrift.protocol.TField schemeField;
        iprot.readStructBegin();
        while (true)
        {
          schemeField = iprot.readFieldBegin();
          if (schemeField.type == org.apache.thrift.protocol.TType.STOP) { 
            break;
          }
          switch (schemeField.id) {
            case 1: // CONNECTION
              if (schemeField.type == org.apache.thrift.protocol.TType.STRUCT) {
                struct.connection = new RConnection();
                struct.connection.read(iprot);
                struct.setConnectionIsSet(true);
              } else { 
                org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
              }
              break;
            default:
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
          }
          iprot.readFieldEnd();
        }
        iprot.readStructEnd();

        // check for required fields of primitive type, which can't be checked in the validate method
        struct.validate();
      }

      public void write(org.apache.thrift.protocol.TProtocol oprot, connection_getTransactionIsolation_args struct) throws org.apache.thrift.TException {
        struct.validate();

        oprot.writeStructBegin(STRUCT_DESC);
        if (struct.connection != null) {
          oprot.writeFieldBegin(CONNECTION_FIELD_DESC);
          struct.connection.write(oprot);
          oprot.writeFieldEnd();
        }
        oprot.writeFieldStop();
        oprot.writeStructEnd();
      }

    }

    private static class connection_getTransactionIsolation_argsTupleSchemeFactory implements SchemeFactory {
      public connection_getTransactionIsolation_argsTupleScheme getScheme() {
        return new connection_getTransactionIsolation_argsTupleScheme();
      }
    }

    private static class connection_getTransactionIsolation_argsTupleScheme extends TupleScheme<connection_getTransactionIsolation_args> {

      @Override
      public void write(org.apache.thrift.protocol.TProtocol prot, connection_getTransactionIsolation_args struct) throws org.apache.thrift.TException {
        TTupleProtocol oprot = (TTupleProtocol) prot;
        BitSet optionals = new BitSet();
        if (struct.isSetConnection()) {
          optionals.set(0);
        }
        oprot.writeBitSet(optionals, 1);
        if (struct.isSetConnection()) {
          struct.connection.write(oprot);
        }
      }

      @Override
      public void read(org.apache.thrift.protocol.TProtocol prot, connection_getTransactionIsolation_args struct) throws org.apache.thrift.TException {
        TTupleProtocol iprot = (TTupleProtocol) prot;
        BitSet incoming = iprot.readBitSet(1);
        if (incoming.get(0)) {
          struct.connection = new RConnection();
          struct.connection.read(iprot);
          struct.setConnectionIsSet(true);
        }
      }
    }

  }

  public static class connection_getTransactionIsolation_result implements org.apache.thrift.TBase<connection_getTransactionIsolation_result, connection_getTransactionIsolation_result._Fields>, java.io.Serializable, Cloneable, Comparable<connection_getTransactionIsolation_result>   {
    private static final org.apache.thrift.protocol.TStruct STRUCT_DESC = new org.apache.thrift.protocol.TStruct("connection_getTransactionIsolation_result");

    private static final org.apache.thrift.protocol.TField SUCCESS_FIELD_DESC = new org.apache.thrift.protocol.TField("success", org.apache.thrift.protocol.TType.I32, (short)0);
    private static final org.apache.thrift.protocol.TField SQL_EXCEPTION_FIELD_DESC = new org.apache.thrift.protocol.TField("sqlException", org.apache.thrift.protocol.TType.STRUCT, (short)1);

    private static final Map<Class<? extends IScheme>, SchemeFactory> schemes = new HashMap<Class<? extends IScheme>, SchemeFactory>();
    static {
      schemes.put(StandardScheme.class, new connection_getTransactionIsolation_resultStandardSchemeFactory());
      schemes.put(TupleScheme.class, new connection_getTransactionIsolation_resultTupleSchemeFactory());
    }

    public int success; // required
    public RSQLException sqlException; // required

    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements org.apache.thrift.TFieldIdEnum {
      SUCCESS((short)0, "success"),
      SQL_EXCEPTION((short)1, "sqlException");

      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        switch(fieldId) {
          case 0: // SUCCESS
            return SUCCESS;
          case 1: // SQL_EXCEPTION
            return SQL_EXCEPTION;
          default:
            return null;
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }

    // isset id assignments
    private static final int __SUCCESS_ISSET_ID = 0;
    private byte __isset_bitfield = 0;
    public static final Map<_Fields, org.apache.thrift.meta_data.FieldMetaData> metaDataMap;
    static {
      Map<_Fields, org.apache.thrift.meta_data.FieldMetaData> tmpMap = new EnumMap<_Fields, org.apache.thrift.meta_data.FieldMetaData>(_Fields.class);
      tmpMap.put(_Fields.SUCCESS, new org.apache.thrift.meta_data.FieldMetaData("success", org.apache.thrift.TFieldRequirementType.DEFAULT, 
          new org.apache.thrift.meta_data.FieldValueMetaData(org.apache.thrift.protocol.TType.I32)));
      tmpMap.put(_Fields.SQL_EXCEPTION, new org.apache.thrift.meta_data.FieldMetaData("sqlException", org.apache.thrift.TFieldRequirementType.DEFAULT, 
          new org.apache.thrift.meta_data.FieldValueMetaData(org.apache.thrift.protocol.TType.STRUCT)));
      metaDataMap = Collections.unmodifiableMap(tmpMap);
      org.apache.thrift.meta_data.FieldMetaData.addStructMetaDataMap(connection_getTransactionIsolation_result.class, metaDataMap);
    }

    public connection_getTransactionIsolation_result() {
    }

    public connection_getTransactionIsolation_result(
      int success,
      RSQLException sqlException)
    {
      this();
      this.success = success;
      setSuccessIsSet(true);
      this.sqlException = sqlException;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public connection_getTransactionIsolation_result(connection_getTransactionIsolation_result other) {
      __isset_bitfield = other.__isset_bitfield;
      this.success = other.success;
      if (other.isSetSqlException()) {
        this.sqlException = new RSQLException(other.sqlException);
      }
    }

    public connection_getTransactionIsolation_result deepCopy() {
      return new connection_getTransactionIsolation_result(this);
    }

    @Override
    public void clear() {
      setSuccessIsSet(false);
      this.success = 0;
      this.sqlException = null;
    }

    public int getSuccess() {
      return this.success;
    }

    public connection_getTransactionIsolation_result setSuccess(int success) {
      this.success = success;
      setSuccessIsSet(true);
      return this;
    }

    public void unsetSuccess() {
      __isset_bitfield = EncodingUtils.clearBit(__isset_bitfield, __SUCCESS_ISSET_ID);
    }

    /** Returns true if field success is set (has been assigned a value) and false otherwise */
    public boolean isSetSuccess() {
      return EncodingUtils.testBit(__isset_bitfield, __SUCCESS_ISSET_ID);
    }

    public void setSuccessIsSet(boolean value) {
      __isset_bitfield = EncodingUtils.setBit(__isset_bitfield, __SUCCESS_ISSET_ID, value);
    }

    public RSQLException getSqlException() {
      return this.sqlException;
    }

    public connection_getTransactionIsolation_result setSqlException(RSQLException sqlException) {
      this.sqlException = sqlException;
      return this;
    }

    public void unsetSqlException() {
      this.sqlException = null;
    }

    /** Returns true if field sqlException is set (has been assigned a value) and false otherwise */
    public boolean isSetSqlException() {
      return this.sqlException != null;
    }

    public void setSqlExceptionIsSet(boolean value) {
      if (!value) {
        this.sqlException = null;
      }
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          setSuccess((Integer)value);
        }
        break;

      case SQL_EXCEPTION:
        if (value == null) {
          unsetSqlException();
        } else {
          setSqlException((RSQLException)value);
        }
        break;

      }
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      case SUCCESS:
        return Integer.valueOf(getSuccess());

      case SQL_EXCEPTION:
        return getSqlException();

      }
      throw new IllegalStateException();
    }

    /** Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      if (field == null) {
        throw new IllegalArgumentException();
      }

      switch (field) {
      case SUCCESS:
        return isSetSuccess();
      case SQL_EXCEPTION:
        return isSetSqlException();
      }
      throw new IllegalStateException();
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof connection_getTransactionIsolation_result)
        return this.equals((connection_getTransactionIsolation_result)that);
      return false;
    }

    public boolean equals(connection_getTransactionIsolation_result that) {
      if (that == null)
        return false;

      boolean this_present_success = true;
      boolean that_present_success = true;
      if (this_present_success || that_present_success) {
        if (!(this_present_success && that_present_success))
          return false;
        if (this.success != that.success)
          return false;
      }

      boolean this_present_sqlException = true && this.isSetSqlException();
      boolean that_present_sqlException = true && that.isSetSqlException();
      if (this_present_sqlException || that_present_sqlException) {
        if (!(this_present_sqlException && that_present_sqlException))
          return false;
        if (!this.sqlException.equals(that.sqlException))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      List<Object> list = new ArrayList<Object>();

      boolean present_success = true;
      list.add(present_success);
      if (present_success)
        list.add(success);

      boolean present_sqlException = true && (isSetSqlException());
      list.add(present_sqlException);
      if (present_sqlException)
        list.add(sqlException);

      return list.hashCode();
    }

    @Override
    public int compareTo(connection_getTransactionIsolation_result other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetSuccess()).compareTo(other.isSetSuccess());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetSuccess()) {
        lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.success, other.success);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      lastComparison = Boolean.valueOf(isSetSqlException()).compareTo(other.isSetSqlException());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetSqlException()) {
        lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.sqlException, other.sqlException);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      return 0;
    }

    public _Fields fieldForId(int fieldId) {
      return _Fields.findByThriftId(fieldId);
    }

    public void read(org.apache.thrift.protocol.TProtocol iprot) throws org.apache.thrift.TException {
      schemes.get(iprot.getScheme()).getScheme().read(iprot, this);
    }

    public void write(org.apache.thrift.protocol.TProtocol oprot) throws org.apache.thrift.TException {
      schemes.get(oprot.getScheme()).getScheme().write(oprot, this);
      }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("connection_getTransactionIsolation_result(");
      boolean first = true;

      sb.append("success:");
      sb.append(this.success);
      first = false;
      if (!first) sb.append(", ");
      sb.append("sqlException:");
      if (this.sqlException == null) {
        sb.append("null");
      } else {
        sb.append(this.sqlException);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws org.apache.thrift.TException {
      // check for required fields
      // check for sub-struct validity
    }

    private void writeObject(java.io.ObjectOutputStream out) throws java.io.IOException {
      try {
        write(new org.apache.thrift.protocol.TCompactProtocol(new org.apache.thrift.transport.TIOStreamTransport(out)));
      } catch (org.apache.thrift.TException te) {
        throw new java.io.IOException(te);
      }
    }

    private void readObject(java.io.ObjectInputStream in) throws java.io.IOException, ClassNotFoundException {
      try {
        // it doesn't seem like you should have to do this, but java serialization is wacky, and doesn't call the default constructor.
        __isset_bitfield = 0;
        read(new org.apache.thrift.protocol.TCompactProtocol(new org.apache.thrift.transport.TIOStreamTransport(in)));
      } catch (org.apache.thrift.TException te) {
        throw new java.io.IOException(te);
      }
    }

    private static class connection_getTransactionIsolation_resultStandardSchemeFactory implements SchemeFactory {
      public connection_getTransactionIsolation_resultStandardScheme getScheme() {
        return new connection_getTransactionIsolation_resultStandardScheme();
      }
    }

    private static class connection_getTransactionIsolation_resultStandardScheme extends StandardScheme<connection_getTransactionIsolation_result> {

      public void read(org.apache.thrift.protocol.TProtocol iprot, connection_getTransactionIsolation_result struct) throws org.apache.thrift.TException {
        org.apache.thrift.protocol.TField schemeField;
        iprot.readStructBegin();
        while (true)
        {
          schemeField = iprot.readFieldBegin();
          if (schemeField.type == org.apache.thrift.protocol.TType.STOP) { 
            break;
          }
          switch (schemeField.id) {
            case 0: // SUCCESS
              if (schemeField.type == org.apache.thrift.protocol.TType.I32) {
                struct.success = iprot.readI32();
                struct.setSuccessIsSet(true);
              } else { 
                org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
              }
              break;
            case 1: // SQL_EXCEPTION
              if (schemeField.type == org.apache.thrift.protocol.TType.STRUCT) {
                struct.sqlException = new RSQLException();
                struct.sqlException.read(iprot);
                struct.setSqlExceptionIsSet(true);
              } else { 
                org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
              }
              break;
            default:
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
          }
          iprot.readFieldEnd();
        }
        iprot.readStructEnd();

        // check for required fields of primitive type, which can't be checked in the validate method
        struct.validate();
      }

      public void write(org.apache.thrift.protocol.TProtocol oprot, connection_getTransactionIsolation_result struct) throws org.apache.thrift.TException {
        struct.validate();

        oprot.writeStructBegin(STRUCT_DESC);
        if (struct.isSetSuccess()) {
          oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
          oprot.writeI32(struct.success);
          oprot.writeFieldEnd();
        }
        if (struct.sqlException != null) {
          oprot.writeFieldBegin(SQL_EXCEPTION_FIELD_DESC);
          struct.sqlException.write(oprot);
          oprot.writeFieldEnd();
        }
        oprot.writeFieldStop();
        oprot.writeStructEnd();
      }

    }

    private static class connection_getTransactionIsolation_resultTupleSchemeFactory implements SchemeFactory {
      public connection_getTransactionIsolation_resultTupleScheme getScheme() {
        return new connection_getTransactionIsolation_resultTupleScheme();
      }
    }

    private static class connection_getTransactionIsolation_resultTupleScheme extends TupleScheme<connection_getTransactionIsolation_result> {

      @Override
      public void write(org.apache.thrift.protocol.TProtocol prot, connection_getTransactionIsolation_result struct) throws org.apache.thrift.TException {
        TTupleProtocol oprot = (TTupleProtocol) prot;
        BitSet optionals = new BitSet();
        if (struct.isSetSuccess()) {
          optionals.set(0);
        }
        if (struct.isSetSqlException()) {
          optionals.set(1);
        }
        oprot.writeBitSet(optionals, 2);
        if (struct.isSetSuccess()) {
          oprot.writeI32(struct.success);
        }
        if (struct.isSetSqlException()) {
          struct.sqlException.write(oprot);
        }
      }

      @Override
      public void read(org.apache.thrift.protocol.TProtocol prot, connection_getTransactionIsolation_result struct) throws org.apache.thrift.TException {
        TTupleProtocol iprot = (TTupleProtocol) prot;
        BitSet incoming = iprot.readBitSet(2);
        if (incoming.get(0)) {
          struct.success = iprot.readI32();
          struct.setSuccessIsSet(true);
        }
        if (incoming.get(1)) {
          struct.sqlException = new RSQLException();
          struct.sqlException.read(iprot);
          struct.setSqlExceptionIsSet(true);
        }
      }
    }

  }

  public static class connection_setReadOnly_args implements org.apache.thrift.TBase<connection_setReadOnly_args, connection_setReadOnly_args._Fields>, java.io.Serializable, Cloneable, Comparable<connection_setReadOnly_args>   {
    private static final org.apache.thrift.protocol.TStruct STRUCT_DESC = new org.apache.thrift.protocol.TStruct("connection_setReadOnly_args");

    private static final org.apache.thrift.protocol.TField CONNECTION_FIELD_DESC = new org.apache.thrift.protocol.TField("connection", org.apache.thrift.protocol.TType.STRUCT, (short)1);
    private static final org.apache.thrift.protocol.TField READ_ONLY_FIELD_DESC = new org.apache.thrift.protocol.TField("readOnly", org.apache.thrift.protocol.TType.BOOL, (short)2);

    private static final Map<Class<? extends IScheme>, SchemeFactory> schemes = new HashMap<Class<? extends IScheme>, SchemeFactory>();
    static {
      schemes.put(StandardScheme.class, new connection_setReadOnly_argsStandardSchemeFactory());
      schemes.put(TupleScheme.class, new connection_setReadOnly_argsTupleSchemeFactory());
    }

    public RConnection connection; // required
    public boolean readOnly; // required

    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements org.apache.thrift.TFieldIdEnum {
      CONNECTION((short)1, "connection"),
      READ_ONLY((short)2, "readOnly");

      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        switch(fieldId) {
          case 1: // CONNECTION
            return CONNECTION;
          case 2: // READ_ONLY
            return READ_ONLY;
          default:
            return null;
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }

    // isset id assignments
    private static final int __READONLY_ISSET_ID = 0;
    private byte __isset_bitfield = 0;
    public static final Map<_Fields, org.apache.thrift.meta_data.FieldMetaData> metaDataMap;
    static {
      Map<_Fields, org.apache.thrift.meta_data.FieldMetaData> tmpMap = new EnumMap<_Fields, org.apache.thrift.meta_data.FieldMetaData>(_Fields.class);
      tmpMap.put(_Fields.CONNECTION, new org.apache.thrift.meta_data.FieldMetaData("connection", org.apache.thrift.TFieldRequirementType.DEFAULT, 
          new org.apache.thrift.meta_data.StructMetaData(org.apache.thrift.protocol.TType.STRUCT, RConnection.class)));
      tmpMap.put(_Fields.READ_ONLY, new org.apache.thrift.meta_data.FieldMetaData("readOnly", org.apache.thrift.TFieldRequirementType.DEFAULT, 
          new org.apache.thrift.meta_data.FieldValueMetaData(org.apache.thrift.protocol.TType.BOOL)));
      metaDataMap = Collections.unmodifiableMap(tmpMap);
      org.apache.thrift.meta_data.FieldMetaData.addStructMetaDataMap(connection_setReadOnly_args.class, metaDataMap);
    }

    public connection_setReadOnly_args() {
    }

    public connection_setReadOnly_args(
      RConnection connection,
      boolean readOnly)
    {
      this();
      this.connection = connection;
      this.readOnly = readOnly;
      setReadOnlyIsSet(true);
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public connection_setReadOnly_args(connection_setReadOnly_args other) {
      __isset_bitfield = other.__isset_bitfield;
      if (other.isSetConnection()) {
        this.connection = new RConnection(other.connection);
      }
      this.readOnly = other.readOnly;
    }

    public connection_setReadOnly_args deepCopy() {
      return new connection_setReadOnly_args(this);
    }

    @Override
    public void clear() {
      this.connection = null;
      setReadOnlyIsSet(false);
      this.readOnly = false;
    }

    public RConnection getConnection() {
      return this.connection;
    }

    public connection_setReadOnly_args setConnection(RConnection connection) {
      this.connection = connection;
      return this;
    }

    public void unsetConnection() {
      this.connection = null;
    }

    /** Returns true if field connection is set (has been assigned a value) and false otherwise */
    public boolean isSetConnection() {
      return this.connection != null;
    }

    public void setConnectionIsSet(boolean value) {
      if (!value) {
        this.connection = null;
      }
    }

    public boolean isReadOnly() {
      return this.readOnly;
    }

    public connection_setReadOnly_args setReadOnly(boolean readOnly) {
      this.readOnly = readOnly;
      setReadOnlyIsSet(true);
      return this;
    }

    public void unsetReadOnly() {
      __isset_bitfield = EncodingUtils.clearBit(__isset_bitfield, __READONLY_ISSET_ID);
    }

    /** Returns true if field readOnly is set (has been assigned a value) and false otherwise */
    public boolean isSetReadOnly() {
      return EncodingUtils.testBit(__isset_bitfield, __READONLY_ISSET_ID);
    }

    public void setReadOnlyIsSet(boolean value) {
      __isset_bitfield = EncodingUtils.setBit(__isset_bitfield, __READONLY_ISSET_ID, value);
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      case CONNECTION:
        if (value == null) {
          unsetConnection();
        } else {
          setConnection((RConnection)value);
        }
        break;

      case READ_ONLY:
        if (value == null) {
          unsetReadOnly();
        } else {
          setReadOnly((Boolean)value);
        }
        break;

      }
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      case CONNECTION:
        return getConnection();

      case READ_ONLY:
        return Boolean.valueOf(isReadOnly());

      }
      throw new IllegalStateException();
    }

    /** Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      if (field == null) {
        throw new IllegalArgumentException();
      }

      switch (field) {
      case CONNECTION:
        return isSetConnection();
      case READ_ONLY:
        return isSetReadOnly();
      }
      throw new IllegalStateException();
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof connection_setReadOnly_args)
        return this.equals((connection_setReadOnly_args)that);
      return false;
    }

    public boolean equals(connection_setReadOnly_args that) {
      if (that == null)
        return false;

      boolean this_present_connection = true && this.isSetConnection();
      boolean that_present_connection = true && that.isSetConnection();
      if (this_present_connection || that_present_connection) {
        if (!(this_present_connection && that_present_connection))
          return false;
        if (!this.connection.equals(that.connection))
          return false;
      }

      boolean this_present_readOnly = true;
      boolean that_present_readOnly = true;
      if (this_present_readOnly || that_present_readOnly) {
        if (!(this_present_readOnly && that_present_readOnly))
          return false;
        if (this.readOnly != that.readOnly)
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      List<Object> list = new ArrayList<Object>();

      boolean present_connection = true && (isSetConnection());
      list.add(present_connection);
      if (present_connection)
        list.add(connection);

      boolean present_readOnly = true;
      list.add(present_readOnly);
      if (present_readOnly)
        list.add(readOnly);

      return list.hashCode();
    }

    @Override
    public int compareTo(connection_setReadOnly_args other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetConnection()).compareTo(other.isSetConnection());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetConnection()) {
        lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.connection, other.connection);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      lastComparison = Boolean.valueOf(isSetReadOnly()).compareTo(other.isSetReadOnly());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetReadOnly()) {
        lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.readOnly, other.readOnly);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      return 0;
    }

    public _Fields fieldForId(int fieldId) {
      return _Fields.findByThriftId(fieldId);
    }

    public void read(org.apache.thrift.protocol.TProtocol iprot) throws org.apache.thrift.TException {
      schemes.get(iprot.getScheme()).getScheme().read(iprot, this);
    }

    public void write(org.apache.thrift.protocol.TProtocol oprot) throws org.apache.thrift.TException {
      schemes.get(oprot.getScheme()).getScheme().write(oprot, this);
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("connection_setReadOnly_args(");
      boolean first = true;

      sb.append("connection:");
      if (this.connection == null) {
        sb.append("null");
      } else {
        sb.append(this.connection);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("readOnly:");
      sb.append(this.readOnly);
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws org.apache.thrift.TException {
      // check for required fields
      // check for sub-struct validity
      if (connection != null) {
        connection.validate();
      }
    }

    private void writeObject(java.io.ObjectOutputStream out) throws java.io.IOException {
      try {
        write(new org.apache.thrift.protocol.TCompactProtocol(new org.apache.thrift.transport.TIOStreamTransport(out)));
      } catch (org.apache.thrift.TException te) {
        throw new java.io.IOException(te);
      }
    }

    private void readObject(java.io.ObjectInputStream in) throws java.io.IOException, ClassNotFoundException {
      try {
        // it doesn't seem like you should have to do this, but java serialization is wacky, and doesn't call the default constructor.
        __isset_bitfield = 0;
        read(new org.apache.thrift.protocol.TCompactProtocol(new org.apache.thrift.transport.TIOStreamTransport(in)));
      } catch (org.apache.thrift.TException te) {
        throw new java.io.IOException(te);
      }
    }

    private static class connection_setReadOnly_argsStandardSchemeFactory implements SchemeFactory {
      public connection_setReadOnly_argsStandardScheme getScheme() {
        return new connection_setReadOnly_argsStandardScheme();
      }
    }

    private static class connection_setReadOnly_argsStandardScheme extends StandardScheme<connection_setReadOnly_args> {

      public void read(org.apache.thrift.protocol.TProtocol iprot, connection_setReadOnly_args struct) throws org.apache.thrift.TException {
        org.apache.thrift.protocol.TField schemeField;
        iprot.readStructBegin();
        while (true)
        {
          schemeField = iprot.readFieldBegin();
          if (schemeField.type == org.apache.thrift.protocol.TType.STOP) { 
            break;
          }
          switch (schemeField.id) {
            case 1: // CONNECTION
              if (schemeField.type == org.apache.thrift.protocol.TType.STRUCT) {
                struct.connection = new RConnection();
                struct.connection.read(iprot);
                struct.setConnectionIsSet(true);
              } else { 
                org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
              }
              break;
            case 2: // READ_ONLY
              if (schemeField.type == org.apache.thrift.protocol.TType.BOOL) {
                struct.readOnly = iprot.readBool();
                struct.setReadOnlyIsSet(true);
              } else { 
                org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
              }
              break;
            default:
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
          }
          iprot.readFieldEnd();
        }
        iprot.readStructEnd();

        // check for required fields of primitive type, which can't be checked in the validate method
        struct.validate();
      }

      public void write(org.apache.thrift.protocol.TProtocol oprot, connection_setReadOnly_args struct) throws org.apache.thrift.TException {
        struct.validate();

        oprot.writeStructBegin(STRUCT_DESC);
        if (struct.connection != null) {
          oprot.writeFieldBegin(CONNECTION_FIELD_DESC);
          struct.connection.write(oprot);
          oprot.writeFieldEnd();
        }
        oprot.writeFieldBegin(READ_ONLY_FIELD_DESC);
        oprot.writeBool(struct.readOnly);
        oprot.writeFieldEnd();
        oprot.writeFieldStop();
        oprot.writeStructEnd();
      }

    }

    private static class connection_setReadOnly_argsTupleSchemeFactory implements SchemeFactory {
      public connection_setReadOnly_argsTupleScheme getScheme() {
        return new connection_setReadOnly_argsTupleScheme();
      }
    }

    private static class connection_setReadOnly_argsTupleScheme extends TupleScheme<connection_setReadOnly_args> {

      @Override
      public void write(org.apache.thrift.protocol.TProtocol prot, connection_setReadOnly_args struct) throws org.apache.thrift.TException {
        TTupleProtocol oprot = (TTupleProtocol) prot;
        BitSet optionals = new BitSet();
        if (struct.isSetConnection()) {
          optionals.set(0);
        }
        if (struct.isSetReadOnly()) {
          optionals.set(1);
        }
        oprot.writeBitSet(optionals, 2);
        if (struct.isSetConnection()) {
          struct.connection.write(oprot);
        }
        if (struct.isSetReadOnly()) {
          oprot.writeBool(struct.readOnly);
        }
      }

      @Override
      public void read(org.apache.thrift.protocol.TProtocol prot, connection_setReadOnly_args struct) throws org.apache.thrift.TException {
        TTupleProtocol iprot = (TTupleProtocol) prot;
        BitSet incoming = iprot.readBitSet(2);
        if (incoming.get(0)) {
          struct.connection = new RConnection();
          struct.connection.read(iprot);
          struct.setConnectionIsSet(true);
        }
        if (incoming.get(1)) {
          struct.readOnly = iprot.readBool();
          struct.setReadOnlyIsSet(true);
        }
      }
    }

  }

  public static class connection_setReadOnly_result implements org.apache.thrift.TBase<connection_setReadOnly_result, connection_setReadOnly_result._Fields>, java.io.Serializable, Cloneable, Comparable<connection_setReadOnly_result>   {
    private static final org.apache.thrift.protocol.TStruct STRUCT_DESC = new org.apache.thrift.protocol.TStruct("connection_setReadOnly_result");

    private static final org.apache.thrift.protocol.TField SQL_EXCEPTION_FIELD_DESC = new org.apache.thrift.protocol.TField("sqlException", org.apache.thrift.protocol.TType.STRUCT, (short)1);

    private static final Map<Class<? extends IScheme>, SchemeFactory> schemes = new HashMap<Class<? extends IScheme>, SchemeFactory>();
    static {
      schemes.put(StandardScheme.class, new connection_setReadOnly_resultStandardSchemeFactory());
      schemes.put(TupleScheme.class, new connection_setReadOnly_resultTupleSchemeFactory());
    }

    public RSQLException sqlException; // required

    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements org.apache.thrift.TFieldIdEnum {
      SQL_EXCEPTION((short)1, "sqlException");

      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        switch(fieldId) {
          case 1: // SQL_EXCEPTION
            return SQL_EXCEPTION;
          default:
            return null;
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }

    // isset id assignments
    public static final Map<_Fields, org.apache.thrift.meta_data.FieldMetaData> metaDataMap;
    static {
      Map<_Fields, org.apache.thrift.meta_data.FieldMetaData> tmpMap = new EnumMap<_Fields, org.apache.thrift.meta_data.FieldMetaData>(_Fields.class);
      tmpMap.put(_Fields.SQL_EXCEPTION, new org.apache.thrift.meta_data.FieldMetaData("sqlException", org.apache.thrift.TFieldRequirementType.DEFAULT, 
          new org.apache.thrift.meta_data.FieldValueMetaData(org.apache.thrift.protocol.TType.STRUCT)));
      metaDataMap = Collections.unmodifiableMap(tmpMap);
      org.apache.thrift.meta_data.FieldMetaData.addStructMetaDataMap(connection_setReadOnly_result.class, metaDataMap);
    }

    public connection_setReadOnly_result() {
    }

    public connection_setReadOnly_result(
      RSQLException sqlException)
    {
      this();
      this.sqlException = sqlException;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public connection_setReadOnly_result(connection_setReadOnly_result other) {
      if (other.isSetSqlException()) {
        this.sqlException = new RSQLException(other.sqlException);
      }
    }

    public connection_setReadOnly_result deepCopy() {
      return new connection_setReadOnly_result(this);
    }

    @Override
    public void clear() {
      this.sqlException = null;
    }

    public RSQLException getSqlException() {
      return this.sqlException;
    }

    public connection_setReadOnly_result setSqlException(RSQLException sqlException) {
      this.sqlException = sqlException;
      return this;
    }

    public void unsetSqlException() {
      this.sqlException = null;
    }

    /** Returns true if field sqlException is set (has been assigned a value) and false otherwise */
    public boolean isSetSqlException() {
      return this.sqlException != null;
    }

    public void setSqlExceptionIsSet(boolean value) {
      if (!value) {
        this.sqlException = null;
      }
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      case SQL_EXCEPTION:
        if (value == null) {
          unsetSqlException();
        } else {
          setSqlException((RSQLException)value);
        }
        break;

      }
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      case SQL_EXCEPTION:
        return getSqlException();

      }
      throw new IllegalStateException();
    }

    /** Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      if (field == null) {
        throw new IllegalArgumentException();
      }

      switch (field) {
      case SQL_EXCEPTION:
        return isSetSqlException();
      }
      throw new IllegalStateException();
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof connection_setReadOnly_result)
        return this.equals((connection_setReadOnly_result)that);
      return false;
    }

    public boolean equals(connection_setReadOnly_result that) {
      if (that == null)
        return false;

      boolean this_present_sqlException = true && this.isSetSqlException();
      boolean that_present_sqlException = true && that.isSetSqlException();
      if (this_present_sqlException || that_present_sqlException) {
        if (!(this_present_sqlException && that_present_sqlException))
          return false;
        if (!this.sqlException.equals(that.sqlException))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      List<Object> list = new ArrayList<Object>();

      boolean present_sqlException = true && (isSetSqlException());
      list.add(present_sqlException);
      if (present_sqlException)
        list.add(sqlException);

      return list.hashCode();
    }

    @Override
    public int compareTo(connection_setReadOnly_result other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetSqlException()).compareTo(other.isSetSqlException());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetSqlException()) {
        lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.sqlException, other.sqlException);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      return 0;
    }

    public _Fields fieldForId(int fieldId) {
      return _Fields.findByThriftId(fieldId);
    }

    public void read(org.apache.thrift.protocol.TProtocol iprot) throws org.apache.thrift.TException {
      schemes.get(iprot.getScheme()).getScheme().read(iprot, this);
    }

    public void write(org.apache.thrift.protocol.TProtocol oprot) throws org.apache.thrift.TException {
      schemes.get(oprot.getScheme()).getScheme().write(oprot, this);
      }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("connection_setReadOnly_result(");
      boolean first = true;

      sb.append("sqlException:");
      if (this.sqlException == null) {
        sb.append("null");
      } else {
        sb.append(this.sqlException);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws org.apache.thrift.TException {
      // check for required fields
      // check for sub-struct validity
    }

    private void writeObject(java.io.ObjectOutputStream out) throws java.io.IOException {
      try {
        write(new org.apache.thrift.protocol.TCompactProtocol(new org.apache.thrift.transport.TIOStreamTransport(out)));
      } catch (org.apache.thrift.TException te) {
        throw new java.io.IOException(te);
      }
    }

    private void readObject(java.io.ObjectInputStream in) throws java.io.IOException, ClassNotFoundException {
      try {
        read(new org.apache.thrift.protocol.TCompactProtocol(new org.apache.thrift.transport.TIOStreamTransport(in)));
      } catch (org.apache.thrift.TException te) {
        throw new java.io.IOException(te);
      }
    }

    private static class connection_setReadOnly_resultStandardSchemeFactory implements SchemeFactory {
      public connection_setReadOnly_resultStandardScheme getScheme() {
        return new connection_setReadOnly_resultStandardScheme();
      }
    }

    private static class connection_setReadOnly_resultStandardScheme extends StandardScheme<connection_setReadOnly_result> {

      public void read(org.apache.thrift.protocol.TProtocol iprot, connection_setReadOnly_result struct) throws org.apache.thrift.TException {
        org.apache.thrift.protocol.TField schemeField;
        iprot.readStructBegin();
        while (true)
        {
          schemeField = iprot.readFieldBegin();
          if (schemeField.type == org.apache.thrift.protocol.TType.STOP) { 
            break;
          }
          switch (schemeField.id) {
            case 1: // SQL_EXCEPTION
              if (schemeField.type == org.apache.thrift.protocol.TType.STRUCT) {
                struct.sqlException = new RSQLException();
                struct.sqlException.read(iprot);
                struct.setSqlExceptionIsSet(true);
              } else { 
                org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
              }
              break;
            default:
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
          }
          iprot.readFieldEnd();
        }
        iprot.readStructEnd();

        // check for required fields of primitive type, which can't be checked in the validate method
        struct.validate();
      }

      public void write(org.apache.thrift.protocol.TProtocol oprot, connection_setReadOnly_result struct) throws org.apache.thrift.TException {
        struct.validate();

        oprot.writeStructBegin(STRUCT_DESC);
        if (struct.sqlException != null) {
          oprot.writeFieldBegin(SQL_EXCEPTION_FIELD_DESC);
          struct.sqlException.write(oprot);
          oprot.writeFieldEnd();
        }
        oprot.writeFieldStop();
        oprot.writeStructEnd();
      }

    }

    private static class connection_setReadOnly_resultTupleSchemeFactory implements SchemeFactory {
      public connection_setReadOnly_resultTupleScheme getScheme() {
        return new connection_setReadOnly_resultTupleScheme();
      }
    }

    private static class connection_setReadOnly_resultTupleScheme extends TupleScheme<connection_setReadOnly_result> {

      @Override
      public void write(org.apache.thrift.protocol.TProtocol prot, connection_setReadOnly_result struct) throws org.apache.thrift.TException {
        TTupleProtocol oprot = (TTupleProtocol) prot;
        BitSet optionals = new BitSet();
        if (struct.isSetSqlException()) {
          optionals.set(0);
        }
        oprot.writeBitSet(optionals, 1);
        if (struct.isSetSqlException()) {
          struct.sqlException.write(oprot);
        }
      }

      @Override
      public void read(org.apache.thrift.protocol.TProtocol prot, connection_setReadOnly_result struct) throws org.apache.thrift.TException {
        TTupleProtocol iprot = (TTupleProtocol) prot;
        BitSet incoming = iprot.readBitSet(1);
        if (incoming.get(0)) {
          struct.sqlException = new RSQLException();
          struct.sqlException.read(iprot);
          struct.setSqlExceptionIsSet(true);
        }
      }
    }

  }

  public static class connection_getReadOnly_args implements org.apache.thrift.TBase<connection_getReadOnly_args, connection_getReadOnly_args._Fields>, java.io.Serializable, Cloneable, Comparable<connection_getReadOnly_args>   {
    private static final org.apache.thrift.protocol.TStruct STRUCT_DESC = new org.apache.thrift.protocol.TStruct("connection_getReadOnly_args");

    private static final org.apache.thrift.protocol.TField CONNECTION_FIELD_DESC = new org.apache.thrift.protocol.TField("connection", org.apache.thrift.protocol.TType.STRUCT, (short)1);

    private static final Map<Class<? extends IScheme>, SchemeFactory> schemes = new HashMap<Class<? extends IScheme>, SchemeFactory>();
    static {
      schemes.put(StandardScheme.class, new connection_getReadOnly_argsStandardSchemeFactory());
      schemes.put(TupleScheme.class, new connection_getReadOnly_argsTupleSchemeFactory());
    }

    public RConnection connection; // required

    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements org.apache.thrift.TFieldIdEnum {
      CONNECTION((short)1, "connection");

      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        switch(fieldId) {
          case 1: // CONNECTION
            return CONNECTION;
          default:
            return null;
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }

    // isset id assignments
    public static final Map<_Fields, org.apache.thrift.meta_data.FieldMetaData> metaDataMap;
    static {
      Map<_Fields, org.apache.thrift.meta_data.FieldMetaData> tmpMap = new EnumMap<_Fields, org.apache.thrift.meta_data.FieldMetaData>(_Fields.class);
      tmpMap.put(_Fields.CONNECTION, new org.apache.thrift.meta_data.FieldMetaData("connection", org.apache.thrift.TFieldRequirementType.DEFAULT, 
          new org.apache.thrift.meta_data.StructMetaData(org.apache.thrift.protocol.TType.STRUCT, RConnection.class)));
      metaDataMap = Collections.unmodifiableMap(tmpMap);
      org.apache.thrift.meta_data.FieldMetaData.addStructMetaDataMap(connection_getReadOnly_args.class, metaDataMap);
    }

    public connection_getReadOnly_args() {
    }

    public connection_getReadOnly_args(
      RConnection connection)
    {
      this();
      this.connection = connection;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public connection_getReadOnly_args(connection_getReadOnly_args other) {
      if (other.isSetConnection()) {
        this.connection = new RConnection(other.connection);
      }
    }

    public connection_getReadOnly_args deepCopy() {
      return new connection_getReadOnly_args(this);
    }

    @Override
    public void clear() {
      this.connection = null;
    }

    public RConnection getConnection() {
      return this.connection;
    }

    public connection_getReadOnly_args setConnection(RConnection connection) {
      this.connection = connection;
      return this;
    }

    public void unsetConnection() {
      this.connection = null;
    }

    /** Returns true if field connection is set (has been assigned a value) and false otherwise */
    public boolean isSetConnection() {
      return this.connection != null;
    }

    public void setConnectionIsSet(boolean value) {
      if (!value) {
        this.connection = null;
      }
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      case CONNECTION:
        if (value == null) {
          unsetConnection();
        } else {
          setConnection((RConnection)value);
        }
        break;

      }
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      case CONNECTION:
        return getConnection();

      }
      throw new IllegalStateException();
    }

    /** Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      if (field == null) {
        throw new IllegalArgumentException();
      }

      switch (field) {
      case CONNECTION:
        return isSetConnection();
      }
      throw new IllegalStateException();
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof connection_getReadOnly_args)
        return this.equals((connection_getReadOnly_args)that);
      return false;
    }

    public boolean equals(connection_getReadOnly_args that) {
      if (that == null)
        return false;

      boolean this_present_connection = true && this.isSetConnection();
      boolean that_present_connection = true && that.isSetConnection();
      if (this_present_connection || that_present_connection) {
        if (!(this_present_connection && that_present_connection))
          return false;
        if (!this.connection.equals(that.connection))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      List<Object> list = new ArrayList<Object>();

      boolean present_connection = true && (isSetConnection());
      list.add(present_connection);
      if (present_connection)
        list.add(connection);

      return list.hashCode();
    }

    @Override
    public int compareTo(connection_getReadOnly_args other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetConnection()).compareTo(other.isSetConnection());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetConnection()) {
        lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.connection, other.connection);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      return 0;
    }

    public _Fields fieldForId(int fieldId) {
      return _Fields.findByThriftId(fieldId);
    }

    public void read(org.apache.thrift.protocol.TProtocol iprot) throws org.apache.thrift.TException {
      schemes.get(iprot.getScheme()).getScheme().read(iprot, this);
    }

    public void write(org.apache.thrift.protocol.TProtocol oprot) throws org.apache.thrift.TException {
      schemes.get(oprot.getScheme()).getScheme().write(oprot, this);
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("connection_getReadOnly_args(");
      boolean first = true;

      sb.append("connection:");
      if (this.connection == null) {
        sb.append("null");
      } else {
        sb.append(this.connection);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws org.apache.thrift.TException {
      // check for required fields
      // check for sub-struct validity
      if (connection != null) {
        connection.validate();
      }
    }

    private void writeObject(java.io.ObjectOutputStream out) throws java.io.IOException {
      try {
        write(new org.apache.thrift.protocol.TCompactProtocol(new org.apache.thrift.transport.TIOStreamTransport(out)));
      } catch (org.apache.thrift.TException te) {
        throw new java.io.IOException(te);
      }
    }

    private void readObject(java.io.ObjectInputStream in) throws java.io.IOException, ClassNotFoundException {
      try {
        read(new org.apache.thrift.protocol.TCompactProtocol(new org.apache.thrift.transport.TIOStreamTransport(in)));
      } catch (org.apache.thrift.TException te) {
        throw new java.io.IOException(te);
      }
    }

    private static class connection_getReadOnly_argsStandardSchemeFactory implements SchemeFactory {
      public connection_getReadOnly_argsStandardScheme getScheme() {
        return new connection_getReadOnly_argsStandardScheme();
      }
    }

    private static class connection_getReadOnly_argsStandardScheme extends StandardScheme<connection_getReadOnly_args> {

      public void read(org.apache.thrift.protocol.TProtocol iprot, connection_getReadOnly_args struct) throws org.apache.thrift.TException {
        org.apache.thrift.protocol.TField schemeField;
        iprot.readStructBegin();
        while (true)
        {
          schemeField = iprot.readFieldBegin();
          if (schemeField.type == org.apache.thrift.protocol.TType.STOP) { 
            break;
          }
          switch (schemeField.id) {
            case 1: // CONNECTION
              if (schemeField.type == org.apache.thrift.protocol.TType.STRUCT) {
                struct.connection = new RConnection();
                struct.connection.read(iprot);
                struct.setConnectionIsSet(true);
              } else { 
                org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
              }
              break;
            default:
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
          }
          iprot.readFieldEnd();
        }
        iprot.readStructEnd();

        // check for required fields of primitive type, which can't be checked in the validate method
        struct.validate();
      }

      public void write(org.apache.thrift.protocol.TProtocol oprot, connection_getReadOnly_args struct) throws org.apache.thrift.TException {
        struct.validate();

        oprot.writeStructBegin(STRUCT_DESC);
        if (struct.connection != null) {
          oprot.writeFieldBegin(CONNECTION_FIELD_DESC);
          struct.connection.write(oprot);
          oprot.writeFieldEnd();
        }
        oprot.writeFieldStop();
        oprot.writeStructEnd();
      }

    }

    private static class connection_getReadOnly_argsTupleSchemeFactory implements SchemeFactory {
      public connection_getReadOnly_argsTupleScheme getScheme() {
        return new connection_getReadOnly_argsTupleScheme();
      }
    }

    private static class connection_getReadOnly_argsTupleScheme extends TupleScheme<connection_getReadOnly_args> {

      @Override
      public void write(org.apache.thrift.protocol.TProtocol prot, connection_getReadOnly_args struct) throws org.apache.thrift.TException {
        TTupleProtocol oprot = (TTupleProtocol) prot;
        BitSet optionals = new BitSet();
        if (struct.isSetConnection()) {
          optionals.set(0);
        }
        oprot.writeBitSet(optionals, 1);
        if (struct.isSetConnection()) {
          struct.connection.write(oprot);
        }
      }

      @Override
      public void read(org.apache.thrift.protocol.TProtocol prot, connection_getReadOnly_args struct) throws org.apache.thrift.TException {
        TTupleProtocol iprot = (TTupleProtocol) prot;
        BitSet incoming = iprot.readBitSet(1);
        if (incoming.get(0)) {
          struct.connection = new RConnection();
          struct.connection.read(iprot);
          struct.setConnectionIsSet(true);
        }
      }
    }

  }

  public static class connection_getReadOnly_result implements org.apache.thrift.TBase<connection_getReadOnly_result, connection_getReadOnly_result._Fields>, java.io.Serializable, Cloneable, Comparable<connection_getReadOnly_result>   {
    private static final org.apache.thrift.protocol.TStruct STRUCT_DESC = new org.apache.thrift.protocol.TStruct("connection_getReadOnly_result");

    private static final org.apache.thrift.protocol.TField SUCCESS_FIELD_DESC = new org.apache.thrift.protocol.TField("success", org.apache.thrift.protocol.TType.BOOL, (short)0);
    private static final org.apache.thrift.protocol.TField SQL_EXCEPTION_FIELD_DESC = new org.apache.thrift.protocol.TField("sqlException", org.apache.thrift.protocol.TType.STRUCT, (short)1);

    private static final Map<Class<? extends IScheme>, SchemeFactory> schemes = new HashMap<Class<? extends IScheme>, SchemeFactory>();
    static {
      schemes.put(StandardScheme.class, new connection_getReadOnly_resultStandardSchemeFactory());
      schemes.put(TupleScheme.class, new connection_getReadOnly_resultTupleSchemeFactory());
    }

    public boolean success; // required
    public RSQLException sqlException; // required

    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements org.apache.thrift.TFieldIdEnum {
      SUCCESS((short)0, "success"),
      SQL_EXCEPTION((short)1, "sqlException");

      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        switch(fieldId) {
          case 0: // SUCCESS
            return SUCCESS;
          case 1: // SQL_EXCEPTION
            return SQL_EXCEPTION;
          default:
            return null;
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }

    // isset id assignments
    private static final int __SUCCESS_ISSET_ID = 0;
    private byte __isset_bitfield = 0;
    public static final Map<_Fields, org.apache.thrift.meta_data.FieldMetaData> metaDataMap;
    static {
      Map<_Fields, org.apache.thrift.meta_data.FieldMetaData> tmpMap = new EnumMap<_Fields, org.apache.thrift.meta_data.FieldMetaData>(_Fields.class);
      tmpMap.put(_Fields.SUCCESS, new org.apache.thrift.meta_data.FieldMetaData("success", org.apache.thrift.TFieldRequirementType.DEFAULT, 
          new org.apache.thrift.meta_data.FieldValueMetaData(org.apache.thrift.protocol.TType.BOOL)));
      tmpMap.put(_Fields.SQL_EXCEPTION, new org.apache.thrift.meta_data.FieldMetaData("sqlException", org.apache.thrift.TFieldRequirementType.DEFAULT, 
          new org.apache.thrift.meta_data.FieldValueMetaData(org.apache.thrift.protocol.TType.STRUCT)));
      metaDataMap = Collections.unmodifiableMap(tmpMap);
      org.apache.thrift.meta_data.FieldMetaData.addStructMetaDataMap(connection_getReadOnly_result.class, metaDataMap);
    }

    public connection_getReadOnly_result() {
    }

    public connection_getReadOnly_result(
      boolean success,
      RSQLException sqlException)
    {
      this();
      this.success = success;
      setSuccessIsSet(true);
      this.sqlException = sqlException;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public connection_getReadOnly_result(connection_getReadOnly_result other) {
      __isset_bitfield = other.__isset_bitfield;
      this.success = other.success;
      if (other.isSetSqlException()) {
        this.sqlException = new RSQLException(other.sqlException);
      }
    }

    public connection_getReadOnly_result deepCopy() {
      return new connection_getReadOnly_result(this);
    }

    @Override
    public void clear() {
      setSuccessIsSet(false);
      this.success = false;
      this.sqlException = null;
    }

    public boolean isSuccess() {
      return this.success;
    }

    public connection_getReadOnly_result setSuccess(boolean success) {
      this.success = success;
      setSuccessIsSet(true);
      return this;
    }

    public void unsetSuccess() {
      __isset_bitfield = EncodingUtils.clearBit(__isset_bitfield, __SUCCESS_ISSET_ID);
    }

    /** Returns true if field success is set (has been assigned a value) and false otherwise */
    public boolean isSetSuccess() {
      return EncodingUtils.testBit(__isset_bitfield, __SUCCESS_ISSET_ID);
    }

    public void setSuccessIsSet(boolean value) {
      __isset_bitfield = EncodingUtils.setBit(__isset_bitfield, __SUCCESS_ISSET_ID, value);
    }

    public RSQLException getSqlException() {
      return this.sqlException;
    }

    public connection_getReadOnly_result setSqlException(RSQLException sqlException) {
      this.sqlException = sqlException;
      return this;
    }

    public void unsetSqlException() {
      this.sqlException = null;
    }

    /** Returns true if field sqlException is set (has been assigned a value) and false otherwise */
    public boolean isSetSqlException() {
      return this.sqlException != null;
    }

    public void setSqlExceptionIsSet(boolean value) {
      if (!value) {
        this.sqlException = null;
      }
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          setSuccess((Boolean)value);
        }
        break;

      case SQL_EXCEPTION:
        if (value == null) {
          unsetSqlException();
        } else {
          setSqlException((RSQLException)value);
        }
        break;

      }
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      case SUCCESS:
        return Boolean.valueOf(isSuccess());

      case SQL_EXCEPTION:
        return getSqlException();

      }
      throw new IllegalStateException();
    }

    /** Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      if (field == null) {
        throw new IllegalArgumentException();
      }

      switch (field) {
      case SUCCESS:
        return isSetSuccess();
      case SQL_EXCEPTION:
        return isSetSqlException();
      }
      throw new IllegalStateException();
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof connection_getReadOnly_result)
        return this.equals((connection_getReadOnly_result)that);
      return false;
    }

    public boolean equals(connection_getReadOnly_result that) {
      if (that == null)
        return false;

      boolean this_present_success = true;
      boolean that_present_success = true;
      if (this_present_success || that_present_success) {
        if (!(this_present_success && that_present_success))
          return false;
        if (this.success != that.success)
          return false;
      }

      boolean this_present_sqlException = true && this.isSetSqlException();
      boolean that_present_sqlException = true && that.isSetSqlException();
      if (this_present_sqlException || that_present_sqlException) {
        if (!(this_present_sqlException && that_present_sqlException))
          return false;
        if (!this.sqlException.equals(that.sqlException))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      List<Object> list = new ArrayList<Object>();

      boolean present_success = true;
      list.add(present_success);
      if (present_success)
        list.add(success);

      boolean present_sqlException = true && (isSetSqlException());
      list.add(present_sqlException);
      if (present_sqlException)
        list.add(sqlException);

      return list.hashCode();
    }

    @Override
    public int compareTo(connection_getReadOnly_result other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetSuccess()).compareTo(other.isSetSuccess());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetSuccess()) {
        lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.success, other.success);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      lastComparison = Boolean.valueOf(isSetSqlException()).compareTo(other.isSetSqlException());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetSqlException()) {
        lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.sqlException, other.sqlException);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      return 0;
    }

    public _Fields fieldForId(int fieldId) {
      return _Fields.findByThriftId(fieldId);
    }

    public void read(org.apache.thrift.protocol.TProtocol iprot) throws org.apache.thrift.TException {
      schemes.get(iprot.getScheme()).getScheme().read(iprot, this);
    }

    public void write(org.apache.thrift.protocol.TProtocol oprot) throws org.apache.thrift.TException {
      schemes.get(oprot.getScheme()).getScheme().write(oprot, this);
      }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("connection_getReadOnly_result(");
      boolean first = true;

      sb.append("success:");
      sb.append(this.success);
      first = false;
      if (!first) sb.append(", ");
      sb.append("sqlException:");
      if (this.sqlException == null) {
        sb.append("null");
      } else {
        sb.append(this.sqlException);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws org.apache.thrift.TException {
      // check for required fields
      // check for sub-struct validity
    }

    private void writeObject(java.io.ObjectOutputStream out) throws java.io.IOException {
      try {
        write(new org.apache.thrift.protocol.TCompactProtocol(new org.apache.thrift.transport.TIOStreamTransport(out)));
      } catch (org.apache.thrift.TException te) {
        throw new java.io.IOException(te);
      }
    }

    private void readObject(java.io.ObjectInputStream in) throws java.io.IOException, ClassNotFoundException {
      try {
        // it doesn't seem like you should have to do this, but java serialization is wacky, and doesn't call the default constructor.
        __isset_bitfield = 0;
        read(new org.apache.thrift.protocol.TCompactProtocol(new org.apache.thrift.transport.TIOStreamTransport(in)));
      } catch (org.apache.thrift.TException te) {
        throw new java.io.IOException(te);
      }
    }

    private static class connection_getReadOnly_resultStandardSchemeFactory implements SchemeFactory {
      public connection_getReadOnly_resultStandardScheme getScheme() {
        return new connection_getReadOnly_resultStandardScheme();
      }
    }

    private static class connection_getReadOnly_resultStandardScheme extends StandardScheme<connection_getReadOnly_result> {

      public void read(org.apache.thrift.protocol.TProtocol iprot, connection_getReadOnly_result struct) throws org.apache.thrift.TException {
        org.apache.thrift.protocol.TField schemeField;
        iprot.readStructBegin();
        while (true)
        {
          schemeField = iprot.readFieldBegin();
          if (schemeField.type == org.apache.thrift.protocol.TType.STOP) { 
            break;
          }
          switch (schemeField.id) {
            case 0: // SUCCESS
              if (schemeField.type == org.apache.thrift.protocol.TType.BOOL) {
                struct.success = iprot.readBool();
                struct.setSuccessIsSet(true);
              } else { 
                org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
              }
              break;
            case 1: // SQL_EXCEPTION
              if (schemeField.type == org.apache.thrift.protocol.TType.STRUCT) {
                struct.sqlException = new RSQLException();
                struct.sqlException.read(iprot);
                struct.setSqlExceptionIsSet(true);
              } else { 
                org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
              }
              break;
            default:
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
          }
          iprot.readFieldEnd();
        }
        iprot.readStructEnd();

        // check for required fields of primitive type, which can't be checked in the validate method
        struct.validate();
      }

      public void write(org.apache.thrift.protocol.TProtocol oprot, connection_getReadOnly_result struct) throws org.apache.thrift.TException {
        struct.validate();

        oprot.writeStructBegin(STRUCT_DESC);
        if (struct.isSetSuccess()) {
          oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
          oprot.writeBool(struct.success);
          oprot.writeFieldEnd();
        }
        if (struct.sqlException != null) {
          oprot.writeFieldBegin(SQL_EXCEPTION_FIELD_DESC);
          struct.sqlException.write(oprot);
          oprot.writeFieldEnd();
        }
        oprot.writeFieldStop();
        oprot.writeStructEnd();
      }

    }

    private static class connection_getReadOnly_resultTupleSchemeFactory implements SchemeFactory {
      public connection_getReadOnly_resultTupleScheme getScheme() {
        return new connection_getReadOnly_resultTupleScheme();
      }
    }

    private static class connection_getReadOnly_resultTupleScheme extends TupleScheme<connection_getReadOnly_result> {

      @Override
      public void write(org.apache.thrift.protocol.TProtocol prot, connection_getReadOnly_result struct) throws org.apache.thrift.TException {
        TTupleProtocol oprot = (TTupleProtocol) prot;
        BitSet optionals = new BitSet();
        if (struct.isSetSuccess()) {
          optionals.set(0);
        }
        if (struct.isSetSqlException()) {
          optionals.set(1);
        }
        oprot.writeBitSet(optionals, 2);
        if (struct.isSetSuccess()) {
          oprot.writeBool(struct.success);
        }
        if (struct.isSetSqlException()) {
          struct.sqlException.write(oprot);
        }
      }

      @Override
      public void read(org.apache.thrift.protocol.TProtocol prot, connection_getReadOnly_result struct) throws org.apache.thrift.TException {
        TTupleProtocol iprot = (TTupleProtocol) prot;
        BitSet incoming = iprot.readBitSet(2);
        if (incoming.get(0)) {
          struct.success = iprot.readBool();
          struct.setSuccessIsSet(true);
        }
        if (incoming.get(1)) {
          struct.sqlException = new RSQLException();
          struct.sqlException.read(iprot);
          struct.setSqlExceptionIsSet(true);
        }
      }
    }

  }

  public static class connection_setCatalog_args implements org.apache.thrift.TBase<connection_setCatalog_args, connection_setCatalog_args._Fields>, java.io.Serializable, Cloneable, Comparable<connection_setCatalog_args>   {
    private static final org.apache.thrift.protocol.TStruct STRUCT_DESC = new org.apache.thrift.protocol.TStruct("connection_setCatalog_args");

    private static final org.apache.thrift.protocol.TField CONNECTION_FIELD_DESC = new org.apache.thrift.protocol.TField("connection", org.apache.thrift.protocol.TType.STRUCT, (short)1);
    private static final org.apache.thrift.protocol.TField CATALOG_FIELD_DESC = new org.apache.thrift.protocol.TField("catalog", org.apache.thrift.protocol.TType.STRING, (short)2);

    private static final Map<Class<? extends IScheme>, SchemeFactory> schemes = new HashMap<Class<? extends IScheme>, SchemeFactory>();
    static {
      schemes.put(StandardScheme.class, new connection_setCatalog_argsStandardSchemeFactory());
      schemes.put(TupleScheme.class, new connection_setCatalog_argsTupleSchemeFactory());
    }

    public RConnection connection; // required
    public String catalog; // required

    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements org.apache.thrift.TFieldIdEnum {
      CONNECTION((short)1, "connection"),
      CATALOG((short)2, "catalog");

      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        switch(fieldId) {
          case 1: // CONNECTION
            return CONNECTION;
          case 2: // CATALOG
            return CATALOG;
          default:
            return null;
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }

    // isset id assignments
    public static final Map<_Fields, org.apache.thrift.meta_data.FieldMetaData> metaDataMap;
    static {
      Map<_Fields, org.apache.thrift.meta_data.FieldMetaData> tmpMap = new EnumMap<_Fields, org.apache.thrift.meta_data.FieldMetaData>(_Fields.class);
      tmpMap.put(_Fields.CONNECTION, new org.apache.thrift.meta_data.FieldMetaData("connection", org.apache.thrift.TFieldRequirementType.DEFAULT, 
          new org.apache.thrift.meta_data.StructMetaData(org.apache.thrift.protocol.TType.STRUCT, RConnection.class)));
      tmpMap.put(_Fields.CATALOG, new org.apache.thrift.meta_data.FieldMetaData("catalog", org.apache.thrift.TFieldRequirementType.DEFAULT, 
          new org.apache.thrift.meta_data.FieldValueMetaData(org.apache.thrift.protocol.TType.STRING)));
      metaDataMap = Collections.unmodifiableMap(tmpMap);
      org.apache.thrift.meta_data.FieldMetaData.addStructMetaDataMap(connection_setCatalog_args.class, metaDataMap);
    }

    public connection_setCatalog_args() {
    }

    public connection_setCatalog_args(
      RConnection connection,
      String catalog)
    {
      this();
      this.connection = connection;
      this.catalog = catalog;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public connection_setCatalog_args(connection_setCatalog_args other) {
      if (other.isSetConnection()) {
        this.connection = new RConnection(other.connection);
      }
      if (other.isSetCatalog()) {
        this.catalog = other.catalog;
      }
    }

    public connection_setCatalog_args deepCopy() {
      return new connection_setCatalog_args(this);
    }

    @Override
    public void clear() {
      this.connection = null;
      this.catalog = null;
    }

    public RConnection getConnection() {
      return this.connection;
    }

    public connection_setCatalog_args setConnection(RConnection connection) {
      this.connection = connection;
      return this;
    }

    public void unsetConnection() {
      this.connection = null;
    }

    /** Returns true if field connection is set (has been assigned a value) and false otherwise */
    public boolean isSetConnection() {
      return this.connection != null;
    }

    public void setConnectionIsSet(boolean value) {
      if (!value) {
        this.connection = null;
      }
    }

    public String getCatalog() {
      return this.catalog;
    }

    public connection_setCatalog_args setCatalog(String catalog) {
      this.catalog = catalog;
      return this;
    }

    public void unsetCatalog() {
      this.catalog = null;
    }

    /** Returns true if field catalog is set (has been assigned a value) and false otherwise */
    public boolean isSetCatalog() {
      return this.catalog != null;
    }

    public void setCatalogIsSet(boolean value) {
      if (!value) {
        this.catalog = null;
      }
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      case CONNECTION:
        if (value == null) {
          unsetConnection();
        } else {
          setConnection((RConnection)value);
        }
        break;

      case CATALOG:
        if (value == null) {
          unsetCatalog();
        } else {
          setCatalog((String)value);
        }
        break;

      }
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      case CONNECTION:
        return getConnection();

      case CATALOG:
        return getCatalog();

      }
      throw new IllegalStateException();
    }

    /** Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      if (field == null) {
        throw new IllegalArgumentException();
      }

      switch (field) {
      case CONNECTION:
        return isSetConnection();
      case CATALOG:
        return isSetCatalog();
      }
      throw new IllegalStateException();
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof connection_setCatalog_args)
        return this.equals((connection_setCatalog_args)that);
      return false;
    }

    public boolean equals(connection_setCatalog_args that) {
      if (that == null)
        return false;

      boolean this_present_connection = true && this.isSetConnection();
      boolean that_present_connection = true && that.isSetConnection();
      if (this_present_connection || that_present_connection) {
        if (!(this_present_connection && that_present_connection))
          return false;
        if (!this.connection.equals(that.connection))
          return false;
      }

      boolean this_present_catalog = true && this.isSetCatalog();
      boolean that_present_catalog = true && that.isSetCatalog();
      if (this_present_catalog || that_present_catalog) {
        if (!(this_present_catalog && that_present_catalog))
          return false;
        if (!this.catalog.equals(that.catalog))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      List<Object> list = new ArrayList<Object>();

      boolean present_connection = true && (isSetConnection());
      list.add(present_connection);
      if (present_connection)
        list.add(connection);

      boolean present_catalog = true && (isSetCatalog());
      list.add(present_catalog);
      if (present_catalog)
        list.add(catalog);

      return list.hashCode();
    }

    @Override
    public int compareTo(connection_setCatalog_args other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetConnection()).compareTo(other.isSetConnection());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetConnection()) {
        lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.connection, other.connection);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      lastComparison = Boolean.valueOf(isSetCatalog()).compareTo(other.isSetCatalog());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetCatalog()) {
        lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.catalog, other.catalog);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      return 0;
    }

    public _Fields fieldForId(int fieldId) {
      return _Fields.findByThriftId(fieldId);
    }

    public void read(org.apache.thrift.protocol.TProtocol iprot) throws org.apache.thrift.TException {
      schemes.get(iprot.getScheme()).getScheme().read(iprot, this);
    }

    public void write(org.apache.thrift.protocol.TProtocol oprot) throws org.apache.thrift.TException {
      schemes.get(oprot.getScheme()).getScheme().write(oprot, this);
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("connection_setCatalog_args(");
      boolean first = true;

      sb.append("connection:");
      if (this.connection == null) {
        sb.append("null");
      } else {
        sb.append(this.connection);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("catalog:");
      if (this.catalog == null) {
        sb.append("null");
      } else {
        sb.append(this.catalog);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws org.apache.thrift.TException {
      // check for required fields
      // check for sub-struct validity
      if (connection != null) {
        connection.validate();
      }
    }

    private void writeObject(java.io.ObjectOutputStream out) throws java.io.IOException {
      try {
        write(new org.apache.thrift.protocol.TCompactProtocol(new org.apache.thrift.transport.TIOStreamTransport(out)));
      } catch (org.apache.thrift.TException te) {
        throw new java.io.IOException(te);
      }
    }

    private void readObject(java.io.ObjectInputStream in) throws java.io.IOException, ClassNotFoundException {
      try {
        read(new org.apache.thrift.protocol.TCompactProtocol(new org.apache.thrift.transport.TIOStreamTransport(in)));
      } catch (org.apache.thrift.TException te) {
        throw new java.io.IOException(te);
      }
    }

    private static class connection_setCatalog_argsStandardSchemeFactory implements SchemeFactory {
      public connection_setCatalog_argsStandardScheme getScheme() {
        return new connection_setCatalog_argsStandardScheme();
      }
    }

    private static class connection_setCatalog_argsStandardScheme extends StandardScheme<connection_setCatalog_args> {

      public void read(org.apache.thrift.protocol.TProtocol iprot, connection_setCatalog_args struct) throws org.apache.thrift.TException {
        org.apache.thrift.protocol.TField schemeField;
        iprot.readStructBegin();
        while (true)
        {
          schemeField = iprot.readFieldBegin();
          if (schemeField.type == org.apache.thrift.protocol.TType.STOP) { 
            break;
          }
          switch (schemeField.id) {
            case 1: // CONNECTION
              if (schemeField.type == org.apache.thrift.protocol.TType.STRUCT) {
                struct.connection = new RConnection();
                struct.connection.read(iprot);
                struct.setConnectionIsSet(true);
              } else { 
                org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
              }
              break;
            case 2: // CATALOG
              if (schemeField.type == org.apache.thrift.protocol.TType.STRING) {
                struct.catalog = iprot.readString();
                struct.setCatalogIsSet(true);
              } else { 
                org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
              }
              break;
            default:
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
          }
          iprot.readFieldEnd();
        }
        iprot.readStructEnd();

        // check for required fields of primitive type, which can't be checked in the validate method
        struct.validate();
      }

      public void write(org.apache.thrift.protocol.TProtocol oprot, connection_setCatalog_args struct) throws org.apache.thrift.TException {
        struct.validate();

        oprot.writeStructBegin(STRUCT_DESC);
        if (struct.connection != null) {
          oprot.writeFieldBegin(CONNECTION_FIELD_DESC);
          struct.connection.write(oprot);
          oprot.writeFieldEnd();
        }
        if (struct.catalog != null) {
          oprot.writeFieldBegin(CATALOG_FIELD_DESC);
          oprot.writeString(struct.catalog);
          oprot.writeFieldEnd();
        }
        oprot.writeFieldStop();
        oprot.writeStructEnd();
      }

    }

    private static class connection_setCatalog_argsTupleSchemeFactory implements SchemeFactory {
      public connection_setCatalog_argsTupleScheme getScheme() {
        return new connection_setCatalog_argsTupleScheme();
      }
    }

    private static class connection_setCatalog_argsTupleScheme extends TupleScheme<connection_setCatalog_args> {

      @Override
      public void write(org.apache.thrift.protocol.TProtocol prot, connection_setCatalog_args struct) throws org.apache.thrift.TException {
        TTupleProtocol oprot = (TTupleProtocol) prot;
        BitSet optionals = new BitSet();
        if (struct.isSetConnection()) {
          optionals.set(0);
        }
        if (struct.isSetCatalog()) {
          optionals.set(1);
        }
        oprot.writeBitSet(optionals, 2);
        if (struct.isSetConnection()) {
          struct.connection.write(oprot);
        }
        if (struct.isSetCatalog()) {
          oprot.writeString(struct.catalog);
        }
      }

      @Override
      public void read(org.apache.thrift.protocol.TProtocol prot, connection_setCatalog_args struct) throws org.apache.thrift.TException {
        TTupleProtocol iprot = (TTupleProtocol) prot;
        BitSet incoming = iprot.readBitSet(2);
        if (incoming.get(0)) {
          struct.connection = new RConnection();
          struct.connection.read(iprot);
          struct.setConnectionIsSet(true);
        }
        if (incoming.get(1)) {
          struct.catalog = iprot.readString();
          struct.setCatalogIsSet(true);
        }
      }
    }

  }

  public static class connection_setCatalog_result implements org.apache.thrift.TBase<connection_setCatalog_result, connection_setCatalog_result._Fields>, java.io.Serializable, Cloneable, Comparable<connection_setCatalog_result>   {
    private static final org.apache.thrift.protocol.TStruct STRUCT_DESC = new org.apache.thrift.protocol.TStruct("connection_setCatalog_result");

    private static final org.apache.thrift.protocol.TField SQL_EXCEPTION_FIELD_DESC = new org.apache.thrift.protocol.TField("sqlException", org.apache.thrift.protocol.TType.STRUCT, (short)1);

    private static final Map<Class<? extends IScheme>, SchemeFactory> schemes = new HashMap<Class<? extends IScheme>, SchemeFactory>();
    static {
      schemes.put(StandardScheme.class, new connection_setCatalog_resultStandardSchemeFactory());
      schemes.put(TupleScheme.class, new connection_setCatalog_resultTupleSchemeFactory());
    }

    public RSQLException sqlException; // required

    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements org.apache.thrift.TFieldIdEnum {
      SQL_EXCEPTION((short)1, "sqlException");

      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        switch(fieldId) {
          case 1: // SQL_EXCEPTION
            return SQL_EXCEPTION;
          default:
            return null;
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }

    // isset id assignments
    public static final Map<_Fields, org.apache.thrift.meta_data.FieldMetaData> metaDataMap;
    static {
      Map<_Fields, org.apache.thrift.meta_data.FieldMetaData> tmpMap = new EnumMap<_Fields, org.apache.thrift.meta_data.FieldMetaData>(_Fields.class);
      tmpMap.put(_Fields.SQL_EXCEPTION, new org.apache.thrift.meta_data.FieldMetaData("sqlException", org.apache.thrift.TFieldRequirementType.DEFAULT, 
          new org.apache.thrift.meta_data.FieldValueMetaData(org.apache.thrift.protocol.TType.STRUCT)));
      metaDataMap = Collections.unmodifiableMap(tmpMap);
      org.apache.thrift.meta_data.FieldMetaData.addStructMetaDataMap(connection_setCatalog_result.class, metaDataMap);
    }

    public connection_setCatalog_result() {
    }

    public connection_setCatalog_result(
      RSQLException sqlException)
    {
      this();
      this.sqlException = sqlException;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public connection_setCatalog_result(connection_setCatalog_result other) {
      if (other.isSetSqlException()) {
        this.sqlException = new RSQLException(other.sqlException);
      }
    }

    public connection_setCatalog_result deepCopy() {
      return new connection_setCatalog_result(this);
    }

    @Override
    public void clear() {
      this.sqlException = null;
    }

    public RSQLException getSqlException() {
      return this.sqlException;
    }

    public connection_setCatalog_result setSqlException(RSQLException sqlException) {
      this.sqlException = sqlException;
      return this;
    }

    public void unsetSqlException() {
      this.sqlException = null;
    }

    /** Returns true if field sqlException is set (has been assigned a value) and false otherwise */
    public boolean isSetSqlException() {
      return this.sqlException != null;
    }

    public void setSqlExceptionIsSet(boolean value) {
      if (!value) {
        this.sqlException = null;
      }
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      case SQL_EXCEPTION:
        if (value == null) {
          unsetSqlException();
        } else {
          setSqlException((RSQLException)value);
        }
        break;

      }
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      case SQL_EXCEPTION:
        return getSqlException();

      }
      throw new IllegalStateException();
    }

    /** Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      if (field == null) {
        throw new IllegalArgumentException();
      }

      switch (field) {
      case SQL_EXCEPTION:
        return isSetSqlException();
      }
      throw new IllegalStateException();
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof connection_setCatalog_result)
        return this.equals((connection_setCatalog_result)that);
      return false;
    }

    public boolean equals(connection_setCatalog_result that) {
      if (that == null)
        return false;

      boolean this_present_sqlException = true && this.isSetSqlException();
      boolean that_present_sqlException = true && that.isSetSqlException();
      if (this_present_sqlException || that_present_sqlException) {
        if (!(this_present_sqlException && that_present_sqlException))
          return false;
        if (!this.sqlException.equals(that.sqlException))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      List<Object> list = new ArrayList<Object>();

      boolean present_sqlException = true && (isSetSqlException());
      list.add(present_sqlException);
      if (present_sqlException)
        list.add(sqlException);

      return list.hashCode();
    }

    @Override
    public int compareTo(connection_setCatalog_result other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetSqlException()).compareTo(other.isSetSqlException());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetSqlException()) {
        lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.sqlException, other.sqlException);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      return 0;
    }

    public _Fields fieldForId(int fieldId) {
      return _Fields.findByThriftId(fieldId);
    }

    public void read(org.apache.thrift.protocol.TProtocol iprot) throws org.apache.thrift.TException {
      schemes.get(iprot.getScheme()).getScheme().read(iprot, this);
    }

    public void write(org.apache.thrift.protocol.TProtocol oprot) throws org.apache.thrift.TException {
      schemes.get(oprot.getScheme()).getScheme().write(oprot, this);
      }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("connection_setCatalog_result(");
      boolean first = true;

      sb.append("sqlException:");
      if (this.sqlException == null) {
        sb.append("null");
      } else {
        sb.append(this.sqlException);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws org.apache.thrift.TException {
      // check for required fields
      // check for sub-struct validity
    }

    private void writeObject(java.io.ObjectOutputStream out) throws java.io.IOException {
      try {
        write(new org.apache.thrift.protocol.TCompactProtocol(new org.apache.thrift.transport.TIOStreamTransport(out)));
      } catch (org.apache.thrift.TException te) {
        throw new java.io.IOException(te);
      }
    }

    private void readObject(java.io.ObjectInputStream in) throws java.io.IOException, ClassNotFoundException {
      try {
        read(new org.apache.thrift.protocol.TCompactProtocol(new org.apache.thrift.transport.TIOStreamTransport(in)));
      } catch (org.apache.thrift.TException te) {
        throw new java.io.IOException(te);
      }
    }

    private static class connection_setCatalog_resultStandardSchemeFactory implements SchemeFactory {
      public connection_setCatalog_resultStandardScheme getScheme() {
        return new connection_setCatalog_resultStandardScheme();
      }
    }

    private static class connection_setCatalog_resultStandardScheme extends StandardScheme<connection_setCatalog_result> {

      public void read(org.apache.thrift.protocol.TProtocol iprot, connection_setCatalog_result struct) throws org.apache.thrift.TException {
        org.apache.thrift.protocol.TField schemeField;
        iprot.readStructBegin();
        while (true)
        {
          schemeField = iprot.readFieldBegin();
          if (schemeField.type == org.apache.thrift.protocol.TType.STOP) { 
            break;
          }
          switch (schemeField.id) {
            case 1: // SQL_EXCEPTION
              if (schemeField.type == org.apache.thrift.protocol.TType.STRUCT) {
                struct.sqlException = new RSQLException();
                struct.sqlException.read(iprot);
                struct.setSqlExceptionIsSet(true);
              } else { 
                org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
              }
              break;
            default:
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
          }
          iprot.readFieldEnd();
        }
        iprot.readStructEnd();

        // check for required fields of primitive type, which can't be checked in the validate method
        struct.validate();
      }

      public void write(org.apache.thrift.protocol.TProtocol oprot, connection_setCatalog_result struct) throws org.apache.thrift.TException {
        struct.validate();

        oprot.writeStructBegin(STRUCT_DESC);
        if (struct.sqlException != null) {
          oprot.writeFieldBegin(SQL_EXCEPTION_FIELD_DESC);
          struct.sqlException.write(oprot);
          oprot.writeFieldEnd();
        }
        oprot.writeFieldStop();
        oprot.writeStructEnd();
      }

    }

    private static class connection_setCatalog_resultTupleSchemeFactory implements SchemeFactory {
      public connection_setCatalog_resultTupleScheme getScheme() {
        return new connection_setCatalog_resultTupleScheme();
      }
    }

    private static class connection_setCatalog_resultTupleScheme extends TupleScheme<connection_setCatalog_result> {

      @Override
      public void write(org.apache.thrift.protocol.TProtocol prot, connection_setCatalog_result struct) throws org.apache.thrift.TException {
        TTupleProtocol oprot = (TTupleProtocol) prot;
        BitSet optionals = new BitSet();
        if (struct.isSetSqlException()) {
          optionals.set(0);
        }
        oprot.writeBitSet(optionals, 1);
        if (struct.isSetSqlException()) {
          struct.sqlException.write(oprot);
        }
      }

      @Override
      public void read(org.apache.thrift.protocol.TProtocol prot, connection_setCatalog_result struct) throws org.apache.thrift.TException {
        TTupleProtocol iprot = (TTupleProtocol) prot;
        BitSet incoming = iprot.readBitSet(1);
        if (incoming.get(0)) {
          struct.sqlException = new RSQLException();
          struct.sqlException.read(iprot);
          struct.setSqlExceptionIsSet(true);
        }
      }
    }

  }

  public static class connection_getCatalog_args implements org.apache.thrift.TBase<connection_getCatalog_args, connection_getCatalog_args._Fields>, java.io.Serializable, Cloneable, Comparable<connection_getCatalog_args>   {
    private static final org.apache.thrift.protocol.TStruct STRUCT_DESC = new org.apache.thrift.protocol.TStruct("connection_getCatalog_args");

    private static final org.apache.thrift.protocol.TField CONNECTION_FIELD_DESC = new org.apache.thrift.protocol.TField("connection", org.apache.thrift.protocol.TType.STRUCT, (short)1);

    private static final Map<Class<? extends IScheme>, SchemeFactory> schemes = new HashMap<Class<? extends IScheme>, SchemeFactory>();
    static {
      schemes.put(StandardScheme.class, new connection_getCatalog_argsStandardSchemeFactory());
      schemes.put(TupleScheme.class, new connection_getCatalog_argsTupleSchemeFactory());
    }

    public RConnection connection; // required

    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements org.apache.thrift.TFieldIdEnum {
      CONNECTION((short)1, "connection");

      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        switch(fieldId) {
          case 1: // CONNECTION
            return CONNECTION;
          default:
            return null;
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }

    // isset id assignments
    public static final Map<_Fields, org.apache.thrift.meta_data.FieldMetaData> metaDataMap;
    static {
      Map<_Fields, org.apache.thrift.meta_data.FieldMetaData> tmpMap = new EnumMap<_Fields, org.apache.thrift.meta_data.FieldMetaData>(_Fields.class);
      tmpMap.put(_Fields.CONNECTION, new org.apache.thrift.meta_data.FieldMetaData("connection", org.apache.thrift.TFieldRequirementType.DEFAULT, 
          new org.apache.thrift.meta_data.StructMetaData(org.apache.thrift.protocol.TType.STRUCT, RConnection.class)));
      metaDataMap = Collections.unmodifiableMap(tmpMap);
      org.apache.thrift.meta_data.FieldMetaData.addStructMetaDataMap(connection_getCatalog_args.class, metaDataMap);
    }

    public connection_getCatalog_args() {
    }

    public connection_getCatalog_args(
      RConnection connection)
    {
      this();
      this.connection = connection;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public connection_getCatalog_args(connection_getCatalog_args other) {
      if (other.isSetConnection()) {
        this.connection = new RConnection(other.connection);
      }
    }

    public connection_getCatalog_args deepCopy() {
      return new connection_getCatalog_args(this);
    }

    @Override
    public void clear() {
      this.connection = null;
    }

    public RConnection getConnection() {
      return this.connection;
    }

    public connection_getCatalog_args setConnection(RConnection connection) {
      this.connection = connection;
      return this;
    }

    public void unsetConnection() {
      this.connection = null;
    }

    /** Returns true if field connection is set (has been assigned a value) and false otherwise */
    public boolean isSetConnection() {
      return this.connection != null;
    }

    public void setConnectionIsSet(boolean value) {
      if (!value) {
        this.connection = null;
      }
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      case CONNECTION:
        if (value == null) {
          unsetConnection();
        } else {
          setConnection((RConnection)value);
        }
        break;

      }
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      case CONNECTION:
        return getConnection();

      }
      throw new IllegalStateException();
    }

    /** Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      if (field == null) {
        throw new IllegalArgumentException();
      }

      switch (field) {
      case CONNECTION:
        return isSetConnection();
      }
      throw new IllegalStateException();
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof connection_getCatalog_args)
        return this.equals((connection_getCatalog_args)that);
      return false;
    }

    public boolean equals(connection_getCatalog_args that) {
      if (that == null)
        return false;

      boolean this_present_connection = true && this.isSetConnection();
      boolean that_present_connection = true && that.isSetConnection();
      if (this_present_connection || that_present_connection) {
        if (!(this_present_connection && that_present_connection))
          return false;
        if (!this.connection.equals(that.connection))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      List<Object> list = new ArrayList<Object>();

      boolean present_connection = true && (isSetConnection());
      list.add(present_connection);
      if (present_connection)
        list.add(connection);

      return list.hashCode();
    }

    @Override
    public int compareTo(connection_getCatalog_args other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetConnection()).compareTo(other.isSetConnection());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetConnection()) {
        lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.connection, other.connection);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      return 0;
    }

    public _Fields fieldForId(int fieldId) {
      return _Fields.findByThriftId(fieldId);
    }

    public void read(org.apache.thrift.protocol.TProtocol iprot) throws org.apache.thrift.TException {
      schemes.get(iprot.getScheme()).getScheme().read(iprot, this);
    }

    public void write(org.apache.thrift.protocol.TProtocol oprot) throws org.apache.thrift.TException {
      schemes.get(oprot.getScheme()).getScheme().write(oprot, this);
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("connection_getCatalog_args(");
      boolean first = true;

      sb.append("connection:");
      if (this.connection == null) {
        sb.append("null");
      } else {
        sb.append(this.connection);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws org.apache.thrift.TException {
      // check for required fields
      // check for sub-struct validity
      if (connection != null) {
        connection.validate();
      }
    }

    private void writeObject(java.io.ObjectOutputStream out) throws java.io.IOException {
      try {
        write(new org.apache.thrift.protocol.TCompactProtocol(new org.apache.thrift.transport.TIOStreamTransport(out)));
      } catch (org.apache.thrift.TException te) {
        throw new java.io.IOException(te);
      }
    }

    private void readObject(java.io.ObjectInputStream in) throws java.io.IOException, ClassNotFoundException {
      try {
        read(new org.apache.thrift.protocol.TCompactProtocol(new org.apache.thrift.transport.TIOStreamTransport(in)));
      } catch (org.apache.thrift.TException te) {
        throw new java.io.IOException(te);
      }
    }

    private static class connection_getCatalog_argsStandardSchemeFactory implements SchemeFactory {
      public connection_getCatalog_argsStandardScheme getScheme() {
        return new connection_getCatalog_argsStandardScheme();
      }
    }

    private static class connection_getCatalog_argsStandardScheme extends StandardScheme<connection_getCatalog_args> {

      public void read(org.apache.thrift.protocol.TProtocol iprot, connection_getCatalog_args struct) throws org.apache.thrift.TException {
        org.apache.thrift.protocol.TField schemeField;
        iprot.readStructBegin();
        while (true)
        {
          schemeField = iprot.readFieldBegin();
          if (schemeField.type == org.apache.thrift.protocol.TType.STOP) { 
            break;
          }
          switch (schemeField.id) {
            case 1: // CONNECTION
              if (schemeField.type == org.apache.thrift.protocol.TType.STRUCT) {
                struct.connection = new RConnection();
                struct.connection.read(iprot);
                struct.setConnectionIsSet(true);
              } else { 
                org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
              }
              break;
            default:
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
          }
          iprot.readFieldEnd();
        }
        iprot.readStructEnd();

        // check for required fields of primitive type, which can't be checked in the validate method
        struct.validate();
      }

      public void write(org.apache.thrift.protocol.TProtocol oprot, connection_getCatalog_args struct) throws org.apache.thrift.TException {
        struct.validate();

        oprot.writeStructBegin(STRUCT_DESC);
        if (struct.connection != null) {
          oprot.writeFieldBegin(CONNECTION_FIELD_DESC);
          struct.connection.write(oprot);
          oprot.writeFieldEnd();
        }
        oprot.writeFieldStop();
        oprot.writeStructEnd();
      }

    }

    private static class connection_getCatalog_argsTupleSchemeFactory implements SchemeFactory {
      public connection_getCatalog_argsTupleScheme getScheme() {
        return new connection_getCatalog_argsTupleScheme();
      }
    }

    private static class connection_getCatalog_argsTupleScheme extends TupleScheme<connection_getCatalog_args> {

      @Override
      public void write(org.apache.thrift.protocol.TProtocol prot, connection_getCatalog_args struct) throws org.apache.thrift.TException {
        TTupleProtocol oprot = (TTupleProtocol) prot;
        BitSet optionals = new BitSet();
        if (struct.isSetConnection()) {
          optionals.set(0);
        }
        oprot.writeBitSet(optionals, 1);
        if (struct.isSetConnection()) {
          struct.connection.write(oprot);
        }
      }

      @Override
      public void read(org.apache.thrift.protocol.TProtocol prot, connection_getCatalog_args struct) throws org.apache.thrift.TException {
        TTupleProtocol iprot = (TTupleProtocol) prot;
        BitSet incoming = iprot.readBitSet(1);
        if (incoming.get(0)) {
          struct.connection = new RConnection();
          struct.connection.read(iprot);
          struct.setConnectionIsSet(true);
        }
      }
    }

  }

  public static class connection_getCatalog_result implements org.apache.thrift.TBase<connection_getCatalog_result, connection_getCatalog_result._Fields>, java.io.Serializable, Cloneable, Comparable<connection_getCatalog_result>   {
    private static final org.apache.thrift.protocol.TStruct STRUCT_DESC = new org.apache.thrift.protocol.TStruct("connection_getCatalog_result");

    private static final org.apache.thrift.protocol.TField SUCCESS_FIELD_DESC = new org.apache.thrift.protocol.TField("success", org.apache.thrift.protocol.TType.STRING, (short)0);
    private static final org.apache.thrift.protocol.TField SQL_EXCEPTION_FIELD_DESC = new org.apache.thrift.protocol.TField("sqlException", org.apache.thrift.protocol.TType.STRUCT, (short)1);

    private static final Map<Class<? extends IScheme>, SchemeFactory> schemes = new HashMap<Class<? extends IScheme>, SchemeFactory>();
    static {
      schemes.put(StandardScheme.class, new connection_getCatalog_resultStandardSchemeFactory());
      schemes.put(TupleScheme.class, new connection_getCatalog_resultTupleSchemeFactory());
    }

    public String success; // required
    public RSQLException sqlException; // required

    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements org.apache.thrift.TFieldIdEnum {
      SUCCESS((short)0, "success"),
      SQL_EXCEPTION((short)1, "sqlException");

      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        switch(fieldId) {
          case 0: // SUCCESS
            return SUCCESS;
          case 1: // SQL_EXCEPTION
            return SQL_EXCEPTION;
          default:
            return null;
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }

    // isset id assignments
    public static final Map<_Fields, org.apache.thrift.meta_data.FieldMetaData> metaDataMap;
    static {
      Map<_Fields, org.apache.thrift.meta_data.FieldMetaData> tmpMap = new EnumMap<_Fields, org.apache.thrift.meta_data.FieldMetaData>(_Fields.class);
      tmpMap.put(_Fields.SUCCESS, new org.apache.thrift.meta_data.FieldMetaData("success", org.apache.thrift.TFieldRequirementType.DEFAULT, 
          new org.apache.thrift.meta_data.FieldValueMetaData(org.apache.thrift.protocol.TType.STRING)));
      tmpMap.put(_Fields.SQL_EXCEPTION, new org.apache.thrift.meta_data.FieldMetaData("sqlException", org.apache.thrift.TFieldRequirementType.DEFAULT, 
          new org.apache.thrift.meta_data.FieldValueMetaData(org.apache.thrift.protocol.TType.STRUCT)));
      metaDataMap = Collections.unmodifiableMap(tmpMap);
      org.apache.thrift.meta_data.FieldMetaData.addStructMetaDataMap(connection_getCatalog_result.class, metaDataMap);
    }

    public connection_getCatalog_result() {
    }

    public connection_getCatalog_result(
      String success,
      RSQLException sqlException)
    {
      this();
      this.success = success;
      this.sqlException = sqlException;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public connection_getCatalog_result(connection_getCatalog_result other) {
      if (other.isSetSuccess()) {
        this.success = other.success;
      }
      if (other.isSetSqlException()) {
        this.sqlException = new RSQLException(other.sqlException);
      }
    }

    public connection_getCatalog_result deepCopy() {
      return new connection_getCatalog_result(this);
    }

    @Override
    public void clear() {
      this.success = null;
      this.sqlException = null;
    }

    public String getSuccess() {
      return this.success;
    }

    public connection_getCatalog_result setSuccess(String success) {
      this.success = success;
      return this;
    }

    public void unsetSuccess() {
      this.success = null;
    }

    /** Returns true if field success is set (has been assigned a value) and false otherwise */
    public boolean isSetSuccess() {
      return this.success != null;
    }

    public void setSuccessIsSet(boolean value) {
      if (!value) {
        this.success = null;
      }
    }

    public RSQLException getSqlException() {
      return this.sqlException;
    }

    public connection_getCatalog_result setSqlException(RSQLException sqlException) {
      this.sqlException = sqlException;
      return this;
    }

    public void unsetSqlException() {
      this.sqlException = null;
    }

    /** Returns true if field sqlException is set (has been assigned a value) and false otherwise */
    public boolean isSetSqlException() {
      return this.sqlException != null;
    }

    public void setSqlExceptionIsSet(boolean value) {
      if (!value) {
        this.sqlException = null;
      }
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          setSuccess((String)value);
        }
        break;

      case SQL_EXCEPTION:
        if (value == null) {
          unsetSqlException();
        } else {
          setSqlException((RSQLException)value);
        }
        break;

      }
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      case SUCCESS:
        return getSuccess();

      case SQL_EXCEPTION:
        return getSqlException();

      }
      throw new IllegalStateException();
    }

    /** Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      if (field == null) {
        throw new IllegalArgumentException();
      }

      switch (field) {
      case SUCCESS:
        return isSetSuccess();
      case SQL_EXCEPTION:
        return isSetSqlException();
      }
      throw new IllegalStateException();
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof connection_getCatalog_result)
        return this.equals((connection_getCatalog_result)that);
      return false;
    }

    public boolean equals(connection_getCatalog_result that) {
      if (that == null)
        return false;

      boolean this_present_success = true && this.isSetSuccess();
      boolean that_present_success = true && that.isSetSuccess();
      if (this_present_success || that_present_success) {
        if (!(this_present_success && that_present_success))
          return false;
        if (!this.success.equals(that.success))
          return false;
      }

      boolean this_present_sqlException = true && this.isSetSqlException();
      boolean that_present_sqlException = true && that.isSetSqlException();
      if (this_present_sqlException || that_present_sqlException) {
        if (!(this_present_sqlException && that_present_sqlException))
          return false;
        if (!this.sqlException.equals(that.sqlException))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      List<Object> list = new ArrayList<Object>();

      boolean present_success = true && (isSetSuccess());
      list.add(present_success);
      if (present_success)
        list.add(success);

      boolean present_sqlException = true && (isSetSqlException());
      list.add(present_sqlException);
      if (present_sqlException)
        list.add(sqlException);

      return list.hashCode();
    }

    @Override
    public int compareTo(connection_getCatalog_result other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetSuccess()).compareTo(other.isSetSuccess());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetSuccess()) {
        lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.success, other.success);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      lastComparison = Boolean.valueOf(isSetSqlException()).compareTo(other.isSetSqlException());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetSqlException()) {
        lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.sqlException, other.sqlException);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      return 0;
    }

    public _Fields fieldForId(int fieldId) {
      return _Fields.findByThriftId(fieldId);
    }

    public void read(org.apache.thrift.protocol.TProtocol iprot) throws org.apache.thrift.TException {
      schemes.get(iprot.getScheme()).getScheme().read(iprot, this);
    }

    public void write(org.apache.thrift.protocol.TProtocol oprot) throws org.apache.thrift.TException {
      schemes.get(oprot.getScheme()).getScheme().write(oprot, this);
      }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("connection_getCatalog_result(");
      boolean first = true;

      sb.append("success:");
      if (this.success == null) {
        sb.append("null");
      } else {
        sb.append(this.success);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("sqlException:");
      if (this.sqlException == null) {
        sb.append("null");
      } else {
        sb.append(this.sqlException);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws org.apache.thrift.TException {
      // check for required fields
      // check for sub-struct validity
    }

    private void writeObject(java.io.ObjectOutputStream out) throws java.io.IOException {
      try {
        write(new org.apache.thrift.protocol.TCompactProtocol(new org.apache.thrift.transport.TIOStreamTransport(out)));
      } catch (org.apache.thrift.TException te) {
        throw new java.io.IOException(te);
      }
    }

    private void readObject(java.io.ObjectInputStream in) throws java.io.IOException, ClassNotFoundException {
      try {
        read(new org.apache.thrift.protocol.TCompactProtocol(new org.apache.thrift.transport.TIOStreamTransport(in)));
      } catch (org.apache.thrift.TException te) {
        throw new java.io.IOException(te);
      }
    }

    private static class connection_getCatalog_resultStandardSchemeFactory implements SchemeFactory {
      public connection_getCatalog_resultStandardScheme getScheme() {
        return new connection_getCatalog_resultStandardScheme();
      }
    }

    private static class connection_getCatalog_resultStandardScheme extends StandardScheme<connection_getCatalog_result> {

      public void read(org.apache.thrift.protocol.TProtocol iprot, connection_getCatalog_result struct) throws org.apache.thrift.TException {
        org.apache.thrift.protocol.TField schemeField;
        iprot.readStructBegin();
        while (true)
        {
          schemeField = iprot.readFieldBegin();
          if (schemeField.type == org.apache.thrift.protocol.TType.STOP) { 
            break;
          }
          switch (schemeField.id) {
            case 0: // SUCCESS
              if (schemeField.type == org.apache.thrift.protocol.TType.STRING) {
                struct.success = iprot.readString();
                struct.setSuccessIsSet(true);
              } else { 
                org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
              }
              break;
            case 1: // SQL_EXCEPTION
              if (schemeField.type == org.apache.thrift.protocol.TType.STRUCT) {
                struct.sqlException = new RSQLException();
                struct.sqlException.read(iprot);
                struct.setSqlExceptionIsSet(true);
              } else { 
                org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
              }
              break;
            default:
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
          }
          iprot.readFieldEnd();
        }
        iprot.readStructEnd();

        // check for required fields of primitive type, which can't be checked in the validate method
        struct.validate();
      }

      public void write(org.apache.thrift.protocol.TProtocol oprot, connection_getCatalog_result struct) throws org.apache.thrift.TException {
        struct.validate();

        oprot.writeStructBegin(STRUCT_DESC);
        if (struct.success != null) {
          oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
          oprot.writeString(struct.success);
          oprot.writeFieldEnd();
        }
        if (struct.sqlException != null) {
          oprot.writeFieldBegin(SQL_EXCEPTION_FIELD_DESC);
          struct.sqlException.write(oprot);
          oprot.writeFieldEnd();
        }
        oprot.writeFieldStop();
        oprot.writeStructEnd();
      }

    }

    private static class connection_getCatalog_resultTupleSchemeFactory implements SchemeFactory {
      public connection_getCatalog_resultTupleScheme getScheme() {
        return new connection_getCatalog_resultTupleScheme();
      }
    }

    private static class connection_getCatalog_resultTupleScheme extends TupleScheme<connection_getCatalog_result> {

      @Override
      public void write(org.apache.thrift.protocol.TProtocol prot, connection_getCatalog_result struct) throws org.apache.thrift.TException {
        TTupleProtocol oprot = (TTupleProtocol) prot;
        BitSet optionals = new BitSet();
        if (struct.isSetSuccess()) {
          optionals.set(0);
        }
        if (struct.isSetSqlException()) {
          optionals.set(1);
        }
        oprot.writeBitSet(optionals, 2);
        if (struct.isSetSuccess()) {
          oprot.writeString(struct.success);
        }
        if (struct.isSetSqlException()) {
          struct.sqlException.write(oprot);
        }
      }

      @Override
      public void read(org.apache.thrift.protocol.TProtocol prot, connection_getCatalog_result struct) throws org.apache.thrift.TException {
        TTupleProtocol iprot = (TTupleProtocol) prot;
        BitSet incoming = iprot.readBitSet(2);
        if (incoming.get(0)) {
          struct.success = iprot.readString();
          struct.setSuccessIsSet(true);
        }
        if (incoming.get(1)) {
          struct.sqlException = new RSQLException();
          struct.sqlException.read(iprot);
          struct.setSqlExceptionIsSet(true);
        }
      }
    }

  }

  public static class connection_setSchema_args implements org.apache.thrift.TBase<connection_setSchema_args, connection_setSchema_args._Fields>, java.io.Serializable, Cloneable, Comparable<connection_setSchema_args>   {
    private static final org.apache.thrift.protocol.TStruct STRUCT_DESC = new org.apache.thrift.protocol.TStruct("connection_setSchema_args");

    private static final org.apache.thrift.protocol.TField CONNECTION_FIELD_DESC = new org.apache.thrift.protocol.TField("connection", org.apache.thrift.protocol.TType.STRUCT, (short)1);
    private static final org.apache.thrift.protocol.TField SCHEMA_FIELD_DESC = new org.apache.thrift.protocol.TField("schema", org.apache.thrift.protocol.TType.STRING, (short)2);

    private static final Map<Class<? extends IScheme>, SchemeFactory> schemes = new HashMap<Class<? extends IScheme>, SchemeFactory>();
    static {
      schemes.put(StandardScheme.class, new connection_setSchema_argsStandardSchemeFactory());
      schemes.put(TupleScheme.class, new connection_setSchema_argsTupleSchemeFactory());
    }

    public RConnection connection; // required
    public String schema; // required

    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements org.apache.thrift.TFieldIdEnum {
      CONNECTION((short)1, "connection"),
      SCHEMA((short)2, "schema");

      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        switch(fieldId) {
          case 1: // CONNECTION
            return CONNECTION;
          case 2: // SCHEMA
            return SCHEMA;
          default:
            return null;
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }

    // isset id assignments
    public static final Map<_Fields, org.apache.thrift.meta_data.FieldMetaData> metaDataMap;
    static {
      Map<_Fields, org.apache.thrift.meta_data.FieldMetaData> tmpMap = new EnumMap<_Fields, org.apache.thrift.meta_data.FieldMetaData>(_Fields.class);
      tmpMap.put(_Fields.CONNECTION, new org.apache.thrift.meta_data.FieldMetaData("connection", org.apache.thrift.TFieldRequirementType.DEFAULT, 
          new org.apache.thrift.meta_data.StructMetaData(org.apache.thrift.protocol.TType.STRUCT, RConnection.class)));
      tmpMap.put(_Fields.SCHEMA, new org.apache.thrift.meta_data.FieldMetaData("schema", org.apache.thrift.TFieldRequirementType.DEFAULT, 
          new org.apache.thrift.meta_data.FieldValueMetaData(org.apache.thrift.protocol.TType.STRING)));
      metaDataMap = Collections.unmodifiableMap(tmpMap);
      org.apache.thrift.meta_data.FieldMetaData.addStructMetaDataMap(connection_setSchema_args.class, metaDataMap);
    }

    public connection_setSchema_args() {
    }

    public connection_setSchema_args(
      RConnection connection,
      String schema)
    {
      this();
      this.connection = connection;
      this.schema = schema;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public connection_setSchema_args(connection_setSchema_args other) {
      if (other.isSetConnection()) {
        this.connection = new RConnection(other.connection);
      }
      if (other.isSetSchema()) {
        this.schema = other.schema;
      }
    }

    public connection_setSchema_args deepCopy() {
      return new connection_setSchema_args(this);
    }

    @Override
    public void clear() {
      this.connection = null;
      this.schema = null;
    }

    public RConnection getConnection() {
      return this.connection;
    }

    public connection_setSchema_args setConnection(RConnection connection) {
      this.connection = connection;
      return this;
    }

    public void unsetConnection() {
      this.connection = null;
    }

    /** Returns true if field connection is set (has been assigned a value) and false otherwise */
    public boolean isSetConnection() {
      return this.connection != null;
    }

    public void setConnectionIsSet(boolean value) {
      if (!value) {
        this.connection = null;
      }
    }

    public String getSchema() {
      return this.schema;
    }

    public connection_setSchema_args setSchema(String schema) {
      this.schema = schema;
      return this;
    }

    public void unsetSchema() {
      this.schema = null;
    }

    /** Returns true if field schema is set (has been assigned a value) and false otherwise */
    public boolean isSetSchema() {
      return this.schema != null;
    }

    public void setSchemaIsSet(boolean value) {
      if (!value) {
        this.schema = null;
      }
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      case CONNECTION:
        if (value == null) {
          unsetConnection();
        } else {
          setConnection((RConnection)value);
        }
        break;

      case SCHEMA:
        if (value == null) {
          unsetSchema();
        } else {
          setSchema((String)value);
        }
        break;

      }
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      case CONNECTION:
        return getConnection();

      case SCHEMA:
        return getSchema();

      }
      throw new IllegalStateException();
    }

    /** Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      if (field == null) {
        throw new IllegalArgumentException();
      }

      switch (field) {
      case CONNECTION:
        return isSetConnection();
      case SCHEMA:
        return isSetSchema();
      }
      throw new IllegalStateException();
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof connection_setSchema_args)
        return this.equals((connection_setSchema_args)that);
      return false;
    }

    public boolean equals(connection_setSchema_args that) {
      if (that == null)
        return false;

      boolean this_present_connection = true && this.isSetConnection();
      boolean that_present_connection = true && that.isSetConnection();
      if (this_present_connection || that_present_connection) {
        if (!(this_present_connection && that_present_connection))
          return false;
        if (!this.connection.equals(that.connection))
          return false;
      }

      boolean this_present_schema = true && this.isSetSchema();
      boolean that_present_schema = true && that.isSetSchema();
      if (this_present_schema || that_present_schema) {
        if (!(this_present_schema && that_present_schema))
          return false;
        if (!this.schema.equals(that.schema))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      List<Object> list = new ArrayList<Object>();

      boolean present_connection = true && (isSetConnection());
      list.add(present_connection);
      if (present_connection)
        list.add(connection);

      boolean present_schema = true && (isSetSchema());
      list.add(present_schema);
      if (present_schema)
        list.add(schema);

      return list.hashCode();
    }

    @Override
    public int compareTo(connection_setSchema_args other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetConnection()).compareTo(other.isSetConnection());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetConnection()) {
        lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.connection, other.connection);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      lastComparison = Boolean.valueOf(isSetSchema()).compareTo(other.isSetSchema());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetSchema()) {
        lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.schema, other.schema);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      return 0;
    }

    public _Fields fieldForId(int fieldId) {
      return _Fields.findByThriftId(fieldId);
    }

    public void read(org.apache.thrift.protocol.TProtocol iprot) throws org.apache.thrift.TException {
      schemes.get(iprot.getScheme()).getScheme().read(iprot, this);
    }

    public void write(org.apache.thrift.protocol.TProtocol oprot) throws org.apache.thrift.TException {
      schemes.get(oprot.getScheme()).getScheme().write(oprot, this);
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("connection_setSchema_args(");
      boolean first = true;

      sb.append("connection:");
      if (this.connection == null) {
        sb.append("null");
      } else {
        sb.append(this.connection);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("schema:");
      if (this.schema == null) {
        sb.append("null");
      } else {
        sb.append(this.schema);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws org.apache.thrift.TException {
      // check for required fields
      // check for sub-struct validity
      if (connection != null) {
        connection.validate();
      }
    }

    private void writeObject(java.io.ObjectOutputStream out) throws java.io.IOException {
      try {
        write(new org.apache.thrift.protocol.TCompactProtocol(new org.apache.thrift.transport.TIOStreamTransport(out)));
      } catch (org.apache.thrift.TException te) {
        throw new java.io.IOException(te);
      }
    }

    private void readObject(java.io.ObjectInputStream in) throws java.io.IOException, ClassNotFoundException {
      try {
        read(new org.apache.thrift.protocol.TCompactProtocol(new org.apache.thrift.transport.TIOStreamTransport(in)));
      } catch (org.apache.thrift.TException te) {
        throw new java.io.IOException(te);
      }
    }

    private static class connection_setSchema_argsStandardSchemeFactory implements SchemeFactory {
      public connection_setSchema_argsStandardScheme getScheme() {
        return new connection_setSchema_argsStandardScheme();
      }
    }

    private static class connection_setSchema_argsStandardScheme extends StandardScheme<connection_setSchema_args> {

      public void read(org.apache.thrift.protocol.TProtocol iprot, connection_setSchema_args struct) throws org.apache.thrift.TException {
        org.apache.thrift.protocol.TField schemeField;
        iprot.readStructBegin();
        while (true)
        {
          schemeField = iprot.readFieldBegin();
          if (schemeField.type == org.apache.thrift.protocol.TType.STOP) { 
            break;
          }
          switch (schemeField.id) {
            case 1: // CONNECTION
              if (schemeField.type == org.apache.thrift.protocol.TType.STRUCT) {
                struct.connection = new RConnection();
                struct.connection.read(iprot);
                struct.setConnectionIsSet(true);
              } else { 
                org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
              }
              break;
            case 2: // SCHEMA
              if (schemeField.type == org.apache.thrift.protocol.TType.STRING) {
                struct.schema = iprot.readString();
                struct.setSchemaIsSet(true);
              } else { 
                org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
              }
              break;
            default:
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
          }
          iprot.readFieldEnd();
        }
        iprot.readStructEnd();

        // check for required fields of primitive type, which can't be checked in the validate method
        struct.validate();
      }

      public void write(org.apache.thrift.protocol.TProtocol oprot, connection_setSchema_args struct) throws org.apache.thrift.TException {
        struct.validate();

        oprot.writeStructBegin(STRUCT_DESC);
        if (struct.connection != null) {
          oprot.writeFieldBegin(CONNECTION_FIELD_DESC);
          struct.connection.write(oprot);
          oprot.writeFieldEnd();
        }
        if (struct.schema != null) {
          oprot.writeFieldBegin(SCHEMA_FIELD_DESC);
          oprot.writeString(struct.schema);
          oprot.writeFieldEnd();
        }
        oprot.writeFieldStop();
        oprot.writeStructEnd();
      }

    }

    private static class connection_setSchema_argsTupleSchemeFactory implements SchemeFactory {
      public connection_setSchema_argsTupleScheme getScheme() {
        return new connection_setSchema_argsTupleScheme();
      }
    }

    private static class connection_setSchema_argsTupleScheme extends TupleScheme<connection_setSchema_args> {

      @Override
      public void write(org.apache.thrift.protocol.TProtocol prot, connection_setSchema_args struct) throws org.apache.thrift.TException {
        TTupleProtocol oprot = (TTupleProtocol) prot;
        BitSet optionals = new BitSet();
        if (struct.isSetConnection()) {
          optionals.set(0);
        }
        if (struct.isSetSchema()) {
          optionals.set(1);
        }
        oprot.writeBitSet(optionals, 2);
        if (struct.isSetConnection()) {
          struct.connection.write(oprot);
        }
        if (struct.isSetSchema()) {
          oprot.writeString(struct.schema);
        }
      }

      @Override
      public void read(org.apache.thrift.protocol.TProtocol prot, connection_setSchema_args struct) throws org.apache.thrift.TException {
        TTupleProtocol iprot = (TTupleProtocol) prot;
        BitSet incoming = iprot.readBitSet(2);
        if (incoming.get(0)) {
          struct.connection = new RConnection();
          struct.connection.read(iprot);
          struct.setConnectionIsSet(true);
        }
        if (incoming.get(1)) {
          struct.schema = iprot.readString();
          struct.setSchemaIsSet(true);
        }
      }
    }

  }

  public static class connection_setSchema_result implements org.apache.thrift.TBase<connection_setSchema_result, connection_setSchema_result._Fields>, java.io.Serializable, Cloneable, Comparable<connection_setSchema_result>   {
    private static final org.apache.thrift.protocol.TStruct STRUCT_DESC = new org.apache.thrift.protocol.TStruct("connection_setSchema_result");

    private static final org.apache.thrift.protocol.TField SQL_EXCEPTION_FIELD_DESC = new org.apache.thrift.protocol.TField("sqlException", org.apache.thrift.protocol.TType.STRUCT, (short)1);

    private static final Map<Class<? extends IScheme>, SchemeFactory> schemes = new HashMap<Class<? extends IScheme>, SchemeFactory>();
    static {
      schemes.put(StandardScheme.class, new connection_setSchema_resultStandardSchemeFactory());
      schemes.put(TupleScheme.class, new connection_setSchema_resultTupleSchemeFactory());
    }

    public RSQLException sqlException; // required

    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements org.apache.thrift.TFieldIdEnum {
      SQL_EXCEPTION((short)1, "sqlException");

      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        switch(fieldId) {
          case 1: // SQL_EXCEPTION
            return SQL_EXCEPTION;
          default:
            return null;
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }

    // isset id assignments
    public static final Map<_Fields, org.apache.thrift.meta_data.FieldMetaData> metaDataMap;
    static {
      Map<_Fields, org.apache.thrift.meta_data.FieldMetaData> tmpMap = new EnumMap<_Fields, org.apache.thrift.meta_data.FieldMetaData>(_Fields.class);
      tmpMap.put(_Fields.SQL_EXCEPTION, new org.apache.thrift.meta_data.FieldMetaData("sqlException", org.apache.thrift.TFieldRequirementType.DEFAULT, 
          new org.apache.thrift.meta_data.FieldValueMetaData(org.apache.thrift.protocol.TType.STRUCT)));
      metaDataMap = Collections.unmodifiableMap(tmpMap);
      org.apache.thrift.meta_data.FieldMetaData.addStructMetaDataMap(connection_setSchema_result.class, metaDataMap);
    }

    public connection_setSchema_result() {
    }

    public connection_setSchema_result(
      RSQLException sqlException)
    {
      this();
      this.sqlException = sqlException;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public connection_setSchema_result(connection_setSchema_result other) {
      if (other.isSetSqlException()) {
        this.sqlException = new RSQLException(other.sqlException);
      }
    }

    public connection_setSchema_result deepCopy() {
      return new connection_setSchema_result(this);
    }

    @Override
    public void clear() {
      this.sqlException = null;
    }

    public RSQLException getSqlException() {
      return this.sqlException;
    }

    public connection_setSchema_result setSqlException(RSQLException sqlException) {
      this.sqlException = sqlException;
      return this;
    }

    public void unsetSqlException() {
      this.sqlException = null;
    }

    /** Returns true if field sqlException is set (has been assigned a value) and false otherwise */
    public boolean isSetSqlException() {
      return this.sqlException != null;
    }

    public void setSqlExceptionIsSet(boolean value) {
      if (!value) {
        this.sqlException = null;
      }
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      case SQL_EXCEPTION:
        if (value == null) {
          unsetSqlException();
        } else {
          setSqlException((RSQLException)value);
        }
        break;

      }
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      case SQL_EXCEPTION:
        return getSqlException();

      }
      throw new IllegalStateException();
    }

    /** Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      if (field == null) {
        throw new IllegalArgumentException();
      }

      switch (field) {
      case SQL_EXCEPTION:
        return isSetSqlException();
      }
      throw new IllegalStateException();
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof connection_setSchema_result)
        return this.equals((connection_setSchema_result)that);
      return false;
    }

    public boolean equals(connection_setSchema_result that) {
      if (that == null)
        return false;

      boolean this_present_sqlException = true && this.isSetSqlException();
      boolean that_present_sqlException = true && that.isSetSqlException();
      if (this_present_sqlException || that_present_sqlException) {
        if (!(this_present_sqlException && that_present_sqlException))
          return false;
        if (!this.sqlException.equals(that.sqlException))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      List<Object> list = new ArrayList<Object>();

      boolean present_sqlException = true && (isSetSqlException());
      list.add(present_sqlException);
      if (present_sqlException)
        list.add(sqlException);

      return list.hashCode();
    }

    @Override
    public int compareTo(connection_setSchema_result other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetSqlException()).compareTo(other.isSetSqlException());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetSqlException()) {
        lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.sqlException, other.sqlException);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      return 0;
    }

    public _Fields fieldForId(int fieldId) {
      return _Fields.findByThriftId(fieldId);
    }

    public void read(org.apache.thrift.protocol.TProtocol iprot) throws org.apache.thrift.TException {
      schemes.get(iprot.getScheme()).getScheme().read(iprot, this);
    }

    public void write(org.apache.thrift.protocol.TProtocol oprot) throws org.apache.thrift.TException {
      schemes.get(oprot.getScheme()).getScheme().write(oprot, this);
      }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("connection_setSchema_result(");
      boolean first = true;

      sb.append("sqlException:");
      if (this.sqlException == null) {
        sb.append("null");
      } else {
        sb.append(this.sqlException);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws org.apache.thrift.TException {
      // check for required fields
      // check for sub-struct validity
    }

    private void writeObject(java.io.ObjectOutputStream out) throws java.io.IOException {
      try {
        write(new org.apache.thrift.protocol.TCompactProtocol(new org.apache.thrift.transport.TIOStreamTransport(out)));
      } catch (org.apache.thrift.TException te) {
        throw new java.io.IOException(te);
      }
    }

    private void readObject(java.io.ObjectInputStream in) throws java.io.IOException, ClassNotFoundException {
      try {
        read(new org.apache.thrift.protocol.TCompactProtocol(new org.apache.thrift.transport.TIOStreamTransport(in)));
      } catch (org.apache.thrift.TException te) {
        throw new java.io.IOException(te);
      }
    }

    private static class connection_setSchema_resultStandardSchemeFactory implements SchemeFactory {
      public connection_setSchema_resultStandardScheme getScheme() {
        return new connection_setSchema_resultStandardScheme();
      }
    }

    private static class connection_setSchema_resultStandardScheme extends StandardScheme<connection_setSchema_result> {

      public void read(org.apache.thrift.protocol.TProtocol iprot, connection_setSchema_result struct) throws org.apache.thrift.TException {
        org.apache.thrift.protocol.TField schemeField;
        iprot.readStructBegin();
        while (true)
        {
          schemeField = iprot.readFieldBegin();
          if (schemeField.type == org.apache.thrift.protocol.TType.STOP) { 
            break;
          }
          switch (schemeField.id) {
            case 1: // SQL_EXCEPTION
              if (schemeField.type == org.apache.thrift.protocol.TType.STRUCT) {
                struct.sqlException = new RSQLException();
                struct.sqlException.read(iprot);
                struct.setSqlExceptionIsSet(true);
              } else { 
                org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
              }
              break;
            default:
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
          }
          iprot.readFieldEnd();
        }
        iprot.readStructEnd();

        // check for required fields of primitive type, which can't be checked in the validate method
        struct.validate();
      }

      public void write(org.apache.thrift.protocol.TProtocol oprot, connection_setSchema_result struct) throws org.apache.thrift.TException {
        struct.validate();

        oprot.writeStructBegin(STRUCT_DESC);
        if (struct.sqlException != null) {
          oprot.writeFieldBegin(SQL_EXCEPTION_FIELD_DESC);
          struct.sqlException.write(oprot);
          oprot.writeFieldEnd();
        }
        oprot.writeFieldStop();
        oprot.writeStructEnd();
      }

    }

    private static class connection_setSchema_resultTupleSchemeFactory implements SchemeFactory {
      public connection_setSchema_resultTupleScheme getScheme() {
        return new connection_setSchema_resultTupleScheme();
      }
    }

    private static class connection_setSchema_resultTupleScheme extends TupleScheme<connection_setSchema_result> {

      @Override
      public void write(org.apache.thrift.protocol.TProtocol prot, connection_setSchema_result struct) throws org.apache.thrift.TException {
        TTupleProtocol oprot = (TTupleProtocol) prot;
        BitSet optionals = new BitSet();
        if (struct.isSetSqlException()) {
          optionals.set(0);
        }
        oprot.writeBitSet(optionals, 1);
        if (struct.isSetSqlException()) {
          struct.sqlException.write(oprot);
        }
      }

      @Override
      public void read(org.apache.thrift.protocol.TProtocol prot, connection_setSchema_result struct) throws org.apache.thrift.TException {
        TTupleProtocol iprot = (TTupleProtocol) prot;
        BitSet incoming = iprot.readBitSet(1);
        if (incoming.get(0)) {
          struct.sqlException = new RSQLException();
          struct.sqlException.read(iprot);
          struct.setSqlExceptionIsSet(true);
        }
      }
    }

  }

  public static class connection_getSchema_args implements org.apache.thrift.TBase<connection_getSchema_args, connection_getSchema_args._Fields>, java.io.Serializable, Cloneable, Comparable<connection_getSchema_args>   {
    private static final org.apache.thrift.protocol.TStruct STRUCT_DESC = new org.apache.thrift.protocol.TStruct("connection_getSchema_args");

    private static final org.apache.thrift.protocol.TField CONNECTION_FIELD_DESC = new org.apache.thrift.protocol.TField("connection", org.apache.thrift.protocol.TType.STRUCT, (short)1);

    private static final Map<Class<? extends IScheme>, SchemeFactory> schemes = new HashMap<Class<? extends IScheme>, SchemeFactory>();
    static {
      schemes.put(StandardScheme.class, new connection_getSchema_argsStandardSchemeFactory());
      schemes.put(TupleScheme.class, new connection_getSchema_argsTupleSchemeFactory());
    }

    public RConnection connection; // required

    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements org.apache.thrift.TFieldIdEnum {
      CONNECTION((short)1, "connection");

      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        switch(fieldId) {
          case 1: // CONNECTION
            return CONNECTION;
          default:
            return null;
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }

    // isset id assignments
    public static final Map<_Fields, org.apache.thrift.meta_data.FieldMetaData> metaDataMap;
    static {
      Map<_Fields, org.apache.thrift.meta_data.FieldMetaData> tmpMap = new EnumMap<_Fields, org.apache.thrift.meta_data.FieldMetaData>(_Fields.class);
      tmpMap.put(_Fields.CONNECTION, new org.apache.thrift.meta_data.FieldMetaData("connection", org.apache.thrift.TFieldRequirementType.DEFAULT, 
          new org.apache.thrift.meta_data.StructMetaData(org.apache.thrift.protocol.TType.STRUCT, RConnection.class)));
      metaDataMap = Collections.unmodifiableMap(tmpMap);
      org.apache.thrift.meta_data.FieldMetaData.addStructMetaDataMap(connection_getSchema_args.class, metaDataMap);
    }

    public connection_getSchema_args() {
    }

    public connection_getSchema_args(
      RConnection connection)
    {
      this();
      this.connection = connection;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public connection_getSchema_args(connection_getSchema_args other) {
      if (other.isSetConnection()) {
        this.connection = new RConnection(other.connection);
      }
    }

    public connection_getSchema_args deepCopy() {
      return new connection_getSchema_args(this);
    }

    @Override
    public void clear() {
      this.connection = null;
    }

    public RConnection getConnection() {
      return this.connection;
    }

    public connection_getSchema_args setConnection(RConnection connection) {
      this.connection = connection;
      return this;
    }

    public void unsetConnection() {
      this.connection = null;
    }

    /** Returns true if field connection is set (has been assigned a value) and false otherwise */
    public boolean isSetConnection() {
      return this.connection != null;
    }

    public void setConnectionIsSet(boolean value) {
      if (!value) {
        this.connection = null;
      }
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      case CONNECTION:
        if (value == null) {
          unsetConnection();
        } else {
          setConnection((RConnection)value);
        }
        break;

      }
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      case CONNECTION:
        return getConnection();

      }
      throw new IllegalStateException();
    }

    /** Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      if (field == null) {
        throw new IllegalArgumentException();
      }

      switch (field) {
      case CONNECTION:
        return isSetConnection();
      }
      throw new IllegalStateException();
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof connection_getSchema_args)
        return this.equals((connection_getSchema_args)that);
      return false;
    }

    public boolean equals(connection_getSchema_args that) {
      if (that == null)
        return false;

      boolean this_present_connection = true && this.isSetConnection();
      boolean that_present_connection = true && that.isSetConnection();
      if (this_present_connection || that_present_connection) {
        if (!(this_present_connection && that_present_connection))
          return false;
        if (!this.connection.equals(that.connection))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      List<Object> list = new ArrayList<Object>();

      boolean present_connection = true && (isSetConnection());
      list.add(present_connection);
      if (present_connection)
        list.add(connection);

      return list.hashCode();
    }

    @Override
    public int compareTo(connection_getSchema_args other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetConnection()).compareTo(other.isSetConnection());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetConnection()) {
        lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.connection, other.connection);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      return 0;
    }

    public _Fields fieldForId(int fieldId) {
      return _Fields.findByThriftId(fieldId);
    }

    public void read(org.apache.thrift.protocol.TProtocol iprot) throws org.apache.thrift.TException {
      schemes.get(iprot.getScheme()).getScheme().read(iprot, this);
    }

    public void write(org.apache.thrift.protocol.TProtocol oprot) throws org.apache.thrift.TException {
      schemes.get(oprot.getScheme()).getScheme().write(oprot, this);
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("connection_getSchema_args(");
      boolean first = true;

      sb.append("connection:");
      if (this.connection == null) {
        sb.append("null");
      } else {
        sb.append(this.connection);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws org.apache.thrift.TException {
      // check for required fields
      // check for sub-struct validity
      if (connection != null) {
        connection.validate();
      }
    }

    private void writeObject(java.io.ObjectOutputStream out) throws java.io.IOException {
      try {
        write(new org.apache.thrift.protocol.TCompactProtocol(new org.apache.thrift.transport.TIOStreamTransport(out)));
      } catch (org.apache.thrift.TException te) {
        throw new java.io.IOException(te);
      }
    }

    private void readObject(java.io.ObjectInputStream in) throws java.io.IOException, ClassNotFoundException {
      try {
        read(new org.apache.thrift.protocol.TCompactProtocol(new org.apache.thrift.transport.TIOStreamTransport(in)));
      } catch (org.apache.thrift.TException te) {
        throw new java.io.IOException(te);
      }
    }

    private static class connection_getSchema_argsStandardSchemeFactory implements SchemeFactory {
      public connection_getSchema_argsStandardScheme getScheme() {
        return new connection_getSchema_argsStandardScheme();
      }
    }

    private static class connection_getSchema_argsStandardScheme extends StandardScheme<connection_getSchema_args> {

      public void read(org.apache.thrift.protocol.TProtocol iprot, connection_getSchema_args struct) throws org.apache.thrift.TException {
        org.apache.thrift.protocol.TField schemeField;
        iprot.readStructBegin();
        while (true)
        {
          schemeField = iprot.readFieldBegin();
          if (schemeField.type == org.apache.thrift.protocol.TType.STOP) { 
            break;
          }
          switch (schemeField.id) {
            case 1: // CONNECTION
              if (schemeField.type == org.apache.thrift.protocol.TType.STRUCT) {
                struct.connection = new RConnection();
                struct.connection.read(iprot);
                struct.setConnectionIsSet(true);
              } else { 
                org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
              }
              break;
            default:
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
          }
          iprot.readFieldEnd();
        }
        iprot.readStructEnd();

        // check for required fields of primitive type, which can't be checked in the validate method
        struct.validate();
      }

      public void write(org.apache.thrift.protocol.TProtocol oprot, connection_getSchema_args struct) throws org.apache.thrift.TException {
        struct.validate();

        oprot.writeStructBegin(STRUCT_DESC);
        if (struct.connection != null) {
          oprot.writeFieldBegin(CONNECTION_FIELD_DESC);
          struct.connection.write(oprot);
          oprot.writeFieldEnd();
        }
        oprot.writeFieldStop();
        oprot.writeStructEnd();
      }

    }

    private static class connection_getSchema_argsTupleSchemeFactory implements SchemeFactory {
      public connection_getSchema_argsTupleScheme getScheme() {
        return new connection_getSchema_argsTupleScheme();
      }
    }

    private static class connection_getSchema_argsTupleScheme extends TupleScheme<connection_getSchema_args> {

      @Override
      public void write(org.apache.thrift.protocol.TProtocol prot, connection_getSchema_args struct) throws org.apache.thrift.TException {
        TTupleProtocol oprot = (TTupleProtocol) prot;
        BitSet optionals = new BitSet();
        if (struct.isSetConnection()) {
          optionals.set(0);
        }
        oprot.writeBitSet(optionals, 1);
        if (struct.isSetConnection()) {
          struct.connection.write(oprot);
        }
      }

      @Override
      public void read(org.apache.thrift.protocol.TProtocol prot, connection_getSchema_args struct) throws org.apache.thrift.TException {
        TTupleProtocol iprot = (TTupleProtocol) prot;
        BitSet incoming = iprot.readBitSet(1);
        if (incoming.get(0)) {
          struct.connection = new RConnection();
          struct.connection.read(iprot);
          struct.setConnectionIsSet(true);
        }
      }
    }

  }

  public static class connection_getSchema_result implements org.apache.thrift.TBase<connection_getSchema_result, connection_getSchema_result._Fields>, java.io.Serializable, Cloneable, Comparable<connection_getSchema_result>   {
    private static final org.apache.thrift.protocol.TStruct STRUCT_DESC = new org.apache.thrift.protocol.TStruct("connection_getSchema_result");

    private static final org.apache.thrift.protocol.TField SUCCESS_FIELD_DESC = new org.apache.thrift.protocol.TField("success", org.apache.thrift.protocol.TType.STRING, (short)0);
    private static final org.apache.thrift.protocol.TField SQL_EXCEPTION_FIELD_DESC = new org.apache.thrift.protocol.TField("sqlException", org.apache.thrift.protocol.TType.STRUCT, (short)1);

    private static final Map<Class<? extends IScheme>, SchemeFactory> schemes = new HashMap<Class<? extends IScheme>, SchemeFactory>();
    static {
      schemes.put(StandardScheme.class, new connection_getSchema_resultStandardSchemeFactory());
      schemes.put(TupleScheme.class, new connection_getSchema_resultTupleSchemeFactory());
    }

    public String success; // required
    public RSQLException sqlException; // required

    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements org.apache.thrift.TFieldIdEnum {
      SUCCESS((short)0, "success"),
      SQL_EXCEPTION((short)1, "sqlException");

      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        switch(fieldId) {
          case 0: // SUCCESS
            return SUCCESS;
          case 1: // SQL_EXCEPTION
            return SQL_EXCEPTION;
          default:
            return null;
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }

    // isset id assignments
    public static final Map<_Fields, org.apache.thrift.meta_data.FieldMetaData> metaDataMap;
    static {
      Map<_Fields, org.apache.thrift.meta_data.FieldMetaData> tmpMap = new EnumMap<_Fields, org.apache.thrift.meta_data.FieldMetaData>(_Fields.class);
      tmpMap.put(_Fields.SUCCESS, new org.apache.thrift.meta_data.FieldMetaData("success", org.apache.thrift.TFieldRequirementType.DEFAULT, 
          new org.apache.thrift.meta_data.FieldValueMetaData(org.apache.thrift.protocol.TType.STRING)));
      tmpMap.put(_Fields.SQL_EXCEPTION, new org.apache.thrift.meta_data.FieldMetaData("sqlException", org.apache.thrift.TFieldRequirementType.DEFAULT, 
          new org.apache.thrift.meta_data.FieldValueMetaData(org.apache.thrift.protocol.TType.STRUCT)));
      metaDataMap = Collections.unmodifiableMap(tmpMap);
      org.apache.thrift.meta_data.FieldMetaData.addStructMetaDataMap(connection_getSchema_result.class, metaDataMap);
    }

    public connection_getSchema_result() {
    }

    public connection_getSchema_result(
      String success,
      RSQLException sqlException)
    {
      this();
      this.success = success;
      this.sqlException = sqlException;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public connection_getSchema_result(connection_getSchema_result other) {
      if (other.isSetSuccess()) {
        this.success = other.success;
      }
      if (other.isSetSqlException()) {
        this.sqlException = new RSQLException(other.sqlException);
      }
    }

    public connection_getSchema_result deepCopy() {
      return new connection_getSchema_result(this);
    }

    @Override
    public void clear() {
      this.success = null;
      this.sqlException = null;
    }

    public String getSuccess() {
      return this.success;
    }

    public connection_getSchema_result setSuccess(String success) {
      this.success = success;
      return this;
    }

    public void unsetSuccess() {
      this.success = null;
    }

    /** Returns true if field success is set (has been assigned a value) and false otherwise */
    public boolean isSetSuccess() {
      return this.success != null;
    }

    public void setSuccessIsSet(boolean value) {
      if (!value) {
        this.success = null;
      }
    }

    public RSQLException getSqlException() {
      return this.sqlException;
    }

    public connection_getSchema_result setSqlException(RSQLException sqlException) {
      this.sqlException = sqlException;
      return this;
    }

    public void unsetSqlException() {
      this.sqlException = null;
    }

    /** Returns true if field sqlException is set (has been assigned a value) and false otherwise */
    public boolean isSetSqlException() {
      return this.sqlException != null;
    }

    public void setSqlExceptionIsSet(boolean value) {
      if (!value) {
        this.sqlException = null;
      }
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          setSuccess((String)value);
        }
        break;

      case SQL_EXCEPTION:
        if (value == null) {
          unsetSqlException();
        } else {
          setSqlException((RSQLException)value);
        }
        break;

      }
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      case SUCCESS:
        return getSuccess();

      case SQL_EXCEPTION:
        return getSqlException();

      }
      throw new IllegalStateException();
    }

    /** Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      if (field == null) {
        throw new IllegalArgumentException();
      }

      switch (field) {
      case SUCCESS:
        return isSetSuccess();
      case SQL_EXCEPTION:
        return isSetSqlException();
      }
      throw new IllegalStateException();
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof connection_getSchema_result)
        return this.equals((connection_getSchema_result)that);
      return false;
    }

    public boolean equals(connection_getSchema_result that) {
      if (that == null)
        return false;

      boolean this_present_success = true && this.isSetSuccess();
      boolean that_present_success = true && that.isSetSuccess();
      if (this_present_success || that_present_success) {
        if (!(this_present_success && that_present_success))
          return false;
        if (!this.success.equals(that.success))
          return false;
      }

      boolean this_present_sqlException = true && this.isSetSqlException();
      boolean that_present_sqlException = true && that.isSetSqlException();
      if (this_present_sqlException || that_present_sqlException) {
        if (!(this_present_sqlException && that_present_sqlException))
          return false;
        if (!this.sqlException.equals(that.sqlException))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      List<Object> list = new ArrayList<Object>();

      boolean present_success = true && (isSetSuccess());
      list.add(present_success);
      if (present_success)
        list.add(success);

      boolean present_sqlException = true && (isSetSqlException());
      list.add(present_sqlException);
      if (present_sqlException)
        list.add(sqlException);

      return list.hashCode();
    }

    @Override
    public int compareTo(connection_getSchema_result other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetSuccess()).compareTo(other.isSetSuccess());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetSuccess()) {
        lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.success, other.success);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      lastComparison = Boolean.valueOf(isSetSqlException()).compareTo(other.isSetSqlException());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetSqlException()) {
        lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.sqlException, other.sqlException);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      return 0;
    }

    public _Fields fieldForId(int fieldId) {
      return _Fields.findByThriftId(fieldId);
    }

    public void read(org.apache.thrift.protocol.TProtocol iprot) throws org.apache.thrift.TException {
      schemes.get(iprot.getScheme()).getScheme().read(iprot, this);
    }

    public void write(org.apache.thrift.protocol.TProtocol oprot) throws org.apache.thrift.TException {
      schemes.get(oprot.getScheme()).getScheme().write(oprot, this);
      }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("connection_getSchema_result(");
      boolean first = true;

      sb.append("success:");
      if (this.success == null) {
        sb.append("null");
      } else {
        sb.append(this.success);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("sqlException:");
      if (this.sqlException == null) {
        sb.append("null");
      } else {
        sb.append(this.sqlException);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws org.apache.thrift.TException {
      // check for required fields
      // check for sub-struct validity
    }

    private void writeObject(java.io.ObjectOutputStream out) throws java.io.IOException {
      try {
        write(new org.apache.thrift.protocol.TCompactProtocol(new org.apache.thrift.transport.TIOStreamTransport(out)));
      } catch (org.apache.thrift.TException te) {
        throw new java.io.IOException(te);
      }
    }

    private void readObject(java.io.ObjectInputStream in) throws java.io.IOException, ClassNotFoundException {
      try {
        read(new org.apache.thrift.protocol.TCompactProtocol(new org.apache.thrift.transport.TIOStreamTransport(in)));
      } catch (org.apache.thrift.TException te) {
        throw new java.io.IOException(te);
      }
    }

    private static class connection_getSchema_resultStandardSchemeFactory implements SchemeFactory {
      public connection_getSchema_resultStandardScheme getScheme() {
        return new connection_getSchema_resultStandardScheme();
      }
    }

    private static class connection_getSchema_resultStandardScheme extends StandardScheme<connection_getSchema_result> {

      public void read(org.apache.thrift.protocol.TProtocol iprot, connection_getSchema_result struct) throws org.apache.thrift.TException {
        org.apache.thrift.protocol.TField schemeField;
        iprot.readStructBegin();
        while (true)
        {
          schemeField = iprot.readFieldBegin();
          if (schemeField.type == org.apache.thrift.protocol.TType.STOP) { 
            break;
          }
          switch (schemeField.id) {
            case 0: // SUCCESS
              if (schemeField.type == org.apache.thrift.protocol.TType.STRING) {
                struct.success = iprot.readString();
                struct.setSuccessIsSet(true);
              } else { 
                org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
              }
              break;
            case 1: // SQL_EXCEPTION
              if (schemeField.type == org.apache.thrift.protocol.TType.STRUCT) {
                struct.sqlException = new RSQLException();
                struct.sqlException.read(iprot);
                struct.setSqlExceptionIsSet(true);
              } else { 
                org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
              }
              break;
            default:
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
          }
          iprot.readFieldEnd();
        }
        iprot.readStructEnd();

        // check for required fields of primitive type, which can't be checked in the validate method
        struct.validate();
      }

      public void write(org.apache.thrift.protocol.TProtocol oprot, connection_getSchema_result struct) throws org.apache.thrift.TException {
        struct.validate();

        oprot.writeStructBegin(STRUCT_DESC);
        if (struct.success != null) {
          oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
          oprot.writeString(struct.success);
          oprot.writeFieldEnd();
        }
        if (struct.sqlException != null) {
          oprot.writeFieldBegin(SQL_EXCEPTION_FIELD_DESC);
          struct.sqlException.write(oprot);
          oprot.writeFieldEnd();
        }
        oprot.writeFieldStop();
        oprot.writeStructEnd();
      }

    }

    private static class connection_getSchema_resultTupleSchemeFactory implements SchemeFactory {
      public connection_getSchema_resultTupleScheme getScheme() {
        return new connection_getSchema_resultTupleScheme();
      }
    }

    private static class connection_getSchema_resultTupleScheme extends TupleScheme<connection_getSchema_result> {

      @Override
      public void write(org.apache.thrift.protocol.TProtocol prot, connection_getSchema_result struct) throws org.apache.thrift.TException {
        TTupleProtocol oprot = (TTupleProtocol) prot;
        BitSet optionals = new BitSet();
        if (struct.isSetSuccess()) {
          optionals.set(0);
        }
        if (struct.isSetSqlException()) {
          optionals.set(1);
        }
        oprot.writeBitSet(optionals, 2);
        if (struct.isSetSuccess()) {
          oprot.writeString(struct.success);
        }
        if (struct.isSetSqlException()) {
          struct.sqlException.write(oprot);
        }
      }

      @Override
      public void read(org.apache.thrift.protocol.TProtocol prot, connection_getSchema_result struct) throws org.apache.thrift.TException {
        TTupleProtocol iprot = (TTupleProtocol) prot;
        BitSet incoming = iprot.readBitSet(2);
        if (incoming.get(0)) {
          struct.success = iprot.readString();
          struct.setSuccessIsSet(true);
        }
        if (incoming.get(1)) {
          struct.sqlException = new RSQLException();
          struct.sqlException.read(iprot);
          struct.setSqlExceptionIsSet(true);
        }
      }
    }

  }

  public static class connection_getCatalogSeparator_args implements org.apache.thrift.TBase<connection_getCatalogSeparator_args, connection_getCatalogSeparator_args._Fields>, java.io.Serializable, Cloneable, Comparable<connection_getCatalogSeparator_args>   {
    private static final org.apache.thrift.protocol.TStruct STRUCT_DESC = new org.apache.thrift.protocol.TStruct("connection_getCatalogSeparator_args");

    private static final org.apache.thrift.protocol.TField CONNECTION_FIELD_DESC = new org.apache.thrift.protocol.TField("connection", org.apache.thrift.protocol.TType.STRUCT, (short)1);

    private static final Map<Class<? extends IScheme>, SchemeFactory> schemes = new HashMap<Class<? extends IScheme>, SchemeFactory>();
    static {
      schemes.put(StandardScheme.class, new connection_getCatalogSeparator_argsStandardSchemeFactory());
      schemes.put(TupleScheme.class, new connection_getCatalogSeparator_argsTupleSchemeFactory());
    }

    public RConnection connection; // required

    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements org.apache.thrift.TFieldIdEnum {
      CONNECTION((short)1, "connection");

      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        switch(fieldId) {
          case 1: // CONNECTION
            return CONNECTION;
          default:
            return null;
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }

    // isset id assignments
    public static final Map<_Fields, org.apache.thrift.meta_data.FieldMetaData> metaDataMap;
    static {
      Map<_Fields, org.apache.thrift.meta_data.FieldMetaData> tmpMap = new EnumMap<_Fields, org.apache.thrift.meta_data.FieldMetaData>(_Fields.class);
      tmpMap.put(_Fields.CONNECTION, new org.apache.thrift.meta_data.FieldMetaData("connection", org.apache.thrift.TFieldRequirementType.DEFAULT, 
          new org.apache.thrift.meta_data.StructMetaData(org.apache.thrift.protocol.TType.STRUCT, RConnection.class)));
      metaDataMap = Collections.unmodifiableMap(tmpMap);
      org.apache.thrift.meta_data.FieldMetaData.addStructMetaDataMap(connection_getCatalogSeparator_args.class, metaDataMap);
    }

    public connection_getCatalogSeparator_args() {
    }

    public connection_getCatalogSeparator_args(
      RConnection connection)
    {
      this();
      this.connection = connection;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public connection_getCatalogSeparator_args(connection_getCatalogSeparator_args other) {
      if (other.isSetConnection()) {
        this.connection = new RConnection(other.connection);
      }
    }

    public connection_getCatalogSeparator_args deepCopy() {
      return new connection_getCatalogSeparator_args(this);
    }

    @Override
    public void clear() {
      this.connection = null;
    }

    public RConnection getConnection() {
      return this.connection;
    }

    public connection_getCatalogSeparator_args setConnection(RConnection connection) {
      this.connection = connection;
      return this;
    }

    public void unsetConnection() {
      this.connection = null;
    }

    /** Returns true if field connection is set (has been assigned a value) and false otherwise */
    public boolean isSetConnection() {
      return this.connection != null;
    }

    public void setConnectionIsSet(boolean value) {
      if (!value) {
        this.connection = null;
      }
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      case CONNECTION:
        if (value == null) {
          unsetConnection();
        } else {
          setConnection((RConnection)value);
        }
        break;

      }
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      case CONNECTION:
        return getConnection();

      }
      throw new IllegalStateException();
    }

    /** Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      if (field == null) {
        throw new IllegalArgumentException();
      }

      switch (field) {
      case CONNECTION:
        return isSetConnection();
      }
      throw new IllegalStateException();
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof connection_getCatalogSeparator_args)
        return this.equals((connection_getCatalogSeparator_args)that);
      return false;
    }

    public boolean equals(connection_getCatalogSeparator_args that) {
      if (that == null)
        return false;

      boolean this_present_connection = true && this.isSetConnection();
      boolean that_present_connection = true && that.isSetConnection();
      if (this_present_connection || that_present_connection) {
        if (!(this_present_connection && that_present_connection))
          return false;
        if (!this.connection.equals(that.connection))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      List<Object> list = new ArrayList<Object>();

      boolean present_connection = true && (isSetConnection());
      list.add(present_connection);
      if (present_connection)
        list.add(connection);

      return list.hashCode();
    }

    @Override
    public int compareTo(connection_getCatalogSeparator_args other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetConnection()).compareTo(other.isSetConnection());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetConnection()) {
        lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.connection, other.connection);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      return 0;
    }

    public _Fields fieldForId(int fieldId) {
      return _Fields.findByThriftId(fieldId);
    }

    public void read(org.apache.thrift.protocol.TProtocol iprot) throws org.apache.thrift.TException {
      schemes.get(iprot.getScheme()).getScheme().read(iprot, this);
    }

    public void write(org.apache.thrift.protocol.TProtocol oprot) throws org.apache.thrift.TException {
      schemes.get(oprot.getScheme()).getScheme().write(oprot, this);
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("connection_getCatalogSeparator_args(");
      boolean first = true;

      sb.append("connection:");
      if (this.connection == null) {
        sb.append("null");
      } else {
        sb.append(this.connection);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws org.apache.thrift.TException {
      // check for required fields
      // check for sub-struct validity
      if (connection != null) {
        connection.validate();
      }
    }

    private void writeObject(java.io.ObjectOutputStream out) throws java.io.IOException {
      try {
        write(new org.apache.thrift.protocol.TCompactProtocol(new org.apache.thrift.transport.TIOStreamTransport(out)));
      } catch (org.apache.thrift.TException te) {
        throw new java.io.IOException(te);
      }
    }

    private void readObject(java.io.ObjectInputStream in) throws java.io.IOException, ClassNotFoundException {
      try {
        read(new org.apache.thrift.protocol.TCompactProtocol(new org.apache.thrift.transport.TIOStreamTransport(in)));
      } catch (org.apache.thrift.TException te) {
        throw new java.io.IOException(te);
      }
    }

    private static class connection_getCatalogSeparator_argsStandardSchemeFactory implements SchemeFactory {
      public connection_getCatalogSeparator_argsStandardScheme getScheme() {
        return new connection_getCatalogSeparator_argsStandardScheme();
      }
    }

    private static class connection_getCatalogSeparator_argsStandardScheme extends StandardScheme<connection_getCatalogSeparator_args> {

      public void read(org.apache.thrift.protocol.TProtocol iprot, connection_getCatalogSeparator_args struct) throws org.apache.thrift.TException {
        org.apache.thrift.protocol.TField schemeField;
        iprot.readStructBegin();
        while (true)
        {
          schemeField = iprot.readFieldBegin();
          if (schemeField.type == org.apache.thrift.protocol.TType.STOP) { 
            break;
          }
          switch (schemeField.id) {
            case 1: // CONNECTION
              if (schemeField.type == org.apache.thrift.protocol.TType.STRUCT) {
                struct.connection = new RConnection();
                struct.connection.read(iprot);
                struct.setConnectionIsSet(true);
              } else { 
                org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
              }
              break;
            default:
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
          }
          iprot.readFieldEnd();
        }
        iprot.readStructEnd();

        // check for required fields of primitive type, which can't be checked in the validate method
        struct.validate();
      }

      public void write(org.apache.thrift.protocol.TProtocol oprot, connection_getCatalogSeparator_args struct) throws org.apache.thrift.TException {
        struct.validate();

        oprot.writeStructBegin(STRUCT_DESC);
        if (struct.connection != null) {
          oprot.writeFieldBegin(CONNECTION_FIELD_DESC);
          struct.connection.write(oprot);
          oprot.writeFieldEnd();
        }
        oprot.writeFieldStop();
        oprot.writeStructEnd();
      }

    }

    private static class connection_getCatalogSeparator_argsTupleSchemeFactory implements SchemeFactory {
      public connection_getCatalogSeparator_argsTupleScheme getScheme() {
        return new connection_getCatalogSeparator_argsTupleScheme();
      }
    }

    private static class connection_getCatalogSeparator_argsTupleScheme extends TupleScheme<connection_getCatalogSeparator_args> {

      @Override
      public void write(org.apache.thrift.protocol.TProtocol prot, connection_getCatalogSeparator_args struct) throws org.apache.thrift.TException {
        TTupleProtocol oprot = (TTupleProtocol) prot;
        BitSet optionals = new BitSet();
        if (struct.isSetConnection()) {
          optionals.set(0);
        }
        oprot.writeBitSet(optionals, 1);
        if (struct.isSetConnection()) {
          struct.connection.write(oprot);
        }
      }

      @Override
      public void read(org.apache.thrift.protocol.TProtocol prot, connection_getCatalogSeparator_args struct) throws org.apache.thrift.TException {
        TTupleProtocol iprot = (TTupleProtocol) prot;
        BitSet incoming = iprot.readBitSet(1);
        if (incoming.get(0)) {
          struct.connection = new RConnection();
          struct.connection.read(iprot);
          struct.setConnectionIsSet(true);
        }
      }
    }

  }

  public static class connection_getCatalogSeparator_result implements org.apache.thrift.TBase<connection_getCatalogSeparator_result, connection_getCatalogSeparator_result._Fields>, java.io.Serializable, Cloneable, Comparable<connection_getCatalogSeparator_result>   {
    private static final org.apache.thrift.protocol.TStruct STRUCT_DESC = new org.apache.thrift.protocol.TStruct("connection_getCatalogSeparator_result");

    private static final org.apache.thrift.protocol.TField SUCCESS_FIELD_DESC = new org.apache.thrift.protocol.TField("success", org.apache.thrift.protocol.TType.STRING, (short)0);
    private static final org.apache.thrift.protocol.TField SQL_EXCEPTION_FIELD_DESC = new org.apache.thrift.protocol.TField("sqlException", org.apache.thrift.protocol.TType.STRUCT, (short)1);

    private static final Map<Class<? extends IScheme>, SchemeFactory> schemes = new HashMap<Class<? extends IScheme>, SchemeFactory>();
    static {
      schemes.put(StandardScheme.class, new connection_getCatalogSeparator_resultStandardSchemeFactory());
      schemes.put(TupleScheme.class, new connection_getCatalogSeparator_resultTupleSchemeFactory());
    }

    public String success; // required
    public RSQLException sqlException; // required

    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements org.apache.thrift.TFieldIdEnum {
      SUCCESS((short)0, "success"),
      SQL_EXCEPTION((short)1, "sqlException");

      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        switch(fieldId) {
          case 0: // SUCCESS
            return SUCCESS;
          case 1: // SQL_EXCEPTION
            return SQL_EXCEPTION;
          default:
            return null;
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }

    // isset id assignments
    public static final Map<_Fields, org.apache.thrift.meta_data.FieldMetaData> metaDataMap;
    static {
      Map<_Fields, org.apache.thrift.meta_data.FieldMetaData> tmpMap = new EnumMap<_Fields, org.apache.thrift.meta_data.FieldMetaData>(_Fields.class);
      tmpMap.put(_Fields.SUCCESS, new org.apache.thrift.meta_data.FieldMetaData("success", org.apache.thrift.TFieldRequirementType.DEFAULT, 
          new org.apache.thrift.meta_data.FieldValueMetaData(org.apache.thrift.protocol.TType.STRING)));
      tmpMap.put(_Fields.SQL_EXCEPTION, new org.apache.thrift.meta_data.FieldMetaData("sqlException", org.apache.thrift.TFieldRequirementType.DEFAULT, 
          new org.apache.thrift.meta_data.FieldValueMetaData(org.apache.thrift.protocol.TType.STRUCT)));
      metaDataMap = Collections.unmodifiableMap(tmpMap);
      org.apache.thrift.meta_data.FieldMetaData.addStructMetaDataMap(connection_getCatalogSeparator_result.class, metaDataMap);
    }

    public connection_getCatalogSeparator_result() {
    }

    public connection_getCatalogSeparator_result(
      String success,
      RSQLException sqlException)
    {
      this();
      this.success = success;
      this.sqlException = sqlException;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public connection_getCatalogSeparator_result(connection_getCatalogSeparator_result other) {
      if (other.isSetSuccess()) {
        this.success = other.success;
      }
      if (other.isSetSqlException()) {
        this.sqlException = new RSQLException(other.sqlException);
      }
    }

    public connection_getCatalogSeparator_result deepCopy() {
      return new connection_getCatalogSeparator_result(this);
    }

    @Override
    public void clear() {
      this.success = null;
      this.sqlException = null;
    }

    public String getSuccess() {
      return this.success;
    }

    public connection_getCatalogSeparator_result setSuccess(String success) {
      this.success = success;
      return this;
    }

    public void unsetSuccess() {
      this.success = null;
    }

    /** Returns true if field success is set (has been assigned a value) and false otherwise */
    public boolean isSetSuccess() {
      return this.success != null;
    }

    public void setSuccessIsSet(boolean value) {
      if (!value) {
        this.success = null;
      }
    }

    public RSQLException getSqlException() {
      return this.sqlException;
    }

    public connection_getCatalogSeparator_result setSqlException(RSQLException sqlException) {
      this.sqlException = sqlException;
      return this;
    }

    public void unsetSqlException() {
      this.sqlException = null;
    }

    /** Returns true if field sqlException is set (has been assigned a value) and false otherwise */
    public boolean isSetSqlException() {
      return this.sqlException != null;
    }

    public void setSqlExceptionIsSet(boolean value) {
      if (!value) {
        this.sqlException = null;
      }
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          setSuccess((String)value);
        }
        break;

      case SQL_EXCEPTION:
        if (value == null) {
          unsetSqlException();
        } else {
          setSqlException((RSQLException)value);
        }
        break;

      }
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      case SUCCESS:
        return getSuccess();

      case SQL_EXCEPTION:
        return getSqlException();

      }
      throw new IllegalStateException();
    }

    /** Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      if (field == null) {
        throw new IllegalArgumentException();
      }

      switch (field) {
      case SUCCESS:
        return isSetSuccess();
      case SQL_EXCEPTION:
        return isSetSqlException();
      }
      throw new IllegalStateException();
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof connection_getCatalogSeparator_result)
        return this.equals((connection_getCatalogSeparator_result)that);
      return false;
    }

    public boolean equals(connection_getCatalogSeparator_result that) {
      if (that == null)
        return false;

      boolean this_present_success = true && this.isSetSuccess();
      boolean that_present_success = true && that.isSetSuccess();
      if (this_present_success || that_present_success) {
        if (!(this_present_success && that_present_success))
          return false;
        if (!this.success.equals(that.success))
          return false;
      }

      boolean this_present_sqlException = true && this.isSetSqlException();
      boolean that_present_sqlException = true && that.isSetSqlException();
      if (this_present_sqlException || that_present_sqlException) {
        if (!(this_present_sqlException && that_present_sqlException))
          return false;
        if (!this.sqlException.equals(that.sqlException))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      List<Object> list = new ArrayList<Object>();

      boolean present_success = true && (isSetSuccess());
      list.add(present_success);
      if (present_success)
        list.add(success);

      boolean present_sqlException = true && (isSetSqlException());
      list.add(present_sqlException);
      if (present_sqlException)
        list.add(sqlException);

      return list.hashCode();
    }

    @Override
    public int compareTo(connection_getCatalogSeparator_result other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetSuccess()).compareTo(other.isSetSuccess());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetSuccess()) {
        lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.success, other.success);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      lastComparison = Boolean.valueOf(isSetSqlException()).compareTo(other.isSetSqlException());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetSqlException()) {
        lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.sqlException, other.sqlException);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      return 0;
    }

    public _Fields fieldForId(int fieldId) {
      return _Fields.findByThriftId(fieldId);
    }

    public void read(org.apache.thrift.protocol.TProtocol iprot) throws org.apache.thrift.TException {
      schemes.get(iprot.getScheme()).getScheme().read(iprot, this);
    }

    public void write(org.apache.thrift.protocol.TProtocol oprot) throws org.apache.thrift.TException {
      schemes.get(oprot.getScheme()).getScheme().write(oprot, this);
      }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("connection_getCatalogSeparator_result(");
      boolean first = true;

      sb.append("success:");
      if (this.success == null) {
        sb.append("null");
      } else {
        sb.append(this.success);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("sqlException:");
      if (this.sqlException == null) {
        sb.append("null");
      } else {
        sb.append(this.sqlException);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws org.apache.thrift.TException {
      // check for required fields
      // check for sub-struct validity
    }

    private void writeObject(java.io.ObjectOutputStream out) throws java.io.IOException {
      try {
        write(new org.apache.thrift.protocol.TCompactProtocol(new org.apache.thrift.transport.TIOStreamTransport(out)));
      } catch (org.apache.thrift.TException te) {
        throw new java.io.IOException(te);
      }
    }

    private void readObject(java.io.ObjectInputStream in) throws java.io.IOException, ClassNotFoundException {
      try {
        read(new org.apache.thrift.protocol.TCompactProtocol(new org.apache.thrift.transport.TIOStreamTransport(in)));
      } catch (org.apache.thrift.TException te) {
        throw new java.io.IOException(te);
      }
    }

    private static class connection_getCatalogSeparator_resultStandardSchemeFactory implements SchemeFactory {
      public connection_getCatalogSeparator_resultStandardScheme getScheme() {
        return new connection_getCatalogSeparator_resultStandardScheme();
      }
    }

    private static class connection_getCatalogSeparator_resultStandardScheme extends StandardScheme<connection_getCatalogSeparator_result> {

      public void read(org.apache.thrift.protocol.TProtocol iprot, connection_getCatalogSeparator_result struct) throws org.apache.thrift.TException {
        org.apache.thrift.protocol.TField schemeField;
        iprot.readStructBegin();
        while (true)
        {
          schemeField = iprot.readFieldBegin();
          if (schemeField.type == org.apache.thrift.protocol.TType.STOP) { 
            break;
          }
          switch (schemeField.id) {
            case 0: // SUCCESS
              if (schemeField.type == org.apache.thrift.protocol.TType.STRING) {
                struct.success = iprot.readString();
                struct.setSuccessIsSet(true);
              } else { 
                org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
              }
              break;
            case 1: // SQL_EXCEPTION
              if (schemeField.type == org.apache.thrift.protocol.TType.STRUCT) {
                struct.sqlException = new RSQLException();
                struct.sqlException.read(iprot);
                struct.setSqlExceptionIsSet(true);
              } else { 
                org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
              }
              break;
            default:
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
          }
          iprot.readFieldEnd();
        }
        iprot.readStructEnd();

        // check for required fields of primitive type, which can't be checked in the validate method
        struct.validate();
      }

      public void write(org.apache.thrift.protocol.TProtocol oprot, connection_getCatalogSeparator_result struct) throws org.apache.thrift.TException {
        struct.validate();

        oprot.writeStructBegin(STRUCT_DESC);
        if (struct.success != null) {
          oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
          oprot.writeString(struct.success);
          oprot.writeFieldEnd();
        }
        if (struct.sqlException != null) {
          oprot.writeFieldBegin(SQL_EXCEPTION_FIELD_DESC);
          struct.sqlException.write(oprot);
          oprot.writeFieldEnd();
        }
        oprot.writeFieldStop();
        oprot.writeStructEnd();
      }

    }

    private static class connection_getCatalogSeparator_resultTupleSchemeFactory implements SchemeFactory {
      public connection_getCatalogSeparator_resultTupleScheme getScheme() {
        return new connection_getCatalogSeparator_resultTupleScheme();
      }
    }

    private static class connection_getCatalogSeparator_resultTupleScheme extends TupleScheme<connection_getCatalogSeparator_result> {

      @Override
      public void write(org.apache.thrift.protocol.TProtocol prot, connection_getCatalogSeparator_result struct) throws org.apache.thrift.TException {
        TTupleProtocol oprot = (TTupleProtocol) prot;
        BitSet optionals = new BitSet();
        if (struct.isSetSuccess()) {
          optionals.set(0);
        }
        if (struct.isSetSqlException()) {
          optionals.set(1);
        }
        oprot.writeBitSet(optionals, 2);
        if (struct.isSetSuccess()) {
          oprot.writeString(struct.success);
        }
        if (struct.isSetSqlException()) {
          struct.sqlException.write(oprot);
        }
      }

      @Override
      public void read(org.apache.thrift.protocol.TProtocol prot, connection_getCatalogSeparator_result struct) throws org.apache.thrift.TException {
        TTupleProtocol iprot = (TTupleProtocol) prot;
        BitSet incoming = iprot.readBitSet(2);
        if (incoming.get(0)) {
          struct.success = iprot.readString();
          struct.setSuccessIsSet(true);
        }
        if (incoming.get(1)) {
          struct.sqlException = new RSQLException();
          struct.sqlException.read(iprot);
          struct.setSqlExceptionIsSet(true);
        }
      }
    }

  }

  public static class connection_getCatalogTerm_args implements org.apache.thrift.TBase<connection_getCatalogTerm_args, connection_getCatalogTerm_args._Fields>, java.io.Serializable, Cloneable, Comparable<connection_getCatalogTerm_args>   {
    private static final org.apache.thrift.protocol.TStruct STRUCT_DESC = new org.apache.thrift.protocol.TStruct("connection_getCatalogTerm_args");

    private static final org.apache.thrift.protocol.TField CONNECTION_FIELD_DESC = new org.apache.thrift.protocol.TField("connection", org.apache.thrift.protocol.TType.STRUCT, (short)1);

    private static final Map<Class<? extends IScheme>, SchemeFactory> schemes = new HashMap<Class<? extends IScheme>, SchemeFactory>();
    static {
      schemes.put(StandardScheme.class, new connection_getCatalogTerm_argsStandardSchemeFactory());
      schemes.put(TupleScheme.class, new connection_getCatalogTerm_argsTupleSchemeFactory());
    }

    public RConnection connection; // required

    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements org.apache.thrift.TFieldIdEnum {
      CONNECTION((short)1, "connection");

      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        switch(fieldId) {
          case 1: // CONNECTION
            return CONNECTION;
          default:
            return null;
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }

    // isset id assignments
    public static final Map<_Fields, org.apache.thrift.meta_data.FieldMetaData> metaDataMap;
    static {
      Map<_Fields, org.apache.thrift.meta_data.FieldMetaData> tmpMap = new EnumMap<_Fields, org.apache.thrift.meta_data.FieldMetaData>(_Fields.class);
      tmpMap.put(_Fields.CONNECTION, new org.apache.thrift.meta_data.FieldMetaData("connection", org.apache.thrift.TFieldRequirementType.DEFAULT, 
          new org.apache.thrift.meta_data.StructMetaData(org.apache.thrift.protocol.TType.STRUCT, RConnection.class)));
      metaDataMap = Collections.unmodifiableMap(tmpMap);
      org.apache.thrift.meta_data.FieldMetaData.addStructMetaDataMap(connection_getCatalogTerm_args.class, metaDataMap);
    }

    public connection_getCatalogTerm_args() {
    }

    public connection_getCatalogTerm_args(
      RConnection connection)
    {
      this();
      this.connection = connection;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public connection_getCatalogTerm_args(connection_getCatalogTerm_args other) {
      if (other.isSetConnection()) {
        this.connection = new RConnection(other.connection);
      }
    }

    public connection_getCatalogTerm_args deepCopy() {
      return new connection_getCatalogTerm_args(this);
    }

    @Override
    public void clear() {
      this.connection = null;
    }

    public RConnection getConnection() {
      return this.connection;
    }

    public connection_getCatalogTerm_args setConnection(RConnection connection) {
      this.connection = connection;
      return this;
    }

    public void unsetConnection() {
      this.connection = null;
    }

    /** Returns true if field connection is set (has been assigned a value) and false otherwise */
    public boolean isSetConnection() {
      return this.connection != null;
    }

    public void setConnectionIsSet(boolean value) {
      if (!value) {
        this.connection = null;
      }
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      case CONNECTION:
        if (value == null) {
          unsetConnection();
        } else {
          setConnection((RConnection)value);
        }
        break;

      }
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      case CONNECTION:
        return getConnection();

      }
      throw new IllegalStateException();
    }

    /** Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      if (field == null) {
        throw new IllegalArgumentException();
      }

      switch (field) {
      case CONNECTION:
        return isSetConnection();
      }
      throw new IllegalStateException();
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof connection_getCatalogTerm_args)
        return this.equals((connection_getCatalogTerm_args)that);
      return false;
    }

    public boolean equals(connection_getCatalogTerm_args that) {
      if (that == null)
        return false;

      boolean this_present_connection = true && this.isSetConnection();
      boolean that_present_connection = true && that.isSetConnection();
      if (this_present_connection || that_present_connection) {
        if (!(this_present_connection && that_present_connection))
          return false;
        if (!this.connection.equals(that.connection))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      List<Object> list = new ArrayList<Object>();

      boolean present_connection = true && (isSetConnection());
      list.add(present_connection);
      if (present_connection)
        list.add(connection);

      return list.hashCode();
    }

    @Override
    public int compareTo(connection_getCatalogTerm_args other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetConnection()).compareTo(other.isSetConnection());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetConnection()) {
        lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.connection, other.connection);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      return 0;
    }

    public _Fields fieldForId(int fieldId) {
      return _Fields.findByThriftId(fieldId);
    }

    public void read(org.apache.thrift.protocol.TProtocol iprot) throws org.apache.thrift.TException {
      schemes.get(iprot.getScheme()).getScheme().read(iprot, this);
    }

    public void write(org.apache.thrift.protocol.TProtocol oprot) throws org.apache.thrift.TException {
      schemes.get(oprot.getScheme()).getScheme().write(oprot, this);
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("connection_getCatalogTerm_args(");
      boolean first = true;

      sb.append("connection:");
      if (this.connection == null) {
        sb.append("null");
      } else {
        sb.append(this.connection);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws org.apache.thrift.TException {
      // check for required fields
      // check for sub-struct validity
      if (connection != null) {
        connection.validate();
      }
    }

    private void writeObject(java.io.ObjectOutputStream out) throws java.io.IOException {
      try {
        write(new org.apache.thrift.protocol.TCompactProtocol(new org.apache.thrift.transport.TIOStreamTransport(out)));
      } catch (org.apache.thrift.TException te) {
        throw new java.io.IOException(te);
      }
    }

    private void readObject(java.io.ObjectInputStream in) throws java.io.IOException, ClassNotFoundException {
      try {
        read(new org.apache.thrift.protocol.TCompactProtocol(new org.apache.thrift.transport.TIOStreamTransport(in)));
      } catch (org.apache.thrift.TException te) {
        throw new java.io.IOException(te);
      }
    }

    private static class connection_getCatalogTerm_argsStandardSchemeFactory implements SchemeFactory {
      public connection_getCatalogTerm_argsStandardScheme getScheme() {
        return new connection_getCatalogTerm_argsStandardScheme();
      }
    }

    private static class connection_getCatalogTerm_argsStandardScheme extends StandardScheme<connection_getCatalogTerm_args> {

      public void read(org.apache.thrift.protocol.TProtocol iprot, connection_getCatalogTerm_args struct) throws org.apache.thrift.TException {
        org.apache.thrift.protocol.TField schemeField;
        iprot.readStructBegin();
        while (true)
        {
          schemeField = iprot.readFieldBegin();
          if (schemeField.type == org.apache.thrift.protocol.TType.STOP) { 
            break;
          }
          switch (schemeField.id) {
            case 1: // CONNECTION
              if (schemeField.type == org.apache.thrift.protocol.TType.STRUCT) {
                struct.connection = new RConnection();
                struct.connection.read(iprot);
                struct.setConnectionIsSet(true);
              } else { 
                org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
              }
              break;
            default:
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
          }
          iprot.readFieldEnd();
        }
        iprot.readStructEnd();

        // check for required fields of primitive type, which can't be checked in the validate method
        struct.validate();
      }

      public void write(org.apache.thrift.protocol.TProtocol oprot, connection_getCatalogTerm_args struct) throws org.apache.thrift.TException {
        struct.validate();

        oprot.writeStructBegin(STRUCT_DESC);
        if (struct.connection != null) {
          oprot.writeFieldBegin(CONNECTION_FIELD_DESC);
          struct.connection.write(oprot);
          oprot.writeFieldEnd();
        }
        oprot.writeFieldStop();
        oprot.writeStructEnd();
      }

    }

    private static class connection_getCatalogTerm_argsTupleSchemeFactory implements SchemeFactory {
      public connection_getCatalogTerm_argsTupleScheme getScheme() {
        return new connection_getCatalogTerm_argsTupleScheme();
      }
    }

    private static class connection_getCatalogTerm_argsTupleScheme extends TupleScheme<connection_getCatalogTerm_args> {

      @Override
      public void write(org.apache.thrift.protocol.TProtocol prot, connection_getCatalogTerm_args struct) throws org.apache.thrift.TException {
        TTupleProtocol oprot = (TTupleProtocol) prot;
        BitSet optionals = new BitSet();
        if (struct.isSetConnection()) {
          optionals.set(0);
        }
        oprot.writeBitSet(optionals, 1);
        if (struct.isSetConnection()) {
          struct.connection.write(oprot);
        }
      }

      @Override
      public void read(org.apache.thrift.protocol.TProtocol prot, connection_getCatalogTerm_args struct) throws org.apache.thrift.TException {
        TTupleProtocol iprot = (TTupleProtocol) prot;
        BitSet incoming = iprot.readBitSet(1);
        if (incoming.get(0)) {
          struct.connection = new RConnection();
          struct.connection.read(iprot);
          struct.setConnectionIsSet(true);
        }
      }
    }

  }

  public static class connection_getCatalogTerm_result implements org.apache.thrift.TBase<connection_getCatalogTerm_result, connection_getCatalogTerm_result._Fields>, java.io.Serializable, Cloneable, Comparable<connection_getCatalogTerm_result>   {
    private static final org.apache.thrift.protocol.TStruct STRUCT_DESC = new org.apache.thrift.protocol.TStruct("connection_getCatalogTerm_result");

    private static final org.apache.thrift.protocol.TField SUCCESS_FIELD_DESC = new org.apache.thrift.protocol.TField("success", org.apache.thrift.protocol.TType.STRING, (short)0);
    private static final org.apache.thrift.protocol.TField SQL_EXCEPTION_FIELD_DESC = new org.apache.thrift.protocol.TField("sqlException", org.apache.thrift.protocol.TType.STRUCT, (short)1);

    private static final Map<Class<? extends IScheme>, SchemeFactory> schemes = new HashMap<Class<? extends IScheme>, SchemeFactory>();
    static {
      schemes.put(StandardScheme.class, new connection_getCatalogTerm_resultStandardSchemeFactory());
      schemes.put(TupleScheme.class, new connection_getCatalogTerm_resultTupleSchemeFactory());
    }

    public String success; // required
    public RSQLException sqlException; // required

    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements org.apache.thrift.TFieldIdEnum {
      SUCCESS((short)0, "success"),
      SQL_EXCEPTION((short)1, "sqlException");

      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        switch(fieldId) {
          case 0: // SUCCESS
            return SUCCESS;
          case 1: // SQL_EXCEPTION
            return SQL_EXCEPTION;
          default:
            return null;
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }

    // isset id assignments
    public static final Map<_Fields, org.apache.thrift.meta_data.FieldMetaData> metaDataMap;
    static {
      Map<_Fields, org.apache.thrift.meta_data.FieldMetaData> tmpMap = new EnumMap<_Fields, org.apache.thrift.meta_data.FieldMetaData>(_Fields.class);
      tmpMap.put(_Fields.SUCCESS, new org.apache.thrift.meta_data.FieldMetaData("success", org.apache.thrift.TFieldRequirementType.DEFAULT, 
          new org.apache.thrift.meta_data.FieldValueMetaData(org.apache.thrift.protocol.TType.STRING)));
      tmpMap.put(_Fields.SQL_EXCEPTION, new org.apache.thrift.meta_data.FieldMetaData("sqlException", org.apache.thrift.TFieldRequirementType.DEFAULT, 
          new org.apache.thrift.meta_data.FieldValueMetaData(org.apache.thrift.protocol.TType.STRUCT)));
      metaDataMap = Collections.unmodifiableMap(tmpMap);
      org.apache.thrift.meta_data.FieldMetaData.addStructMetaDataMap(connection_getCatalogTerm_result.class, metaDataMap);
    }

    public connection_getCatalogTerm_result() {
    }

    public connection_getCatalogTerm_result(
      String success,
      RSQLException sqlException)
    {
      this();
      this.success = success;
      this.sqlException = sqlException;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public connection_getCatalogTerm_result(connection_getCatalogTerm_result other) {
      if (other.isSetSuccess()) {
        this.success = other.success;
      }
      if (other.isSetSqlException()) {
        this.sqlException = new RSQLException(other.sqlException);
      }
    }

    public connection_getCatalogTerm_result deepCopy() {
      return new connection_getCatalogTerm_result(this);
    }

    @Override
    public void clear() {
      this.success = null;
      this.sqlException = null;
    }

    public String getSuccess() {
      return this.success;
    }

    public connection_getCatalogTerm_result setSuccess(String success) {
      this.success = success;
      return this;
    }

    public void unsetSuccess() {
      this.success = null;
    }

    /** Returns true if field success is set (has been assigned a value) and false otherwise */
    public boolean isSetSuccess() {
      return this.success != null;
    }

    public void setSuccessIsSet(boolean value) {
      if (!value) {
        this.success = null;
      }
    }

    public RSQLException getSqlException() {
      return this.sqlException;
    }

    public connection_getCatalogTerm_result setSqlException(RSQLException sqlException) {
      this.sqlException = sqlException;
      return this;
    }

    public void unsetSqlException() {
      this.sqlException = null;
    }

    /** Returns true if field sqlException is set (has been assigned a value) and false otherwise */
    public boolean isSetSqlException() {
      return this.sqlException != null;
    }

    public void setSqlExceptionIsSet(boolean value) {
      if (!value) {
        this.sqlException = null;
      }
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          setSuccess((String)value);
        }
        break;

      case SQL_EXCEPTION:
        if (value == null) {
          unsetSqlException();
        } else {
          setSqlException((RSQLException)value);
        }
        break;

      }
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      case SUCCESS:
        return getSuccess();

      case SQL_EXCEPTION:
        return getSqlException();

      }
      throw new IllegalStateException();
    }

    /** Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      if (field == null) {
        throw new IllegalArgumentException();
      }

      switch (field) {
      case SUCCESS:
        return isSetSuccess();
      case SQL_EXCEPTION:
        return isSetSqlException();
      }
      throw new IllegalStateException();
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof connection_getCatalogTerm_result)
        return this.equals((connection_getCatalogTerm_result)that);
      return false;
    }

    public boolean equals(connection_getCatalogTerm_result that) {
      if (that == null)
        return false;

      boolean this_present_success = true && this.isSetSuccess();
      boolean that_present_success = true && that.isSetSuccess();
      if (this_present_success || that_present_success) {
        if (!(this_present_success && that_present_success))
          return false;
        if (!this.success.equals(that.success))
          return false;
      }

      boolean this_present_sqlException = true && this.isSetSqlException();
      boolean that_present_sqlException = true && that.isSetSqlException();
      if (this_present_sqlException || that_present_sqlException) {
        if (!(this_present_sqlException && that_present_sqlException))
          return false;
        if (!this.sqlException.equals(that.sqlException))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      List<Object> list = new ArrayList<Object>();

      boolean present_success = true && (isSetSuccess());
      list.add(present_success);
      if (present_success)
        list.add(success);

      boolean present_sqlException = true && (isSetSqlException());
      list.add(present_sqlException);
      if (present_sqlException)
        list.add(sqlException);

      return list.hashCode();
    }

    @Override
    public int compareTo(connection_getCatalogTerm_result other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetSuccess()).compareTo(other.isSetSuccess());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetSuccess()) {
        lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.success, other.success);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      lastComparison = Boolean.valueOf(isSetSqlException()).compareTo(other.isSetSqlException());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetSqlException()) {
        lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.sqlException, other.sqlException);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      return 0;
    }

    public _Fields fieldForId(int fieldId) {
      return _Fields.findByThriftId(fieldId);
    }

    public void read(org.apache.thrift.protocol.TProtocol iprot) throws org.apache.thrift.TException {
      schemes.get(iprot.getScheme()).getScheme().read(iprot, this);
    }

    public void write(org.apache.thrift.protocol.TProtocol oprot) throws org.apache.thrift.TException {
      schemes.get(oprot.getScheme()).getScheme().write(oprot, this);
      }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("connection_getCatalogTerm_result(");
      boolean first = true;

      sb.append("success:");
      if (this.success == null) {
        sb.append("null");
      } else {
        sb.append(this.success);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("sqlException:");
      if (this.sqlException == null) {
        sb.append("null");
      } else {
        sb.append(this.sqlException);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws org.apache.thrift.TException {
      // check for required fields
      // check for sub-struct validity
    }

    private void writeObject(java.io.ObjectOutputStream out) throws java.io.IOException {
      try {
        write(new org.apache.thrift.protocol.TCompactProtocol(new org.apache.thrift.transport.TIOStreamTransport(out)));
      } catch (org.apache.thrift.TException te) {
        throw new java.io.IOException(te);
      }
    }

    private void readObject(java.io.ObjectInputStream in) throws java.io.IOException, ClassNotFoundException {
      try {
        read(new org.apache.thrift.protocol.TCompactProtocol(new org.apache.thrift.transport.TIOStreamTransport(in)));
      } catch (org.apache.thrift.TException te) {
        throw new java.io.IOException(te);
      }
    }

    private static class connection_getCatalogTerm_resultStandardSchemeFactory implements SchemeFactory {
      public connection_getCatalogTerm_resultStandardScheme getScheme() {
        return new connection_getCatalogTerm_resultStandardScheme();
      }
    }

    private static class connection_getCatalogTerm_resultStandardScheme extends StandardScheme<connection_getCatalogTerm_result> {

      public void read(org.apache.thrift.protocol.TProtocol iprot, connection_getCatalogTerm_result struct) throws org.apache.thrift.TException {
        org.apache.thrift.protocol.TField schemeField;
        iprot.readStructBegin();
        while (true)
        {
          schemeField = iprot.readFieldBegin();
          if (schemeField.type == org.apache.thrift.protocol.TType.STOP) { 
            break;
          }
          switch (schemeField.id) {
            case 0: // SUCCESS
              if (schemeField.type == org.apache.thrift.protocol.TType.STRING) {
                struct.success = iprot.readString();
                struct.setSuccessIsSet(true);
              } else { 
                org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
              }
              break;
            case 1: // SQL_EXCEPTION
              if (schemeField.type == org.apache.thrift.protocol.TType.STRUCT) {
                struct.sqlException = new RSQLException();
                struct.sqlException.read(iprot);
                struct.setSqlExceptionIsSet(true);
              } else { 
                org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
              }
              break;
            default:
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
          }
          iprot.readFieldEnd();
        }
        iprot.readStructEnd();

        // check for required fields of primitive type, which can't be checked in the validate method
        struct.validate();
      }

      public void write(org.apache.thrift.protocol.TProtocol oprot, connection_getCatalogTerm_result struct) throws org.apache.thrift.TException {
        struct.validate();

        oprot.writeStructBegin(STRUCT_DESC);
        if (struct.success != null) {
          oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
          oprot.writeString(struct.success);
          oprot.writeFieldEnd();
        }
        if (struct.sqlException != null) {
          oprot.writeFieldBegin(SQL_EXCEPTION_FIELD_DESC);
          struct.sqlException.write(oprot);
          oprot.writeFieldEnd();
        }
        oprot.writeFieldStop();
        oprot.writeStructEnd();
      }

    }

    private static class connection_getCatalogTerm_resultTupleSchemeFactory implements SchemeFactory {
      public connection_getCatalogTerm_resultTupleScheme getScheme() {
        return new connection_getCatalogTerm_resultTupleScheme();
      }
    }

    private static class connection_getCatalogTerm_resultTupleScheme extends TupleScheme<connection_getCatalogTerm_result> {

      @Override
      public void write(org.apache.thrift.protocol.TProtocol prot, connection_getCatalogTerm_result struct) throws org.apache.thrift.TException {
        TTupleProtocol oprot = (TTupleProtocol) prot;
        BitSet optionals = new BitSet();
        if (struct.isSetSuccess()) {
          optionals.set(0);
        }
        if (struct.isSetSqlException()) {
          optionals.set(1);
        }
        oprot.writeBitSet(optionals, 2);
        if (struct.isSetSuccess()) {
          oprot.writeString(struct.success);
        }
        if (struct.isSetSqlException()) {
          struct.sqlException.write(oprot);
        }
      }

      @Override
      public void read(org.apache.thrift.protocol.TProtocol prot, connection_getCatalogTerm_result struct) throws org.apache.thrift.TException {
        TTupleProtocol iprot = (TTupleProtocol) prot;
        BitSet incoming = iprot.readBitSet(2);
        if (incoming.get(0)) {
          struct.success = iprot.readString();
          struct.setSuccessIsSet(true);
        }
        if (incoming.get(1)) {
          struct.sqlException = new RSQLException();
          struct.sqlException.read(iprot);
          struct.setSqlExceptionIsSet(true);
        }
      }
    }

  }

  public static class connection_getSchemaTerm_args implements org.apache.thrift.TBase<connection_getSchemaTerm_args, connection_getSchemaTerm_args._Fields>, java.io.Serializable, Cloneable, Comparable<connection_getSchemaTerm_args>   {
    private static final org.apache.thrift.protocol.TStruct STRUCT_DESC = new org.apache.thrift.protocol.TStruct("connection_getSchemaTerm_args");

    private static final org.apache.thrift.protocol.TField CONNECTION_FIELD_DESC = new org.apache.thrift.protocol.TField("connection", org.apache.thrift.protocol.TType.STRUCT, (short)1);

    private static final Map<Class<? extends IScheme>, SchemeFactory> schemes = new HashMap<Class<? extends IScheme>, SchemeFactory>();
    static {
      schemes.put(StandardScheme.class, new connection_getSchemaTerm_argsStandardSchemeFactory());
      schemes.put(TupleScheme.class, new connection_getSchemaTerm_argsTupleSchemeFactory());
    }

    public RConnection connection; // required

    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements org.apache.thrift.TFieldIdEnum {
      CONNECTION((short)1, "connection");

      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        switch(fieldId) {
          case 1: // CONNECTION
            return CONNECTION;
          default:
            return null;
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }

    // isset id assignments
    public static final Map<_Fields, org.apache.thrift.meta_data.FieldMetaData> metaDataMap;
    static {
      Map<_Fields, org.apache.thrift.meta_data.FieldMetaData> tmpMap = new EnumMap<_Fields, org.apache.thrift.meta_data.FieldMetaData>(_Fields.class);
      tmpMap.put(_Fields.CONNECTION, new org.apache.thrift.meta_data.FieldMetaData("connection", org.apache.thrift.TFieldRequirementType.DEFAULT, 
          new org.apache.thrift.meta_data.StructMetaData(org.apache.thrift.protocol.TType.STRUCT, RConnection.class)));
      metaDataMap = Collections.unmodifiableMap(tmpMap);
      org.apache.thrift.meta_data.FieldMetaData.addStructMetaDataMap(connection_getSchemaTerm_args.class, metaDataMap);
    }

    public connection_getSchemaTerm_args() {
    }

    public connection_getSchemaTerm_args(
      RConnection connection)
    {
      this();
      this.connection = connection;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public connection_getSchemaTerm_args(connection_getSchemaTerm_args other) {
      if (other.isSetConnection()) {
        this.connection = new RConnection(other.connection);
      }
    }

    public connection_getSchemaTerm_args deepCopy() {
      return new connection_getSchemaTerm_args(this);
    }

    @Override
    public void clear() {
      this.connection = null;
    }

    public RConnection getConnection() {
      return this.connection;
    }

    public connection_getSchemaTerm_args setConnection(RConnection connection) {
      this.connection = connection;
      return this;
    }

    public void unsetConnection() {
      this.connection = null;
    }

    /** Returns true if field connection is set (has been assigned a value) and false otherwise */
    public boolean isSetConnection() {
      return this.connection != null;
    }

    public void setConnectionIsSet(boolean value) {
      if (!value) {
        this.connection = null;
      }
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      case CONNECTION:
        if (value == null) {
          unsetConnection();
        } else {
          setConnection((RConnection)value);
        }
        break;

      }
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      case CONNECTION:
        return getConnection();

      }
      throw new IllegalStateException();
    }

    /** Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      if (field == null) {
        throw new IllegalArgumentException();
      }

      switch (field) {
      case CONNECTION:
        return isSetConnection();
      }
      throw new IllegalStateException();
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof connection_getSchemaTerm_args)
        return this.equals((connection_getSchemaTerm_args)that);
      return false;
    }

    public boolean equals(connection_getSchemaTerm_args that) {
      if (that == null)
        return false;

      boolean this_present_connection = true && this.isSetConnection();
      boolean that_present_connection = true && that.isSetConnection();
      if (this_present_connection || that_present_connection) {
        if (!(this_present_connection && that_present_connection))
          return false;
        if (!this.connection.equals(that.connection))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      List<Object> list = new ArrayList<Object>();

      boolean present_connection = true && (isSetConnection());
      list.add(present_connection);
      if (present_connection)
        list.add(connection);

      return list.hashCode();
    }

    @Override
    public int compareTo(connection_getSchemaTerm_args other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetConnection()).compareTo(other.isSetConnection());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetConnection()) {
        lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.connection, other.connection);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      return 0;
    }

    public _Fields fieldForId(int fieldId) {
      return _Fields.findByThriftId(fieldId);
    }

    public void read(org.apache.thrift.protocol.TProtocol iprot) throws org.apache.thrift.TException {
      schemes.get(iprot.getScheme()).getScheme().read(iprot, this);
    }

    public void write(org.apache.thrift.protocol.TProtocol oprot) throws org.apache.thrift.TException {
      schemes.get(oprot.getScheme()).getScheme().write(oprot, this);
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("connection_getSchemaTerm_args(");
      boolean first = true;

      sb.append("connection:");
      if (this.connection == null) {
        sb.append("null");
      } else {
        sb.append(this.connection);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws org.apache.thrift.TException {
      // check for required fields
      // check for sub-struct validity
      if (connection != null) {
        connection.validate();
      }
    }

    private void writeObject(java.io.ObjectOutputStream out) throws java.io.IOException {
      try {
        write(new org.apache.thrift.protocol.TCompactProtocol(new org.apache.thrift.transport.TIOStreamTransport(out)));
      } catch (org.apache.thrift.TException te) {
        throw new java.io.IOException(te);
      }
    }

    private void readObject(java.io.ObjectInputStream in) throws java.io.IOException, ClassNotFoundException {
      try {
        read(new org.apache.thrift.protocol.TCompactProtocol(new org.apache.thrift.transport.TIOStreamTransport(in)));
      } catch (org.apache.thrift.TException te) {
        throw new java.io.IOException(te);
      }
    }

    private static class connection_getSchemaTerm_argsStandardSchemeFactory implements SchemeFactory {
      public connection_getSchemaTerm_argsStandardScheme getScheme() {
        return new connection_getSchemaTerm_argsStandardScheme();
      }
    }

    private static class connection_getSchemaTerm_argsStandardScheme extends StandardScheme<connection_getSchemaTerm_args> {

      public void read(org.apache.thrift.protocol.TProtocol iprot, connection_getSchemaTerm_args struct) throws org.apache.thrift.TException {
        org.apache.thrift.protocol.TField schemeField;
        iprot.readStructBegin();
        while (true)
        {
          schemeField = iprot.readFieldBegin();
          if (schemeField.type == org.apache.thrift.protocol.TType.STOP) { 
            break;
          }
          switch (schemeField.id) {
            case 1: // CONNECTION
              if (schemeField.type == org.apache.thrift.protocol.TType.STRUCT) {
                struct.connection = new RConnection();
                struct.connection.read(iprot);
                struct.setConnectionIsSet(true);
              } else { 
                org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
              }
              break;
            default:
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
          }
          iprot.readFieldEnd();
        }
        iprot.readStructEnd();

        // check for required fields of primitive type, which can't be checked in the validate method
        struct.validate();
      }

      public void write(org.apache.thrift.protocol.TProtocol oprot, connection_getSchemaTerm_args struct) throws org.apache.thrift.TException {
        struct.validate();

        oprot.writeStructBegin(STRUCT_DESC);
        if (struct.connection != null) {
          oprot.writeFieldBegin(CONNECTION_FIELD_DESC);
          struct.connection.write(oprot);
          oprot.writeFieldEnd();
        }
        oprot.writeFieldStop();
        oprot.writeStructEnd();
      }

    }

    private static class connection_getSchemaTerm_argsTupleSchemeFactory implements SchemeFactory {
      public connection_getSchemaTerm_argsTupleScheme getScheme() {
        return new connection_getSchemaTerm_argsTupleScheme();
      }
    }

    private static class connection_getSchemaTerm_argsTupleScheme extends TupleScheme<connection_getSchemaTerm_args> {

      @Override
      public void write(org.apache.thrift.protocol.TProtocol prot, connection_getSchemaTerm_args struct) throws org.apache.thrift.TException {
        TTupleProtocol oprot = (TTupleProtocol) prot;
        BitSet optionals = new BitSet();
        if (struct.isSetConnection()) {
          optionals.set(0);
        }
        oprot.writeBitSet(optionals, 1);
        if (struct.isSetConnection()) {
          struct.connection.write(oprot);
        }
      }

      @Override
      public void read(org.apache.thrift.protocol.TProtocol prot, connection_getSchemaTerm_args struct) throws org.apache.thrift.TException {
        TTupleProtocol iprot = (TTupleProtocol) prot;
        BitSet incoming = iprot.readBitSet(1);
        if (incoming.get(0)) {
          struct.connection = new RConnection();
          struct.connection.read(iprot);
          struct.setConnectionIsSet(true);
        }
      }
    }

  }

  public static class connection_getSchemaTerm_result implements org.apache.thrift.TBase<connection_getSchemaTerm_result, connection_getSchemaTerm_result._Fields>, java.io.Serializable, Cloneable, Comparable<connection_getSchemaTerm_result>   {
    private static final org.apache.thrift.protocol.TStruct STRUCT_DESC = new org.apache.thrift.protocol.TStruct("connection_getSchemaTerm_result");

    private static final org.apache.thrift.protocol.TField SUCCESS_FIELD_DESC = new org.apache.thrift.protocol.TField("success", org.apache.thrift.protocol.TType.STRING, (short)0);
    private static final org.apache.thrift.protocol.TField SQL_EXCEPTION_FIELD_DESC = new org.apache.thrift.protocol.TField("sqlException", org.apache.thrift.protocol.TType.STRUCT, (short)1);

    private static final Map<Class<? extends IScheme>, SchemeFactory> schemes = new HashMap<Class<? extends IScheme>, SchemeFactory>();
    static {
      schemes.put(StandardScheme.class, new connection_getSchemaTerm_resultStandardSchemeFactory());
      schemes.put(TupleScheme.class, new connection_getSchemaTerm_resultTupleSchemeFactory());
    }

    public String success; // required
    public RSQLException sqlException; // required

    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements org.apache.thrift.TFieldIdEnum {
      SUCCESS((short)0, "success"),
      SQL_EXCEPTION((short)1, "sqlException");

      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        switch(fieldId) {
          case 0: // SUCCESS
            return SUCCESS;
          case 1: // SQL_EXCEPTION
            return SQL_EXCEPTION;
          default:
            return null;
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }

    // isset id assignments
    public static final Map<_Fields, org.apache.thrift.meta_data.FieldMetaData> metaDataMap;
    static {
      Map<_Fields, org.apache.thrift.meta_data.FieldMetaData> tmpMap = new EnumMap<_Fields, org.apache.thrift.meta_data.FieldMetaData>(_Fields.class);
      tmpMap.put(_Fields.SUCCESS, new org.apache.thrift.meta_data.FieldMetaData("success", org.apache.thrift.TFieldRequirementType.DEFAULT, 
          new org.apache.thrift.meta_data.FieldValueMetaData(org.apache.thrift.protocol.TType.STRING)));
      tmpMap.put(_Fields.SQL_EXCEPTION, new org.apache.thrift.meta_data.FieldMetaData("sqlException", org.apache.thrift.TFieldRequirementType.DEFAULT, 
          new org.apache.thrift.meta_data.FieldValueMetaData(org.apache.thrift.protocol.TType.STRUCT)));
      metaDataMap = Collections.unmodifiableMap(tmpMap);
      org.apache.thrift.meta_data.FieldMetaData.addStructMetaDataMap(connection_getSchemaTerm_result.class, metaDataMap);
    }

    public connection_getSchemaTerm_result() {
    }

    public connection_getSchemaTerm_result(
      String success,
      RSQLException sqlException)
    {
      this();
      this.success = success;
      this.sqlException = sqlException;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public connection_getSchemaTerm_result(connection_getSchemaTerm_result other) {
      if (other.isSetSuccess()) {
        this.success = other.success;
      }
      if (other.isSetSqlException()) {
        this.sqlException = new RSQLException(other.sqlException);
      }
    }

    public connection_getSchemaTerm_result deepCopy() {
      return new connection_getSchemaTerm_result(this);
    }

    @Override
    public void clear() {
      this.success = null;
      this.sqlException = null;
    }

    public String getSuccess() {
      return this.success;
    }

    public connection_getSchemaTerm_result setSuccess(String success) {
      this.success = success;
      return this;
    }

    public void unsetSuccess() {
      this.success = null;
    }

    /** Returns true if field success is set (has been assigned a value) and false otherwise */
    public boolean isSetSuccess() {
      return this.success != null;
    }

    public void setSuccessIsSet(boolean value) {
      if (!value) {
        this.success = null;
      }
    }

    public RSQLException getSqlException() {
      return this.sqlException;
    }

    public connection_getSchemaTerm_result setSqlException(RSQLException sqlException) {
      this.sqlException = sqlException;
      return this;
    }

    public void unsetSqlException() {
      this.sqlException = null;
    }

    /** Returns true if field sqlException is set (has been assigned a value) and false otherwise */
    public boolean isSetSqlException() {
      return this.sqlException != null;
    }

    public void setSqlExceptionIsSet(boolean value) {
      if (!value) {
        this.sqlException = null;
      }
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          setSuccess((String)value);
        }
        break;

      case SQL_EXCEPTION:
        if (value == null) {
          unsetSqlException();
        } else {
          setSqlException((RSQLException)value);
        }
        break;

      }
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      case SUCCESS:
        return getSuccess();

      case SQL_EXCEPTION:
        return getSqlException();

      }
      throw new IllegalStateException();
    }

    /** Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      if (field == null) {
        throw new IllegalArgumentException();
      }

      switch (field) {
      case SUCCESS:
        return isSetSuccess();
      case SQL_EXCEPTION:
        return isSetSqlException();
      }
      throw new IllegalStateException();
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof connection_getSchemaTerm_result)
        return this.equals((connection_getSchemaTerm_result)that);
      return false;
    }

    public boolean equals(connection_getSchemaTerm_result that) {
      if (that == null)
        return false;

      boolean this_present_success = true && this.isSetSuccess();
      boolean that_present_success = true && that.isSetSuccess();
      if (this_present_success || that_present_success) {
        if (!(this_present_success && that_present_success))
          return false;
        if (!this.success.equals(that.success))
          return false;
      }

      boolean this_present_sqlException = true && this.isSetSqlException();
      boolean that_present_sqlException = true && that.isSetSqlException();
      if (this_present_sqlException || that_present_sqlException) {
        if (!(this_present_sqlException && that_present_sqlException))
          return false;
        if (!this.sqlException.equals(that.sqlException))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      List<Object> list = new ArrayList<Object>();

      boolean present_success = true && (isSetSuccess());
      list.add(present_success);
      if (present_success)
        list.add(success);

      boolean present_sqlException = true && (isSetSqlException());
      list.add(present_sqlException);
      if (present_sqlException)
        list.add(sqlException);

      return list.hashCode();
    }

    @Override
    public int compareTo(connection_getSchemaTerm_result other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetSuccess()).compareTo(other.isSetSuccess());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetSuccess()) {
        lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.success, other.success);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      lastComparison = Boolean.valueOf(isSetSqlException()).compareTo(other.isSetSqlException());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetSqlException()) {
        lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.sqlException, other.sqlException);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      return 0;
    }

    public _Fields fieldForId(int fieldId) {
      return _Fields.findByThriftId(fieldId);
    }

    public void read(org.apache.thrift.protocol.TProtocol iprot) throws org.apache.thrift.TException {
      schemes.get(iprot.getScheme()).getScheme().read(iprot, this);
    }

    public void write(org.apache.thrift.protocol.TProtocol oprot) throws org.apache.thrift.TException {
      schemes.get(oprot.getScheme()).getScheme().write(oprot, this);
      }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("connection_getSchemaTerm_result(");
      boolean first = true;

      sb.append("success:");
      if (this.success == null) {
        sb.append("null");
      } else {
        sb.append(this.success);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("sqlException:");
      if (this.sqlException == null) {
        sb.append("null");
      } else {
        sb.append(this.sqlException);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws org.apache.thrift.TException {
      // check for required fields
      // check for sub-struct validity
    }

    private void writeObject(java.io.ObjectOutputStream out) throws java.io.IOException {
      try {
        write(new org.apache.thrift.protocol.TCompactProtocol(new org.apache.thrift.transport.TIOStreamTransport(out)));
      } catch (org.apache.thrift.TException te) {
        throw new java.io.IOException(te);
      }
    }

    private void readObject(java.io.ObjectInputStream in) throws java.io.IOException, ClassNotFoundException {
      try {
        read(new org.apache.thrift.protocol.TCompactProtocol(new org.apache.thrift.transport.TIOStreamTransport(in)));
      } catch (org.apache.thrift.TException te) {
        throw new java.io.IOException(te);
      }
    }

    private static class connection_getSchemaTerm_resultStandardSchemeFactory implements SchemeFactory {
      public connection_getSchemaTerm_resultStandardScheme getScheme() {
        return new connection_getSchemaTerm_resultStandardScheme();
      }
    }

    private static class connection_getSchemaTerm_resultStandardScheme extends StandardScheme<connection_getSchemaTerm_result> {

      public void read(org.apache.thrift.protocol.TProtocol iprot, connection_getSchemaTerm_result struct) throws org.apache.thrift.TException {
        org.apache.thrift.protocol.TField schemeField;
        iprot.readStructBegin();
        while (true)
        {
          schemeField = iprot.readFieldBegin();
          if (schemeField.type == org.apache.thrift.protocol.TType.STOP) { 
            break;
          }
          switch (schemeField.id) {
            case 0: // SUCCESS
              if (schemeField.type == org.apache.thrift.protocol.TType.STRING) {
                struct.success = iprot.readString();
                struct.setSuccessIsSet(true);
              } else { 
                org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
              }
              break;
            case 1: // SQL_EXCEPTION
              if (schemeField.type == org.apache.thrift.protocol.TType.STRUCT) {
                struct.sqlException = new RSQLException();
                struct.sqlException.read(iprot);
                struct.setSqlExceptionIsSet(true);
              } else { 
                org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
              }
              break;
            default:
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
          }
          iprot.readFieldEnd();
        }
        iprot.readStructEnd();

        // check for required fields of primitive type, which can't be checked in the validate method
        struct.validate();
      }

      public void write(org.apache.thrift.protocol.TProtocol oprot, connection_getSchemaTerm_result struct) throws org.apache.thrift.TException {
        struct.validate();

        oprot.writeStructBegin(STRUCT_DESC);
        if (struct.success != null) {
          oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
          oprot.writeString(struct.success);
          oprot.writeFieldEnd();
        }
        if (struct.sqlException != null) {
          oprot.writeFieldBegin(SQL_EXCEPTION_FIELD_DESC);
          struct.sqlException.write(oprot);
          oprot.writeFieldEnd();
        }
        oprot.writeFieldStop();
        oprot.writeStructEnd();
      }

    }

    private static class connection_getSchemaTerm_resultTupleSchemeFactory implements SchemeFactory {
      public connection_getSchemaTerm_resultTupleScheme getScheme() {
        return new connection_getSchemaTerm_resultTupleScheme();
      }
    }

    private static class connection_getSchemaTerm_resultTupleScheme extends TupleScheme<connection_getSchemaTerm_result> {

      @Override
      public void write(org.apache.thrift.protocol.TProtocol prot, connection_getSchemaTerm_result struct) throws org.apache.thrift.TException {
        TTupleProtocol oprot = (TTupleProtocol) prot;
        BitSet optionals = new BitSet();
        if (struct.isSetSuccess()) {
          optionals.set(0);
        }
        if (struct.isSetSqlException()) {
          optionals.set(1);
        }
        oprot.writeBitSet(optionals, 2);
        if (struct.isSetSuccess()) {
          oprot.writeString(struct.success);
        }
        if (struct.isSetSqlException()) {
          struct.sqlException.write(oprot);
        }
      }

      @Override
      public void read(org.apache.thrift.protocol.TProtocol prot, connection_getSchemaTerm_result struct) throws org.apache.thrift.TException {
        TTupleProtocol iprot = (TTupleProtocol) prot;
        BitSet incoming = iprot.readBitSet(2);
        if (incoming.get(0)) {
          struct.success = iprot.readString();
          struct.setSuccessIsSet(true);
        }
        if (incoming.get(1)) {
          struct.sqlException = new RSQLException();
          struct.sqlException.read(iprot);
          struct.setSqlExceptionIsSet(true);
        }
      }
    }

  }

  public static class connection_getCatalogs_args implements org.apache.thrift.TBase<connection_getCatalogs_args, connection_getCatalogs_args._Fields>, java.io.Serializable, Cloneable, Comparable<connection_getCatalogs_args>   {
    private static final org.apache.thrift.protocol.TStruct STRUCT_DESC = new org.apache.thrift.protocol.TStruct("connection_getCatalogs_args");

    private static final org.apache.thrift.protocol.TField CONNECTION_FIELD_DESC = new org.apache.thrift.protocol.TField("connection", org.apache.thrift.protocol.TType.STRUCT, (short)1);

    private static final Map<Class<? extends IScheme>, SchemeFactory> schemes = new HashMap<Class<? extends IScheme>, SchemeFactory>();
    static {
      schemes.put(StandardScheme.class, new connection_getCatalogs_argsStandardSchemeFactory());
      schemes.put(TupleScheme.class, new connection_getCatalogs_argsTupleSchemeFactory());
    }

    public RConnection connection; // required

    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements org.apache.thrift.TFieldIdEnum {
      CONNECTION((short)1, "connection");

      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        switch(fieldId) {
          case 1: // CONNECTION
            return CONNECTION;
          default:
            return null;
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }

    // isset id assignments
    public static final Map<_Fields, org.apache.thrift.meta_data.FieldMetaData> metaDataMap;
    static {
      Map<_Fields, org.apache.thrift.meta_data.FieldMetaData> tmpMap = new EnumMap<_Fields, org.apache.thrift.meta_data.FieldMetaData>(_Fields.class);
      tmpMap.put(_Fields.CONNECTION, new org.apache.thrift.meta_data.FieldMetaData("connection", org.apache.thrift.TFieldRequirementType.DEFAULT, 
          new org.apache.thrift.meta_data.StructMetaData(org.apache.thrift.protocol.TType.STRUCT, RConnection.class)));
      metaDataMap = Collections.unmodifiableMap(tmpMap);
      org.apache.thrift.meta_data.FieldMetaData.addStructMetaDataMap(connection_getCatalogs_args.class, metaDataMap);
    }

    public connection_getCatalogs_args() {
    }

    public connection_getCatalogs_args(
      RConnection connection)
    {
      this();
      this.connection = connection;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public connection_getCatalogs_args(connection_getCatalogs_args other) {
      if (other.isSetConnection()) {
        this.connection = new RConnection(other.connection);
      }
    }

    public connection_getCatalogs_args deepCopy() {
      return new connection_getCatalogs_args(this);
    }

    @Override
    public void clear() {
      this.connection = null;
    }

    public RConnection getConnection() {
      return this.connection;
    }

    public connection_getCatalogs_args setConnection(RConnection connection) {
      this.connection = connection;
      return this;
    }

    public void unsetConnection() {
      this.connection = null;
    }

    /** Returns true if field connection is set (has been assigned a value) and false otherwise */
    public boolean isSetConnection() {
      return this.connection != null;
    }

    public void setConnectionIsSet(boolean value) {
      if (!value) {
        this.connection = null;
      }
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      case CONNECTION:
        if (value == null) {
          unsetConnection();
        } else {
          setConnection((RConnection)value);
        }
        break;

      }
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      case CONNECTION:
        return getConnection();

      }
      throw new IllegalStateException();
    }

    /** Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      if (field == null) {
        throw new IllegalArgumentException();
      }

      switch (field) {
      case CONNECTION:
        return isSetConnection();
      }
      throw new IllegalStateException();
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof connection_getCatalogs_args)
        return this.equals((connection_getCatalogs_args)that);
      return false;
    }

    public boolean equals(connection_getCatalogs_args that) {
      if (that == null)
        return false;

      boolean this_present_connection = true && this.isSetConnection();
      boolean that_present_connection = true && that.isSetConnection();
      if (this_present_connection || that_present_connection) {
        if (!(this_present_connection && that_present_connection))
          return false;
        if (!this.connection.equals(that.connection))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      List<Object> list = new ArrayList<Object>();

      boolean present_connection = true && (isSetConnection());
      list.add(present_connection);
      if (present_connection)
        list.add(connection);

      return list.hashCode();
    }

    @Override
    public int compareTo(connection_getCatalogs_args other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetConnection()).compareTo(other.isSetConnection());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetConnection()) {
        lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.connection, other.connection);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      return 0;
    }

    public _Fields fieldForId(int fieldId) {
      return _Fields.findByThriftId(fieldId);
    }

    public void read(org.apache.thrift.protocol.TProtocol iprot) throws org.apache.thrift.TException {
      schemes.get(iprot.getScheme()).getScheme().read(iprot, this);
    }

    public void write(org.apache.thrift.protocol.TProtocol oprot) throws org.apache.thrift.TException {
      schemes.get(oprot.getScheme()).getScheme().write(oprot, this);
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("connection_getCatalogs_args(");
      boolean first = true;

      sb.append("connection:");
      if (this.connection == null) {
        sb.append("null");
      } else {
        sb.append(this.connection);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws org.apache.thrift.TException {
      // check for required fields
      // check for sub-struct validity
      if (connection != null) {
        connection.validate();
      }
    }

    private void writeObject(java.io.ObjectOutputStream out) throws java.io.IOException {
      try {
        write(new org.apache.thrift.protocol.TCompactProtocol(new org.apache.thrift.transport.TIOStreamTransport(out)));
      } catch (org.apache.thrift.TException te) {
        throw new java.io.IOException(te);
      }
    }

    private void readObject(java.io.ObjectInputStream in) throws java.io.IOException, ClassNotFoundException {
      try {
        read(new org.apache.thrift.protocol.TCompactProtocol(new org.apache.thrift.transport.TIOStreamTransport(in)));
      } catch (org.apache.thrift.TException te) {
        throw new java.io.IOException(te);
      }
    }

    private static class connection_getCatalogs_argsStandardSchemeFactory implements SchemeFactory {
      public connection_getCatalogs_argsStandardScheme getScheme() {
        return new connection_getCatalogs_argsStandardScheme();
      }
    }

    private static class connection_getCatalogs_argsStandardScheme extends StandardScheme<connection_getCatalogs_args> {

      public void read(org.apache.thrift.protocol.TProtocol iprot, connection_getCatalogs_args struct) throws org.apache.thrift.TException {
        org.apache.thrift.protocol.TField schemeField;
        iprot.readStructBegin();
        while (true)
        {
          schemeField = iprot.readFieldBegin();
          if (schemeField.type == org.apache.thrift.protocol.TType.STOP) { 
            break;
          }
          switch (schemeField.id) {
            case 1: // CONNECTION
              if (schemeField.type == org.apache.thrift.protocol.TType.STRUCT) {
                struct.connection = new RConnection();
                struct.connection.read(iprot);
                struct.setConnectionIsSet(true);
              } else { 
                org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
              }
              break;
            default:
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
          }
          iprot.readFieldEnd();
        }
        iprot.readStructEnd();

        // check for required fields of primitive type, which can't be checked in the validate method
        struct.validate();
      }

      public void write(org.apache.thrift.protocol.TProtocol oprot, connection_getCatalogs_args struct) throws org.apache.thrift.TException {
        struct.validate();

        oprot.writeStructBegin(STRUCT_DESC);
        if (struct.connection != null) {
          oprot.writeFieldBegin(CONNECTION_FIELD_DESC);
          struct.connection.write(oprot);
          oprot.writeFieldEnd();
        }
        oprot.writeFieldStop();
        oprot.writeStructEnd();
      }

    }

    private static class connection_getCatalogs_argsTupleSchemeFactory implements SchemeFactory {
      public connection_getCatalogs_argsTupleScheme getScheme() {
        return new connection_getCatalogs_argsTupleScheme();
      }
    }

    private static class connection_getCatalogs_argsTupleScheme extends TupleScheme<connection_getCatalogs_args> {

      @Override
      public void write(org.apache.thrift.protocol.TProtocol prot, connection_getCatalogs_args struct) throws org.apache.thrift.TException {
        TTupleProtocol oprot = (TTupleProtocol) prot;
        BitSet optionals = new BitSet();
        if (struct.isSetConnection()) {
          optionals.set(0);
        }
        oprot.writeBitSet(optionals, 1);
        if (struct.isSetConnection()) {
          struct.connection.write(oprot);
        }
      }

      @Override
      public void read(org.apache.thrift.protocol.TProtocol prot, connection_getCatalogs_args struct) throws org.apache.thrift.TException {
        TTupleProtocol iprot = (TTupleProtocol) prot;
        BitSet incoming = iprot.readBitSet(1);
        if (incoming.get(0)) {
          struct.connection = new RConnection();
          struct.connection.read(iprot);
          struct.setConnectionIsSet(true);
        }
      }
    }

  }

  public static class connection_getCatalogs_result implements org.apache.thrift.TBase<connection_getCatalogs_result, connection_getCatalogs_result._Fields>, java.io.Serializable, Cloneable, Comparable<connection_getCatalogs_result>   {
    private static final org.apache.thrift.protocol.TStruct STRUCT_DESC = new org.apache.thrift.protocol.TStruct("connection_getCatalogs_result");

    private static final org.apache.thrift.protocol.TField SUCCESS_FIELD_DESC = new org.apache.thrift.protocol.TField("success", org.apache.thrift.protocol.TType.STRUCT, (short)0);
    private static final org.apache.thrift.protocol.TField SQL_EXCEPTION_FIELD_DESC = new org.apache.thrift.protocol.TField("sqlException", org.apache.thrift.protocol.TType.STRUCT, (short)1);

    private static final Map<Class<? extends IScheme>, SchemeFactory> schemes = new HashMap<Class<? extends IScheme>, SchemeFactory>();
    static {
      schemes.put(StandardScheme.class, new connection_getCatalogs_resultStandardSchemeFactory());
      schemes.put(TupleScheme.class, new connection_getCatalogs_resultTupleSchemeFactory());
    }

    public RResultSet success; // required
    public RSQLException sqlException; // required

    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements org.apache.thrift.TFieldIdEnum {
      SUCCESS((short)0, "success"),
      SQL_EXCEPTION((short)1, "sqlException");

      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        switch(fieldId) {
          case 0: // SUCCESS
            return SUCCESS;
          case 1: // SQL_EXCEPTION
            return SQL_EXCEPTION;
          default:
            return null;
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }

    // isset id assignments
    public static final Map<_Fields, org.apache.thrift.meta_data.FieldMetaData> metaDataMap;
    static {
      Map<_Fields, org.apache.thrift.meta_data.FieldMetaData> tmpMap = new EnumMap<_Fields, org.apache.thrift.meta_data.FieldMetaData>(_Fields.class);
      tmpMap.put(_Fields.SUCCESS, new org.apache.thrift.meta_data.FieldMetaData("success", org.apache.thrift.TFieldRequirementType.DEFAULT, 
          new org.apache.thrift.meta_data.StructMetaData(org.apache.thrift.protocol.TType.STRUCT, RResultSet.class)));
      tmpMap.put(_Fields.SQL_EXCEPTION, new org.apache.thrift.meta_data.FieldMetaData("sqlException", org.apache.thrift.TFieldRequirementType.DEFAULT, 
          new org.apache.thrift.meta_data.FieldValueMetaData(org.apache.thrift.protocol.TType.STRUCT)));
      metaDataMap = Collections.unmodifiableMap(tmpMap);
      org.apache.thrift.meta_data.FieldMetaData.addStructMetaDataMap(connection_getCatalogs_result.class, metaDataMap);
    }

    public connection_getCatalogs_result() {
    }

    public connection_getCatalogs_result(
      RResultSet success,
      RSQLException sqlException)
    {
      this();
      this.success = success;
      this.sqlException = sqlException;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public connection_getCatalogs_result(connection_getCatalogs_result other) {
      if (other.isSetSuccess()) {
        this.success = new RResultSet(other.success);
      }
      if (other.isSetSqlException()) {
        this.sqlException = new RSQLException(other.sqlException);
      }
    }

    public connection_getCatalogs_result deepCopy() {
      return new connection_getCatalogs_result(this);
    }

    @Override
    public void clear() {
      this.success = null;
      this.sqlException = null;
    }

    public RResultSet getSuccess() {
      return this.success;
    }

    public connection_getCatalogs_result setSuccess(RResultSet success) {
      this.success = success;
      return this;
    }

    public void unsetSuccess() {
      this.success = null;
    }

    /** Returns true if field success is set (has been assigned a value) and false otherwise */
    public boolean isSetSuccess() {
      return this.success != null;
    }

    public void setSuccessIsSet(boolean value) {
      if (!value) {
        this.success = null;
      }
    }

    public RSQLException getSqlException() {
      return this.sqlException;
    }

    public connection_getCatalogs_result setSqlException(RSQLException sqlException) {
      this.sqlException = sqlException;
      return this;
    }

    public void unsetSqlException() {
      this.sqlException = null;
    }

    /** Returns true if field sqlException is set (has been assigned a value) and false otherwise */
    public boolean isSetSqlException() {
      return this.sqlException != null;
    }

    public void setSqlExceptionIsSet(boolean value) {
      if (!value) {
        this.sqlException = null;
      }
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          setSuccess((RResultSet)value);
        }
        break;

      case SQL_EXCEPTION:
        if (value == null) {
          unsetSqlException();
        } else {
          setSqlException((RSQLException)value);
        }
        break;

      }
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      case SUCCESS:
        return getSuccess();

      case SQL_EXCEPTION:
        return getSqlException();

      }
      throw new IllegalStateException();
    }

    /** Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      if (field == null) {
        throw new IllegalArgumentException();
      }

      switch (field) {
      case SUCCESS:
        return isSetSuccess();
      case SQL_EXCEPTION:
        return isSetSqlException();
      }
      throw new IllegalStateException();
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof connection_getCatalogs_result)
        return this.equals((connection_getCatalogs_result)that);
      return false;
    }

    public boolean equals(connection_getCatalogs_result that) {
      if (that == null)
        return false;

      boolean this_present_success = true && this.isSetSuccess();
      boolean that_present_success = true && that.isSetSuccess();
      if (this_present_success || that_present_success) {
        if (!(this_present_success && that_present_success))
          return false;
        if (!this.success.equals(that.success))
          return false;
      }

      boolean this_present_sqlException = true && this.isSetSqlException();
      boolean that_present_sqlException = true && that.isSetSqlException();
      if (this_present_sqlException || that_present_sqlException) {
        if (!(this_present_sqlException && that_present_sqlException))
          return false;
        if (!this.sqlException.equals(that.sqlException))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      List<Object> list = new ArrayList<Object>();

      boolean present_success = true && (isSetSuccess());
      list.add(present_success);
      if (present_success)
        list.add(success);

      boolean present_sqlException = true && (isSetSqlException());
      list.add(present_sqlException);
      if (present_sqlException)
        list.add(sqlException);

      return list.hashCode();
    }

    @Override
    public int compareTo(connection_getCatalogs_result other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetSuccess()).compareTo(other.isSetSuccess());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetSuccess()) {
        lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.success, other.success);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      lastComparison = Boolean.valueOf(isSetSqlException()).compareTo(other.isSetSqlException());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetSqlException()) {
        lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.sqlException, other.sqlException);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      return 0;
    }

    public _Fields fieldForId(int fieldId) {
      return _Fields.findByThriftId(fieldId);
    }

    public void read(org.apache.thrift.protocol.TProtocol iprot) throws org.apache.thrift.TException {
      schemes.get(iprot.getScheme()).getScheme().read(iprot, this);
    }

    public void write(org.apache.thrift.protocol.TProtocol oprot) throws org.apache.thrift.TException {
      schemes.get(oprot.getScheme()).getScheme().write(oprot, this);
      }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("connection_getCatalogs_result(");
      boolean first = true;

      sb.append("success:");
      if (this.success == null) {
        sb.append("null");
      } else {
        sb.append(this.success);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("sqlException:");
      if (this.sqlException == null) {
        sb.append("null");
      } else {
        sb.append(this.sqlException);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws org.apache.thrift.TException {
      // check for required fields
      // check for sub-struct validity
      if (success != null) {
        success.validate();
      }
    }

    private void writeObject(java.io.ObjectOutputStream out) throws java.io.IOException {
      try {
        write(new org.apache.thrift.protocol.TCompactProtocol(new org.apache.thrift.transport.TIOStreamTransport(out)));
      } catch (org.apache.thrift.TException te) {
        throw new java.io.IOException(te);
      }
    }

    private void readObject(java.io.ObjectInputStream in) throws java.io.IOException, ClassNotFoundException {
      try {
        read(new org.apache.thrift.protocol.TCompactProtocol(new org.apache.thrift.transport.TIOStreamTransport(in)));
      } catch (org.apache.thrift.TException te) {
        throw new java.io.IOException(te);
      }
    }

    private static class connection_getCatalogs_resultStandardSchemeFactory implements SchemeFactory {
      public connection_getCatalogs_resultStandardScheme getScheme() {
        return new connection_getCatalogs_resultStandardScheme();
      }
    }

    private static class connection_getCatalogs_resultStandardScheme extends StandardScheme<connection_getCatalogs_result> {

      public void read(org.apache.thrift.protocol.TProtocol iprot, connection_getCatalogs_result struct) throws org.apache.thrift.TException {
        org.apache.thrift.protocol.TField schemeField;
        iprot.readStructBegin();
        while (true)
        {
          schemeField = iprot.readFieldBegin();
          if (schemeField.type == org.apache.thrift.protocol.TType.STOP) { 
            break;
          }
          switch (schemeField.id) {
            case 0: // SUCCESS
              if (schemeField.type == org.apache.thrift.protocol.TType.STRUCT) {
                struct.success = new RResultSet();
                struct.success.read(iprot);
                struct.setSuccessIsSet(true);
              } else { 
                org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
              }
              break;
            case 1: // SQL_EXCEPTION
              if (schemeField.type == org.apache.thrift.protocol.TType.STRUCT) {
                struct.sqlException = new RSQLException();
                struct.sqlException.read(iprot);
                struct.setSqlExceptionIsSet(true);
              } else { 
                org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
              }
              break;
            default:
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
          }
          iprot.readFieldEnd();
        }
        iprot.readStructEnd();

        // check for required fields of primitive type, which can't be checked in the validate method
        struct.validate();
      }

      public void write(org.apache.thrift.protocol.TProtocol oprot, connection_getCatalogs_result struct) throws org.apache.thrift.TException {
        struct.validate();

        oprot.writeStructBegin(STRUCT_DESC);
        if (struct.success != null) {
          oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
          struct.success.write(oprot);
          oprot.writeFieldEnd();
        }
        if (struct.sqlException != null) {
          oprot.writeFieldBegin(SQL_EXCEPTION_FIELD_DESC);
          struct.sqlException.write(oprot);
          oprot.writeFieldEnd();
        }
        oprot.writeFieldStop();
        oprot.writeStructEnd();
      }

    }

    private static class connection_getCatalogs_resultTupleSchemeFactory implements SchemeFactory {
      public connection_getCatalogs_resultTupleScheme getScheme() {
        return new connection_getCatalogs_resultTupleScheme();
      }
    }

    private static class connection_getCatalogs_resultTupleScheme extends TupleScheme<connection_getCatalogs_result> {

      @Override
      public void write(org.apache.thrift.protocol.TProtocol prot, connection_getCatalogs_result struct) throws org.apache.thrift.TException {
        TTupleProtocol oprot = (TTupleProtocol) prot;
        BitSet optionals = new BitSet();
        if (struct.isSetSuccess()) {
          optionals.set(0);
        }
        if (struct.isSetSqlException()) {
          optionals.set(1);
        }
        oprot.writeBitSet(optionals, 2);
        if (struct.isSetSuccess()) {
          struct.success.write(oprot);
        }
        if (struct.isSetSqlException()) {
          struct.sqlException.write(oprot);
        }
      }

      @Override
      public void read(org.apache.thrift.protocol.TProtocol prot, connection_getCatalogs_result struct) throws org.apache.thrift.TException {
        TTupleProtocol iprot = (TTupleProtocol) prot;
        BitSet incoming = iprot.readBitSet(2);
        if (incoming.get(0)) {
          struct.success = new RResultSet();
          struct.success.read(iprot);
          struct.setSuccessIsSet(true);
        }
        if (incoming.get(1)) {
          struct.sqlException = new RSQLException();
          struct.sqlException.read(iprot);
          struct.setSqlExceptionIsSet(true);
        }
      }
    }

  }

  public static class connection_getSchemas_args implements org.apache.thrift.TBase<connection_getSchemas_args, connection_getSchemas_args._Fields>, java.io.Serializable, Cloneable, Comparable<connection_getSchemas_args>   {
    private static final org.apache.thrift.protocol.TStruct STRUCT_DESC = new org.apache.thrift.protocol.TStruct("connection_getSchemas_args");

    private static final org.apache.thrift.protocol.TField CONNECTION_FIELD_DESC = new org.apache.thrift.protocol.TField("connection", org.apache.thrift.protocol.TType.STRUCT, (short)1);
    private static final org.apache.thrift.protocol.TField CATALOG_FIELD_DESC = new org.apache.thrift.protocol.TField("catalog", org.apache.thrift.protocol.TType.STRING, (short)2);
    private static final org.apache.thrift.protocol.TField SCHEMA_PATTERN_FIELD_DESC = new org.apache.thrift.protocol.TField("schemaPattern", org.apache.thrift.protocol.TType.STRING, (short)3);

    private static final Map<Class<? extends IScheme>, SchemeFactory> schemes = new HashMap<Class<? extends IScheme>, SchemeFactory>();
    static {
      schemes.put(StandardScheme.class, new connection_getSchemas_argsStandardSchemeFactory());
      schemes.put(TupleScheme.class, new connection_getSchemas_argsTupleSchemeFactory());
    }

    public RConnection connection; // required
    public String catalog; // required
    public String schemaPattern; // required

    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements org.apache.thrift.TFieldIdEnum {
      CONNECTION((short)1, "connection"),
      CATALOG((short)2, "catalog"),
      SCHEMA_PATTERN((short)3, "schemaPattern");

      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        switch(fieldId) {
          case 1: // CONNECTION
            return CONNECTION;
          case 2: // CATALOG
            return CATALOG;
          case 3: // SCHEMA_PATTERN
            return SCHEMA_PATTERN;
          default:
            return null;
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }

    // isset id assignments
    public static final Map<_Fields, org.apache.thrift.meta_data.FieldMetaData> metaDataMap;
    static {
      Map<_Fields, org.apache.thrift.meta_data.FieldMetaData> tmpMap = new EnumMap<_Fields, org.apache.thrift.meta_data.FieldMetaData>(_Fields.class);
      tmpMap.put(_Fields.CONNECTION, new org.apache.thrift.meta_data.FieldMetaData("connection", org.apache.thrift.TFieldRequirementType.DEFAULT, 
          new org.apache.thrift.meta_data.StructMetaData(org.apache.thrift.protocol.TType.STRUCT, RConnection.class)));
      tmpMap.put(_Fields.CATALOG, new org.apache.thrift.meta_data.FieldMetaData("catalog", org.apache.thrift.TFieldRequirementType.DEFAULT, 
          new org.apache.thrift.meta_data.FieldValueMetaData(org.apache.thrift.protocol.TType.STRING)));
      tmpMap.put(_Fields.SCHEMA_PATTERN, new org.apache.thrift.meta_data.FieldMetaData("schemaPattern", org.apache.thrift.TFieldRequirementType.DEFAULT, 
          new org.apache.thrift.meta_data.FieldValueMetaData(org.apache.thrift.protocol.TType.STRING)));
      metaDataMap = Collections.unmodifiableMap(tmpMap);
      org.apache.thrift.meta_data.FieldMetaData.addStructMetaDataMap(connection_getSchemas_args.class, metaDataMap);
    }

    public connection_getSchemas_args() {
    }

    public connection_getSchemas_args(
      RConnection connection,
      String catalog,
      String schemaPattern)
    {
      this();
      this.connection = connection;
      this.catalog = catalog;
      this.schemaPattern = schemaPattern;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public connection_getSchemas_args(connection_getSchemas_args other) {
      if (other.isSetConnection()) {
        this.connection = new RConnection(other.connection);
      }
      if (other.isSetCatalog()) {
        this.catalog = other.catalog;
      }
      if (other.isSetSchemaPattern()) {
        this.schemaPattern = other.schemaPattern;
      }
    }

    public connection_getSchemas_args deepCopy() {
      return new connection_getSchemas_args(this);
    }

    @Override
    public void clear() {
      this.connection = null;
      this.catalog = null;
      this.schemaPattern = null;
    }

    public RConnection getConnection() {
      return this.connection;
    }

    public connection_getSchemas_args setConnection(RConnection connection) {
      this.connection = connection;
      return this;
    }

    public void unsetConnection() {
      this.connection = null;
    }

    /** Returns true if field connection is set (has been assigned a value) and false otherwise */
    public boolean isSetConnection() {
      return this.connection != null;
    }

    public void setConnectionIsSet(boolean value) {
      if (!value) {
        this.connection = null;
      }
    }

    public String getCatalog() {
      return this.catalog;
    }

    public connection_getSchemas_args setCatalog(String catalog) {
      this.catalog = catalog;
      return this;
    }

    public void unsetCatalog() {
      this.catalog = null;
    }

    /** Returns true if field catalog is set (has been assigned a value) and false otherwise */
    public boolean isSetCatalog() {
      return this.catalog != null;
    }

    public void setCatalogIsSet(boolean value) {
      if (!value) {
        this.catalog = null;
      }
    }

    public String getSchemaPattern() {
      return this.schemaPattern;
    }

    public connection_getSchemas_args setSchemaPattern(String schemaPattern) {
      this.schemaPattern = schemaPattern;
      return this;
    }

    public void unsetSchemaPattern() {
      this.schemaPattern = null;
    }

    /** Returns true if field schemaPattern is set (has been assigned a value) and false otherwise */
    public boolean isSetSchemaPattern() {
      return this.schemaPattern != null;
    }

    public void setSchemaPatternIsSet(boolean value) {
      if (!value) {
        this.schemaPattern = null;
      }
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      case CONNECTION:
        if (value == null) {
          unsetConnection();
        } else {
          setConnection((RConnection)value);
        }
        break;

      case CATALOG:
        if (value == null) {
          unsetCatalog();
        } else {
          setCatalog((String)value);
        }
        break;

      case SCHEMA_PATTERN:
        if (value == null) {
          unsetSchemaPattern();
        } else {
          setSchemaPattern((String)value);
        }
        break;

      }
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      case CONNECTION:
        return getConnection();

      case CATALOG:
        return getCatalog();

      case SCHEMA_PATTERN:
        return getSchemaPattern();

      }
      throw new IllegalStateException();
    }

    /** Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      if (field == null) {
        throw new IllegalArgumentException();
      }

      switch (field) {
      case CONNECTION:
        return isSetConnection();
      case CATALOG:
        return isSetCatalog();
      case SCHEMA_PATTERN:
        return isSetSchemaPattern();
      }
      throw new IllegalStateException();
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof connection_getSchemas_args)
        return this.equals((connection_getSchemas_args)that);
      return false;
    }

    public boolean equals(connection_getSchemas_args that) {
      if (that == null)
        return false;

      boolean this_present_connection = true && this.isSetConnection();
      boolean that_present_connection = true && that.isSetConnection();
      if (this_present_connection || that_present_connection) {
        if (!(this_present_connection && that_present_connection))
          return false;
        if (!this.connection.equals(that.connection))
          return false;
      }

      boolean this_present_catalog = true && this.isSetCatalog();
      boolean that_present_catalog = true && that.isSetCatalog();
      if (this_present_catalog || that_present_catalog) {
        if (!(this_present_catalog && that_present_catalog))
          return false;
        if (!this.catalog.equals(that.catalog))
          return false;
      }

      boolean this_present_schemaPattern = true && this.isSetSchemaPattern();
      boolean that_present_schemaPattern = true && that.isSetSchemaPattern();
      if (this_present_schemaPattern || that_present_schemaPattern) {
        if (!(this_present_schemaPattern && that_present_schemaPattern))
          return false;
        if (!this.schemaPattern.equals(that.schemaPattern))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      List<Object> list = new ArrayList<Object>();

      boolean present_connection = true && (isSetConnection());
      list.add(present_connection);
      if (present_connection)
        list.add(connection);

      boolean present_catalog = true && (isSetCatalog());
      list.add(present_catalog);
      if (present_catalog)
        list.add(catalog);

      boolean present_schemaPattern = true && (isSetSchemaPattern());
      list.add(present_schemaPattern);
      if (present_schemaPattern)
        list.add(schemaPattern);

      return list.hashCode();
    }

    @Override
    public int compareTo(connection_getSchemas_args other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetConnection()).compareTo(other.isSetConnection());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetConnection()) {
        lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.connection, other.connection);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      lastComparison = Boolean.valueOf(isSetCatalog()).compareTo(other.isSetCatalog());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetCatalog()) {
        lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.catalog, other.catalog);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      lastComparison = Boolean.valueOf(isSetSchemaPattern()).compareTo(other.isSetSchemaPattern());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetSchemaPattern()) {
        lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.schemaPattern, other.schemaPattern);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      return 0;
    }

    public _Fields fieldForId(int fieldId) {
      return _Fields.findByThriftId(fieldId);
    }

    public void read(org.apache.thrift.protocol.TProtocol iprot) throws org.apache.thrift.TException {
      schemes.get(iprot.getScheme()).getScheme().read(iprot, this);
    }

    public void write(org.apache.thrift.protocol.TProtocol oprot) throws org.apache.thrift.TException {
      schemes.get(oprot.getScheme()).getScheme().write(oprot, this);
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("connection_getSchemas_args(");
      boolean first = true;

      sb.append("connection:");
      if (this.connection == null) {
        sb.append("null");
      } else {
        sb.append(this.connection);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("catalog:");
      if (this.catalog == null) {
        sb.append("null");
      } else {
        sb.append(this.catalog);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("schemaPattern:");
      if (this.schemaPattern == null) {
        sb.append("null");
      } else {
        sb.append(this.schemaPattern);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws org.apache.thrift.TException {
      // check for required fields
      // check for sub-struct validity
      if (connection != null) {
        connection.validate();
      }
    }

    private void writeObject(java.io.ObjectOutputStream out) throws java.io.IOException {
      try {
        write(new org.apache.thrift.protocol.TCompactProtocol(new org.apache.thrift.transport.TIOStreamTransport(out)));
      } catch (org.apache.thrift.TException te) {
        throw new java.io.IOException(te);
      }
    }

    private void readObject(java.io.ObjectInputStream in) throws java.io.IOException, ClassNotFoundException {
      try {
        read(new org.apache.thrift.protocol.TCompactProtocol(new org.apache.thrift.transport.TIOStreamTransport(in)));
      } catch (org.apache.thrift.TException te) {
        throw new java.io.IOException(te);
      }
    }

    private static class connection_getSchemas_argsStandardSchemeFactory implements SchemeFactory {
      public connection_getSchemas_argsStandardScheme getScheme() {
        return new connection_getSchemas_argsStandardScheme();
      }
    }

    private static class connection_getSchemas_argsStandardScheme extends StandardScheme<connection_getSchemas_args> {

      public void read(org.apache.thrift.protocol.TProtocol iprot, connection_getSchemas_args struct) throws org.apache.thrift.TException {
        org.apache.thrift.protocol.TField schemeField;
        iprot.readStructBegin();
        while (true)
        {
          schemeField = iprot.readFieldBegin();
          if (schemeField.type == org.apache.thrift.protocol.TType.STOP) { 
            break;
          }
          switch (schemeField.id) {
            case 1: // CONNECTION
              if (schemeField.type == org.apache.thrift.protocol.TType.STRUCT) {
                struct.connection = new RConnection();
                struct.connection.read(iprot);
                struct.setConnectionIsSet(true);
              } else { 
                org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
              }
              break;
            case 2: // CATALOG
              if (schemeField.type == org.apache.thrift.protocol.TType.STRING) {
                struct.catalog = iprot.readString();
                struct.setCatalogIsSet(true);
              } else { 
                org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
              }
              break;
            case 3: // SCHEMA_PATTERN
              if (schemeField.type == org.apache.thrift.protocol.TType.STRING) {
                struct.schemaPattern = iprot.readString();
                struct.setSchemaPatternIsSet(true);
              } else { 
                org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
              }
              break;
            default:
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
          }
          iprot.readFieldEnd();
        }
        iprot.readStructEnd();

        // check for required fields of primitive type, which can't be checked in the validate method
        struct.validate();
      }

      public void write(org.apache.thrift.protocol.TProtocol oprot, connection_getSchemas_args struct) throws org.apache.thrift.TException {
        struct.validate();

        oprot.writeStructBegin(STRUCT_DESC);
        if (struct.connection != null) {
          oprot.writeFieldBegin(CONNECTION_FIELD_DESC);
          struct.connection.write(oprot);
          oprot.writeFieldEnd();
        }
        if (struct.catalog != null) {
          oprot.writeFieldBegin(CATALOG_FIELD_DESC);
          oprot.writeString(struct.catalog);
          oprot.writeFieldEnd();
        }
        if (struct.schemaPattern != null) {
          oprot.writeFieldBegin(SCHEMA_PATTERN_FIELD_DESC);
          oprot.writeString(struct.schemaPattern);
          oprot.writeFieldEnd();
        }
        oprot.writeFieldStop();
        oprot.writeStructEnd();
      }

    }

    private static class connection_getSchemas_argsTupleSchemeFactory implements SchemeFactory {
      public connection_getSchemas_argsTupleScheme getScheme() {
        return new connection_getSchemas_argsTupleScheme();
      }
    }

    private static class connection_getSchemas_argsTupleScheme extends TupleScheme<connection_getSchemas_args> {

      @Override
      public void write(org.apache.thrift.protocol.TProtocol prot, connection_getSchemas_args struct) throws org.apache.thrift.TException {
        TTupleProtocol oprot = (TTupleProtocol) prot;
        BitSet optionals = new BitSet();
        if (struct.isSetConnection()) {
          optionals.set(0);
        }
        if (struct.isSetCatalog()) {
          optionals.set(1);
        }
        if (struct.isSetSchemaPattern()) {
          optionals.set(2);
        }
        oprot.writeBitSet(optionals, 3);
        if (struct.isSetConnection()) {
          struct.connection.write(oprot);
        }
        if (struct.isSetCatalog()) {
          oprot.writeString(struct.catalog);
        }
        if (struct.isSetSchemaPattern()) {
          oprot.writeString(struct.schemaPattern);
        }
      }

      @Override
      public void read(org.apache.thrift.protocol.TProtocol prot, connection_getSchemas_args struct) throws org.apache.thrift.TException {
        TTupleProtocol iprot = (TTupleProtocol) prot;
        BitSet incoming = iprot.readBitSet(3);
        if (incoming.get(0)) {
          struct.connection = new RConnection();
          struct.connection.read(iprot);
          struct.setConnectionIsSet(true);
        }
        if (incoming.get(1)) {
          struct.catalog = iprot.readString();
          struct.setCatalogIsSet(true);
        }
        if (incoming.get(2)) {
          struct.schemaPattern = iprot.readString();
          struct.setSchemaPatternIsSet(true);
        }
      }
    }

  }

  public static class connection_getSchemas_result implements org.apache.thrift.TBase<connection_getSchemas_result, connection_getSchemas_result._Fields>, java.io.Serializable, Cloneable, Comparable<connection_getSchemas_result>   {
    private static final org.apache.thrift.protocol.TStruct STRUCT_DESC = new org.apache.thrift.protocol.TStruct("connection_getSchemas_result");

    private static final org.apache.thrift.protocol.TField SUCCESS_FIELD_DESC = new org.apache.thrift.protocol.TField("success", org.apache.thrift.protocol.TType.STRUCT, (short)0);
    private static final org.apache.thrift.protocol.TField SQL_EXCEPTION_FIELD_DESC = new org.apache.thrift.protocol.TField("sqlException", org.apache.thrift.protocol.TType.STRUCT, (short)1);

    private static final Map<Class<? extends IScheme>, SchemeFactory> schemes = new HashMap<Class<? extends IScheme>, SchemeFactory>();
    static {
      schemes.put(StandardScheme.class, new connection_getSchemas_resultStandardSchemeFactory());
      schemes.put(TupleScheme.class, new connection_getSchemas_resultTupleSchemeFactory());
    }

    public RResultSet success; // required
    public RSQLException sqlException; // required

    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements org.apache.thrift.TFieldIdEnum {
      SUCCESS((short)0, "success"),
      SQL_EXCEPTION((short)1, "sqlException");

      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        switch(fieldId) {
          case 0: // SUCCESS
            return SUCCESS;
          case 1: // SQL_EXCEPTION
            return SQL_EXCEPTION;
          default:
            return null;
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }

    // isset id assignments
    public static final Map<_Fields, org.apache.thrift.meta_data.FieldMetaData> metaDataMap;
    static {
      Map<_Fields, org.apache.thrift.meta_data.FieldMetaData> tmpMap = new EnumMap<_Fields, org.apache.thrift.meta_data.FieldMetaData>(_Fields.class);
      tmpMap.put(_Fields.SUCCESS, new org.apache.thrift.meta_data.FieldMetaData("success", org.apache.thrift.TFieldRequirementType.DEFAULT, 
          new org.apache.thrift.meta_data.StructMetaData(org.apache.thrift.protocol.TType.STRUCT, RResultSet.class)));
      tmpMap.put(_Fields.SQL_EXCEPTION, new org.apache.thrift.meta_data.FieldMetaData("sqlException", org.apache.thrift.TFieldRequirementType.DEFAULT, 
          new org.apache.thrift.meta_data.FieldValueMetaData(org.apache.thrift.protocol.TType.STRUCT)));
      metaDataMap = Collections.unmodifiableMap(tmpMap);
      org.apache.thrift.meta_data.FieldMetaData.addStructMetaDataMap(connection_getSchemas_result.class, metaDataMap);
    }

    public connection_getSchemas_result() {
    }

    public connection_getSchemas_result(
      RResultSet success,
      RSQLException sqlException)
    {
      this();
      this.success = success;
      this.sqlException = sqlException;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public connection_getSchemas_result(connection_getSchemas_result other) {
      if (other.isSetSuccess()) {
        this.success = new RResultSet(other.success);
      }
      if (other.isSetSqlException()) {
        this.sqlException = new RSQLException(other.sqlException);
      }
    }

    public connection_getSchemas_result deepCopy() {
      return new connection_getSchemas_result(this);
    }

    @Override
    public void clear() {
      this.success = null;
      this.sqlException = null;
    }

    public RResultSet getSuccess() {
      return this.success;
    }

    public connection_getSchemas_result setSuccess(RResultSet success) {
      this.success = success;
      return this;
    }

    public void unsetSuccess() {
      this.success = null;
    }

    /** Returns true if field success is set (has been assigned a value) and false otherwise */
    public boolean isSetSuccess() {
      return this.success != null;
    }

    public void setSuccessIsSet(boolean value) {
      if (!value) {
        this.success = null;
      }
    }

    public RSQLException getSqlException() {
      return this.sqlException;
    }

    public connection_getSchemas_result setSqlException(RSQLException sqlException) {
      this.sqlException = sqlException;
      return this;
    }

    public void unsetSqlException() {
      this.sqlException = null;
    }

    /** Returns true if field sqlException is set (has been assigned a value) and false otherwise */
    public boolean isSetSqlException() {
      return this.sqlException != null;
    }

    public void setSqlExceptionIsSet(boolean value) {
      if (!value) {
        this.sqlException = null;
      }
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          setSuccess((RResultSet)value);
        }
        break;

      case SQL_EXCEPTION:
        if (value == null) {
          unsetSqlException();
        } else {
          setSqlException((RSQLException)value);
        }
        break;

      }
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      case SUCCESS:
        return getSuccess();

      case SQL_EXCEPTION:
        return getSqlException();

      }
      throw new IllegalStateException();
    }

    /** Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      if (field == null) {
        throw new IllegalArgumentException();
      }

      switch (field) {
      case SUCCESS:
        return isSetSuccess();
      case SQL_EXCEPTION:
        return isSetSqlException();
      }
      throw new IllegalStateException();
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof connection_getSchemas_result)
        return this.equals((connection_getSchemas_result)that);
      return false;
    }

    public boolean equals(connection_getSchemas_result that) {
      if (that == null)
        return false;

      boolean this_present_success = true && this.isSetSuccess();
      boolean that_present_success = true && that.isSetSuccess();
      if (this_present_success || that_present_success) {
        if (!(this_present_success && that_present_success))
          return false;
        if (!this.success.equals(that.success))
          return false;
      }

      boolean this_present_sqlException = true && this.isSetSqlException();
      boolean that_present_sqlException = true && that.isSetSqlException();
      if (this_present_sqlException || that_present_sqlException) {
        if (!(this_present_sqlException && that_present_sqlException))
          return false;
        if (!this.sqlException.equals(that.sqlException))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      List<Object> list = new ArrayList<Object>();

      boolean present_success = true && (isSetSuccess());
      list.add(present_success);
      if (present_success)
        list.add(success);

      boolean present_sqlException = true && (isSetSqlException());
      list.add(present_sqlException);
      if (present_sqlException)
        list.add(sqlException);

      return list.hashCode();
    }

    @Override
    public int compareTo(connection_getSchemas_result other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetSuccess()).compareTo(other.isSetSuccess());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetSuccess()) {
        lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.success, other.success);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      lastComparison = Boolean.valueOf(isSetSqlException()).compareTo(other.isSetSqlException());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetSqlException()) {
        lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.sqlException, other.sqlException);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      return 0;
    }

    public _Fields fieldForId(int fieldId) {
      return _Fields.findByThriftId(fieldId);
    }

    public void read(org.apache.thrift.protocol.TProtocol iprot) throws org.apache.thrift.TException {
      schemes.get(iprot.getScheme()).getScheme().read(iprot, this);
    }

    public void write(org.apache.thrift.protocol.TProtocol oprot) throws org.apache.thrift.TException {
      schemes.get(oprot.getScheme()).getScheme().write(oprot, this);
      }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("connection_getSchemas_result(");
      boolean first = true;

      sb.append("success:");
      if (this.success == null) {
        sb.append("null");
      } else {
        sb.append(this.success);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("sqlException:");
      if (this.sqlException == null) {
        sb.append("null");
      } else {
        sb.append(this.sqlException);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws org.apache.thrift.TException {
      // check for required fields
      // check for sub-struct validity
      if (success != null) {
        success.validate();
      }
    }

    private void writeObject(java.io.ObjectOutputStream out) throws java.io.IOException {
      try {
        write(new org.apache.thrift.protocol.TCompactProtocol(new org.apache.thrift.transport.TIOStreamTransport(out)));
      } catch (org.apache.thrift.TException te) {
        throw new java.io.IOException(te);
      }
    }

    private void readObject(java.io.ObjectInputStream in) throws java.io.IOException, ClassNotFoundException {
      try {
        read(new org.apache.thrift.protocol.TCompactProtocol(new org.apache.thrift.transport.TIOStreamTransport(in)));
      } catch (org.apache.thrift.TException te) {
        throw new java.io.IOException(te);
      }
    }

    private static class connection_getSchemas_resultStandardSchemeFactory implements SchemeFactory {
      public connection_getSchemas_resultStandardScheme getScheme() {
        return new connection_getSchemas_resultStandardScheme();
      }
    }

    private static class connection_getSchemas_resultStandardScheme extends StandardScheme<connection_getSchemas_result> {

      public void read(org.apache.thrift.protocol.TProtocol iprot, connection_getSchemas_result struct) throws org.apache.thrift.TException {
        org.apache.thrift.protocol.TField schemeField;
        iprot.readStructBegin();
        while (true)
        {
          schemeField = iprot.readFieldBegin();
          if (schemeField.type == org.apache.thrift.protocol.TType.STOP) { 
            break;
          }
          switch (schemeField.id) {
            case 0: // SUCCESS
              if (schemeField.type == org.apache.thrift.protocol.TType.STRUCT) {
                struct.success = new RResultSet();
                struct.success.read(iprot);
                struct.setSuccessIsSet(true);
              } else { 
                org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
              }
              break;
            case 1: // SQL_EXCEPTION
              if (schemeField.type == org.apache.thrift.protocol.TType.STRUCT) {
                struct.sqlException = new RSQLException();
                struct.sqlException.read(iprot);
                struct.setSqlExceptionIsSet(true);
              } else { 
                org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
              }
              break;
            default:
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
          }
          iprot.readFieldEnd();
        }
        iprot.readStructEnd();

        // check for required fields of primitive type, which can't be checked in the validate method
        struct.validate();
      }

      public void write(org.apache.thrift.protocol.TProtocol oprot, connection_getSchemas_result struct) throws org.apache.thrift.TException {
        struct.validate();

        oprot.writeStructBegin(STRUCT_DESC);
        if (struct.success != null) {
          oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
          struct.success.write(oprot);
          oprot.writeFieldEnd();
        }
        if (struct.sqlException != null) {
          oprot.writeFieldBegin(SQL_EXCEPTION_FIELD_DESC);
          struct.sqlException.write(oprot);
          oprot.writeFieldEnd();
        }
        oprot.writeFieldStop();
        oprot.writeStructEnd();
      }

    }

    private static class connection_getSchemas_resultTupleSchemeFactory implements SchemeFactory {
      public connection_getSchemas_resultTupleScheme getScheme() {
        return new connection_getSchemas_resultTupleScheme();
      }
    }

    private static class connection_getSchemas_resultTupleScheme extends TupleScheme<connection_getSchemas_result> {

      @Override
      public void write(org.apache.thrift.protocol.TProtocol prot, connection_getSchemas_result struct) throws org.apache.thrift.TException {
        TTupleProtocol oprot = (TTupleProtocol) prot;
        BitSet optionals = new BitSet();
        if (struct.isSetSuccess()) {
          optionals.set(0);
        }
        if (struct.isSetSqlException()) {
          optionals.set(1);
        }
        oprot.writeBitSet(optionals, 2);
        if (struct.isSetSuccess()) {
          struct.success.write(oprot);
        }
        if (struct.isSetSqlException()) {
          struct.sqlException.write(oprot);
        }
      }

      @Override
      public void read(org.apache.thrift.protocol.TProtocol prot, connection_getSchemas_result struct) throws org.apache.thrift.TException {
        TTupleProtocol iprot = (TTupleProtocol) prot;
        BitSet incoming = iprot.readBitSet(2);
        if (incoming.get(0)) {
          struct.success = new RResultSet();
          struct.success.read(iprot);
          struct.setSuccessIsSet(true);
        }
        if (incoming.get(1)) {
          struct.sqlException = new RSQLException();
          struct.sqlException.read(iprot);
          struct.setSqlExceptionIsSet(true);
        }
      }
    }

  }

  public static class connection_getTables_args implements org.apache.thrift.TBase<connection_getTables_args, connection_getTables_args._Fields>, java.io.Serializable, Cloneable, Comparable<connection_getTables_args>   {
    private static final org.apache.thrift.protocol.TStruct STRUCT_DESC = new org.apache.thrift.protocol.TStruct("connection_getTables_args");

    private static final org.apache.thrift.protocol.TField CONNECTION_FIELD_DESC = new org.apache.thrift.protocol.TField("connection", org.apache.thrift.protocol.TType.STRUCT, (short)1);
    private static final org.apache.thrift.protocol.TField CATALOG_FIELD_DESC = new org.apache.thrift.protocol.TField("catalog", org.apache.thrift.protocol.TType.STRING, (short)2);
    private static final org.apache.thrift.protocol.TField SCHEMA_PATTERN_FIELD_DESC = new org.apache.thrift.protocol.TField("schemaPattern", org.apache.thrift.protocol.TType.STRING, (short)3);
    private static final org.apache.thrift.protocol.TField TABLE_NAME_PATTERN_FIELD_DESC = new org.apache.thrift.protocol.TField("tableNamePattern", org.apache.thrift.protocol.TType.STRING, (short)4);
    private static final org.apache.thrift.protocol.TField TYPES_FIELD_DESC = new org.apache.thrift.protocol.TField("types", org.apache.thrift.protocol.TType.LIST, (short)5);

    private static final Map<Class<? extends IScheme>, SchemeFactory> schemes = new HashMap<Class<? extends IScheme>, SchemeFactory>();
    static {
      schemes.put(StandardScheme.class, new connection_getTables_argsStandardSchemeFactory());
      schemes.put(TupleScheme.class, new connection_getTables_argsTupleSchemeFactory());
    }

    public RConnection connection; // required
    public String catalog; // required
    public String schemaPattern; // required
    public String tableNamePattern; // required
    public List<String> types; // required

    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements org.apache.thrift.TFieldIdEnum {
      CONNECTION((short)1, "connection"),
      CATALOG((short)2, "catalog"),
      SCHEMA_PATTERN((short)3, "schemaPattern"),
      TABLE_NAME_PATTERN((short)4, "tableNamePattern"),
      TYPES((short)5, "types");

      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        switch(fieldId) {
          case 1: // CONNECTION
            return CONNECTION;
          case 2: // CATALOG
            return CATALOG;
          case 3: // SCHEMA_PATTERN
            return SCHEMA_PATTERN;
          case 4: // TABLE_NAME_PATTERN
            return TABLE_NAME_PATTERN;
          case 5: // TYPES
            return TYPES;
          default:
            return null;
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }

    // isset id assignments
    public static final Map<_Fields, org.apache.thrift.meta_data.FieldMetaData> metaDataMap;
    static {
      Map<_Fields, org.apache.thrift.meta_data.FieldMetaData> tmpMap = new EnumMap<_Fields, org.apache.thrift.meta_data.FieldMetaData>(_Fields.class);
      tmpMap.put(_Fields.CONNECTION, new org.apache.thrift.meta_data.FieldMetaData("connection", org.apache.thrift.TFieldRequirementType.DEFAULT, 
          new org.apache.thrift.meta_data.StructMetaData(org.apache.thrift.protocol.TType.STRUCT, RConnection.class)));
      tmpMap.put(_Fields.CATALOG, new org.apache.thrift.meta_data.FieldMetaData("catalog", org.apache.thrift.TFieldRequirementType.DEFAULT, 
          new org.apache.thrift.meta_data.FieldValueMetaData(org.apache.thrift.protocol.TType.STRING)));
      tmpMap.put(_Fields.SCHEMA_PATTERN, new org.apache.thrift.meta_data.FieldMetaData("schemaPattern", org.apache.thrift.TFieldRequirementType.DEFAULT, 
          new org.apache.thrift.meta_data.FieldValueMetaData(org.apache.thrift.protocol.TType.STRING)));
      tmpMap.put(_Fields.TABLE_NAME_PATTERN, new org.apache.thrift.meta_data.FieldMetaData("tableNamePattern", org.apache.thrift.TFieldRequirementType.DEFAULT, 
          new org.apache.thrift.meta_data.FieldValueMetaData(org.apache.thrift.protocol.TType.STRING)));
      tmpMap.put(_Fields.TYPES, new org.apache.thrift.meta_data.FieldMetaData("types", org.apache.thrift.TFieldRequirementType.DEFAULT, 
          new org.apache.thrift.meta_data.ListMetaData(org.apache.thrift.protocol.TType.LIST, 
              new org.apache.thrift.meta_data.FieldValueMetaData(org.apache.thrift.protocol.TType.STRING))));
      metaDataMap = Collections.unmodifiableMap(tmpMap);
      org.apache.thrift.meta_data.FieldMetaData.addStructMetaDataMap(connection_getTables_args.class, metaDataMap);
    }

    public connection_getTables_args() {
    }

    public connection_getTables_args(
      RConnection connection,
      String catalog,
      String schemaPattern,
      String tableNamePattern,
      List<String> types)
    {
      this();
      this.connection = connection;
      this.catalog = catalog;
      this.schemaPattern = schemaPattern;
      this.tableNamePattern = tableNamePattern;
      this.types = types;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public connection_getTables_args(connection_getTables_args other) {
      if (other.isSetConnection()) {
        this.connection = new RConnection(other.connection);
      }
      if (other.isSetCatalog()) {
        this.catalog = other.catalog;
      }
      if (other.isSetSchemaPattern()) {
        this.schemaPattern = other.schemaPattern;
      }
      if (other.isSetTableNamePattern()) {
        this.tableNamePattern = other.tableNamePattern;
      }
      if (other.isSetTypes()) {
        List<String> __this__types = new ArrayList<String>(other.types);
        this.types = __this__types;
      }
    }

    public connection_getTables_args deepCopy() {
      return new connection_getTables_args(this);
    }

    @Override
    public void clear() {
      this.connection = null;
      this.catalog = null;
      this.schemaPattern = null;
      this.tableNamePattern = null;
      this.types = null;
    }

    public RConnection getConnection() {
      return this.connection;
    }

    public connection_getTables_args setConnection(RConnection connection) {
      this.connection = connection;
      return this;
    }

    public void unsetConnection() {
      this.connection = null;
    }

    /** Returns true if field connection is set (has been assigned a value) and false otherwise */
    public boolean isSetConnection() {
      return this.connection != null;
    }

    public void setConnectionIsSet(boolean value) {
      if (!value) {
        this.connection = null;
      }
    }

    public String getCatalog() {
      return this.catalog;
    }

    public connection_getTables_args setCatalog(String catalog) {
      this.catalog = catalog;
      return this;
    }

    public void unsetCatalog() {
      this.catalog = null;
    }

    /** Returns true if field catalog is set (has been assigned a value) and false otherwise */
    public boolean isSetCatalog() {
      return this.catalog != null;
    }

    public void setCatalogIsSet(boolean value) {
      if (!value) {
        this.catalog = null;
      }
    }

    public String getSchemaPattern() {
      return this.schemaPattern;
    }

    public connection_getTables_args setSchemaPattern(String schemaPattern) {
      this.schemaPattern = schemaPattern;
      return this;
    }

    public void unsetSchemaPattern() {
      this.schemaPattern = null;
    }

    /** Returns true if field schemaPattern is set (has been assigned a value) and false otherwise */
    public boolean isSetSchemaPattern() {
      return this.schemaPattern != null;
    }

    public void setSchemaPatternIsSet(boolean value) {
      if (!value) {
        this.schemaPattern = null;
      }
    }

    public String getTableNamePattern() {
      return this.tableNamePattern;
    }

    public connection_getTables_args setTableNamePattern(String tableNamePattern) {
      this.tableNamePattern = tableNamePattern;
      return this;
    }

    public void unsetTableNamePattern() {
      this.tableNamePattern = null;
    }

    /** Returns true if field tableNamePattern is set (has been assigned a value) and false otherwise */
    public boolean isSetTableNamePattern() {
      return this.tableNamePattern != null;
    }

    public void setTableNamePatternIsSet(boolean value) {
      if (!value) {
        this.tableNamePattern = null;
      }
    }

    public int getTypesSize() {
      return (this.types == null) ? 0 : this.types.size();
    }

    public java.util.Iterator<String> getTypesIterator() {
      return (this.types == null) ? null : this.types.iterator();
    }

    public void addToTypes(String elem) {
      if (this.types == null) {
        this.types = new ArrayList<String>();
      }
      this.types.add(elem);
    }

    public List<String> getTypes() {
      return this.types;
    }

    public connection_getTables_args setTypes(List<String> types) {
      this.types = types;
      return this;
    }

    public void unsetTypes() {
      this.types = null;
    }

    /** Returns true if field types is set (has been assigned a value) and false otherwise */
    public boolean isSetTypes() {
      return this.types != null;
    }

    public void setTypesIsSet(boolean value) {
      if (!value) {
        this.types = null;
      }
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      case CONNECTION:
        if (value == null) {
          unsetConnection();
        } else {
          setConnection((RConnection)value);
        }
        break;

      case CATALOG:
        if (value == null) {
          unsetCatalog();
        } else {
          setCatalog((String)value);
        }
        break;

      case SCHEMA_PATTERN:
        if (value == null) {
          unsetSchemaPattern();
        } else {
          setSchemaPattern((String)value);
        }
        break;

      case TABLE_NAME_PATTERN:
        if (value == null) {
          unsetTableNamePattern();
        } else {
          setTableNamePattern((String)value);
        }
        break;

      case TYPES:
        if (value == null) {
          unsetTypes();
        } else {
          setTypes((List<String>)value);
        }
        break;

      }
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      case CONNECTION:
        return getConnection();

      case CATALOG:
        return getCatalog();

      case SCHEMA_PATTERN:
        return getSchemaPattern();

      case TABLE_NAME_PATTERN:
        return getTableNamePattern();

      case TYPES:
        return getTypes();

      }
      throw new IllegalStateException();
    }

    /** Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      if (field == null) {
        throw new IllegalArgumentException();
      }

      switch (field) {
      case CONNECTION:
        return isSetConnection();
      case CATALOG:
        return isSetCatalog();
      case SCHEMA_PATTERN:
        return isSetSchemaPattern();
      case TABLE_NAME_PATTERN:
        return isSetTableNamePattern();
      case TYPES:
        return isSetTypes();
      }
      throw new IllegalStateException();
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof connection_getTables_args)
        return this.equals((connection_getTables_args)that);
      return false;
    }

    public boolean equals(connection_getTables_args that) {
      if (that == null)
        return false;

      boolean this_present_connection = true && this.isSetConnection();
      boolean that_present_connection = true && that.isSetConnection();
      if (this_present_connection || that_present_connection) {
        if (!(this_present_connection && that_present_connection))
          return false;
        if (!this.connection.equals(that.connection))
          return false;
      }

      boolean this_present_catalog = true && this.isSetCatalog();
      boolean that_present_catalog = true && that.isSetCatalog();
      if (this_present_catalog || that_present_catalog) {
        if (!(this_present_catalog && that_present_catalog))
          return false;
        if (!this.catalog.equals(that.catalog))
          return false;
      }

      boolean this_present_schemaPattern = true && this.isSetSchemaPattern();
      boolean that_present_schemaPattern = true && that.isSetSchemaPattern();
      if (this_present_schemaPattern || that_present_schemaPattern) {
        if (!(this_present_schemaPattern && that_present_schemaPattern))
          return false;
        if (!this.schemaPattern.equals(that.schemaPattern))
          return false;
      }

      boolean this_present_tableNamePattern = true && this.isSetTableNamePattern();
      boolean that_present_tableNamePattern = true && that.isSetTableNamePattern();
      if (this_present_tableNamePattern || that_present_tableNamePattern) {
        if (!(this_present_tableNamePattern && that_present_tableNamePattern))
          return false;
        if (!this.tableNamePattern.equals(that.tableNamePattern))
          return false;
      }

      boolean this_present_types = true && this.isSetTypes();
      boolean that_present_types = true && that.isSetTypes();
      if (this_present_types || that_present_types) {
        if (!(this_present_types && that_present_types))
          return false;
        if (!this.types.equals(that.types))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      List<Object> list = new ArrayList<Object>();

      boolean present_connection = true && (isSetConnection());
      list.add(present_connection);
      if (present_connection)
        list.add(connection);

      boolean present_catalog = true && (isSetCatalog());
      list.add(present_catalog);
      if (present_catalog)
        list.add(catalog);

      boolean present_schemaPattern = true && (isSetSchemaPattern());
      list.add(present_schemaPattern);
      if (present_schemaPattern)
        list.add(schemaPattern);

      boolean present_tableNamePattern = true && (isSetTableNamePattern());
      list.add(present_tableNamePattern);
      if (present_tableNamePattern)
        list.add(tableNamePattern);

      boolean present_types = true && (isSetTypes());
      list.add(present_types);
      if (present_types)
        list.add(types);

      return list.hashCode();
    }

    @Override
    public int compareTo(connection_getTables_args other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetConnection()).compareTo(other.isSetConnection());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetConnection()) {
        lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.connection, other.connection);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      lastComparison = Boolean.valueOf(isSetCatalog()).compareTo(other.isSetCatalog());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetCatalog()) {
        lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.catalog, other.catalog);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      lastComparison = Boolean.valueOf(isSetSchemaPattern()).compareTo(other.isSetSchemaPattern());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetSchemaPattern()) {
        lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.schemaPattern, other.schemaPattern);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      lastComparison = Boolean.valueOf(isSetTableNamePattern()).compareTo(other.isSetTableNamePattern());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetTableNamePattern()) {
        lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.tableNamePattern, other.tableNamePattern);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      lastComparison = Boolean.valueOf(isSetTypes()).compareTo(other.isSetTypes());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetTypes()) {
        lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.types, other.types);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      return 0;
    }

    public _Fields fieldForId(int fieldId) {
      return _Fields.findByThriftId(fieldId);
    }

    public void read(org.apache.thrift.protocol.TProtocol iprot) throws org.apache.thrift.TException {
      schemes.get(iprot.getScheme()).getScheme().read(iprot, this);
    }

    public void write(org.apache.thrift.protocol.TProtocol oprot) throws org.apache.thrift.TException {
      schemes.get(oprot.getScheme()).getScheme().write(oprot, this);
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("connection_getTables_args(");
      boolean first = true;

      sb.append("connection:");
      if (this.connection == null) {
        sb.append("null");
      } else {
        sb.append(this.connection);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("catalog:");
      if (this.catalog == null) {
        sb.append("null");
      } else {
        sb.append(this.catalog);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("schemaPattern:");
      if (this.schemaPattern == null) {
        sb.append("null");
      } else {
        sb.append(this.schemaPattern);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("tableNamePattern:");
      if (this.tableNamePattern == null) {
        sb.append("null");
      } else {
        sb.append(this.tableNamePattern);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("types:");
      if (this.types == null) {
        sb.append("null");
      } else {
        sb.append(this.types);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws org.apache.thrift.TException {
      // check for required fields
      // check for sub-struct validity
      if (connection != null) {
        connection.validate();
      }
    }

    private void writeObject(java.io.ObjectOutputStream out) throws java.io.IOException {
      try {
        write(new org.apache.thrift.protocol.TCompactProtocol(new org.apache.thrift.transport.TIOStreamTransport(out)));
      } catch (org.apache.thrift.TException te) {
        throw new java.io.IOException(te);
      }
    }

    private void readObject(java.io.ObjectInputStream in) throws java.io.IOException, ClassNotFoundException {
      try {
        read(new org.apache.thrift.protocol.TCompactProtocol(new org.apache.thrift.transport.TIOStreamTransport(in)));
      } catch (org.apache.thrift.TException te) {
        throw new java.io.IOException(te);
      }
    }

    private static class connection_getTables_argsStandardSchemeFactory implements SchemeFactory {
      public connection_getTables_argsStandardScheme getScheme() {
        return new connection_getTables_argsStandardScheme();
      }
    }

    private static class connection_getTables_argsStandardScheme extends StandardScheme<connection_getTables_args> {

      public void read(org.apache.thrift.protocol.TProtocol iprot, connection_getTables_args struct) throws org.apache.thrift.TException {
        org.apache.thrift.protocol.TField schemeField;
        iprot.readStructBegin();
        while (true)
        {
          schemeField = iprot.readFieldBegin();
          if (schemeField.type == org.apache.thrift.protocol.TType.STOP) { 
            break;
          }
          switch (schemeField.id) {
            case 1: // CONNECTION
              if (schemeField.type == org.apache.thrift.protocol.TType.STRUCT) {
                struct.connection = new RConnection();
                struct.connection.read(iprot);
                struct.setConnectionIsSet(true);
              } else { 
                org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
              }
              break;
            case 2: // CATALOG
              if (schemeField.type == org.apache.thrift.protocol.TType.STRING) {
                struct.catalog = iprot.readString();
                struct.setCatalogIsSet(true);
              } else { 
                org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
              }
              break;
            case 3: // SCHEMA_PATTERN
              if (schemeField.type == org.apache.thrift.protocol.TType.STRING) {
                struct.schemaPattern = iprot.readString();
                struct.setSchemaPatternIsSet(true);
              } else { 
                org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
              }
              break;
            case 4: // TABLE_NAME_PATTERN
              if (schemeField.type == org.apache.thrift.protocol.TType.STRING) {
                struct.tableNamePattern = iprot.readString();
                struct.setTableNamePatternIsSet(true);
              } else { 
                org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
              }
              break;
            case 5: // TYPES
              if (schemeField.type == org.apache.thrift.protocol.TType.LIST) {
                {
                  org.apache.thrift.protocol.TList _list50 = iprot.readListBegin();
                  struct.types = new ArrayList<String>(_list50.size);
                  String _elem51;
                  for (int _i52 = 0; _i52 < _list50.size; ++_i52)
                  {
                    _elem51 = iprot.readString();
                    struct.types.add(_elem51);
                  }
                  iprot.readListEnd();
                }
                struct.setTypesIsSet(true);
              } else { 
                org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
              }
              break;
            default:
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
          }
          iprot.readFieldEnd();
        }
        iprot.readStructEnd();

        // check for required fields of primitive type, which can't be checked in the validate method
        struct.validate();
      }

      public void write(org.apache.thrift.protocol.TProtocol oprot, connection_getTables_args struct) throws org.apache.thrift.TException {
        struct.validate();

        oprot.writeStructBegin(STRUCT_DESC);
        if (struct.connection != null) {
          oprot.writeFieldBegin(CONNECTION_FIELD_DESC);
          struct.connection.write(oprot);
          oprot.writeFieldEnd();
        }
        if (struct.catalog != null) {
          oprot.writeFieldBegin(CATALOG_FIELD_DESC);
          oprot.writeString(struct.catalog);
          oprot.writeFieldEnd();
        }
        if (struct.schemaPattern != null) {
          oprot.writeFieldBegin(SCHEMA_PATTERN_FIELD_DESC);
          oprot.writeString(struct.schemaPattern);
          oprot.writeFieldEnd();
        }
        if (struct.tableNamePattern != null) {
          oprot.writeFieldBegin(TABLE_NAME_PATTERN_FIELD_DESC);
          oprot.writeString(struct.tableNamePattern);
          oprot.writeFieldEnd();
        }
        if (struct.types != null) {
          oprot.writeFieldBegin(TYPES_FIELD_DESC);
          {
            oprot.writeListBegin(new org.apache.thrift.protocol.TList(org.apache.thrift.protocol.TType.STRING, struct.types.size()));
            for (String _iter53 : struct.types)
            {
              oprot.writeString(_iter53);
            }
            oprot.writeListEnd();
          }
          oprot.writeFieldEnd();
        }
        oprot.writeFieldStop();
        oprot.writeStructEnd();
      }

    }

    private static class connection_getTables_argsTupleSchemeFactory implements SchemeFactory {
      public connection_getTables_argsTupleScheme getScheme() {
        return new connection_getTables_argsTupleScheme();
      }
    }

    private static class connection_getTables_argsTupleScheme extends TupleScheme<connection_getTables_args> {

      @Override
      public void write(org.apache.thrift.protocol.TProtocol prot, connection_getTables_args struct) throws org.apache.thrift.TException {
        TTupleProtocol oprot = (TTupleProtocol) prot;
        BitSet optionals = new BitSet();
        if (struct.isSetConnection()) {
          optionals.set(0);
        }
        if (struct.isSetCatalog()) {
          optionals.set(1);
        }
        if (struct.isSetSchemaPattern()) {
          optionals.set(2);
        }
        if (struct.isSetTableNamePattern()) {
          optionals.set(3);
        }
        if (struct.isSetTypes()) {
          optionals.set(4);
        }
        oprot.writeBitSet(optionals, 5);
        if (struct.isSetConnection()) {
          struct.connection.write(oprot);
        }
        if (struct.isSetCatalog()) {
          oprot.writeString(struct.catalog);
        }
        if (struct.isSetSchemaPattern()) {
          oprot.writeString(struct.schemaPattern);
        }
        if (struct.isSetTableNamePattern()) {
          oprot.writeString(struct.tableNamePattern);
        }
        if (struct.isSetTypes()) {
          {
            oprot.writeI32(struct.types.size());
            for (String _iter54 : struct.types)
            {
              oprot.writeString(_iter54);
            }
          }
        }
      }

      @Override
      public void read(org.apache.thrift.protocol.TProtocol prot, connection_getTables_args struct) throws org.apache.thrift.TException {
        TTupleProtocol iprot = (TTupleProtocol) prot;
        BitSet incoming = iprot.readBitSet(5);
        if (incoming.get(0)) {
          struct.connection = new RConnection();
          struct.connection.read(iprot);
          struct.setConnectionIsSet(true);
        }
        if (incoming.get(1)) {
          struct.catalog = iprot.readString();
          struct.setCatalogIsSet(true);
        }
        if (incoming.get(2)) {
          struct.schemaPattern = iprot.readString();
          struct.setSchemaPatternIsSet(true);
        }
        if (incoming.get(3)) {
          struct.tableNamePattern = iprot.readString();
          struct.setTableNamePatternIsSet(true);
        }
        if (incoming.get(4)) {
          {
            org.apache.thrift.protocol.TList _list55 = new org.apache.thrift.protocol.TList(org.apache.thrift.protocol.TType.STRING, iprot.readI32());
            struct.types = new ArrayList<String>(_list55.size);
            String _elem56;
            for (int _i57 = 0; _i57 < _list55.size; ++_i57)
            {
              _elem56 = iprot.readString();
              struct.types.add(_elem56);
            }
          }
          struct.setTypesIsSet(true);
        }
      }
    }

  }

  public static class connection_getTables_result implements org.apache.thrift.TBase<connection_getTables_result, connection_getTables_result._Fields>, java.io.Serializable, Cloneable, Comparable<connection_getTables_result>   {
    private static final org.apache.thrift.protocol.TStruct STRUCT_DESC = new org.apache.thrift.protocol.TStruct("connection_getTables_result");

    private static final org.apache.thrift.protocol.TField SUCCESS_FIELD_DESC = new org.apache.thrift.protocol.TField("success", org.apache.thrift.protocol.TType.STRUCT, (short)0);
    private static final org.apache.thrift.protocol.TField SQL_EXCEPTION_FIELD_DESC = new org.apache.thrift.protocol.TField("sqlException", org.apache.thrift.protocol.TType.STRUCT, (short)1);

    private static final Map<Class<? extends IScheme>, SchemeFactory> schemes = new HashMap<Class<? extends IScheme>, SchemeFactory>();
    static {
      schemes.put(StandardScheme.class, new connection_getTables_resultStandardSchemeFactory());
      schemes.put(TupleScheme.class, new connection_getTables_resultTupleSchemeFactory());
    }

    public RResultSet success; // required
    public RSQLException sqlException; // required

    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements org.apache.thrift.TFieldIdEnum {
      SUCCESS((short)0, "success"),
      SQL_EXCEPTION((short)1, "sqlException");

      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        switch(fieldId) {
          case 0: // SUCCESS
            return SUCCESS;
          case 1: // SQL_EXCEPTION
            return SQL_EXCEPTION;
          default:
            return null;
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }

    // isset id assignments
    public static final Map<_Fields, org.apache.thrift.meta_data.FieldMetaData> metaDataMap;
    static {
      Map<_Fields, org.apache.thrift.meta_data.FieldMetaData> tmpMap = new EnumMap<_Fields, org.apache.thrift.meta_data.FieldMetaData>(_Fields.class);
      tmpMap.put(_Fields.SUCCESS, new org.apache.thrift.meta_data.FieldMetaData("success", org.apache.thrift.TFieldRequirementType.DEFAULT, 
          new org.apache.thrift.meta_data.StructMetaData(org.apache.thrift.protocol.TType.STRUCT, RResultSet.class)));
      tmpMap.put(_Fields.SQL_EXCEPTION, new org.apache.thrift.meta_data.FieldMetaData("sqlException", org.apache.thrift.TFieldRequirementType.DEFAULT, 
          new org.apache.thrift.meta_data.FieldValueMetaData(org.apache.thrift.protocol.TType.STRUCT)));
      metaDataMap = Collections.unmodifiableMap(tmpMap);
      org.apache.thrift.meta_data.FieldMetaData.addStructMetaDataMap(connection_getTables_result.class, metaDataMap);
    }

    public connection_getTables_result() {
    }

    public connection_getTables_result(
      RResultSet success,
      RSQLException sqlException)
    {
      this();
      this.success = success;
      this.sqlException = sqlException;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public connection_getTables_result(connection_getTables_result other) {
      if (other.isSetSuccess()) {
        this.success = new RResultSet(other.success);
      }
      if (other.isSetSqlException()) {
        this.sqlException = new RSQLException(other.sqlException);
      }
    }

    public connection_getTables_result deepCopy() {
      return new connection_getTables_result(this);
    }

    @Override
    public void clear() {
      this.success = null;
      this.sqlException = null;
    }

    public RResultSet getSuccess() {
      return this.success;
    }

    public connection_getTables_result setSuccess(RResultSet success) {
      this.success = success;
      return this;
    }

    public void unsetSuccess() {
      this.success = null;
    }

    /** Returns true if field success is set (has been assigned a value) and false otherwise */
    public boolean isSetSuccess() {
      return this.success != null;
    }

    public void setSuccessIsSet(boolean value) {
      if (!value) {
        this.success = null;
      }
    }

    public RSQLException getSqlException() {
      return this.sqlException;
    }

    public connection_getTables_result setSqlException(RSQLException sqlException) {
      this.sqlException = sqlException;
      return this;
    }

    public void unsetSqlException() {
      this.sqlException = null;
    }

    /** Returns true if field sqlException is set (has been assigned a value) and false otherwise */
    public boolean isSetSqlException() {
      return this.sqlException != null;
    }

    public void setSqlExceptionIsSet(boolean value) {
      if (!value) {
        this.sqlException = null;
      }
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          setSuccess((RResultSet)value);
        }
        break;

      case SQL_EXCEPTION:
        if (value == null) {
          unsetSqlException();
        } else {
          setSqlException((RSQLException)value);
        }
        break;

      }
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      case SUCCESS:
        return getSuccess();

      case SQL_EXCEPTION:
        return getSqlException();

      }
      throw new IllegalStateException();
    }

    /** Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      if (field == null) {
        throw new IllegalArgumentException();
      }

      switch (field) {
      case SUCCESS:
        return isSetSuccess();
      case SQL_EXCEPTION:
        return isSetSqlException();
      }
      throw new IllegalStateException();
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof connection_getTables_result)
        return this.equals((connection_getTables_result)that);
      return false;
    }

    public boolean equals(connection_getTables_result that) {
      if (that == null)
        return false;

      boolean this_present_success = true && this.isSetSuccess();
      boolean that_present_success = true && that.isSetSuccess();
      if (this_present_success || that_present_success) {
        if (!(this_present_success && that_present_success))
          return false;
        if (!this.success.equals(that.success))
          return false;
      }

      boolean this_present_sqlException = true && this.isSetSqlException();
      boolean that_present_sqlException = true && that.isSetSqlException();
      if (this_present_sqlException || that_present_sqlException) {
        if (!(this_present_sqlException && that_present_sqlException))
          return false;
        if (!this.sqlException.equals(that.sqlException))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      List<Object> list = new ArrayList<Object>();

      boolean present_success = true && (isSetSuccess());
      list.add(present_success);
      if (present_success)
        list.add(success);

      boolean present_sqlException = true && (isSetSqlException());
      list.add(present_sqlException);
      if (present_sqlException)
        list.add(sqlException);

      return list.hashCode();
    }

    @Override
    public int compareTo(connection_getTables_result other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetSuccess()).compareTo(other.isSetSuccess());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetSuccess()) {
        lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.success, other.success);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      lastComparison = Boolean.valueOf(isSetSqlException()).compareTo(other.isSetSqlException());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetSqlException()) {
        lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.sqlException, other.sqlException);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      return 0;
    }

    public _Fields fieldForId(int fieldId) {
      return _Fields.findByThriftId(fieldId);
    }

    public void read(org.apache.thrift.protocol.TProtocol iprot) throws org.apache.thrift.TException {
      schemes.get(iprot.getScheme()).getScheme().read(iprot, this);
    }

    public void write(org.apache.thrift.protocol.TProtocol oprot) throws org.apache.thrift.TException {
      schemes.get(oprot.getScheme()).getScheme().write(oprot, this);
      }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("connection_getTables_result(");
      boolean first = true;

      sb.append("success:");
      if (this.success == null) {
        sb.append("null");
      } else {
        sb.append(this.success);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("sqlException:");
      if (this.sqlException == null) {
        sb.append("null");
      } else {
        sb.append(this.sqlException);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws org.apache.thrift.TException {
      // check for required fields
      // check for sub-struct validity
      if (success != null) {
        success.validate();
      }
    }

    private void writeObject(java.io.ObjectOutputStream out) throws java.io.IOException {
      try {
        write(new org.apache.thrift.protocol.TCompactProtocol(new org.apache.thrift.transport.TIOStreamTransport(out)));
      } catch (org.apache.thrift.TException te) {
        throw new java.io.IOException(te);
      }
    }

    private void readObject(java.io.ObjectInputStream in) throws java.io.IOException, ClassNotFoundException {
      try {
        read(new org.apache.thrift.protocol.TCompactProtocol(new org.apache.thrift.transport.TIOStreamTransport(in)));
      } catch (org.apache.thrift.TException te) {
        throw new java.io.IOException(te);
      }
    }

    private static class connection_getTables_resultStandardSchemeFactory implements SchemeFactory {
      public connection_getTables_resultStandardScheme getScheme() {
        return new connection_getTables_resultStandardScheme();
      }
    }

    private static class connection_getTables_resultStandardScheme extends StandardScheme<connection_getTables_result> {

      public void read(org.apache.thrift.protocol.TProtocol iprot, connection_getTables_result struct) throws org.apache.thrift.TException {
        org.apache.thrift.protocol.TField schemeField;
        iprot.readStructBegin();
        while (true)
        {
          schemeField = iprot.readFieldBegin();
          if (schemeField.type == org.apache.thrift.protocol.TType.STOP) { 
            break;
          }
          switch (schemeField.id) {
            case 0: // SUCCESS
              if (schemeField.type == org.apache.thrift.protocol.TType.STRUCT) {
                struct.success = new RResultSet();
                struct.success.read(iprot);
                struct.setSuccessIsSet(true);
              } else { 
                org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
              }
              break;
            case 1: // SQL_EXCEPTION
              if (schemeField.type == org.apache.thrift.protocol.TType.STRUCT) {
                struct.sqlException = new RSQLException();
                struct.sqlException.read(iprot);
                struct.setSqlExceptionIsSet(true);
              } else { 
                org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
              }
              break;
            default:
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
          }
          iprot.readFieldEnd();
        }
        iprot.readStructEnd();

        // check for required fields of primitive type, which can't be checked in the validate method
        struct.validate();
      }

      public void write(org.apache.thrift.protocol.TProtocol oprot, connection_getTables_result struct) throws org.apache.thrift.TException {
        struct.validate();

        oprot.writeStructBegin(STRUCT_DESC);
        if (struct.success != null) {
          oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
          struct.success.write(oprot);
          oprot.writeFieldEnd();
        }
        if (struct.sqlException != null) {
          oprot.writeFieldBegin(SQL_EXCEPTION_FIELD_DESC);
          struct.sqlException.write(oprot);
          oprot.writeFieldEnd();
        }
        oprot.writeFieldStop();
        oprot.writeStructEnd();
      }

    }

    private static class connection_getTables_resultTupleSchemeFactory implements SchemeFactory {
      public connection_getTables_resultTupleScheme getScheme() {
        return new connection_getTables_resultTupleScheme();
      }
    }

    private static class connection_getTables_resultTupleScheme extends TupleScheme<connection_getTables_result> {

      @Override
      public void write(org.apache.thrift.protocol.TProtocol prot, connection_getTables_result struct) throws org.apache.thrift.TException {
        TTupleProtocol oprot = (TTupleProtocol) prot;
        BitSet optionals = new BitSet();
        if (struct.isSetSuccess()) {
          optionals.set(0);
        }
        if (struct.isSetSqlException()) {
          optionals.set(1);
        }
        oprot.writeBitSet(optionals, 2);
        if (struct.isSetSuccess()) {
          struct.success.write(oprot);
        }
        if (struct.isSetSqlException()) {
          struct.sqlException.write(oprot);
        }
      }

      @Override
      public void read(org.apache.thrift.protocol.TProtocol prot, connection_getTables_result struct) throws org.apache.thrift.TException {
        TTupleProtocol iprot = (TTupleProtocol) prot;
        BitSet incoming = iprot.readBitSet(2);
        if (incoming.get(0)) {
          struct.success = new RResultSet();
          struct.success.read(iprot);
          struct.setSuccessIsSet(true);
        }
        if (incoming.get(1)) {
          struct.sqlException = new RSQLException();
          struct.sqlException.read(iprot);
          struct.setSqlExceptionIsSet(true);
        }
      }
    }

  }

  public static class connection_getColumns_args implements org.apache.thrift.TBase<connection_getColumns_args, connection_getColumns_args._Fields>, java.io.Serializable, Cloneable, Comparable<connection_getColumns_args>   {
    private static final org.apache.thrift.protocol.TStruct STRUCT_DESC = new org.apache.thrift.protocol.TStruct("connection_getColumns_args");

    private static final org.apache.thrift.protocol.TField CONNECTION_FIELD_DESC = new org.apache.thrift.protocol.TField("connection", org.apache.thrift.protocol.TType.STRUCT, (short)1);
    private static final org.apache.thrift.protocol.TField CATALOG_FIELD_DESC = new org.apache.thrift.protocol.TField("catalog", org.apache.thrift.protocol.TType.STRING, (short)2);
    private static final org.apache.thrift.protocol.TField SCHEMA_PATTERN_FIELD_DESC = new org.apache.thrift.protocol.TField("schemaPattern", org.apache.thrift.protocol.TType.STRING, (short)3);
    private static final org.apache.thrift.protocol.TField TABLE_NAME_PATTERN_FIELD_DESC = new org.apache.thrift.protocol.TField("tableNamePattern", org.apache.thrift.protocol.TType.STRING, (short)4);
    private static final org.apache.thrift.protocol.TField COLUMN_NAME_PATTERN_FIELD_DESC = new org.apache.thrift.protocol.TField("columnNamePattern", org.apache.thrift.protocol.TType.STRING, (short)5);

    private static final Map<Class<? extends IScheme>, SchemeFactory> schemes = new HashMap<Class<? extends IScheme>, SchemeFactory>();
    static {
      schemes.put(StandardScheme.class, new connection_getColumns_argsStandardSchemeFactory());
      schemes.put(TupleScheme.class, new connection_getColumns_argsTupleSchemeFactory());
    }

    public RConnection connection; // required
    public String catalog; // required
    public String schemaPattern; // required
    public String tableNamePattern; // required
    public String columnNamePattern; // required

    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements org.apache.thrift.TFieldIdEnum {
      CONNECTION((short)1, "connection"),
      CATALOG((short)2, "catalog"),
      SCHEMA_PATTERN((short)3, "schemaPattern"),
      TABLE_NAME_PATTERN((short)4, "tableNamePattern"),
      COLUMN_NAME_PATTERN((short)5, "columnNamePattern");

      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        switch(fieldId) {
          case 1: // CONNECTION
            return CONNECTION;
          case 2: // CATALOG
            return CATALOG;
          case 3: // SCHEMA_PATTERN
            return SCHEMA_PATTERN;
          case 4: // TABLE_NAME_PATTERN
            return TABLE_NAME_PATTERN;
          case 5: // COLUMN_NAME_PATTERN
            return COLUMN_NAME_PATTERN;
          default:
            return null;
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }

    // isset id assignments
    public static final Map<_Fields, org.apache.thrift.meta_data.FieldMetaData> metaDataMap;
    static {
      Map<_Fields, org.apache.thrift.meta_data.FieldMetaData> tmpMap = new EnumMap<_Fields, org.apache.thrift.meta_data.FieldMetaData>(_Fields.class);
      tmpMap.put(_Fields.CONNECTION, new org.apache.thrift.meta_data.FieldMetaData("connection", org.apache.thrift.TFieldRequirementType.DEFAULT, 
          new org.apache.thrift.meta_data.StructMetaData(org.apache.thrift.protocol.TType.STRUCT, RConnection.class)));
      tmpMap.put(_Fields.CATALOG, new org.apache.thrift.meta_data.FieldMetaData("catalog", org.apache.thrift.TFieldRequirementType.DEFAULT, 
          new org.apache.thrift.meta_data.FieldValueMetaData(org.apache.thrift.protocol.TType.STRING)));
      tmpMap.put(_Fields.SCHEMA_PATTERN, new org.apache.thrift.meta_data.FieldMetaData("schemaPattern", org.apache.thrift.TFieldRequirementType.DEFAULT, 
          new org.apache.thrift.meta_data.FieldValueMetaData(org.apache.thrift.protocol.TType.STRING)));
      tmpMap.put(_Fields.TABLE_NAME_PATTERN, new org.apache.thrift.meta_data.FieldMetaData("tableNamePattern", org.apache.thrift.TFieldRequirementType.DEFAULT, 
          new org.apache.thrift.meta_data.FieldValueMetaData(org.apache.thrift.protocol.TType.STRING)));
      tmpMap.put(_Fields.COLUMN_NAME_PATTERN, new org.apache.thrift.meta_data.FieldMetaData("columnNamePattern", org.apache.thrift.TFieldRequirementType.DEFAULT, 
          new org.apache.thrift.meta_data.FieldValueMetaData(org.apache.thrift.protocol.TType.STRING)));
      metaDataMap = Collections.unmodifiableMap(tmpMap);
      org.apache.thrift.meta_data.FieldMetaData.addStructMetaDataMap(connection_getColumns_args.class, metaDataMap);
    }

    public connection_getColumns_args() {
    }

    public connection_getColumns_args(
      RConnection connection,
      String catalog,
      String schemaPattern,
      String tableNamePattern,
      String columnNamePattern)
    {
      this();
      this.connection = connection;
      this.catalog = catalog;
      this.schemaPattern = schemaPattern;
      this.tableNamePattern = tableNamePattern;
      this.columnNamePattern = columnNamePattern;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public connection_getColumns_args(connection_getColumns_args other) {
      if (other.isSetConnection()) {
        this.connection = new RConnection(other.connection);
      }
      if (other.isSetCatalog()) {
        this.catalog = other.catalog;
      }
      if (other.isSetSchemaPattern()) {
        this.schemaPattern = other.schemaPattern;
      }
      if (other.isSetTableNamePattern()) {
        this.tableNamePattern = other.tableNamePattern;
      }
      if (other.isSetColumnNamePattern()) {
        this.columnNamePattern = other.columnNamePattern;
      }
    }

    public connection_getColumns_args deepCopy() {
      return new connection_getColumns_args(this);
    }

    @Override
    public void clear() {
      this.connection = null;
      this.catalog = null;
      this.schemaPattern = null;
      this.tableNamePattern = null;
      this.columnNamePattern = null;
    }

    public RConnection getConnection() {
      return this.connection;
    }

    public connection_getColumns_args setConnection(RConnection connection) {
      this.connection = connection;
      return this;
    }

    public void unsetConnection() {
      this.connection = null;
    }

    /** Returns true if field connection is set (has been assigned a value) and false otherwise */
    public boolean isSetConnection() {
      return this.connection != null;
    }

    public void setConnectionIsSet(boolean value) {
      if (!value) {
        this.connection = null;
      }
    }

    public String getCatalog() {
      return this.catalog;
    }

    public connection_getColumns_args setCatalog(String catalog) {
      this.catalog = catalog;
      return this;
    }

    public void unsetCatalog() {
      this.catalog = null;
    }

    /** Returns true if field catalog is set (has been assigned a value) and false otherwise */
    public boolean isSetCatalog() {
      return this.catalog != null;
    }

    public void setCatalogIsSet(boolean value) {
      if (!value) {
        this.catalog = null;
      }
    }

    public String getSchemaPattern() {
      return this.schemaPattern;
    }

    public connection_getColumns_args setSchemaPattern(String schemaPattern) {
      this.schemaPattern = schemaPattern;
      return this;
    }

    public void unsetSchemaPattern() {
      this.schemaPattern = null;
    }

    /** Returns true if field schemaPattern is set (has been assigned a value) and false otherwise */
    public boolean isSetSchemaPattern() {
      return this.schemaPattern != null;
    }

    public void setSchemaPatternIsSet(boolean value) {
      if (!value) {
        this.schemaPattern = null;
      }
    }

    public String getTableNamePattern() {
      return this.tableNamePattern;
    }

    public connection_getColumns_args setTableNamePattern(String tableNamePattern) {
      this.tableNamePattern = tableNamePattern;
      return this;
    }

    public void unsetTableNamePattern() {
      this.tableNamePattern = null;
    }

    /** Returns true if field tableNamePattern is set (has been assigned a value) and false otherwise */
    public boolean isSetTableNamePattern() {
      return this.tableNamePattern != null;
    }

    public void setTableNamePatternIsSet(boolean value) {
      if (!value) {
        this.tableNamePattern = null;
      }
    }

    public String getColumnNamePattern() {
      return this.columnNamePattern;
    }

    public connection_getColumns_args setColumnNamePattern(String columnNamePattern) {
      this.columnNamePattern = columnNamePattern;
      return this;
    }

    public void unsetColumnNamePattern() {
      this.columnNamePattern = null;
    }

    /** Returns true if field columnNamePattern is set (has been assigned a value) and false otherwise */
    public boolean isSetColumnNamePattern() {
      return this.columnNamePattern != null;
    }

    public void setColumnNamePatternIsSet(boolean value) {
      if (!value) {
        this.columnNamePattern = null;
      }
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      case CONNECTION:
        if (value == null) {
          unsetConnection();
        } else {
          setConnection((RConnection)value);
        }
        break;

      case CATALOG:
        if (value == null) {
          unsetCatalog();
        } else {
          setCatalog((String)value);
        }
        break;

      case SCHEMA_PATTERN:
        if (value == null) {
          unsetSchemaPattern();
        } else {
          setSchemaPattern((String)value);
        }
        break;

      case TABLE_NAME_PATTERN:
        if (value == null) {
          unsetTableNamePattern();
        } else {
          setTableNamePattern((String)value);
        }
        break;

      case COLUMN_NAME_PATTERN:
        if (value == null) {
          unsetColumnNamePattern();
        } else {
          setColumnNamePattern((String)value);
        }
        break;

      }
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      case CONNECTION:
        return getConnection();

      case CATALOG:
        return getCatalog();

      case SCHEMA_PATTERN:
        return getSchemaPattern();

      case TABLE_NAME_PATTERN:
        return getTableNamePattern();

      case COLUMN_NAME_PATTERN:
        return getColumnNamePattern();

      }
      throw new IllegalStateException();
    }

    /** Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      if (field == null) {
        throw new IllegalArgumentException();
      }

      switch (field) {
      case CONNECTION:
        return isSetConnection();
      case CATALOG:
        return isSetCatalog();
      case SCHEMA_PATTERN:
        return isSetSchemaPattern();
      case TABLE_NAME_PATTERN:
        return isSetTableNamePattern();
      case COLUMN_NAME_PATTERN:
        return isSetColumnNamePattern();
      }
      throw new IllegalStateException();
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof connection_getColumns_args)
        return this.equals((connection_getColumns_args)that);
      return false;
    }

    public boolean equals(connection_getColumns_args that) {
      if (that == null)
        return false;

      boolean this_present_connection = true && this.isSetConnection();
      boolean that_present_connection = true && that.isSetConnection();
      if (this_present_connection || that_present_connection) {
        if (!(this_present_connection && that_present_connection))
          return false;
        if (!this.connection.equals(that.connection))
          return false;
      }

      boolean this_present_catalog = true && this.isSetCatalog();
      boolean that_present_catalog = true && that.isSetCatalog();
      if (this_present_catalog || that_present_catalog) {
        if (!(this_present_catalog && that_present_catalog))
          return false;
        if (!this.catalog.equals(that.catalog))
          return false;
      }

      boolean this_present_schemaPattern = true && this.isSetSchemaPattern();
      boolean that_present_schemaPattern = true && that.isSetSchemaPattern();
      if (this_present_schemaPattern || that_present_schemaPattern) {
        if (!(this_present_schemaPattern && that_present_schemaPattern))
          return false;
        if (!this.schemaPattern.equals(that.schemaPattern))
          return false;
      }

      boolean this_present_tableNamePattern = true && this.isSetTableNamePattern();
      boolean that_present_tableNamePattern = true && that.isSetTableNamePattern();
      if (this_present_tableNamePattern || that_present_tableNamePattern) {
        if (!(this_present_tableNamePattern && that_present_tableNamePattern))
          return false;
        if (!this.tableNamePattern.equals(that.tableNamePattern))
          return false;
      }

      boolean this_present_columnNamePattern = true && this.isSetColumnNamePattern();
      boolean that_present_columnNamePattern = true && that.isSetColumnNamePattern();
      if (this_present_columnNamePattern || that_present_columnNamePattern) {
        if (!(this_present_columnNamePattern && that_present_columnNamePattern))
          return false;
        if (!this.columnNamePattern.equals(that.columnNamePattern))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      List<Object> list = new ArrayList<Object>();

      boolean present_connection = true && (isSetConnection());
      list.add(present_connection);
      if (present_connection)
        list.add(connection);

      boolean present_catalog = true && (isSetCatalog());
      list.add(present_catalog);
      if (present_catalog)
        list.add(catalog);

      boolean present_schemaPattern = true && (isSetSchemaPattern());
      list.add(present_schemaPattern);
      if (present_schemaPattern)
        list.add(schemaPattern);

      boolean present_tableNamePattern = true && (isSetTableNamePattern());
      list.add(present_tableNamePattern);
      if (present_tableNamePattern)
        list.add(tableNamePattern);

      boolean present_columnNamePattern = true && (isSetColumnNamePattern());
      list.add(present_columnNamePattern);
      if (present_columnNamePattern)
        list.add(columnNamePattern);

      return list.hashCode();
    }

    @Override
    public int compareTo(connection_getColumns_args other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetConnection()).compareTo(other.isSetConnection());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetConnection()) {
        lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.connection, other.connection);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      lastComparison = Boolean.valueOf(isSetCatalog()).compareTo(other.isSetCatalog());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetCatalog()) {
        lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.catalog, other.catalog);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      lastComparison = Boolean.valueOf(isSetSchemaPattern()).compareTo(other.isSetSchemaPattern());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetSchemaPattern()) {
        lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.schemaPattern, other.schemaPattern);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      lastComparison = Boolean.valueOf(isSetTableNamePattern()).compareTo(other.isSetTableNamePattern());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetTableNamePattern()) {
        lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.tableNamePattern, other.tableNamePattern);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      lastComparison = Boolean.valueOf(isSetColumnNamePattern()).compareTo(other.isSetColumnNamePattern());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetColumnNamePattern()) {
        lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.columnNamePattern, other.columnNamePattern);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      return 0;
    }

    public _Fields fieldForId(int fieldId) {
      return _Fields.findByThriftId(fieldId);
    }

    public void read(org.apache.thrift.protocol.TProtocol iprot) throws org.apache.thrift.TException {
      schemes.get(iprot.getScheme()).getScheme().read(iprot, this);
    }

    public void write(org.apache.thrift.protocol.TProtocol oprot) throws org.apache.thrift.TException {
      schemes.get(oprot.getScheme()).getScheme().write(oprot, this);
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("connection_getColumns_args(");
      boolean first = true;

      sb.append("connection:");
      if (this.connection == null) {
        sb.append("null");
      } else {
        sb.append(this.connection);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("catalog:");
      if (this.catalog == null) {
        sb.append("null");
      } else {
        sb.append(this.catalog);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("schemaPattern:");
      if (this.schemaPattern == null) {
        sb.append("null");
      } else {
        sb.append(this.schemaPattern);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("tableNamePattern:");
      if (this.tableNamePattern == null) {
        sb.append("null");
      } else {
        sb.append(this.tableNamePattern);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("columnNamePattern:");
      if (this.columnNamePattern == null) {
        sb.append("null");
      } else {
        sb.append(this.columnNamePattern);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws org.apache.thrift.TException {
      // check for required fields
      // check for sub-struct validity
      if (connection != null) {
        connection.validate();
      }
    }

    private void writeObject(java.io.ObjectOutputStream out) throws java.io.IOException {
      try {
        write(new org.apache.thrift.protocol.TCompactProtocol(new org.apache.thrift.transport.TIOStreamTransport(out)));
      } catch (org.apache.thrift.TException te) {
        throw new java.io.IOException(te);
      }
    }

    private void readObject(java.io.ObjectInputStream in) throws java.io.IOException, ClassNotFoundException {
      try {
        read(new org.apache.thrift.protocol.TCompactProtocol(new org.apache.thrift.transport.TIOStreamTransport(in)));
      } catch (org.apache.thrift.TException te) {
        throw new java.io.IOException(te);
      }
    }

    private static class connection_getColumns_argsStandardSchemeFactory implements SchemeFactory {
      public connection_getColumns_argsStandardScheme getScheme() {
        return new connection_getColumns_argsStandardScheme();
      }
    }

    private static class connection_getColumns_argsStandardScheme extends StandardScheme<connection_getColumns_args> {

      public void read(org.apache.thrift.protocol.TProtocol iprot, connection_getColumns_args struct) throws org.apache.thrift.TException {
        org.apache.thrift.protocol.TField schemeField;
        iprot.readStructBegin();
        while (true)
        {
          schemeField = iprot.readFieldBegin();
          if (schemeField.type == org.apache.thrift.protocol.TType.STOP) { 
            break;
          }
          switch (schemeField.id) {
            case 1: // CONNECTION
              if (schemeField.type == org.apache.thrift.protocol.TType.STRUCT) {
                struct.connection = new RConnection();
                struct.connection.read(iprot);
                struct.setConnectionIsSet(true);
              } else { 
                org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
              }
              break;
            case 2: // CATALOG
              if (schemeField.type == org.apache.thrift.protocol.TType.STRING) {
                struct.catalog = iprot.readString();
                struct.setCatalogIsSet(true);
              } else { 
                org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
              }
              break;
            case 3: // SCHEMA_PATTERN
              if (schemeField.type == org.apache.thrift.protocol.TType.STRING) {
                struct.schemaPattern = iprot.readString();
                struct.setSchemaPatternIsSet(true);
              } else { 
                org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
              }
              break;
            case 4: // TABLE_NAME_PATTERN
              if (schemeField.type == org.apache.thrift.protocol.TType.STRING) {
                struct.tableNamePattern = iprot.readString();
                struct.setTableNamePatternIsSet(true);
              } else { 
                org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
              }
              break;
            case 5: // COLUMN_NAME_PATTERN
              if (schemeField.type == org.apache.thrift.protocol.TType.STRING) {
                struct.columnNamePattern = iprot.readString();
                struct.setColumnNamePatternIsSet(true);
              } else { 
                org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
              }
              break;
            default:
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
          }
          iprot.readFieldEnd();
        }
        iprot.readStructEnd();

        // check for required fields of primitive type, which can't be checked in the validate method
        struct.validate();
      }

      public void write(org.apache.thrift.protocol.TProtocol oprot, connection_getColumns_args struct) throws org.apache.thrift.TException {
        struct.validate();

        oprot.writeStructBegin(STRUCT_DESC);
        if (struct.connection != null) {
          oprot.writeFieldBegin(CONNECTION_FIELD_DESC);
          struct.connection.write(oprot);
          oprot.writeFieldEnd();
        }
        if (struct.catalog != null) {
          oprot.writeFieldBegin(CATALOG_FIELD_DESC);
          oprot.writeString(struct.catalog);
          oprot.writeFieldEnd();
        }
        if (struct.schemaPattern != null) {
          oprot.writeFieldBegin(SCHEMA_PATTERN_FIELD_DESC);
          oprot.writeString(struct.schemaPattern);
          oprot.writeFieldEnd();
        }
        if (struct.tableNamePattern != null) {
          oprot.writeFieldBegin(TABLE_NAME_PATTERN_FIELD_DESC);
          oprot.writeString(struct.tableNamePattern);
          oprot.writeFieldEnd();
        }
        if (struct.columnNamePattern != null) {
          oprot.writeFieldBegin(COLUMN_NAME_PATTERN_FIELD_DESC);
          oprot.writeString(struct.columnNamePattern);
          oprot.writeFieldEnd();
        }
        oprot.writeFieldStop();
        oprot.writeStructEnd();
      }

    }

    private static class connection_getColumns_argsTupleSchemeFactory implements SchemeFactory {
      public connection_getColumns_argsTupleScheme getScheme() {
        return new connection_getColumns_argsTupleScheme();
      }
    }

    private static class connection_getColumns_argsTupleScheme extends TupleScheme<connection_getColumns_args> {

      @Override
      public void write(org.apache.thrift.protocol.TProtocol prot, connection_getColumns_args struct) throws org.apache.thrift.TException {
        TTupleProtocol oprot = (TTupleProtocol) prot;
        BitSet optionals = new BitSet();
        if (struct.isSetConnection()) {
          optionals.set(0);
        }
        if (struct.isSetCatalog()) {
          optionals.set(1);
        }
        if (struct.isSetSchemaPattern()) {
          optionals.set(2);
        }
        if (struct.isSetTableNamePattern()) {
          optionals.set(3);
        }
        if (struct.isSetColumnNamePattern()) {
          optionals.set(4);
        }
        oprot.writeBitSet(optionals, 5);
        if (struct.isSetConnection()) {
          struct.connection.write(oprot);
        }
        if (struct.isSetCatalog()) {
          oprot.writeString(struct.catalog);
        }
        if (struct.isSetSchemaPattern()) {
          oprot.writeString(struct.schemaPattern);
        }
        if (struct.isSetTableNamePattern()) {
          oprot.writeString(struct.tableNamePattern);
        }
        if (struct.isSetColumnNamePattern()) {
          oprot.writeString(struct.columnNamePattern);
        }
      }

      @Override
      public void read(org.apache.thrift.protocol.TProtocol prot, connection_getColumns_args struct) throws org.apache.thrift.TException {
        TTupleProtocol iprot = (TTupleProtocol) prot;
        BitSet incoming = iprot.readBitSet(5);
        if (incoming.get(0)) {
          struct.connection = new RConnection();
          struct.connection.read(iprot);
          struct.setConnectionIsSet(true);
        }
        if (incoming.get(1)) {
          struct.catalog = iprot.readString();
          struct.setCatalogIsSet(true);
        }
        if (incoming.get(2)) {
          struct.schemaPattern = iprot.readString();
          struct.setSchemaPatternIsSet(true);
        }
        if (incoming.get(3)) {
          struct.tableNamePattern = iprot.readString();
          struct.setTableNamePatternIsSet(true);
        }
        if (incoming.get(4)) {
          struct.columnNamePattern = iprot.readString();
          struct.setColumnNamePatternIsSet(true);
        }
      }
    }

  }

  public static class connection_getColumns_result implements org.apache.thrift.TBase<connection_getColumns_result, connection_getColumns_result._Fields>, java.io.Serializable, Cloneable, Comparable<connection_getColumns_result>   {
    private static final org.apache.thrift.protocol.TStruct STRUCT_DESC = new org.apache.thrift.protocol.TStruct("connection_getColumns_result");

    private static final org.apache.thrift.protocol.TField SUCCESS_FIELD_DESC = new org.apache.thrift.protocol.TField("success", org.apache.thrift.protocol.TType.STRUCT, (short)0);
    private static final org.apache.thrift.protocol.TField SQL_EXCEPTION_FIELD_DESC = new org.apache.thrift.protocol.TField("sqlException", org.apache.thrift.protocol.TType.STRUCT, (short)1);

    private static final Map<Class<? extends IScheme>, SchemeFactory> schemes = new HashMap<Class<? extends IScheme>, SchemeFactory>();
    static {
      schemes.put(StandardScheme.class, new connection_getColumns_resultStandardSchemeFactory());
      schemes.put(TupleScheme.class, new connection_getColumns_resultTupleSchemeFactory());
    }

    public RResultSet success; // required
    public RSQLException sqlException; // required

    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements org.apache.thrift.TFieldIdEnum {
      SUCCESS((short)0, "success"),
      SQL_EXCEPTION((short)1, "sqlException");

      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        switch(fieldId) {
          case 0: // SUCCESS
            return SUCCESS;
          case 1: // SQL_EXCEPTION
            return SQL_EXCEPTION;
          default:
            return null;
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }

    // isset id assignments
    public static final Map<_Fields, org.apache.thrift.meta_data.FieldMetaData> metaDataMap;
    static {
      Map<_Fields, org.apache.thrift.meta_data.FieldMetaData> tmpMap = new EnumMap<_Fields, org.apache.thrift.meta_data.FieldMetaData>(_Fields.class);
      tmpMap.put(_Fields.SUCCESS, new org.apache.thrift.meta_data.FieldMetaData("success", org.apache.thrift.TFieldRequirementType.DEFAULT, 
          new org.apache.thrift.meta_data.StructMetaData(org.apache.thrift.protocol.TType.STRUCT, RResultSet.class)));
      tmpMap.put(_Fields.SQL_EXCEPTION, new org.apache.thrift.meta_data.FieldMetaData("sqlException", org.apache.thrift.TFieldRequirementType.DEFAULT, 
          new org.apache.thrift.meta_data.FieldValueMetaData(org.apache.thrift.protocol.TType.STRUCT)));
      metaDataMap = Collections.unmodifiableMap(tmpMap);
      org.apache.thrift.meta_data.FieldMetaData.addStructMetaDataMap(connection_getColumns_result.class, metaDataMap);
    }

    public connection_getColumns_result() {
    }

    public connection_getColumns_result(
      RResultSet success,
      RSQLException sqlException)
    {
      this();
      this.success = success;
      this.sqlException = sqlException;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public connection_getColumns_result(connection_getColumns_result other) {
      if (other.isSetSuccess()) {
        this.success = new RResultSet(other.success);
      }
      if (other.isSetSqlException()) {
        this.sqlException = new RSQLException(other.sqlException);
      }
    }

    public connection_getColumns_result deepCopy() {
      return new connection_getColumns_result(this);
    }

    @Override
    public void clear() {
      this.success = null;
      this.sqlException = null;
    }

    public RResultSet getSuccess() {
      return this.success;
    }

    public connection_getColumns_result setSuccess(RResultSet success) {
      this.success = success;
      return this;
    }

    public void unsetSuccess() {
      this.success = null;
    }

    /** Returns true if field success is set (has been assigned a value) and false otherwise */
    public boolean isSetSuccess() {
      return this.success != null;
    }

    public void setSuccessIsSet(boolean value) {
      if (!value) {
        this.success = null;
      }
    }

    public RSQLException getSqlException() {
      return this.sqlException;
    }

    public connection_getColumns_result setSqlException(RSQLException sqlException) {
      this.sqlException = sqlException;
      return this;
    }

    public void unsetSqlException() {
      this.sqlException = null;
    }

    /** Returns true if field sqlException is set (has been assigned a value) and false otherwise */
    public boolean isSetSqlException() {
      return this.sqlException != null;
    }

    public void setSqlExceptionIsSet(boolean value) {
      if (!value) {
        this.sqlException = null;
      }
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          setSuccess((RResultSet)value);
        }
        break;

      case SQL_EXCEPTION:
        if (value == null) {
          unsetSqlException();
        } else {
          setSqlException((RSQLException)value);
        }
        break;

      }
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      case SUCCESS:
        return getSuccess();

      case SQL_EXCEPTION:
        return getSqlException();

      }
      throw new IllegalStateException();
    }

    /** Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      if (field == null) {
        throw new IllegalArgumentException();
      }

      switch (field) {
      case SUCCESS:
        return isSetSuccess();
      case SQL_EXCEPTION:
        return isSetSqlException();
      }
      throw new IllegalStateException();
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof connection_getColumns_result)
        return this.equals((connection_getColumns_result)that);
      return false;
    }

    public boolean equals(connection_getColumns_result that) {
      if (that == null)
        return false;

      boolean this_present_success = true && this.isSetSuccess();
      boolean that_present_success = true && that.isSetSuccess();
      if (this_present_success || that_present_success) {
        if (!(this_present_success && that_present_success))
          return false;
        if (!this.success.equals(that.success))
          return false;
      }

      boolean this_present_sqlException = true && this.isSetSqlException();
      boolean that_present_sqlException = true && that.isSetSqlException();
      if (this_present_sqlException || that_present_sqlException) {
        if (!(this_present_sqlException && that_present_sqlException))
          return false;
        if (!this.sqlException.equals(that.sqlException))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      List<Object> list = new ArrayList<Object>();

      boolean present_success = true && (isSetSuccess());
      list.add(present_success);
      if (present_success)
        list.add(success);

      boolean present_sqlException = true && (isSetSqlException());
      list.add(present_sqlException);
      if (present_sqlException)
        list.add(sqlException);

      return list.hashCode();
    }

    @Override
    public int compareTo(connection_getColumns_result other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetSuccess()).compareTo(other.isSetSuccess());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetSuccess()) {
        lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.success, other.success);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      lastComparison = Boolean.valueOf(isSetSqlException()).compareTo(other.isSetSqlException());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetSqlException()) {
        lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.sqlException, other.sqlException);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      return 0;
    }

    public _Fields fieldForId(int fieldId) {
      return _Fields.findByThriftId(fieldId);
    }

    public void read(org.apache.thrift.protocol.TProtocol iprot) throws org.apache.thrift.TException {
      schemes.get(iprot.getScheme()).getScheme().read(iprot, this);
    }

    public void write(org.apache.thrift.protocol.TProtocol oprot) throws org.apache.thrift.TException {
      schemes.get(oprot.getScheme()).getScheme().write(oprot, this);
      }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("connection_getColumns_result(");
      boolean first = true;

      sb.append("success:");
      if (this.success == null) {
        sb.append("null");
      } else {
        sb.append(this.success);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("sqlException:");
      if (this.sqlException == null) {
        sb.append("null");
      } else {
        sb.append(this.sqlException);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws org.apache.thrift.TException {
      // check for required fields
      // check for sub-struct validity
      if (success != null) {
        success.validate();
      }
    }

    private void writeObject(java.io.ObjectOutputStream out) throws java.io.IOException {
      try {
        write(new org.apache.thrift.protocol.TCompactProtocol(new org.apache.thrift.transport.TIOStreamTransport(out)));
      } catch (org.apache.thrift.TException te) {
        throw new java.io.IOException(te);
      }
    }

    private void readObject(java.io.ObjectInputStream in) throws java.io.IOException, ClassNotFoundException {
      try {
        read(new org.apache.thrift.protocol.TCompactProtocol(new org.apache.thrift.transport.TIOStreamTransport(in)));
      } catch (org.apache.thrift.TException te) {
        throw new java.io.IOException(te);
      }
    }

    private static class connection_getColumns_resultStandardSchemeFactory implements SchemeFactory {
      public connection_getColumns_resultStandardScheme getScheme() {
        return new connection_getColumns_resultStandardScheme();
      }
    }

    private static class connection_getColumns_resultStandardScheme extends StandardScheme<connection_getColumns_result> {

      public void read(org.apache.thrift.protocol.TProtocol iprot, connection_getColumns_result struct) throws org.apache.thrift.TException {
        org.apache.thrift.protocol.TField schemeField;
        iprot.readStructBegin();
        while (true)
        {
          schemeField = iprot.readFieldBegin();
          if (schemeField.type == org.apache.thrift.protocol.TType.STOP) { 
            break;
          }
          switch (schemeField.id) {
            case 0: // SUCCESS
              if (schemeField.type == org.apache.thrift.protocol.TType.STRUCT) {
                struct.success = new RResultSet();
                struct.success.read(iprot);
                struct.setSuccessIsSet(true);
              } else { 
                org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
              }
              break;
            case 1: // SQL_EXCEPTION
              if (schemeField.type == org.apache.thrift.protocol.TType.STRUCT) {
                struct.sqlException = new RSQLException();
                struct.sqlException.read(iprot);
                struct.setSqlExceptionIsSet(true);
              } else { 
                org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
              }
              break;
            default:
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
          }
          iprot.readFieldEnd();
        }
        iprot.readStructEnd();

        // check for required fields of primitive type, which can't be checked in the validate method
        struct.validate();
      }

      public void write(org.apache.thrift.protocol.TProtocol oprot, connection_getColumns_result struct) throws org.apache.thrift.TException {
        struct.validate();

        oprot.writeStructBegin(STRUCT_DESC);
        if (struct.success != null) {
          oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
          struct.success.write(oprot);
          oprot.writeFieldEnd();
        }
        if (struct.sqlException != null) {
          oprot.writeFieldBegin(SQL_EXCEPTION_FIELD_DESC);
          struct.sqlException.write(oprot);
          oprot.writeFieldEnd();
        }
        oprot.writeFieldStop();
        oprot.writeStructEnd();
      }

    }

    private static class connection_getColumns_resultTupleSchemeFactory implements SchemeFactory {
      public connection_getColumns_resultTupleScheme getScheme() {
        return new connection_getColumns_resultTupleScheme();
      }
    }

    private static class connection_getColumns_resultTupleScheme extends TupleScheme<connection_getColumns_result> {

      @Override
      public void write(org.apache.thrift.protocol.TProtocol prot, connection_getColumns_result struct) throws org.apache.thrift.TException {
        TTupleProtocol oprot = (TTupleProtocol) prot;
        BitSet optionals = new BitSet();
        if (struct.isSetSuccess()) {
          optionals.set(0);
        }
        if (struct.isSetSqlException()) {
          optionals.set(1);
        }
        oprot.writeBitSet(optionals, 2);
        if (struct.isSetSuccess()) {
          struct.success.write(oprot);
        }
        if (struct.isSetSqlException()) {
          struct.sqlException.write(oprot);
        }
      }

      @Override
      public void read(org.apache.thrift.protocol.TProtocol prot, connection_getColumns_result struct) throws org.apache.thrift.TException {
        TTupleProtocol iprot = (TTupleProtocol) prot;
        BitSet incoming = iprot.readBitSet(2);
        if (incoming.get(0)) {
          struct.success = new RResultSet();
          struct.success.read(iprot);
          struct.setSuccessIsSet(true);
        }
        if (incoming.get(1)) {
          struct.sqlException = new RSQLException();
          struct.sqlException.read(iprot);
          struct.setSqlExceptionIsSet(true);
        }
      }
    }

  }

  public static class connection_getSQLKeywords_args implements org.apache.thrift.TBase<connection_getSQLKeywords_args, connection_getSQLKeywords_args._Fields>, java.io.Serializable, Cloneable, Comparable<connection_getSQLKeywords_args>   {
    private static final org.apache.thrift.protocol.TStruct STRUCT_DESC = new org.apache.thrift.protocol.TStruct("connection_getSQLKeywords_args");

    private static final org.apache.thrift.protocol.TField CONNECTION_FIELD_DESC = new org.apache.thrift.protocol.TField("connection", org.apache.thrift.protocol.TType.STRUCT, (short)1);

    private static final Map<Class<? extends IScheme>, SchemeFactory> schemes = new HashMap<Class<? extends IScheme>, SchemeFactory>();
    static {
      schemes.put(StandardScheme.class, new connection_getSQLKeywords_argsStandardSchemeFactory());
      schemes.put(TupleScheme.class, new connection_getSQLKeywords_argsTupleSchemeFactory());
    }

    public RConnection connection; // required

    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements org.apache.thrift.TFieldIdEnum {
      CONNECTION((short)1, "connection");

      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        switch(fieldId) {
          case 1: // CONNECTION
            return CONNECTION;
          default:
            return null;
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }

    // isset id assignments
    public static final Map<_Fields, org.apache.thrift.meta_data.FieldMetaData> metaDataMap;
    static {
      Map<_Fields, org.apache.thrift.meta_data.FieldMetaData> tmpMap = new EnumMap<_Fields, org.apache.thrift.meta_data.FieldMetaData>(_Fields.class);
      tmpMap.put(_Fields.CONNECTION, new org.apache.thrift.meta_data.FieldMetaData("connection", org.apache.thrift.TFieldRequirementType.DEFAULT, 
          new org.apache.thrift.meta_data.StructMetaData(org.apache.thrift.protocol.TType.STRUCT, RConnection.class)));
      metaDataMap = Collections.unmodifiableMap(tmpMap);
      org.apache.thrift.meta_data.FieldMetaData.addStructMetaDataMap(connection_getSQLKeywords_args.class, metaDataMap);
    }

    public connection_getSQLKeywords_args() {
    }

    public connection_getSQLKeywords_args(
      RConnection connection)
    {
      this();
      this.connection = connection;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public connection_getSQLKeywords_args(connection_getSQLKeywords_args other) {
      if (other.isSetConnection()) {
        this.connection = new RConnection(other.connection);
      }
    }

    public connection_getSQLKeywords_args deepCopy() {
      return new connection_getSQLKeywords_args(this);
    }

    @Override
    public void clear() {
      this.connection = null;
    }

    public RConnection getConnection() {
      return this.connection;
    }

    public connection_getSQLKeywords_args setConnection(RConnection connection) {
      this.connection = connection;
      return this;
    }

    public void unsetConnection() {
      this.connection = null;
    }

    /** Returns true if field connection is set (has been assigned a value) and false otherwise */
    public boolean isSetConnection() {
      return this.connection != null;
    }

    public void setConnectionIsSet(boolean value) {
      if (!value) {
        this.connection = null;
      }
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      case CONNECTION:
        if (value == null) {
          unsetConnection();
        } else {
          setConnection((RConnection)value);
        }
        break;

      }
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      case CONNECTION:
        return getConnection();

      }
      throw new IllegalStateException();
    }

    /** Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      if (field == null) {
        throw new IllegalArgumentException();
      }

      switch (field) {
      case CONNECTION:
        return isSetConnection();
      }
      throw new IllegalStateException();
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof connection_getSQLKeywords_args)
        return this.equals((connection_getSQLKeywords_args)that);
      return false;
    }

    public boolean equals(connection_getSQLKeywords_args that) {
      if (that == null)
        return false;

      boolean this_present_connection = true && this.isSetConnection();
      boolean that_present_connection = true && that.isSetConnection();
      if (this_present_connection || that_present_connection) {
        if (!(this_present_connection && that_present_connection))
          return false;
        if (!this.connection.equals(that.connection))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      List<Object> list = new ArrayList<Object>();

      boolean present_connection = true && (isSetConnection());
      list.add(present_connection);
      if (present_connection)
        list.add(connection);

      return list.hashCode();
    }

    @Override
    public int compareTo(connection_getSQLKeywords_args other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetConnection()).compareTo(other.isSetConnection());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetConnection()) {
        lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.connection, other.connection);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      return 0;
    }

    public _Fields fieldForId(int fieldId) {
      return _Fields.findByThriftId(fieldId);
    }

    public void read(org.apache.thrift.protocol.TProtocol iprot) throws org.apache.thrift.TException {
      schemes.get(iprot.getScheme()).getScheme().read(iprot, this);
    }

    public void write(org.apache.thrift.protocol.TProtocol oprot) throws org.apache.thrift.TException {
      schemes.get(oprot.getScheme()).getScheme().write(oprot, this);
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("connection_getSQLKeywords_args(");
      boolean first = true;

      sb.append("connection:");
      if (this.connection == null) {
        sb.append("null");
      } else {
        sb.append(this.connection);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws org.apache.thrift.TException {
      // check for required fields
      // check for sub-struct validity
      if (connection != null) {
        connection.validate();
      }
    }

    private void writeObject(java.io.ObjectOutputStream out) throws java.io.IOException {
      try {
        write(new org.apache.thrift.protocol.TCompactProtocol(new org.apache.thrift.transport.TIOStreamTransport(out)));
      } catch (org.apache.thrift.TException te) {
        throw new java.io.IOException(te);
      }
    }

    private void readObject(java.io.ObjectInputStream in) throws java.io.IOException, ClassNotFoundException {
      try {
        read(new org.apache.thrift.protocol.TCompactProtocol(new org.apache.thrift.transport.TIOStreamTransport(in)));
      } catch (org.apache.thrift.TException te) {
        throw new java.io.IOException(te);
      }
    }

    private static class connection_getSQLKeywords_argsStandardSchemeFactory implements SchemeFactory {
      public connection_getSQLKeywords_argsStandardScheme getScheme() {
        return new connection_getSQLKeywords_argsStandardScheme();
      }
    }

    private static class connection_getSQLKeywords_argsStandardScheme extends StandardScheme<connection_getSQLKeywords_args> {

      public void read(org.apache.thrift.protocol.TProtocol iprot, connection_getSQLKeywords_args struct) throws org.apache.thrift.TException {
        org.apache.thrift.protocol.TField schemeField;
        iprot.readStructBegin();
        while (true)
        {
          schemeField = iprot.readFieldBegin();
          if (schemeField.type == org.apache.thrift.protocol.TType.STOP) { 
            break;
          }
          switch (schemeField.id) {
            case 1: // CONNECTION
              if (schemeField.type == org.apache.thrift.protocol.TType.STRUCT) {
                struct.connection = new RConnection();
                struct.connection.read(iprot);
                struct.setConnectionIsSet(true);
              } else { 
                org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
              }
              break;
            default:
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
          }
          iprot.readFieldEnd();
        }
        iprot.readStructEnd();

        // check for required fields of primitive type, which can't be checked in the validate method
        struct.validate();
      }

      public void write(org.apache.thrift.protocol.TProtocol oprot, connection_getSQLKeywords_args struct) throws org.apache.thrift.TException {
        struct.validate();

        oprot.writeStructBegin(STRUCT_DESC);
        if (struct.connection != null) {
          oprot.writeFieldBegin(CONNECTION_FIELD_DESC);
          struct.connection.write(oprot);
          oprot.writeFieldEnd();
        }
        oprot.writeFieldStop();
        oprot.writeStructEnd();
      }

    }

    private static class connection_getSQLKeywords_argsTupleSchemeFactory implements SchemeFactory {
      public connection_getSQLKeywords_argsTupleScheme getScheme() {
        return new connection_getSQLKeywords_argsTupleScheme();
      }
    }

    private static class connection_getSQLKeywords_argsTupleScheme extends TupleScheme<connection_getSQLKeywords_args> {

      @Override
      public void write(org.apache.thrift.protocol.TProtocol prot, connection_getSQLKeywords_args struct) throws org.apache.thrift.TException {
        TTupleProtocol oprot = (TTupleProtocol) prot;
        BitSet optionals = new BitSet();
        if (struct.isSetConnection()) {
          optionals.set(0);
        }
        oprot.writeBitSet(optionals, 1);
        if (struct.isSetConnection()) {
          struct.connection.write(oprot);
        }
      }

      @Override
      public void read(org.apache.thrift.protocol.TProtocol prot, connection_getSQLKeywords_args struct) throws org.apache.thrift.TException {
        TTupleProtocol iprot = (TTupleProtocol) prot;
        BitSet incoming = iprot.readBitSet(1);
        if (incoming.get(0)) {
          struct.connection = new RConnection();
          struct.connection.read(iprot);
          struct.setConnectionIsSet(true);
        }
      }
    }

  }

  public static class connection_getSQLKeywords_result implements org.apache.thrift.TBase<connection_getSQLKeywords_result, connection_getSQLKeywords_result._Fields>, java.io.Serializable, Cloneable, Comparable<connection_getSQLKeywords_result>   {
    private static final org.apache.thrift.protocol.TStruct STRUCT_DESC = new org.apache.thrift.protocol.TStruct("connection_getSQLKeywords_result");

    private static final org.apache.thrift.protocol.TField SUCCESS_FIELD_DESC = new org.apache.thrift.protocol.TField("success", org.apache.thrift.protocol.TType.STRING, (short)0);
    private static final org.apache.thrift.protocol.TField SQL_EXCEPTION_FIELD_DESC = new org.apache.thrift.protocol.TField("sqlException", org.apache.thrift.protocol.TType.STRUCT, (short)1);

    private static final Map<Class<? extends IScheme>, SchemeFactory> schemes = new HashMap<Class<? extends IScheme>, SchemeFactory>();
    static {
      schemes.put(StandardScheme.class, new connection_getSQLKeywords_resultStandardSchemeFactory());
      schemes.put(TupleScheme.class, new connection_getSQLKeywords_resultTupleSchemeFactory());
    }

    public String success; // required
    public RSQLException sqlException; // required

    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements org.apache.thrift.TFieldIdEnum {
      SUCCESS((short)0, "success"),
      SQL_EXCEPTION((short)1, "sqlException");

      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        switch(fieldId) {
          case 0: // SUCCESS
            return SUCCESS;
          case 1: // SQL_EXCEPTION
            return SQL_EXCEPTION;
          default:
            return null;
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }

    // isset id assignments
    public static final Map<_Fields, org.apache.thrift.meta_data.FieldMetaData> metaDataMap;
    static {
      Map<_Fields, org.apache.thrift.meta_data.FieldMetaData> tmpMap = new EnumMap<_Fields, org.apache.thrift.meta_data.FieldMetaData>(_Fields.class);
      tmpMap.put(_Fields.SUCCESS, new org.apache.thrift.meta_data.FieldMetaData("success", org.apache.thrift.TFieldRequirementType.DEFAULT, 
          new org.apache.thrift.meta_data.FieldValueMetaData(org.apache.thrift.protocol.TType.STRING)));
      tmpMap.put(_Fields.SQL_EXCEPTION, new org.apache.thrift.meta_data.FieldMetaData("sqlException", org.apache.thrift.TFieldRequirementType.DEFAULT, 
          new org.apache.thrift.meta_data.FieldValueMetaData(org.apache.thrift.protocol.TType.STRUCT)));
      metaDataMap = Collections.unmodifiableMap(tmpMap);
      org.apache.thrift.meta_data.FieldMetaData.addStructMetaDataMap(connection_getSQLKeywords_result.class, metaDataMap);
    }

    public connection_getSQLKeywords_result() {
    }

    public connection_getSQLKeywords_result(
      String success,
      RSQLException sqlException)
    {
      this();
      this.success = success;
      this.sqlException = sqlException;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public connection_getSQLKeywords_result(connection_getSQLKeywords_result other) {
      if (other.isSetSuccess()) {
        this.success = other.success;
      }
      if (other.isSetSqlException()) {
        this.sqlException = new RSQLException(other.sqlException);
      }
    }

    public connection_getSQLKeywords_result deepCopy() {
      return new connection_getSQLKeywords_result(this);
    }

    @Override
    public void clear() {
      this.success = null;
      this.sqlException = null;
    }

    public String getSuccess() {
      return this.success;
    }

    public connection_getSQLKeywords_result setSuccess(String success) {
      this.success = success;
      return this;
    }

    public void unsetSuccess() {
      this.success = null;
    }

    /** Returns true if field success is set (has been assigned a value) and false otherwise */
    public boolean isSetSuccess() {
      return this.success != null;
    }

    public void setSuccessIsSet(boolean value) {
      if (!value) {
        this.success = null;
      }
    }

    public RSQLException getSqlException() {
      return this.sqlException;
    }

    public connection_getSQLKeywords_result setSqlException(RSQLException sqlException) {
      this.sqlException = sqlException;
      return this;
    }

    public void unsetSqlException() {
      this.sqlException = null;
    }

    /** Returns true if field sqlException is set (has been assigned a value) and false otherwise */
    public boolean isSetSqlException() {
      return this.sqlException != null;
    }

    public void setSqlExceptionIsSet(boolean value) {
      if (!value) {
        this.sqlException = null;
      }
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          setSuccess((String)value);
        }
        break;

      case SQL_EXCEPTION:
        if (value == null) {
          unsetSqlException();
        } else {
          setSqlException((RSQLException)value);
        }
        break;

      }
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      case SUCCESS:
        return getSuccess();

      case SQL_EXCEPTION:
        return getSqlException();

      }
      throw new IllegalStateException();
    }

    /** Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      if (field == null) {
        throw new IllegalArgumentException();
      }

      switch (field) {
      case SUCCESS:
        return isSetSuccess();
      case SQL_EXCEPTION:
        return isSetSqlException();
      }
      throw new IllegalStateException();
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof connection_getSQLKeywords_result)
        return this.equals((connection_getSQLKeywords_result)that);
      return false;
    }

    public boolean equals(connection_getSQLKeywords_result that) {
      if (that == null)
        return false;

      boolean this_present_success = true && this.isSetSuccess();
      boolean that_present_success = true && that.isSetSuccess();
      if (this_present_success || that_present_success) {
        if (!(this_present_success && that_present_success))
          return false;
        if (!this.success.equals(that.success))
          return false;
      }

      boolean this_present_sqlException = true && this.isSetSqlException();
      boolean that_present_sqlException = true && that.isSetSqlException();
      if (this_present_sqlException || that_present_sqlException) {
        if (!(this_present_sqlException && that_present_sqlException))
          return false;
        if (!this.sqlException.equals(that.sqlException))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      List<Object> list = new ArrayList<Object>();

      boolean present_success = true && (isSetSuccess());
      list.add(present_success);
      if (present_success)
        list.add(success);

      boolean present_sqlException = true && (isSetSqlException());
      list.add(present_sqlException);
      if (present_sqlException)
        list.add(sqlException);

      return list.hashCode();
    }

    @Override
    public int compareTo(connection_getSQLKeywords_result other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetSuccess()).compareTo(other.isSetSuccess());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetSuccess()) {
        lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.success, other.success);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      lastComparison = Boolean.valueOf(isSetSqlException()).compareTo(other.isSetSqlException());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetSqlException()) {
        lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.sqlException, other.sqlException);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      return 0;
    }

    public _Fields fieldForId(int fieldId) {
      return _Fields.findByThriftId(fieldId);
    }

    public void read(org.apache.thrift.protocol.TProtocol iprot) throws org.apache.thrift.TException {
      schemes.get(iprot.getScheme()).getScheme().read(iprot, this);
    }

    public void write(org.apache.thrift.protocol.TProtocol oprot) throws org.apache.thrift.TException {
      schemes.get(oprot.getScheme()).getScheme().write(oprot, this);
      }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("connection_getSQLKeywords_result(");
      boolean first = true;

      sb.append("success:");
      if (this.success == null) {
        sb.append("null");
      } else {
        sb.append(this.success);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("sqlException:");
      if (this.sqlException == null) {
        sb.append("null");
      } else {
        sb.append(this.sqlException);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws org.apache.thrift.TException {
      // check for required fields
      // check for sub-struct validity
    }

    private void writeObject(java.io.ObjectOutputStream out) throws java.io.IOException {
      try {
        write(new org.apache.thrift.protocol.TCompactProtocol(new org.apache.thrift.transport.TIOStreamTransport(out)));
      } catch (org.apache.thrift.TException te) {
        throw new java.io.IOException(te);
      }
    }

    private void readObject(java.io.ObjectInputStream in) throws java.io.IOException, ClassNotFoundException {
      try {
        read(new org.apache.thrift.protocol.TCompactProtocol(new org.apache.thrift.transport.TIOStreamTransport(in)));
      } catch (org.apache.thrift.TException te) {
        throw new java.io.IOException(te);
      }
    }

    private static class connection_getSQLKeywords_resultStandardSchemeFactory implements SchemeFactory {
      public connection_getSQLKeywords_resultStandardScheme getScheme() {
        return new connection_getSQLKeywords_resultStandardScheme();
      }
    }

    private static class connection_getSQLKeywords_resultStandardScheme extends StandardScheme<connection_getSQLKeywords_result> {

      public void read(org.apache.thrift.protocol.TProtocol iprot, connection_getSQLKeywords_result struct) throws org.apache.thrift.TException {
        org.apache.thrift.protocol.TField schemeField;
        iprot.readStructBegin();
        while (true)
        {
          schemeField = iprot.readFieldBegin();
          if (schemeField.type == org.apache.thrift.protocol.TType.STOP) { 
            break;
          }
          switch (schemeField.id) {
            case 0: // SUCCESS
              if (schemeField.type == org.apache.thrift.protocol.TType.STRING) {
                struct.success = iprot.readString();
                struct.setSuccessIsSet(true);
              } else { 
                org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
              }
              break;
            case 1: // SQL_EXCEPTION
              if (schemeField.type == org.apache.thrift.protocol.TType.STRUCT) {
                struct.sqlException = new RSQLException();
                struct.sqlException.read(iprot);
                struct.setSqlExceptionIsSet(true);
              } else { 
                org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
              }
              break;
            default:
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
          }
          iprot.readFieldEnd();
        }
        iprot.readStructEnd();

        // check for required fields of primitive type, which can't be checked in the validate method
        struct.validate();
      }

      public void write(org.apache.thrift.protocol.TProtocol oprot, connection_getSQLKeywords_result struct) throws org.apache.thrift.TException {
        struct.validate();

        oprot.writeStructBegin(STRUCT_DESC);
        if (struct.success != null) {
          oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
          oprot.writeString(struct.success);
          oprot.writeFieldEnd();
        }
        if (struct.sqlException != null) {
          oprot.writeFieldBegin(SQL_EXCEPTION_FIELD_DESC);
          struct.sqlException.write(oprot);
          oprot.writeFieldEnd();
        }
        oprot.writeFieldStop();
        oprot.writeStructEnd();
      }

    }

    private static class connection_getSQLKeywords_resultTupleSchemeFactory implements SchemeFactory {
      public connection_getSQLKeywords_resultTupleScheme getScheme() {
        return new connection_getSQLKeywords_resultTupleScheme();
      }
    }

    private static class connection_getSQLKeywords_resultTupleScheme extends TupleScheme<connection_getSQLKeywords_result> {

      @Override
      public void write(org.apache.thrift.protocol.TProtocol prot, connection_getSQLKeywords_result struct) throws org.apache.thrift.TException {
        TTupleProtocol oprot = (TTupleProtocol) prot;
        BitSet optionals = new BitSet();
        if (struct.isSetSuccess()) {
          optionals.set(0);
        }
        if (struct.isSetSqlException()) {
          optionals.set(1);
        }
        oprot.writeBitSet(optionals, 2);
        if (struct.isSetSuccess()) {
          oprot.writeString(struct.success);
        }
        if (struct.isSetSqlException()) {
          struct.sqlException.write(oprot);
        }
      }

      @Override
      public void read(org.apache.thrift.protocol.TProtocol prot, connection_getSQLKeywords_result struct) throws org.apache.thrift.TException {
        TTupleProtocol iprot = (TTupleProtocol) prot;
        BitSet incoming = iprot.readBitSet(2);
        if (incoming.get(0)) {
          struct.success = iprot.readString();
          struct.setSuccessIsSet(true);
        }
        if (incoming.get(1)) {
          struct.sqlException = new RSQLException();
          struct.sqlException.read(iprot);
          struct.setSqlExceptionIsSet(true);
        }
      }
    }

  }

  public static class connection_getTableTypes_args implements org.apache.thrift.TBase<connection_getTableTypes_args, connection_getTableTypes_args._Fields>, java.io.Serializable, Cloneable, Comparable<connection_getTableTypes_args>   {
    private static final org.apache.thrift.protocol.TStruct STRUCT_DESC = new org.apache.thrift.protocol.TStruct("connection_getTableTypes_args");

    private static final org.apache.thrift.protocol.TField CONNECTION_FIELD_DESC = new org.apache.thrift.protocol.TField("connection", org.apache.thrift.protocol.TType.STRUCT, (short)1);

    private static final Map<Class<? extends IScheme>, SchemeFactory> schemes = new HashMap<Class<? extends IScheme>, SchemeFactory>();
    static {
      schemes.put(StandardScheme.class, new connection_getTableTypes_argsStandardSchemeFactory());
      schemes.put(TupleScheme.class, new connection_getTableTypes_argsTupleSchemeFactory());
    }

    public RConnection connection; // required

    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements org.apache.thrift.TFieldIdEnum {
      CONNECTION((short)1, "connection");

      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        switch(fieldId) {
          case 1: // CONNECTION
            return CONNECTION;
          default:
            return null;
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }

    // isset id assignments
    public static final Map<_Fields, org.apache.thrift.meta_data.FieldMetaData> metaDataMap;
    static {
      Map<_Fields, org.apache.thrift.meta_data.FieldMetaData> tmpMap = new EnumMap<_Fields, org.apache.thrift.meta_data.FieldMetaData>(_Fields.class);
      tmpMap.put(_Fields.CONNECTION, new org.apache.thrift.meta_data.FieldMetaData("connection", org.apache.thrift.TFieldRequirementType.DEFAULT, 
          new org.apache.thrift.meta_data.StructMetaData(org.apache.thrift.protocol.TType.STRUCT, RConnection.class)));
      metaDataMap = Collections.unmodifiableMap(tmpMap);
      org.apache.thrift.meta_data.FieldMetaData.addStructMetaDataMap(connection_getTableTypes_args.class, metaDataMap);
    }

    public connection_getTableTypes_args() {
    }

    public connection_getTableTypes_args(
      RConnection connection)
    {
      this();
      this.connection = connection;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public connection_getTableTypes_args(connection_getTableTypes_args other) {
      if (other.isSetConnection()) {
        this.connection = new RConnection(other.connection);
      }
    }

    public connection_getTableTypes_args deepCopy() {
      return new connection_getTableTypes_args(this);
    }

    @Override
    public void clear() {
      this.connection = null;
    }

    public RConnection getConnection() {
      return this.connection;
    }

    public connection_getTableTypes_args setConnection(RConnection connection) {
      this.connection = connection;
      return this;
    }

    public void unsetConnection() {
      this.connection = null;
    }

    /** Returns true if field connection is set (has been assigned a value) and false otherwise */
    public boolean isSetConnection() {
      return this.connection != null;
    }

    public void setConnectionIsSet(boolean value) {
      if (!value) {
        this.connection = null;
      }
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      case CONNECTION:
        if (value == null) {
          unsetConnection();
        } else {
          setConnection((RConnection)value);
        }
        break;

      }
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      case CONNECTION:
        return getConnection();

      }
      throw new IllegalStateException();
    }

    /** Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      if (field == null) {
        throw new IllegalArgumentException();
      }

      switch (field) {
      case CONNECTION:
        return isSetConnection();
      }
      throw new IllegalStateException();
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof connection_getTableTypes_args)
        return this.equals((connection_getTableTypes_args)that);
      return false;
    }

    public boolean equals(connection_getTableTypes_args that) {
      if (that == null)
        return false;

      boolean this_present_connection = true && this.isSetConnection();
      boolean that_present_connection = true && that.isSetConnection();
      if (this_present_connection || that_present_connection) {
        if (!(this_present_connection && that_present_connection))
          return false;
        if (!this.connection.equals(that.connection))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      List<Object> list = new ArrayList<Object>();

      boolean present_connection = true && (isSetConnection());
      list.add(present_connection);
      if (present_connection)
        list.add(connection);

      return list.hashCode();
    }

    @Override
    public int compareTo(connection_getTableTypes_args other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetConnection()).compareTo(other.isSetConnection());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetConnection()) {
        lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.connection, other.connection);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      return 0;
    }

    public _Fields fieldForId(int fieldId) {
      return _Fields.findByThriftId(fieldId);
    }

    public void read(org.apache.thrift.protocol.TProtocol iprot) throws org.apache.thrift.TException {
      schemes.get(iprot.getScheme()).getScheme().read(iprot, this);
    }

    public void write(org.apache.thrift.protocol.TProtocol oprot) throws org.apache.thrift.TException {
      schemes.get(oprot.getScheme()).getScheme().write(oprot, this);
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("connection_getTableTypes_args(");
      boolean first = true;

      sb.append("connection:");
      if (this.connection == null) {
        sb.append("null");
      } else {
        sb.append(this.connection);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws org.apache.thrift.TException {
      // check for required fields
      // check for sub-struct validity
      if (connection != null) {
        connection.validate();
      }
    }

    private void writeObject(java.io.ObjectOutputStream out) throws java.io.IOException {
      try {
        write(new org.apache.thrift.protocol.TCompactProtocol(new org.apache.thrift.transport.TIOStreamTransport(out)));
      } catch (org.apache.thrift.TException te) {
        throw new java.io.IOException(te);
      }
    }

    private void readObject(java.io.ObjectInputStream in) throws java.io.IOException, ClassNotFoundException {
      try {
        read(new org.apache.thrift.protocol.TCompactProtocol(new org.apache.thrift.transport.TIOStreamTransport(in)));
      } catch (org.apache.thrift.TException te) {
        throw new java.io.IOException(te);
      }
    }

    private static class connection_getTableTypes_argsStandardSchemeFactory implements SchemeFactory {
      public connection_getTableTypes_argsStandardScheme getScheme() {
        return new connection_getTableTypes_argsStandardScheme();
      }
    }

    private static class connection_getTableTypes_argsStandardScheme extends StandardScheme<connection_getTableTypes_args> {

      public void read(org.apache.thrift.protocol.TProtocol iprot, connection_getTableTypes_args struct) throws org.apache.thrift.TException {
        org.apache.thrift.protocol.TField schemeField;
        iprot.readStructBegin();
        while (true)
        {
          schemeField = iprot.readFieldBegin();
          if (schemeField.type == org.apache.thrift.protocol.TType.STOP) { 
            break;
          }
          switch (schemeField.id) {
            case 1: // CONNECTION
              if (schemeField.type == org.apache.thrift.protocol.TType.STRUCT) {
                struct.connection = new RConnection();
                struct.connection.read(iprot);
                struct.setConnectionIsSet(true);
              } else { 
                org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
              }
              break;
            default:
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
          }
          iprot.readFieldEnd();
        }
        iprot.readStructEnd();

        // check for required fields of primitive type, which can't be checked in the validate method
        struct.validate();
      }

      public void write(org.apache.thrift.protocol.TProtocol oprot, connection_getTableTypes_args struct) throws org.apache.thrift.TException {
        struct.validate();

        oprot.writeStructBegin(STRUCT_DESC);
        if (struct.connection != null) {
          oprot.writeFieldBegin(CONNECTION_FIELD_DESC);
          struct.connection.write(oprot);
          oprot.writeFieldEnd();
        }
        oprot.writeFieldStop();
        oprot.writeStructEnd();
      }

    }

    private static class connection_getTableTypes_argsTupleSchemeFactory implements SchemeFactory {
      public connection_getTableTypes_argsTupleScheme getScheme() {
        return new connection_getTableTypes_argsTupleScheme();
      }
    }

    private static class connection_getTableTypes_argsTupleScheme extends TupleScheme<connection_getTableTypes_args> {

      @Override
      public void write(org.apache.thrift.protocol.TProtocol prot, connection_getTableTypes_args struct) throws org.apache.thrift.TException {
        TTupleProtocol oprot = (TTupleProtocol) prot;
        BitSet optionals = new BitSet();
        if (struct.isSetConnection()) {
          optionals.set(0);
        }
        oprot.writeBitSet(optionals, 1);
        if (struct.isSetConnection()) {
          struct.connection.write(oprot);
        }
      }

      @Override
      public void read(org.apache.thrift.protocol.TProtocol prot, connection_getTableTypes_args struct) throws org.apache.thrift.TException {
        TTupleProtocol iprot = (TTupleProtocol) prot;
        BitSet incoming = iprot.readBitSet(1);
        if (incoming.get(0)) {
          struct.connection = new RConnection();
          struct.connection.read(iprot);
          struct.setConnectionIsSet(true);
        }
      }
    }

  }

  public static class connection_getTableTypes_result implements org.apache.thrift.TBase<connection_getTableTypes_result, connection_getTableTypes_result._Fields>, java.io.Serializable, Cloneable, Comparable<connection_getTableTypes_result>   {
    private static final org.apache.thrift.protocol.TStruct STRUCT_DESC = new org.apache.thrift.protocol.TStruct("connection_getTableTypes_result");

    private static final org.apache.thrift.protocol.TField SUCCESS_FIELD_DESC = new org.apache.thrift.protocol.TField("success", org.apache.thrift.protocol.TType.STRUCT, (short)0);
    private static final org.apache.thrift.protocol.TField SQL_EXCEPTION_FIELD_DESC = new org.apache.thrift.protocol.TField("sqlException", org.apache.thrift.protocol.TType.STRUCT, (short)1);

    private static final Map<Class<? extends IScheme>, SchemeFactory> schemes = new HashMap<Class<? extends IScheme>, SchemeFactory>();
    static {
      schemes.put(StandardScheme.class, new connection_getTableTypes_resultStandardSchemeFactory());
      schemes.put(TupleScheme.class, new connection_getTableTypes_resultTupleSchemeFactory());
    }

    public RResultSet success; // required
    public RSQLException sqlException; // required

    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements org.apache.thrift.TFieldIdEnum {
      SUCCESS((short)0, "success"),
      SQL_EXCEPTION((short)1, "sqlException");

      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        switch(fieldId) {
          case 0: // SUCCESS
            return SUCCESS;
          case 1: // SQL_EXCEPTION
            return SQL_EXCEPTION;
          default:
            return null;
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }

    // isset id assignments
    public static final Map<_Fields, org.apache.thrift.meta_data.FieldMetaData> metaDataMap;
    static {
      Map<_Fields, org.apache.thrift.meta_data.FieldMetaData> tmpMap = new EnumMap<_Fields, org.apache.thrift.meta_data.FieldMetaData>(_Fields.class);
      tmpMap.put(_Fields.SUCCESS, new org.apache.thrift.meta_data.FieldMetaData("success", org.apache.thrift.TFieldRequirementType.DEFAULT, 
          new org.apache.thrift.meta_data.StructMetaData(org.apache.thrift.protocol.TType.STRUCT, RResultSet.class)));
      tmpMap.put(_Fields.SQL_EXCEPTION, new org.apache.thrift.meta_data.FieldMetaData("sqlException", org.apache.thrift.TFieldRequirementType.DEFAULT, 
          new org.apache.thrift.meta_data.FieldValueMetaData(org.apache.thrift.protocol.TType.STRUCT)));
      metaDataMap = Collections.unmodifiableMap(tmpMap);
      org.apache.thrift.meta_data.FieldMetaData.addStructMetaDataMap(connection_getTableTypes_result.class, metaDataMap);
    }

    public connection_getTableTypes_result() {
    }

    public connection_getTableTypes_result(
      RResultSet success,
      RSQLException sqlException)
    {
      this();
      this.success = success;
      this.sqlException = sqlException;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public connection_getTableTypes_result(connection_getTableTypes_result other) {
      if (other.isSetSuccess()) {
        this.success = new RResultSet(other.success);
      }
      if (other.isSetSqlException()) {
        this.sqlException = new RSQLException(other.sqlException);
      }
    }

    public connection_getTableTypes_result deepCopy() {
      return new connection_getTableTypes_result(this);
    }

    @Override
    public void clear() {
      this.success = null;
      this.sqlException = null;
    }

    public RResultSet getSuccess() {
      return this.success;
    }

    public connection_getTableTypes_result setSuccess(RResultSet success) {
      this.success = success;
      return this;
    }

    public void unsetSuccess() {
      this.success = null;
    }

    /** Returns true if field success is set (has been assigned a value) and false otherwise */
    public boolean isSetSuccess() {
      return this.success != null;
    }

    public void setSuccessIsSet(boolean value) {
      if (!value) {
        this.success = null;
      }
    }

    public RSQLException getSqlException() {
      return this.sqlException;
    }

    public connection_getTableTypes_result setSqlException(RSQLException sqlException) {
      this.sqlException = sqlException;
      return this;
    }

    public void unsetSqlException() {
      this.sqlException = null;
    }

    /** Returns true if field sqlException is set (has been assigned a value) and false otherwise */
    public boolean isSetSqlException() {
      return this.sqlException != null;
    }

    public void setSqlExceptionIsSet(boolean value) {
      if (!value) {
        this.sqlException = null;
      }
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          setSuccess((RResultSet)value);
        }
        break;

      case SQL_EXCEPTION:
        if (value == null) {
          unsetSqlException();
        } else {
          setSqlException((RSQLException)value);
        }
        break;

      }
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      case SUCCESS:
        return getSuccess();

      case SQL_EXCEPTION:
        return getSqlException();

      }
      throw new IllegalStateException();
    }

    /** Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      if (field == null) {
        throw new IllegalArgumentException();
      }

      switch (field) {
      case SUCCESS:
        return isSetSuccess();
      case SQL_EXCEPTION:
        return isSetSqlException();
      }
      throw new IllegalStateException();
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof connection_getTableTypes_result)
        return this.equals((connection_getTableTypes_result)that);
      return false;
    }

    public boolean equals(connection_getTableTypes_result that) {
      if (that == null)
        return false;

      boolean this_present_success = true && this.isSetSuccess();
      boolean that_present_success = true && that.isSetSuccess();
      if (this_present_success || that_present_success) {
        if (!(this_present_success && that_present_success))
          return false;
        if (!this.success.equals(that.success))
          return false;
      }

      boolean this_present_sqlException = true && this.isSetSqlException();
      boolean that_present_sqlException = true && that.isSetSqlException();
      if (this_present_sqlException || that_present_sqlException) {
        if (!(this_present_sqlException && that_present_sqlException))
          return false;
        if (!this.sqlException.equals(that.sqlException))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      List<Object> list = new ArrayList<Object>();

      boolean present_success = true && (isSetSuccess());
      list.add(present_success);
      if (present_success)
        list.add(success);

      boolean present_sqlException = true && (isSetSqlException());
      list.add(present_sqlException);
      if (present_sqlException)
        list.add(sqlException);

      return list.hashCode();
    }

    @Override
    public int compareTo(connection_getTableTypes_result other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetSuccess()).compareTo(other.isSetSuccess());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetSuccess()) {
        lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.success, other.success);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      lastComparison = Boolean.valueOf(isSetSqlException()).compareTo(other.isSetSqlException());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetSqlException()) {
        lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.sqlException, other.sqlException);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      return 0;
    }

    public _Fields fieldForId(int fieldId) {
      return _Fields.findByThriftId(fieldId);
    }

    public void read(org.apache.thrift.protocol.TProtocol iprot) throws org.apache.thrift.TException {
      schemes.get(iprot.getScheme()).getScheme().read(iprot, this);
    }

    public void write(org.apache.thrift.protocol.TProtocol oprot) throws org.apache.thrift.TException {
      schemes.get(oprot.getScheme()).getScheme().write(oprot, this);
      }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("connection_getTableTypes_result(");
      boolean first = true;

      sb.append("success:");
      if (this.success == null) {
        sb.append("null");
      } else {
        sb.append(this.success);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("sqlException:");
      if (this.sqlException == null) {
        sb.append("null");
      } else {
        sb.append(this.sqlException);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws org.apache.thrift.TException {
      // check for required fields
      // check for sub-struct validity
      if (success != null) {
        success.validate();
      }
    }

    private void writeObject(java.io.ObjectOutputStream out) throws java.io.IOException {
      try {
        write(new org.apache.thrift.protocol.TCompactProtocol(new org.apache.thrift.transport.TIOStreamTransport(out)));
      } catch (org.apache.thrift.TException te) {
        throw new java.io.IOException(te);
      }
    }

    private void readObject(java.io.ObjectInputStream in) throws java.io.IOException, ClassNotFoundException {
      try {
        read(new org.apache.thrift.protocol.TCompactProtocol(new org.apache.thrift.transport.TIOStreamTransport(in)));
      } catch (org.apache.thrift.TException te) {
        throw new java.io.IOException(te);
      }
    }

    private static class connection_getTableTypes_resultStandardSchemeFactory implements SchemeFactory {
      public connection_getTableTypes_resultStandardScheme getScheme() {
        return new connection_getTableTypes_resultStandardScheme();
      }
    }

    private static class connection_getTableTypes_resultStandardScheme extends StandardScheme<connection_getTableTypes_result> {

      public void read(org.apache.thrift.protocol.TProtocol iprot, connection_getTableTypes_result struct) throws org.apache.thrift.TException {
        org.apache.thrift.protocol.TField schemeField;
        iprot.readStructBegin();
        while (true)
        {
          schemeField = iprot.readFieldBegin();
          if (schemeField.type == org.apache.thrift.protocol.TType.STOP) { 
            break;
          }
          switch (schemeField.id) {
            case 0: // SUCCESS
              if (schemeField.type == org.apache.thrift.protocol.TType.STRUCT) {
                struct.success = new RResultSet();
                struct.success.read(iprot);
                struct.setSuccessIsSet(true);
              } else { 
                org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
              }
              break;
            case 1: // SQL_EXCEPTION
              if (schemeField.type == org.apache.thrift.protocol.TType.STRUCT) {
                struct.sqlException = new RSQLException();
                struct.sqlException.read(iprot);
                struct.setSqlExceptionIsSet(true);
              } else { 
                org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
              }
              break;
            default:
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
          }
          iprot.readFieldEnd();
        }
        iprot.readStructEnd();

        // check for required fields of primitive type, which can't be checked in the validate method
        struct.validate();
      }

      public void write(org.apache.thrift.protocol.TProtocol oprot, connection_getTableTypes_result struct) throws org.apache.thrift.TException {
        struct.validate();

        oprot.writeStructBegin(STRUCT_DESC);
        if (struct.success != null) {
          oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
          struct.success.write(oprot);
          oprot.writeFieldEnd();
        }
        if (struct.sqlException != null) {
          oprot.writeFieldBegin(SQL_EXCEPTION_FIELD_DESC);
          struct.sqlException.write(oprot);
          oprot.writeFieldEnd();
        }
        oprot.writeFieldStop();
        oprot.writeStructEnd();
      }

    }

    private static class connection_getTableTypes_resultTupleSchemeFactory implements SchemeFactory {
      public connection_getTableTypes_resultTupleScheme getScheme() {
        return new connection_getTableTypes_resultTupleScheme();
      }
    }

    private static class connection_getTableTypes_resultTupleScheme extends TupleScheme<connection_getTableTypes_result> {

      @Override
      public void write(org.apache.thrift.protocol.TProtocol prot, connection_getTableTypes_result struct) throws org.apache.thrift.TException {
        TTupleProtocol oprot = (TTupleProtocol) prot;
        BitSet optionals = new BitSet();
        if (struct.isSetSuccess()) {
          optionals.set(0);
        }
        if (struct.isSetSqlException()) {
          optionals.set(1);
        }
        oprot.writeBitSet(optionals, 2);
        if (struct.isSetSuccess()) {
          struct.success.write(oprot);
        }
        if (struct.isSetSqlException()) {
          struct.sqlException.write(oprot);
        }
      }

      @Override
      public void read(org.apache.thrift.protocol.TProtocol prot, connection_getTableTypes_result struct) throws org.apache.thrift.TException {
        TTupleProtocol iprot = (TTupleProtocol) prot;
        BitSet incoming = iprot.readBitSet(2);
        if (incoming.get(0)) {
          struct.success = new RResultSet();
          struct.success.read(iprot);
          struct.setSuccessIsSet(true);
        }
        if (incoming.get(1)) {
          struct.sqlException = new RSQLException();
          struct.sqlException.read(iprot);
          struct.setSqlExceptionIsSet(true);
        }
      }
    }

  }

  public static class connection_getTypeInfo_args implements org.apache.thrift.TBase<connection_getTypeInfo_args, connection_getTypeInfo_args._Fields>, java.io.Serializable, Cloneable, Comparable<connection_getTypeInfo_args>   {
    private static final org.apache.thrift.protocol.TStruct STRUCT_DESC = new org.apache.thrift.protocol.TStruct("connection_getTypeInfo_args");

    private static final org.apache.thrift.protocol.TField CONNECTION_FIELD_DESC = new org.apache.thrift.protocol.TField("connection", org.apache.thrift.protocol.TType.STRUCT, (short)1);

    private static final Map<Class<? extends IScheme>, SchemeFactory> schemes = new HashMap<Class<? extends IScheme>, SchemeFactory>();
    static {
      schemes.put(StandardScheme.class, new connection_getTypeInfo_argsStandardSchemeFactory());
      schemes.put(TupleScheme.class, new connection_getTypeInfo_argsTupleSchemeFactory());
    }

    public RConnection connection; // required

    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements org.apache.thrift.TFieldIdEnum {
      CONNECTION((short)1, "connection");

      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        switch(fieldId) {
          case 1: // CONNECTION
            return CONNECTION;
          default:
            return null;
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }

    // isset id assignments
    public static final Map<_Fields, org.apache.thrift.meta_data.FieldMetaData> metaDataMap;
    static {
      Map<_Fields, org.apache.thrift.meta_data.FieldMetaData> tmpMap = new EnumMap<_Fields, org.apache.thrift.meta_data.FieldMetaData>(_Fields.class);
      tmpMap.put(_Fields.CONNECTION, new org.apache.thrift.meta_data.FieldMetaData("connection", org.apache.thrift.TFieldRequirementType.DEFAULT, 
          new org.apache.thrift.meta_data.StructMetaData(org.apache.thrift.protocol.TType.STRUCT, RConnection.class)));
      metaDataMap = Collections.unmodifiableMap(tmpMap);
      org.apache.thrift.meta_data.FieldMetaData.addStructMetaDataMap(connection_getTypeInfo_args.class, metaDataMap);
    }

    public connection_getTypeInfo_args() {
    }

    public connection_getTypeInfo_args(
      RConnection connection)
    {
      this();
      this.connection = connection;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public connection_getTypeInfo_args(connection_getTypeInfo_args other) {
      if (other.isSetConnection()) {
        this.connection = new RConnection(other.connection);
      }
    }

    public connection_getTypeInfo_args deepCopy() {
      return new connection_getTypeInfo_args(this);
    }

    @Override
    public void clear() {
      this.connection = null;
    }

    public RConnection getConnection() {
      return this.connection;
    }

    public connection_getTypeInfo_args setConnection(RConnection connection) {
      this.connection = connection;
      return this;
    }

    public void unsetConnection() {
      this.connection = null;
    }

    /** Returns true if field connection is set (has been assigned a value) and false otherwise */
    public boolean isSetConnection() {
      return this.connection != null;
    }

    public void setConnectionIsSet(boolean value) {
      if (!value) {
        this.connection = null;
      }
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      case CONNECTION:
        if (value == null) {
          unsetConnection();
        } else {
          setConnection((RConnection)value);
        }
        break;

      }
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      case CONNECTION:
        return getConnection();

      }
      throw new IllegalStateException();
    }

    /** Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      if (field == null) {
        throw new IllegalArgumentException();
      }

      switch (field) {
      case CONNECTION:
        return isSetConnection();
      }
      throw new IllegalStateException();
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof connection_getTypeInfo_args)
        return this.equals((connection_getTypeInfo_args)that);
      return false;
    }

    public boolean equals(connection_getTypeInfo_args that) {
      if (that == null)
        return false;

      boolean this_present_connection = true && this.isSetConnection();
      boolean that_present_connection = true && that.isSetConnection();
      if (this_present_connection || that_present_connection) {
        if (!(this_present_connection && that_present_connection))
          return false;
        if (!this.connection.equals(that.connection))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      List<Object> list = new ArrayList<Object>();

      boolean present_connection = true && (isSetConnection());
      list.add(present_connection);
      if (present_connection)
        list.add(connection);

      return list.hashCode();
    }

    @Override
    public int compareTo(connection_getTypeInfo_args other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetConnection()).compareTo(other.isSetConnection());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetConnection()) {
        lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.connection, other.connection);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      return 0;
    }

    public _Fields fieldForId(int fieldId) {
      return _Fields.findByThriftId(fieldId);
    }

    public void read(org.apache.thrift.protocol.TProtocol iprot) throws org.apache.thrift.TException {
      schemes.get(iprot.getScheme()).getScheme().read(iprot, this);
    }

    public void write(org.apache.thrift.protocol.TProtocol oprot) throws org.apache.thrift.TException {
      schemes.get(oprot.getScheme()).getScheme().write(oprot, this);
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("connection_getTypeInfo_args(");
      boolean first = true;

      sb.append("connection:");
      if (this.connection == null) {
        sb.append("null");
      } else {
        sb.append(this.connection);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws org.apache.thrift.TException {
      // check for required fields
      // check for sub-struct validity
      if (connection != null) {
        connection.validate();
      }
    }

    private void writeObject(java.io.ObjectOutputStream out) throws java.io.IOException {
      try {
        write(new org.apache.thrift.protocol.TCompactProtocol(new org.apache.thrift.transport.TIOStreamTransport(out)));
      } catch (org.apache.thrift.TException te) {
        throw new java.io.IOException(te);
      }
    }

    private void readObject(java.io.ObjectInputStream in) throws java.io.IOException, ClassNotFoundException {
      try {
        read(new org.apache.thrift.protocol.TCompactProtocol(new org.apache.thrift.transport.TIOStreamTransport(in)));
      } catch (org.apache.thrift.TException te) {
        throw new java.io.IOException(te);
      }
    }

    private static class connection_getTypeInfo_argsStandardSchemeFactory implements SchemeFactory {
      public connection_getTypeInfo_argsStandardScheme getScheme() {
        return new connection_getTypeInfo_argsStandardScheme();
      }
    }

    private static class connection_getTypeInfo_argsStandardScheme extends StandardScheme<connection_getTypeInfo_args> {

      public void read(org.apache.thrift.protocol.TProtocol iprot, connection_getTypeInfo_args struct) throws org.apache.thrift.TException {
        org.apache.thrift.protocol.TField schemeField;
        iprot.readStructBegin();
        while (true)
        {
          schemeField = iprot.readFieldBegin();
          if (schemeField.type == org.apache.thrift.protocol.TType.STOP) { 
            break;
          }
          switch (schemeField.id) {
            case 1: // CONNECTION
              if (schemeField.type == org.apache.thrift.protocol.TType.STRUCT) {
                struct.connection = new RConnection();
                struct.connection.read(iprot);
                struct.setConnectionIsSet(true);
              } else { 
                org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
              }
              break;
            default:
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
          }
          iprot.readFieldEnd();
        }
        iprot.readStructEnd();

        // check for required fields of primitive type, which can't be checked in the validate method
        struct.validate();
      }

      public void write(org.apache.thrift.protocol.TProtocol oprot, connection_getTypeInfo_args struct) throws org.apache.thrift.TException {
        struct.validate();

        oprot.writeStructBegin(STRUCT_DESC);
        if (struct.connection != null) {
          oprot.writeFieldBegin(CONNECTION_FIELD_DESC);
          struct.connection.write(oprot);
          oprot.writeFieldEnd();
        }
        oprot.writeFieldStop();
        oprot.writeStructEnd();
      }

    }

    private static class connection_getTypeInfo_argsTupleSchemeFactory implements SchemeFactory {
      public connection_getTypeInfo_argsTupleScheme getScheme() {
        return new connection_getTypeInfo_argsTupleScheme();
      }
    }

    private static class connection_getTypeInfo_argsTupleScheme extends TupleScheme<connection_getTypeInfo_args> {

      @Override
      public void write(org.apache.thrift.protocol.TProtocol prot, connection_getTypeInfo_args struct) throws org.apache.thrift.TException {
        TTupleProtocol oprot = (TTupleProtocol) prot;
        BitSet optionals = new BitSet();
        if (struct.isSetConnection()) {
          optionals.set(0);
        }
        oprot.writeBitSet(optionals, 1);
        if (struct.isSetConnection()) {
          struct.connection.write(oprot);
        }
      }

      @Override
      public void read(org.apache.thrift.protocol.TProtocol prot, connection_getTypeInfo_args struct) throws org.apache.thrift.TException {
        TTupleProtocol iprot = (TTupleProtocol) prot;
        BitSet incoming = iprot.readBitSet(1);
        if (incoming.get(0)) {
          struct.connection = new RConnection();
          struct.connection.read(iprot);
          struct.setConnectionIsSet(true);
        }
      }
    }

  }

  public static class connection_getTypeInfo_result implements org.apache.thrift.TBase<connection_getTypeInfo_result, connection_getTypeInfo_result._Fields>, java.io.Serializable, Cloneable, Comparable<connection_getTypeInfo_result>   {
    private static final org.apache.thrift.protocol.TStruct STRUCT_DESC = new org.apache.thrift.protocol.TStruct("connection_getTypeInfo_result");

    private static final org.apache.thrift.protocol.TField SUCCESS_FIELD_DESC = new org.apache.thrift.protocol.TField("success", org.apache.thrift.protocol.TType.STRUCT, (short)0);
    private static final org.apache.thrift.protocol.TField SQL_EXCEPTION_FIELD_DESC = new org.apache.thrift.protocol.TField("sqlException", org.apache.thrift.protocol.TType.STRUCT, (short)1);

    private static final Map<Class<? extends IScheme>, SchemeFactory> schemes = new HashMap<Class<? extends IScheme>, SchemeFactory>();
    static {
      schemes.put(StandardScheme.class, new connection_getTypeInfo_resultStandardSchemeFactory());
      schemes.put(TupleScheme.class, new connection_getTypeInfo_resultTupleSchemeFactory());
    }

    public RResultSet success; // required
    public RSQLException sqlException; // required

    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements org.apache.thrift.TFieldIdEnum {
      SUCCESS((short)0, "success"),
      SQL_EXCEPTION((short)1, "sqlException");

      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        switch(fieldId) {
          case 0: // SUCCESS
            return SUCCESS;
          case 1: // SQL_EXCEPTION
            return SQL_EXCEPTION;
          default:
            return null;
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }

    // isset id assignments
    public static final Map<_Fields, org.apache.thrift.meta_data.FieldMetaData> metaDataMap;
    static {
      Map<_Fields, org.apache.thrift.meta_data.FieldMetaData> tmpMap = new EnumMap<_Fields, org.apache.thrift.meta_data.FieldMetaData>(_Fields.class);
      tmpMap.put(_Fields.SUCCESS, new org.apache.thrift.meta_data.FieldMetaData("success", org.apache.thrift.TFieldRequirementType.DEFAULT, 
          new org.apache.thrift.meta_data.StructMetaData(org.apache.thrift.protocol.TType.STRUCT, RResultSet.class)));
      tmpMap.put(_Fields.SQL_EXCEPTION, new org.apache.thrift.meta_data.FieldMetaData("sqlException", org.apache.thrift.TFieldRequirementType.DEFAULT, 
          new org.apache.thrift.meta_data.FieldValueMetaData(org.apache.thrift.protocol.TType.STRUCT)));
      metaDataMap = Collections.unmodifiableMap(tmpMap);
      org.apache.thrift.meta_data.FieldMetaData.addStructMetaDataMap(connection_getTypeInfo_result.class, metaDataMap);
    }

    public connection_getTypeInfo_result() {
    }

    public connection_getTypeInfo_result(
      RResultSet success,
      RSQLException sqlException)
    {
      this();
      this.success = success;
      this.sqlException = sqlException;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public connection_getTypeInfo_result(connection_getTypeInfo_result other) {
      if (other.isSetSuccess()) {
        this.success = new RResultSet(other.success);
      }
      if (other.isSetSqlException()) {
        this.sqlException = new RSQLException(other.sqlException);
      }
    }

    public connection_getTypeInfo_result deepCopy() {
      return new connection_getTypeInfo_result(this);
    }

    @Override
    public void clear() {
      this.success = null;
      this.sqlException = null;
    }

    public RResultSet getSuccess() {
      return this.success;
    }

    public connection_getTypeInfo_result setSuccess(RResultSet success) {
      this.success = success;
      return this;
    }

    public void unsetSuccess() {
      this.success = null;
    }

    /** Returns true if field success is set (has been assigned a value) and false otherwise */
    public boolean isSetSuccess() {
      return this.success != null;
    }

    public void setSuccessIsSet(boolean value) {
      if (!value) {
        this.success = null;
      }
    }

    public RSQLException getSqlException() {
      return this.sqlException;
    }

    public connection_getTypeInfo_result setSqlException(RSQLException sqlException) {
      this.sqlException = sqlException;
      return this;
    }

    public void unsetSqlException() {
      this.sqlException = null;
    }

    /** Returns true if field sqlException is set (has been assigned a value) and false otherwise */
    public boolean isSetSqlException() {
      return this.sqlException != null;
    }

    public void setSqlExceptionIsSet(boolean value) {
      if (!value) {
        this.sqlException = null;
      }
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          setSuccess((RResultSet)value);
        }
        break;

      case SQL_EXCEPTION:
        if (value == null) {
          unsetSqlException();
        } else {
          setSqlException((RSQLException)value);
        }
        break;

      }
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      case SUCCESS:
        return getSuccess();

      case SQL_EXCEPTION:
        return getSqlException();

      }
      throw new IllegalStateException();
    }

    /** Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      if (field == null) {
        throw new IllegalArgumentException();
      }

      switch (field) {
      case SUCCESS:
        return isSetSuccess();
      case SQL_EXCEPTION:
        return isSetSqlException();
      }
      throw new IllegalStateException();
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof connection_getTypeInfo_result)
        return this.equals((connection_getTypeInfo_result)that);
      return false;
    }

    public boolean equals(connection_getTypeInfo_result that) {
      if (that == null)
        return false;

      boolean this_present_success = true && this.isSetSuccess();
      boolean that_present_success = true && that.isSetSuccess();
      if (this_present_success || that_present_success) {
        if (!(this_present_success && that_present_success))
          return false;
        if (!this.success.equals(that.success))
          return false;
      }

      boolean this_present_sqlException = true && this.isSetSqlException();
      boolean that_present_sqlException = true && that.isSetSqlException();
      if (this_present_sqlException || that_present_sqlException) {
        if (!(this_present_sqlException && that_present_sqlException))
          return false;
        if (!this.sqlException.equals(that.sqlException))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      List<Object> list = new ArrayList<Object>();

      boolean present_success = true && (isSetSuccess());
      list.add(present_success);
      if (present_success)
        list.add(success);

      boolean present_sqlException = true && (isSetSqlException());
      list.add(present_sqlException);
      if (present_sqlException)
        list.add(sqlException);

      return list.hashCode();
    }

    @Override
    public int compareTo(connection_getTypeInfo_result other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetSuccess()).compareTo(other.isSetSuccess());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetSuccess()) {
        lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.success, other.success);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      lastComparison = Boolean.valueOf(isSetSqlException()).compareTo(other.isSetSqlException());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetSqlException()) {
        lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.sqlException, other.sqlException);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      return 0;
    }

    public _Fields fieldForId(int fieldId) {
      return _Fields.findByThriftId(fieldId);
    }

    public void read(org.apache.thrift.protocol.TProtocol iprot) throws org.apache.thrift.TException {
      schemes.get(iprot.getScheme()).getScheme().read(iprot, this);
    }

    public void write(org.apache.thrift.protocol.TProtocol oprot) throws org.apache.thrift.TException {
      schemes.get(oprot.getScheme()).getScheme().write(oprot, this);
      }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("connection_getTypeInfo_result(");
      boolean first = true;

      sb.append("success:");
      if (this.success == null) {
        sb.append("null");
      } else {
        sb.append(this.success);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("sqlException:");
      if (this.sqlException == null) {
        sb.append("null");
      } else {
        sb.append(this.sqlException);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws org.apache.thrift.TException {
      // check for required fields
      // check for sub-struct validity
      if (success != null) {
        success.validate();
      }
    }

    private void writeObject(java.io.ObjectOutputStream out) throws java.io.IOException {
      try {
        write(new org.apache.thrift.protocol.TCompactProtocol(new org.apache.thrift.transport.TIOStreamTransport(out)));
      } catch (org.apache.thrift.TException te) {
        throw new java.io.IOException(te);
      }
    }

    private void readObject(java.io.ObjectInputStream in) throws java.io.IOException, ClassNotFoundException {
      try {
        read(new org.apache.thrift.protocol.TCompactProtocol(new org.apache.thrift.transport.TIOStreamTransport(in)));
      } catch (org.apache.thrift.TException te) {
        throw new java.io.IOException(te);
      }
    }

    private static class connection_getTypeInfo_resultStandardSchemeFactory implements SchemeFactory {
      public connection_getTypeInfo_resultStandardScheme getScheme() {
        return new connection_getTypeInfo_resultStandardScheme();
      }
    }

    private static class connection_getTypeInfo_resultStandardScheme extends StandardScheme<connection_getTypeInfo_result> {

      public void read(org.apache.thrift.protocol.TProtocol iprot, connection_getTypeInfo_result struct) throws org.apache.thrift.TException {
        org.apache.thrift.protocol.TField schemeField;
        iprot.readStructBegin();
        while (true)
        {
          schemeField = iprot.readFieldBegin();
          if (schemeField.type == org.apache.thrift.protocol.TType.STOP) { 
            break;
          }
          switch (schemeField.id) {
            case 0: // SUCCESS
              if (schemeField.type == org.apache.thrift.protocol.TType.STRUCT) {
                struct.success = new RResultSet();
                struct.success.read(iprot);
                struct.setSuccessIsSet(true);
              } else { 
                org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
              }
              break;
            case 1: // SQL_EXCEPTION
              if (schemeField.type == org.apache.thrift.protocol.TType.STRUCT) {
                struct.sqlException = new RSQLException();
                struct.sqlException.read(iprot);
                struct.setSqlExceptionIsSet(true);
              } else { 
                org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
              }
              break;
            default:
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
          }
          iprot.readFieldEnd();
        }
        iprot.readStructEnd();

        // check for required fields of primitive type, which can't be checked in the validate method
        struct.validate();
      }

      public void write(org.apache.thrift.protocol.TProtocol oprot, connection_getTypeInfo_result struct) throws org.apache.thrift.TException {
        struct.validate();

        oprot.writeStructBegin(STRUCT_DESC);
        if (struct.success != null) {
          oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
          struct.success.write(oprot);
          oprot.writeFieldEnd();
        }
        if (struct.sqlException != null) {
          oprot.writeFieldBegin(SQL_EXCEPTION_FIELD_DESC);
          struct.sqlException.write(oprot);
          oprot.writeFieldEnd();
        }
        oprot.writeFieldStop();
        oprot.writeStructEnd();
      }

    }

    private static class connection_getTypeInfo_resultTupleSchemeFactory implements SchemeFactory {
      public connection_getTypeInfo_resultTupleScheme getScheme() {
        return new connection_getTypeInfo_resultTupleScheme();
      }
    }

    private static class connection_getTypeInfo_resultTupleScheme extends TupleScheme<connection_getTypeInfo_result> {

      @Override
      public void write(org.apache.thrift.protocol.TProtocol prot, connection_getTypeInfo_result struct) throws org.apache.thrift.TException {
        TTupleProtocol oprot = (TTupleProtocol) prot;
        BitSet optionals = new BitSet();
        if (struct.isSetSuccess()) {
          optionals.set(0);
        }
        if (struct.isSetSqlException()) {
          optionals.set(1);
        }
        oprot.writeBitSet(optionals, 2);
        if (struct.isSetSuccess()) {
          struct.success.write(oprot);
        }
        if (struct.isSetSqlException()) {
          struct.sqlException.write(oprot);
        }
      }

      @Override
      public void read(org.apache.thrift.protocol.TProtocol prot, connection_getTypeInfo_result struct) throws org.apache.thrift.TException {
        TTupleProtocol iprot = (TTupleProtocol) prot;
        BitSet incoming = iprot.readBitSet(2);
        if (incoming.get(0)) {
          struct.success = new RResultSet();
          struct.success.read(iprot);
          struct.setSuccessIsSet(true);
        }
        if (incoming.get(1)) {
          struct.sqlException = new RSQLException();
          struct.sqlException.read(iprot);
          struct.setSqlExceptionIsSet(true);
        }
      }
    }

  }

  public static class closeConnection_args implements org.apache.thrift.TBase<closeConnection_args, closeConnection_args._Fields>, java.io.Serializable, Cloneable, Comparable<closeConnection_args>   {
    private static final org.apache.thrift.protocol.TStruct STRUCT_DESC = new org.apache.thrift.protocol.TStruct("closeConnection_args");

    private static final org.apache.thrift.protocol.TField CONNECTION_FIELD_DESC = new org.apache.thrift.protocol.TField("connection", org.apache.thrift.protocol.TType.STRUCT, (short)1);

    private static final Map<Class<? extends IScheme>, SchemeFactory> schemes = new HashMap<Class<? extends IScheme>, SchemeFactory>();
    static {
      schemes.put(StandardScheme.class, new closeConnection_argsStandardSchemeFactory());
      schemes.put(TupleScheme.class, new closeConnection_argsTupleSchemeFactory());
    }

    public RConnection connection; // required

    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements org.apache.thrift.TFieldIdEnum {
      CONNECTION((short)1, "connection");

      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        switch(fieldId) {
          case 1: // CONNECTION
            return CONNECTION;
          default:
            return null;
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }

    // isset id assignments
    public static final Map<_Fields, org.apache.thrift.meta_data.FieldMetaData> metaDataMap;
    static {
      Map<_Fields, org.apache.thrift.meta_data.FieldMetaData> tmpMap = new EnumMap<_Fields, org.apache.thrift.meta_data.FieldMetaData>(_Fields.class);
      tmpMap.put(_Fields.CONNECTION, new org.apache.thrift.meta_data.FieldMetaData("connection", org.apache.thrift.TFieldRequirementType.DEFAULT, 
          new org.apache.thrift.meta_data.StructMetaData(org.apache.thrift.protocol.TType.STRUCT, RConnection.class)));
      metaDataMap = Collections.unmodifiableMap(tmpMap);
      org.apache.thrift.meta_data.FieldMetaData.addStructMetaDataMap(closeConnection_args.class, metaDataMap);
    }

    public closeConnection_args() {
    }

    public closeConnection_args(
      RConnection connection)
    {
      this();
      this.connection = connection;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public closeConnection_args(closeConnection_args other) {
      if (other.isSetConnection()) {
        this.connection = new RConnection(other.connection);
      }
    }

    public closeConnection_args deepCopy() {
      return new closeConnection_args(this);
    }

    @Override
    public void clear() {
      this.connection = null;
    }

    public RConnection getConnection() {
      return this.connection;
    }

    public closeConnection_args setConnection(RConnection connection) {
      this.connection = connection;
      return this;
    }

    public void unsetConnection() {
      this.connection = null;
    }

    /** Returns true if field connection is set (has been assigned a value) and false otherwise */
    public boolean isSetConnection() {
      return this.connection != null;
    }

    public void setConnectionIsSet(boolean value) {
      if (!value) {
        this.connection = null;
      }
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      case CONNECTION:
        if (value == null) {
          unsetConnection();
        } else {
          setConnection((RConnection)value);
        }
        break;

      }
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      case CONNECTION:
        return getConnection();

      }
      throw new IllegalStateException();
    }

    /** Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      if (field == null) {
        throw new IllegalArgumentException();
      }

      switch (field) {
      case CONNECTION:
        return isSetConnection();
      }
      throw new IllegalStateException();
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof closeConnection_args)
        return this.equals((closeConnection_args)that);
      return false;
    }

    public boolean equals(closeConnection_args that) {
      if (that == null)
        return false;

      boolean this_present_connection = true && this.isSetConnection();
      boolean that_present_connection = true && that.isSetConnection();
      if (this_present_connection || that_present_connection) {
        if (!(this_present_connection && that_present_connection))
          return false;
        if (!this.connection.equals(that.connection))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      List<Object> list = new ArrayList<Object>();

      boolean present_connection = true && (isSetConnection());
      list.add(present_connection);
      if (present_connection)
        list.add(connection);

      return list.hashCode();
    }

    @Override
    public int compareTo(closeConnection_args other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetConnection()).compareTo(other.isSetConnection());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetConnection()) {
        lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.connection, other.connection);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      return 0;
    }

    public _Fields fieldForId(int fieldId) {
      return _Fields.findByThriftId(fieldId);
    }

    public void read(org.apache.thrift.protocol.TProtocol iprot) throws org.apache.thrift.TException {
      schemes.get(iprot.getScheme()).getScheme().read(iprot, this);
    }

    public void write(org.apache.thrift.protocol.TProtocol oprot) throws org.apache.thrift.TException {
      schemes.get(oprot.getScheme()).getScheme().write(oprot, this);
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("closeConnection_args(");
      boolean first = true;

      sb.append("connection:");
      if (this.connection == null) {
        sb.append("null");
      } else {
        sb.append(this.connection);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws org.apache.thrift.TException {
      // check for required fields
      // check for sub-struct validity
      if (connection != null) {
        connection.validate();
      }
    }

    private void writeObject(java.io.ObjectOutputStream out) throws java.io.IOException {
      try {
        write(new org.apache.thrift.protocol.TCompactProtocol(new org.apache.thrift.transport.TIOStreamTransport(out)));
      } catch (org.apache.thrift.TException te) {
        throw new java.io.IOException(te);
      }
    }

    private void readObject(java.io.ObjectInputStream in) throws java.io.IOException, ClassNotFoundException {
      try {
        read(new org.apache.thrift.protocol.TCompactProtocol(new org.apache.thrift.transport.TIOStreamTransport(in)));
      } catch (org.apache.thrift.TException te) {
        throw new java.io.IOException(te);
      }
    }

    private static class closeConnection_argsStandardSchemeFactory implements SchemeFactory {
      public closeConnection_argsStandardScheme getScheme() {
        return new closeConnection_argsStandardScheme();
      }
    }

    private static class closeConnection_argsStandardScheme extends StandardScheme<closeConnection_args> {

      public void read(org.apache.thrift.protocol.TProtocol iprot, closeConnection_args struct) throws org.apache.thrift.TException {
        org.apache.thrift.protocol.TField schemeField;
        iprot.readStructBegin();
        while (true)
        {
          schemeField = iprot.readFieldBegin();
          if (schemeField.type == org.apache.thrift.protocol.TType.STOP) { 
            break;
          }
          switch (schemeField.id) {
            case 1: // CONNECTION
              if (schemeField.type == org.apache.thrift.protocol.TType.STRUCT) {
                struct.connection = new RConnection();
                struct.connection.read(iprot);
                struct.setConnectionIsSet(true);
              } else { 
                org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
              }
              break;
            default:
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
          }
          iprot.readFieldEnd();
        }
        iprot.readStructEnd();

        // check for required fields of primitive type, which can't be checked in the validate method
        struct.validate();
      }

      public void write(org.apache.thrift.protocol.TProtocol oprot, closeConnection_args struct) throws org.apache.thrift.TException {
        struct.validate();

        oprot.writeStructBegin(STRUCT_DESC);
        if (struct.connection != null) {
          oprot.writeFieldBegin(CONNECTION_FIELD_DESC);
          struct.connection.write(oprot);
          oprot.writeFieldEnd();
        }
        oprot.writeFieldStop();
        oprot.writeStructEnd();
      }

    }

    private static class closeConnection_argsTupleSchemeFactory implements SchemeFactory {
      public closeConnection_argsTupleScheme getScheme() {
        return new closeConnection_argsTupleScheme();
      }
    }

    private static class closeConnection_argsTupleScheme extends TupleScheme<closeConnection_args> {

      @Override
      public void write(org.apache.thrift.protocol.TProtocol prot, closeConnection_args struct) throws org.apache.thrift.TException {
        TTupleProtocol oprot = (TTupleProtocol) prot;
        BitSet optionals = new BitSet();
        if (struct.isSetConnection()) {
          optionals.set(0);
        }
        oprot.writeBitSet(optionals, 1);
        if (struct.isSetConnection()) {
          struct.connection.write(oprot);
        }
      }

      @Override
      public void read(org.apache.thrift.protocol.TProtocol prot, closeConnection_args struct) throws org.apache.thrift.TException {
        TTupleProtocol iprot = (TTupleProtocol) prot;
        BitSet incoming = iprot.readBitSet(1);
        if (incoming.get(0)) {
          struct.connection = new RConnection();
          struct.connection.read(iprot);
          struct.setConnectionIsSet(true);
        }
      }
    }

  }

  public static class closeConnection_result implements org.apache.thrift.TBase<closeConnection_result, closeConnection_result._Fields>, java.io.Serializable, Cloneable, Comparable<closeConnection_result>   {
    private static final org.apache.thrift.protocol.TStruct STRUCT_DESC = new org.apache.thrift.protocol.TStruct("closeConnection_result");

    private static final org.apache.thrift.protocol.TField SQL_EXCEPTION_FIELD_DESC = new org.apache.thrift.protocol.TField("sqlException", org.apache.thrift.protocol.TType.STRUCT, (short)1);

    private static final Map<Class<? extends IScheme>, SchemeFactory> schemes = new HashMap<Class<? extends IScheme>, SchemeFactory>();
    static {
      schemes.put(StandardScheme.class, new closeConnection_resultStandardSchemeFactory());
      schemes.put(TupleScheme.class, new closeConnection_resultTupleSchemeFactory());
    }

    public RSQLException sqlException; // required

    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements org.apache.thrift.TFieldIdEnum {
      SQL_EXCEPTION((short)1, "sqlException");

      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        switch(fieldId) {
          case 1: // SQL_EXCEPTION
            return SQL_EXCEPTION;
          default:
            return null;
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }

    // isset id assignments
    public static final Map<_Fields, org.apache.thrift.meta_data.FieldMetaData> metaDataMap;
    static {
      Map<_Fields, org.apache.thrift.meta_data.FieldMetaData> tmpMap = new EnumMap<_Fields, org.apache.thrift.meta_data.FieldMetaData>(_Fields.class);
      tmpMap.put(_Fields.SQL_EXCEPTION, new org.apache.thrift.meta_data.FieldMetaData("sqlException", org.apache.thrift.TFieldRequirementType.DEFAULT, 
          new org.apache.thrift.meta_data.FieldValueMetaData(org.apache.thrift.protocol.TType.STRUCT)));
      metaDataMap = Collections.unmodifiableMap(tmpMap);
      org.apache.thrift.meta_data.FieldMetaData.addStructMetaDataMap(closeConnection_result.class, metaDataMap);
    }

    public closeConnection_result() {
    }

    public closeConnection_result(
      RSQLException sqlException)
    {
      this();
      this.sqlException = sqlException;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public closeConnection_result(closeConnection_result other) {
      if (other.isSetSqlException()) {
        this.sqlException = new RSQLException(other.sqlException);
      }
    }

    public closeConnection_result deepCopy() {
      return new closeConnection_result(this);
    }

    @Override
    public void clear() {
      this.sqlException = null;
    }

    public RSQLException getSqlException() {
      return this.sqlException;
    }

    public closeConnection_result setSqlException(RSQLException sqlException) {
      this.sqlException = sqlException;
      return this;
    }

    public void unsetSqlException() {
      this.sqlException = null;
    }

    /** Returns true if field sqlException is set (has been assigned a value) and false otherwise */
    public boolean isSetSqlException() {
      return this.sqlException != null;
    }

    public void setSqlExceptionIsSet(boolean value) {
      if (!value) {
        this.sqlException = null;
      }
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      case SQL_EXCEPTION:
        if (value == null) {
          unsetSqlException();
        } else {
          setSqlException((RSQLException)value);
        }
        break;

      }
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      case SQL_EXCEPTION:
        return getSqlException();

      }
      throw new IllegalStateException();
    }

    /** Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      if (field == null) {
        throw new IllegalArgumentException();
      }

      switch (field) {
      case SQL_EXCEPTION:
        return isSetSqlException();
      }
      throw new IllegalStateException();
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof closeConnection_result)
        return this.equals((closeConnection_result)that);
      return false;
    }

    public boolean equals(closeConnection_result that) {
      if (that == null)
        return false;

      boolean this_present_sqlException = true && this.isSetSqlException();
      boolean that_present_sqlException = true && that.isSetSqlException();
      if (this_present_sqlException || that_present_sqlException) {
        if (!(this_present_sqlException && that_present_sqlException))
          return false;
        if (!this.sqlException.equals(that.sqlException))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      List<Object> list = new ArrayList<Object>();

      boolean present_sqlException = true && (isSetSqlException());
      list.add(present_sqlException);
      if (present_sqlException)
        list.add(sqlException);

      return list.hashCode();
    }

    @Override
    public int compareTo(closeConnection_result other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetSqlException()).compareTo(other.isSetSqlException());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetSqlException()) {
        lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.sqlException, other.sqlException);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      return 0;
    }

    public _Fields fieldForId(int fieldId) {
      return _Fields.findByThriftId(fieldId);
    }

    public void read(org.apache.thrift.protocol.TProtocol iprot) throws org.apache.thrift.TException {
      schemes.get(iprot.getScheme()).getScheme().read(iprot, this);
    }

    public void write(org.apache.thrift.protocol.TProtocol oprot) throws org.apache.thrift.TException {
      schemes.get(oprot.getScheme()).getScheme().write(oprot, this);
      }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("closeConnection_result(");
      boolean first = true;

      sb.append("sqlException:");
      if (this.sqlException == null) {
        sb.append("null");
      } else {
        sb.append(this.sqlException);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws org.apache.thrift.TException {
      // check for required fields
      // check for sub-struct validity
    }

    private void writeObject(java.io.ObjectOutputStream out) throws java.io.IOException {
      try {
        write(new org.apache.thrift.protocol.TCompactProtocol(new org.apache.thrift.transport.TIOStreamTransport(out)));
      } catch (org.apache.thrift.TException te) {
        throw new java.io.IOException(te);
      }
    }

    private void readObject(java.io.ObjectInputStream in) throws java.io.IOException, ClassNotFoundException {
      try {
        read(new org.apache.thrift.protocol.TCompactProtocol(new org.apache.thrift.transport.TIOStreamTransport(in)));
      } catch (org.apache.thrift.TException te) {
        throw new java.io.IOException(te);
      }
    }

    private static class closeConnection_resultStandardSchemeFactory implements SchemeFactory {
      public closeConnection_resultStandardScheme getScheme() {
        return new closeConnection_resultStandardScheme();
      }
    }

    private static class closeConnection_resultStandardScheme extends StandardScheme<closeConnection_result> {

      public void read(org.apache.thrift.protocol.TProtocol iprot, closeConnection_result struct) throws org.apache.thrift.TException {
        org.apache.thrift.protocol.TField schemeField;
        iprot.readStructBegin();
        while (true)
        {
          schemeField = iprot.readFieldBegin();
          if (schemeField.type == org.apache.thrift.protocol.TType.STOP) { 
            break;
          }
          switch (schemeField.id) {
            case 1: // SQL_EXCEPTION
              if (schemeField.type == org.apache.thrift.protocol.TType.STRUCT) {
                struct.sqlException = new RSQLException();
                struct.sqlException.read(iprot);
                struct.setSqlExceptionIsSet(true);
              } else { 
                org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
              }
              break;
            default:
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
          }
          iprot.readFieldEnd();
        }
        iprot.readStructEnd();

        // check for required fields of primitive type, which can't be checked in the validate method
        struct.validate();
      }

      public void write(org.apache.thrift.protocol.TProtocol oprot, closeConnection_result struct) throws org.apache.thrift.TException {
        struct.validate();

        oprot.writeStructBegin(STRUCT_DESC);
        if (struct.sqlException != null) {
          oprot.writeFieldBegin(SQL_EXCEPTION_FIELD_DESC);
          struct.sqlException.write(oprot);
          oprot.writeFieldEnd();
        }
        oprot.writeFieldStop();
        oprot.writeStructEnd();
      }

    }

    private static class closeConnection_resultTupleSchemeFactory implements SchemeFactory {
      public closeConnection_resultTupleScheme getScheme() {
        return new closeConnection_resultTupleScheme();
      }
    }

    private static class closeConnection_resultTupleScheme extends TupleScheme<closeConnection_result> {

      @Override
      public void write(org.apache.thrift.protocol.TProtocol prot, closeConnection_result struct) throws org.apache.thrift.TException {
        TTupleProtocol oprot = (TTupleProtocol) prot;
        BitSet optionals = new BitSet();
        if (struct.isSetSqlException()) {
          optionals.set(0);
        }
        oprot.writeBitSet(optionals, 1);
        if (struct.isSetSqlException()) {
          struct.sqlException.write(oprot);
        }
      }

      @Override
      public void read(org.apache.thrift.protocol.TProtocol prot, closeConnection_result struct) throws org.apache.thrift.TException {
        TTupleProtocol iprot = (TTupleProtocol) prot;
        BitSet incoming = iprot.readBitSet(1);
        if (incoming.get(0)) {
          struct.sqlException = new RSQLException();
          struct.sqlException.read(iprot);
          struct.setSqlExceptionIsSet(true);
        }
      }
    }

  }

  public static class statement_close_args implements org.apache.thrift.TBase<statement_close_args, statement_close_args._Fields>, java.io.Serializable, Cloneable, Comparable<statement_close_args>   {
    private static final org.apache.thrift.protocol.TStruct STRUCT_DESC = new org.apache.thrift.protocol.TStruct("statement_close_args");

    private static final org.apache.thrift.protocol.TField STATEMENT_FIELD_DESC = new org.apache.thrift.protocol.TField("statement", org.apache.thrift.protocol.TType.STRUCT, (short)1);

    private static final Map<Class<? extends IScheme>, SchemeFactory> schemes = new HashMap<Class<? extends IScheme>, SchemeFactory>();
    static {
      schemes.put(StandardScheme.class, new statement_close_argsStandardSchemeFactory());
      schemes.put(TupleScheme.class, new statement_close_argsTupleSchemeFactory());
    }

    public RStatement statement; // required

    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements org.apache.thrift.TFieldIdEnum {
      STATEMENT((short)1, "statement");

      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        switch(fieldId) {
          case 1: // STATEMENT
            return STATEMENT;
          default:
            return null;
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }

    // isset id assignments
    public static final Map<_Fields, org.apache.thrift.meta_data.FieldMetaData> metaDataMap;
    static {
      Map<_Fields, org.apache.thrift.meta_data.FieldMetaData> tmpMap = new EnumMap<_Fields, org.apache.thrift.meta_data.FieldMetaData>(_Fields.class);
      tmpMap.put(_Fields.STATEMENT, new org.apache.thrift.meta_data.FieldMetaData("statement", org.apache.thrift.TFieldRequirementType.DEFAULT, 
          new org.apache.thrift.meta_data.StructMetaData(org.apache.thrift.protocol.TType.STRUCT, RStatement.class)));
      metaDataMap = Collections.unmodifiableMap(tmpMap);
      org.apache.thrift.meta_data.FieldMetaData.addStructMetaDataMap(statement_close_args.class, metaDataMap);
    }

    public statement_close_args() {
    }

    public statement_close_args(
      RStatement statement)
    {
      this();
      this.statement = statement;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public statement_close_args(statement_close_args other) {
      if (other.isSetStatement()) {
        this.statement = new RStatement(other.statement);
      }
    }

    public statement_close_args deepCopy() {
      return new statement_close_args(this);
    }

    @Override
    public void clear() {
      this.statement = null;
    }

    public RStatement getStatement() {
      return this.statement;
    }

    public statement_close_args setStatement(RStatement statement) {
      this.statement = statement;
      return this;
    }

    public void unsetStatement() {
      this.statement = null;
    }

    /** Returns true if field statement is set (has been assigned a value) and false otherwise */
    public boolean isSetStatement() {
      return this.statement != null;
    }

    public void setStatementIsSet(boolean value) {
      if (!value) {
        this.statement = null;
      }
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      case STATEMENT:
        if (value == null) {
          unsetStatement();
        } else {
          setStatement((RStatement)value);
        }
        break;

      }
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      case STATEMENT:
        return getStatement();

      }
      throw new IllegalStateException();
    }

    /** Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      if (field == null) {
        throw new IllegalArgumentException();
      }

      switch (field) {
      case STATEMENT:
        return isSetStatement();
      }
      throw new IllegalStateException();
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof statement_close_args)
        return this.equals((statement_close_args)that);
      return false;
    }

    public boolean equals(statement_close_args that) {
      if (that == null)
        return false;

      boolean this_present_statement = true && this.isSetStatement();
      boolean that_present_statement = true && that.isSetStatement();
      if (this_present_statement || that_present_statement) {
        if (!(this_present_statement && that_present_statement))
          return false;
        if (!this.statement.equals(that.statement))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      List<Object> list = new ArrayList<Object>();

      boolean present_statement = true && (isSetStatement());
      list.add(present_statement);
      if (present_statement)
        list.add(statement);

      return list.hashCode();
    }

    @Override
    public int compareTo(statement_close_args other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetStatement()).compareTo(other.isSetStatement());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetStatement()) {
        lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.statement, other.statement);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      return 0;
    }

    public _Fields fieldForId(int fieldId) {
      return _Fields.findByThriftId(fieldId);
    }

    public void read(org.apache.thrift.protocol.TProtocol iprot) throws org.apache.thrift.TException {
      schemes.get(iprot.getScheme()).getScheme().read(iprot, this);
    }

    public void write(org.apache.thrift.protocol.TProtocol oprot) throws org.apache.thrift.TException {
      schemes.get(oprot.getScheme()).getScheme().write(oprot, this);
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("statement_close_args(");
      boolean first = true;

      sb.append("statement:");
      if (this.statement == null) {
        sb.append("null");
      } else {
        sb.append(this.statement);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws org.apache.thrift.TException {
      // check for required fields
      // check for sub-struct validity
      if (statement != null) {
        statement.validate();
      }
    }

    private void writeObject(java.io.ObjectOutputStream out) throws java.io.IOException {
      try {
        write(new org.apache.thrift.protocol.TCompactProtocol(new org.apache.thrift.transport.TIOStreamTransport(out)));
      } catch (org.apache.thrift.TException te) {
        throw new java.io.IOException(te);
      }
    }

    private void readObject(java.io.ObjectInputStream in) throws java.io.IOException, ClassNotFoundException {
      try {
        read(new org.apache.thrift.protocol.TCompactProtocol(new org.apache.thrift.transport.TIOStreamTransport(in)));
      } catch (org.apache.thrift.TException te) {
        throw new java.io.IOException(te);
      }
    }

    private static class statement_close_argsStandardSchemeFactory implements SchemeFactory {
      public statement_close_argsStandardScheme getScheme() {
        return new statement_close_argsStandardScheme();
      }
    }

    private static class statement_close_argsStandardScheme extends StandardScheme<statement_close_args> {

      public void read(org.apache.thrift.protocol.TProtocol iprot, statement_close_args struct) throws org.apache.thrift.TException {
        org.apache.thrift.protocol.TField schemeField;
        iprot.readStructBegin();
        while (true)
        {
          schemeField = iprot.readFieldBegin();
          if (schemeField.type == org.apache.thrift.protocol.TType.STOP) { 
            break;
          }
          switch (schemeField.id) {
            case 1: // STATEMENT
              if (schemeField.type == org.apache.thrift.protocol.TType.STRUCT) {
                struct.statement = new RStatement();
                struct.statement.read(iprot);
                struct.setStatementIsSet(true);
              } else { 
                org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
              }
              break;
            default:
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
          }
          iprot.readFieldEnd();
        }
        iprot.readStructEnd();

        // check for required fields of primitive type, which can't be checked in the validate method
        struct.validate();
      }

      public void write(org.apache.thrift.protocol.TProtocol oprot, statement_close_args struct) throws org.apache.thrift.TException {
        struct.validate();

        oprot.writeStructBegin(STRUCT_DESC);
        if (struct.statement != null) {
          oprot.writeFieldBegin(STATEMENT_FIELD_DESC);
          struct.statement.write(oprot);
          oprot.writeFieldEnd();
        }
        oprot.writeFieldStop();
        oprot.writeStructEnd();
      }

    }

    private static class statement_close_argsTupleSchemeFactory implements SchemeFactory {
      public statement_close_argsTupleScheme getScheme() {
        return new statement_close_argsTupleScheme();
      }
    }

    private static class statement_close_argsTupleScheme extends TupleScheme<statement_close_args> {

      @Override
      public void write(org.apache.thrift.protocol.TProtocol prot, statement_close_args struct) throws org.apache.thrift.TException {
        TTupleProtocol oprot = (TTupleProtocol) prot;
        BitSet optionals = new BitSet();
        if (struct.isSetStatement()) {
          optionals.set(0);
        }
        oprot.writeBitSet(optionals, 1);
        if (struct.isSetStatement()) {
          struct.statement.write(oprot);
        }
      }

      @Override
      public void read(org.apache.thrift.protocol.TProtocol prot, statement_close_args struct) throws org.apache.thrift.TException {
        TTupleProtocol iprot = (TTupleProtocol) prot;
        BitSet incoming = iprot.readBitSet(1);
        if (incoming.get(0)) {
          struct.statement = new RStatement();
          struct.statement.read(iprot);
          struct.setStatementIsSet(true);
        }
      }
    }

  }

  public static class statement_close_result implements org.apache.thrift.TBase<statement_close_result, statement_close_result._Fields>, java.io.Serializable, Cloneable, Comparable<statement_close_result>   {
    private static final org.apache.thrift.protocol.TStruct STRUCT_DESC = new org.apache.thrift.protocol.TStruct("statement_close_result");

    private static final org.apache.thrift.protocol.TField SQL_EXCEPTION_FIELD_DESC = new org.apache.thrift.protocol.TField("sqlException", org.apache.thrift.protocol.TType.STRUCT, (short)1);

    private static final Map<Class<? extends IScheme>, SchemeFactory> schemes = new HashMap<Class<? extends IScheme>, SchemeFactory>();
    static {
      schemes.put(StandardScheme.class, new statement_close_resultStandardSchemeFactory());
      schemes.put(TupleScheme.class, new statement_close_resultTupleSchemeFactory());
    }

    public RSQLException sqlException; // required

    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements org.apache.thrift.TFieldIdEnum {
      SQL_EXCEPTION((short)1, "sqlException");

      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        switch(fieldId) {
          case 1: // SQL_EXCEPTION
            return SQL_EXCEPTION;
          default:
            return null;
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }

    // isset id assignments
    public static final Map<_Fields, org.apache.thrift.meta_data.FieldMetaData> metaDataMap;
    static {
      Map<_Fields, org.apache.thrift.meta_data.FieldMetaData> tmpMap = new EnumMap<_Fields, org.apache.thrift.meta_data.FieldMetaData>(_Fields.class);
      tmpMap.put(_Fields.SQL_EXCEPTION, new org.apache.thrift.meta_data.FieldMetaData("sqlException", org.apache.thrift.TFieldRequirementType.DEFAULT, 
          new org.apache.thrift.meta_data.FieldValueMetaData(org.apache.thrift.protocol.TType.STRUCT)));
      metaDataMap = Collections.unmodifiableMap(tmpMap);
      org.apache.thrift.meta_data.FieldMetaData.addStructMetaDataMap(statement_close_result.class, metaDataMap);
    }

    public statement_close_result() {
    }

    public statement_close_result(
      RSQLException sqlException)
    {
      this();
      this.sqlException = sqlException;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public statement_close_result(statement_close_result other) {
      if (other.isSetSqlException()) {
        this.sqlException = new RSQLException(other.sqlException);
      }
    }

    public statement_close_result deepCopy() {
      return new statement_close_result(this);
    }

    @Override
    public void clear() {
      this.sqlException = null;
    }

    public RSQLException getSqlException() {
      return this.sqlException;
    }

    public statement_close_result setSqlException(RSQLException sqlException) {
      this.sqlException = sqlException;
      return this;
    }

    public void unsetSqlException() {
      this.sqlException = null;
    }

    /** Returns true if field sqlException is set (has been assigned a value) and false otherwise */
    public boolean isSetSqlException() {
      return this.sqlException != null;
    }

    public void setSqlExceptionIsSet(boolean value) {
      if (!value) {
        this.sqlException = null;
      }
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      case SQL_EXCEPTION:
        if (value == null) {
          unsetSqlException();
        } else {
          setSqlException((RSQLException)value);
        }
        break;

      }
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      case SQL_EXCEPTION:
        return getSqlException();

      }
      throw new IllegalStateException();
    }

    /** Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      if (field == null) {
        throw new IllegalArgumentException();
      }

      switch (field) {
      case SQL_EXCEPTION:
        return isSetSqlException();
      }
      throw new IllegalStateException();
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof statement_close_result)
        return this.equals((statement_close_result)that);
      return false;
    }

    public boolean equals(statement_close_result that) {
      if (that == null)
        return false;

      boolean this_present_sqlException = true && this.isSetSqlException();
      boolean that_present_sqlException = true && that.isSetSqlException();
      if (this_present_sqlException || that_present_sqlException) {
        if (!(this_present_sqlException && that_present_sqlException))
          return false;
        if (!this.sqlException.equals(that.sqlException))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      List<Object> list = new ArrayList<Object>();

      boolean present_sqlException = true && (isSetSqlException());
      list.add(present_sqlException);
      if (present_sqlException)
        list.add(sqlException);

      return list.hashCode();
    }

    @Override
    public int compareTo(statement_close_result other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetSqlException()).compareTo(other.isSetSqlException());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetSqlException()) {
        lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.sqlException, other.sqlException);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      return 0;
    }

    public _Fields fieldForId(int fieldId) {
      return _Fields.findByThriftId(fieldId);
    }

    public void read(org.apache.thrift.protocol.TProtocol iprot) throws org.apache.thrift.TException {
      schemes.get(iprot.getScheme()).getScheme().read(iprot, this);
    }

    public void write(org.apache.thrift.protocol.TProtocol oprot) throws org.apache.thrift.TException {
      schemes.get(oprot.getScheme()).getScheme().write(oprot, this);
      }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("statement_close_result(");
      boolean first = true;

      sb.append("sqlException:");
      if (this.sqlException == null) {
        sb.append("null");
      } else {
        sb.append(this.sqlException);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws org.apache.thrift.TException {
      // check for required fields
      // check for sub-struct validity
    }

    private void writeObject(java.io.ObjectOutputStream out) throws java.io.IOException {
      try {
        write(new org.apache.thrift.protocol.TCompactProtocol(new org.apache.thrift.transport.TIOStreamTransport(out)));
      } catch (org.apache.thrift.TException te) {
        throw new java.io.IOException(te);
      }
    }

    private void readObject(java.io.ObjectInputStream in) throws java.io.IOException, ClassNotFoundException {
      try {
        read(new org.apache.thrift.protocol.TCompactProtocol(new org.apache.thrift.transport.TIOStreamTransport(in)));
      } catch (org.apache.thrift.TException te) {
        throw new java.io.IOException(te);
      }
    }

    private static class statement_close_resultStandardSchemeFactory implements SchemeFactory {
      public statement_close_resultStandardScheme getScheme() {
        return new statement_close_resultStandardScheme();
      }
    }

    private static class statement_close_resultStandardScheme extends StandardScheme<statement_close_result> {

      public void read(org.apache.thrift.protocol.TProtocol iprot, statement_close_result struct) throws org.apache.thrift.TException {
        org.apache.thrift.protocol.TField schemeField;
        iprot.readStructBegin();
        while (true)
        {
          schemeField = iprot.readFieldBegin();
          if (schemeField.type == org.apache.thrift.protocol.TType.STOP) { 
            break;
          }
          switch (schemeField.id) {
            case 1: // SQL_EXCEPTION
              if (schemeField.type == org.apache.thrift.protocol.TType.STRUCT) {
                struct.sqlException = new RSQLException();
                struct.sqlException.read(iprot);
                struct.setSqlExceptionIsSet(true);
              } else { 
                org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
              }
              break;
            default:
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
          }
          iprot.readFieldEnd();
        }
        iprot.readStructEnd();

        // check for required fields of primitive type, which can't be checked in the validate method
        struct.validate();
      }

      public void write(org.apache.thrift.protocol.TProtocol oprot, statement_close_result struct) throws org.apache.thrift.TException {
        struct.validate();

        oprot.writeStructBegin(STRUCT_DESC);
        if (struct.sqlException != null) {
          oprot.writeFieldBegin(SQL_EXCEPTION_FIELD_DESC);
          struct.sqlException.write(oprot);
          oprot.writeFieldEnd();
        }
        oprot.writeFieldStop();
        oprot.writeStructEnd();
      }

    }

    private static class statement_close_resultTupleSchemeFactory implements SchemeFactory {
      public statement_close_resultTupleScheme getScheme() {
        return new statement_close_resultTupleScheme();
      }
    }

    private static class statement_close_resultTupleScheme extends TupleScheme<statement_close_result> {

      @Override
      public void write(org.apache.thrift.protocol.TProtocol prot, statement_close_result struct) throws org.apache.thrift.TException {
        TTupleProtocol oprot = (TTupleProtocol) prot;
        BitSet optionals = new BitSet();
        if (struct.isSetSqlException()) {
          optionals.set(0);
        }
        oprot.writeBitSet(optionals, 1);
        if (struct.isSetSqlException()) {
          struct.sqlException.write(oprot);
        }
      }

      @Override
      public void read(org.apache.thrift.protocol.TProtocol prot, statement_close_result struct) throws org.apache.thrift.TException {
        TTupleProtocol iprot = (TTupleProtocol) prot;
        BitSet incoming = iprot.readBitSet(1);
        if (incoming.get(0)) {
          struct.sqlException = new RSQLException();
          struct.sqlException.read(iprot);
          struct.setSqlExceptionIsSet(true);
        }
      }
    }

  }

  public static class statement_execute_args implements org.apache.thrift.TBase<statement_execute_args, statement_execute_args._Fields>, java.io.Serializable, Cloneable, Comparable<statement_execute_args>   {
    private static final org.apache.thrift.protocol.TStruct STRUCT_DESC = new org.apache.thrift.protocol.TStruct("statement_execute_args");

    private static final org.apache.thrift.protocol.TField STATEMENT_FIELD_DESC = new org.apache.thrift.protocol.TField("statement", org.apache.thrift.protocol.TType.STRUCT, (short)1);
    private static final org.apache.thrift.protocol.TField SQL_FIELD_DESC = new org.apache.thrift.protocol.TField("sql", org.apache.thrift.protocol.TType.STRING, (short)2);

    private static final Map<Class<? extends IScheme>, SchemeFactory> schemes = new HashMap<Class<? extends IScheme>, SchemeFactory>();
    static {
      schemes.put(StandardScheme.class, new statement_execute_argsStandardSchemeFactory());
      schemes.put(TupleScheme.class, new statement_execute_argsTupleSchemeFactory());
    }

    public RStatement statement; // required
    public String sql; // required

    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements org.apache.thrift.TFieldIdEnum {
      STATEMENT((short)1, "statement"),
      SQL((short)2, "sql");

      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        switch(fieldId) {
          case 1: // STATEMENT
            return STATEMENT;
          case 2: // SQL
            return SQL;
          default:
            return null;
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }

    // isset id assignments
    public static final Map<_Fields, org.apache.thrift.meta_data.FieldMetaData> metaDataMap;
    static {
      Map<_Fields, org.apache.thrift.meta_data.FieldMetaData> tmpMap = new EnumMap<_Fields, org.apache.thrift.meta_data.FieldMetaData>(_Fields.class);
      tmpMap.put(_Fields.STATEMENT, new org.apache.thrift.meta_data.FieldMetaData("statement", org.apache.thrift.TFieldRequirementType.DEFAULT, 
          new org.apache.thrift.meta_data.StructMetaData(org.apache.thrift.protocol.TType.STRUCT, RStatement.class)));
      tmpMap.put(_Fields.SQL, new org.apache.thrift.meta_data.FieldMetaData("sql", org.apache.thrift.TFieldRequirementType.DEFAULT, 
          new org.apache.thrift.meta_data.FieldValueMetaData(org.apache.thrift.protocol.TType.STRING)));
      metaDataMap = Collections.unmodifiableMap(tmpMap);
      org.apache.thrift.meta_data.FieldMetaData.addStructMetaDataMap(statement_execute_args.class, metaDataMap);
    }

    public statement_execute_args() {
    }

    public statement_execute_args(
      RStatement statement,
      String sql)
    {
      this();
      this.statement = statement;
      this.sql = sql;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public statement_execute_args(statement_execute_args other) {
      if (other.isSetStatement()) {
        this.statement = new RStatement(other.statement);
      }
      if (other.isSetSql()) {
        this.sql = other.sql;
      }
    }

    public statement_execute_args deepCopy() {
      return new statement_execute_args(this);
    }

    @Override
    public void clear() {
      this.statement = null;
      this.sql = null;
    }

    public RStatement getStatement() {
      return this.statement;
    }

    public statement_execute_args setStatement(RStatement statement) {
      this.statement = statement;
      return this;
    }

    public void unsetStatement() {
      this.statement = null;
    }

    /** Returns true if field statement is set (has been assigned a value) and false otherwise */
    public boolean isSetStatement() {
      return this.statement != null;
    }

    public void setStatementIsSet(boolean value) {
      if (!value) {
        this.statement = null;
      }
    }

    public String getSql() {
      return this.sql;
    }

    public statement_execute_args setSql(String sql) {
      this.sql = sql;
      return this;
    }

    public void unsetSql() {
      this.sql = null;
    }

    /** Returns true if field sql is set (has been assigned a value) and false otherwise */
    public boolean isSetSql() {
      return this.sql != null;
    }

    public void setSqlIsSet(boolean value) {
      if (!value) {
        this.sql = null;
      }
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      case STATEMENT:
        if (value == null) {
          unsetStatement();
        } else {
          setStatement((RStatement)value);
        }
        break;

      case SQL:
        if (value == null) {
          unsetSql();
        } else {
          setSql((String)value);
        }
        break;

      }
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      case STATEMENT:
        return getStatement();

      case SQL:
        return getSql();

      }
      throw new IllegalStateException();
    }

    /** Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      if (field == null) {
        throw new IllegalArgumentException();
      }

      switch (field) {
      case STATEMENT:
        return isSetStatement();
      case SQL:
        return isSetSql();
      }
      throw new IllegalStateException();
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof statement_execute_args)
        return this.equals((statement_execute_args)that);
      return false;
    }

    public boolean equals(statement_execute_args that) {
      if (that == null)
        return false;

      boolean this_present_statement = true && this.isSetStatement();
      boolean that_present_statement = true && that.isSetStatement();
      if (this_present_statement || that_present_statement) {
        if (!(this_present_statement && that_present_statement))
          return false;
        if (!this.statement.equals(that.statement))
          return false;
      }

      boolean this_present_sql = true && this.isSetSql();
      boolean that_present_sql = true && that.isSetSql();
      if (this_present_sql || that_present_sql) {
        if (!(this_present_sql && that_present_sql))
          return false;
        if (!this.sql.equals(that.sql))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      List<Object> list = new ArrayList<Object>();

      boolean present_statement = true && (isSetStatement());
      list.add(present_statement);
      if (present_statement)
        list.add(statement);

      boolean present_sql = true && (isSetSql());
      list.add(present_sql);
      if (present_sql)
        list.add(sql);

      return list.hashCode();
    }

    @Override
    public int compareTo(statement_execute_args other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetStatement()).compareTo(other.isSetStatement());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetStatement()) {
        lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.statement, other.statement);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      lastComparison = Boolean.valueOf(isSetSql()).compareTo(other.isSetSql());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetSql()) {
        lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.sql, other.sql);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      return 0;
    }

    public _Fields fieldForId(int fieldId) {
      return _Fields.findByThriftId(fieldId);
    }

    public void read(org.apache.thrift.protocol.TProtocol iprot) throws org.apache.thrift.TException {
      schemes.get(iprot.getScheme()).getScheme().read(iprot, this);
    }

    public void write(org.apache.thrift.protocol.TProtocol oprot) throws org.apache.thrift.TException {
      schemes.get(oprot.getScheme()).getScheme().write(oprot, this);
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("statement_execute_args(");
      boolean first = true;

      sb.append("statement:");
      if (this.statement == null) {
        sb.append("null");
      } else {
        sb.append(this.statement);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("sql:");
      if (this.sql == null) {
        sb.append("null");
      } else {
        sb.append(this.sql);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws org.apache.thrift.TException {
      // check for required fields
      // check for sub-struct validity
      if (statement != null) {
        statement.validate();
      }
    }

    private void writeObject(java.io.ObjectOutputStream out) throws java.io.IOException {
      try {
        write(new org.apache.thrift.protocol.TCompactProtocol(new org.apache.thrift.transport.TIOStreamTransport(out)));
      } catch (org.apache.thrift.TException te) {
        throw new java.io.IOException(te);
      }
    }

    private void readObject(java.io.ObjectInputStream in) throws java.io.IOException, ClassNotFoundException {
      try {
        read(new org.apache.thrift.protocol.TCompactProtocol(new org.apache.thrift.transport.TIOStreamTransport(in)));
      } catch (org.apache.thrift.TException te) {
        throw new java.io.IOException(te);
      }
    }

    private static class statement_execute_argsStandardSchemeFactory implements SchemeFactory {
      public statement_execute_argsStandardScheme getScheme() {
        return new statement_execute_argsStandardScheme();
      }
    }

    private static class statement_execute_argsStandardScheme extends StandardScheme<statement_execute_args> {

      public void read(org.apache.thrift.protocol.TProtocol iprot, statement_execute_args struct) throws org.apache.thrift.TException {
        org.apache.thrift.protocol.TField schemeField;
        iprot.readStructBegin();
        while (true)
        {
          schemeField = iprot.readFieldBegin();
          if (schemeField.type == org.apache.thrift.protocol.TType.STOP) { 
            break;
          }
          switch (schemeField.id) {
            case 1: // STATEMENT
              if (schemeField.type == org.apache.thrift.protocol.TType.STRUCT) {
                struct.statement = new RStatement();
                struct.statement.read(iprot);
                struct.setStatementIsSet(true);
              } else { 
                org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
              }
              break;
            case 2: // SQL
              if (schemeField.type == org.apache.thrift.protocol.TType.STRING) {
                struct.sql = iprot.readString();
                struct.setSqlIsSet(true);
              } else { 
                org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
              }
              break;
            default:
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
          }
          iprot.readFieldEnd();
        }
        iprot.readStructEnd();

        // check for required fields of primitive type, which can't be checked in the validate method
        struct.validate();
      }

      public void write(org.apache.thrift.protocol.TProtocol oprot, statement_execute_args struct) throws org.apache.thrift.TException {
        struct.validate();

        oprot.writeStructBegin(STRUCT_DESC);
        if (struct.statement != null) {
          oprot.writeFieldBegin(STATEMENT_FIELD_DESC);
          struct.statement.write(oprot);
          oprot.writeFieldEnd();
        }
        if (struct.sql != null) {
          oprot.writeFieldBegin(SQL_FIELD_DESC);
          oprot.writeString(struct.sql);
          oprot.writeFieldEnd();
        }
        oprot.writeFieldStop();
        oprot.writeStructEnd();
      }

    }

    private static class statement_execute_argsTupleSchemeFactory implements SchemeFactory {
      public statement_execute_argsTupleScheme getScheme() {
        return new statement_execute_argsTupleScheme();
      }
    }

    private static class statement_execute_argsTupleScheme extends TupleScheme<statement_execute_args> {

      @Override
      public void write(org.apache.thrift.protocol.TProtocol prot, statement_execute_args struct) throws org.apache.thrift.TException {
        TTupleProtocol oprot = (TTupleProtocol) prot;
        BitSet optionals = new BitSet();
        if (struct.isSetStatement()) {
          optionals.set(0);
        }
        if (struct.isSetSql()) {
          optionals.set(1);
        }
        oprot.writeBitSet(optionals, 2);
        if (struct.isSetStatement()) {
          struct.statement.write(oprot);
        }
        if (struct.isSetSql()) {
          oprot.writeString(struct.sql);
        }
      }

      @Override
      public void read(org.apache.thrift.protocol.TProtocol prot, statement_execute_args struct) throws org.apache.thrift.TException {
        TTupleProtocol iprot = (TTupleProtocol) prot;
        BitSet incoming = iprot.readBitSet(2);
        if (incoming.get(0)) {
          struct.statement = new RStatement();
          struct.statement.read(iprot);
          struct.setStatementIsSet(true);
        }
        if (incoming.get(1)) {
          struct.sql = iprot.readString();
          struct.setSqlIsSet(true);
        }
      }
    }

  }

  public static class statement_execute_result implements org.apache.thrift.TBase<statement_execute_result, statement_execute_result._Fields>, java.io.Serializable, Cloneable, Comparable<statement_execute_result>   {
    private static final org.apache.thrift.protocol.TStruct STRUCT_DESC = new org.apache.thrift.protocol.TStruct("statement_execute_result");

    private static final org.apache.thrift.protocol.TField SUCCESS_FIELD_DESC = new org.apache.thrift.protocol.TField("success", org.apache.thrift.protocol.TType.BOOL, (short)0);
    private static final org.apache.thrift.protocol.TField SQL_EXCEPTION_FIELD_DESC = new org.apache.thrift.protocol.TField("sqlException", org.apache.thrift.protocol.TType.STRUCT, (short)1);

    private static final Map<Class<? extends IScheme>, SchemeFactory> schemes = new HashMap<Class<? extends IScheme>, SchemeFactory>();
    static {
      schemes.put(StandardScheme.class, new statement_execute_resultStandardSchemeFactory());
      schemes.put(TupleScheme.class, new statement_execute_resultTupleSchemeFactory());
    }

    public boolean success; // required
    public RSQLException sqlException; // required

    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements org.apache.thrift.TFieldIdEnum {
      SUCCESS((short)0, "success"),
      SQL_EXCEPTION((short)1, "sqlException");

      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        switch(fieldId) {
          case 0: // SUCCESS
            return SUCCESS;
          case 1: // SQL_EXCEPTION
            return SQL_EXCEPTION;
          default:
            return null;
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }

    // isset id assignments
    private static final int __SUCCESS_ISSET_ID = 0;
    private byte __isset_bitfield = 0;
    public static final Map<_Fields, org.apache.thrift.meta_data.FieldMetaData> metaDataMap;
    static {
      Map<_Fields, org.apache.thrift.meta_data.FieldMetaData> tmpMap = new EnumMap<_Fields, org.apache.thrift.meta_data.FieldMetaData>(_Fields.class);
      tmpMap.put(_Fields.SUCCESS, new org.apache.thrift.meta_data.FieldMetaData("success", org.apache.thrift.TFieldRequirementType.DEFAULT, 
          new org.apache.thrift.meta_data.FieldValueMetaData(org.apache.thrift.protocol.TType.BOOL)));
      tmpMap.put(_Fields.SQL_EXCEPTION, new org.apache.thrift.meta_data.FieldMetaData("sqlException", org.apache.thrift.TFieldRequirementType.DEFAULT, 
          new org.apache.thrift.meta_data.FieldValueMetaData(org.apache.thrift.protocol.TType.STRUCT)));
      metaDataMap = Collections.unmodifiableMap(tmpMap);
      org.apache.thrift.meta_data.FieldMetaData.addStructMetaDataMap(statement_execute_result.class, metaDataMap);
    }

    public statement_execute_result() {
    }

    public statement_execute_result(
      boolean success,
      RSQLException sqlException)
    {
      this();
      this.success = success;
      setSuccessIsSet(true);
      this.sqlException = sqlException;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public statement_execute_result(statement_execute_result other) {
      __isset_bitfield = other.__isset_bitfield;
      this.success = other.success;
      if (other.isSetSqlException()) {
        this.sqlException = new RSQLException(other.sqlException);
      }
    }

    public statement_execute_result deepCopy() {
      return new statement_execute_result(this);
    }

    @Override
    public void clear() {
      setSuccessIsSet(false);
      this.success = false;
      this.sqlException = null;
    }

    public boolean isSuccess() {
      return this.success;
    }

    public statement_execute_result setSuccess(boolean success) {
      this.success = success;
      setSuccessIsSet(true);
      return this;
    }

    public void unsetSuccess() {
      __isset_bitfield = EncodingUtils.clearBit(__isset_bitfield, __SUCCESS_ISSET_ID);
    }

    /** Returns true if field success is set (has been assigned a value) and false otherwise */
    public boolean isSetSuccess() {
      return EncodingUtils.testBit(__isset_bitfield, __SUCCESS_ISSET_ID);
    }

    public void setSuccessIsSet(boolean value) {
      __isset_bitfield = EncodingUtils.setBit(__isset_bitfield, __SUCCESS_ISSET_ID, value);
    }

    public RSQLException getSqlException() {
      return this.sqlException;
    }

    public statement_execute_result setSqlException(RSQLException sqlException) {
      this.sqlException = sqlException;
      return this;
    }

    public void unsetSqlException() {
      this.sqlException = null;
    }

    /** Returns true if field sqlException is set (has been assigned a value) and false otherwise */
    public boolean isSetSqlException() {
      return this.sqlException != null;
    }

    public void setSqlExceptionIsSet(boolean value) {
      if (!value) {
        this.sqlException = null;
      }
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          setSuccess((Boolean)value);
        }
        break;

      case SQL_EXCEPTION:
        if (value == null) {
          unsetSqlException();
        } else {
          setSqlException((RSQLException)value);
        }
        break;

      }
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      case SUCCESS:
        return Boolean.valueOf(isSuccess());

      case SQL_EXCEPTION:
        return getSqlException();

      }
      throw new IllegalStateException();
    }

    /** Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      if (field == null) {
        throw new IllegalArgumentException();
      }

      switch (field) {
      case SUCCESS:
        return isSetSuccess();
      case SQL_EXCEPTION:
        return isSetSqlException();
      }
      throw new IllegalStateException();
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof statement_execute_result)
        return this.equals((statement_execute_result)that);
      return false;
    }

    public boolean equals(statement_execute_result that) {
      if (that == null)
        return false;

      boolean this_present_success = true;
      boolean that_present_success = true;
      if (this_present_success || that_present_success) {
        if (!(this_present_success && that_present_success))
          return false;
        if (this.success != that.success)
          return false;
      }

      boolean this_present_sqlException = true && this.isSetSqlException();
      boolean that_present_sqlException = true && that.isSetSqlException();
      if (this_present_sqlException || that_present_sqlException) {
        if (!(this_present_sqlException && that_present_sqlException))
          return false;
        if (!this.sqlException.equals(that.sqlException))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      List<Object> list = new ArrayList<Object>();

      boolean present_success = true;
      list.add(present_success);
      if (present_success)
        list.add(success);

      boolean present_sqlException = true && (isSetSqlException());
      list.add(present_sqlException);
      if (present_sqlException)
        list.add(sqlException);

      return list.hashCode();
    }

    @Override
    public int compareTo(statement_execute_result other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetSuccess()).compareTo(other.isSetSuccess());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetSuccess()) {
        lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.success, other.success);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      lastComparison = Boolean.valueOf(isSetSqlException()).compareTo(other.isSetSqlException());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetSqlException()) {
        lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.sqlException, other.sqlException);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      return 0;
    }

    public _Fields fieldForId(int fieldId) {
      return _Fields.findByThriftId(fieldId);
    }

    public void read(org.apache.thrift.protocol.TProtocol iprot) throws org.apache.thrift.TException {
      schemes.get(iprot.getScheme()).getScheme().read(iprot, this);
    }

    public void write(org.apache.thrift.protocol.TProtocol oprot) throws org.apache.thrift.TException {
      schemes.get(oprot.getScheme()).getScheme().write(oprot, this);
      }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("statement_execute_result(");
      boolean first = true;

      sb.append("success:");
      sb.append(this.success);
      first = false;
      if (!first) sb.append(", ");
      sb.append("sqlException:");
      if (this.sqlException == null) {
        sb.append("null");
      } else {
        sb.append(this.sqlException);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws org.apache.thrift.TException {
      // check for required fields
      // check for sub-struct validity
    }

    private void writeObject(java.io.ObjectOutputStream out) throws java.io.IOException {
      try {
        write(new org.apache.thrift.protocol.TCompactProtocol(new org.apache.thrift.transport.TIOStreamTransport(out)));
      } catch (org.apache.thrift.TException te) {
        throw new java.io.IOException(te);
      }
    }

    private void readObject(java.io.ObjectInputStream in) throws java.io.IOException, ClassNotFoundException {
      try {
        // it doesn't seem like you should have to do this, but java serialization is wacky, and doesn't call the default constructor.
        __isset_bitfield = 0;
        read(new org.apache.thrift.protocol.TCompactProtocol(new org.apache.thrift.transport.TIOStreamTransport(in)));
      } catch (org.apache.thrift.TException te) {
        throw new java.io.IOException(te);
      }
    }

    private static class statement_execute_resultStandardSchemeFactory implements SchemeFactory {
      public statement_execute_resultStandardScheme getScheme() {
        return new statement_execute_resultStandardScheme();
      }
    }

    private static class statement_execute_resultStandardScheme extends StandardScheme<statement_execute_result> {

      public void read(org.apache.thrift.protocol.TProtocol iprot, statement_execute_result struct) throws org.apache.thrift.TException {
        org.apache.thrift.protocol.TField schemeField;
        iprot.readStructBegin();
        while (true)
        {
          schemeField = iprot.readFieldBegin();
          if (schemeField.type == org.apache.thrift.protocol.TType.STOP) { 
            break;
          }
          switch (schemeField.id) {
            case 0: // SUCCESS
              if (schemeField.type == org.apache.thrift.protocol.TType.BOOL) {
                struct.success = iprot.readBool();
                struct.setSuccessIsSet(true);
              } else { 
                org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
              }
              break;
            case 1: // SQL_EXCEPTION
              if (schemeField.type == org.apache.thrift.protocol.TType.STRUCT) {
                struct.sqlException = new RSQLException();
                struct.sqlException.read(iprot);
                struct.setSqlExceptionIsSet(true);
              } else { 
                org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
              }
              break;
            default:
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
          }
          iprot.readFieldEnd();
        }
        iprot.readStructEnd();

        // check for required fields of primitive type, which can't be checked in the validate method
        struct.validate();
      }

      public void write(org.apache.thrift.protocol.TProtocol oprot, statement_execute_result struct) throws org.apache.thrift.TException {
        struct.validate();

        oprot.writeStructBegin(STRUCT_DESC);
        if (struct.isSetSuccess()) {
          oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
          oprot.writeBool(struct.success);
          oprot.writeFieldEnd();
        }
        if (struct.sqlException != null) {
          oprot.writeFieldBegin(SQL_EXCEPTION_FIELD_DESC);
          struct.sqlException.write(oprot);
          oprot.writeFieldEnd();
        }
        oprot.writeFieldStop();
        oprot.writeStructEnd();
      }

    }

    private static class statement_execute_resultTupleSchemeFactory implements SchemeFactory {
      public statement_execute_resultTupleScheme getScheme() {
        return new statement_execute_resultTupleScheme();
      }
    }

    private static class statement_execute_resultTupleScheme extends TupleScheme<statement_execute_result> {

      @Override
      public void write(org.apache.thrift.protocol.TProtocol prot, statement_execute_result struct) throws org.apache.thrift.TException {
        TTupleProtocol oprot = (TTupleProtocol) prot;
        BitSet optionals = new BitSet();
        if (struct.isSetSuccess()) {
          optionals.set(0);
        }
        if (struct.isSetSqlException()) {
          optionals.set(1);
        }
        oprot.writeBitSet(optionals, 2);
        if (struct.isSetSuccess()) {
          oprot.writeBool(struct.success);
        }
        if (struct.isSetSqlException()) {
          struct.sqlException.write(oprot);
        }
      }

      @Override
      public void read(org.apache.thrift.protocol.TProtocol prot, statement_execute_result struct) throws org.apache.thrift.TException {
        TTupleProtocol iprot = (TTupleProtocol) prot;
        BitSet incoming = iprot.readBitSet(2);
        if (incoming.get(0)) {
          struct.success = iprot.readBool();
          struct.setSuccessIsSet(true);
        }
        if (incoming.get(1)) {
          struct.sqlException = new RSQLException();
          struct.sqlException.read(iprot);
          struct.setSqlExceptionIsSet(true);
        }
      }
    }

  }

  public static class statement_executeQuery_args implements org.apache.thrift.TBase<statement_executeQuery_args, statement_executeQuery_args._Fields>, java.io.Serializable, Cloneable, Comparable<statement_executeQuery_args>   {
    private static final org.apache.thrift.protocol.TStruct STRUCT_DESC = new org.apache.thrift.protocol.TStruct("statement_executeQuery_args");

    private static final org.apache.thrift.protocol.TField STATEMENT_FIELD_DESC = new org.apache.thrift.protocol.TField("statement", org.apache.thrift.protocol.TType.STRUCT, (short)1);
    private static final org.apache.thrift.protocol.TField SQL_FIELD_DESC = new org.apache.thrift.protocol.TField("sql", org.apache.thrift.protocol.TType.STRING, (short)2);

    private static final Map<Class<? extends IScheme>, SchemeFactory> schemes = new HashMap<Class<? extends IScheme>, SchemeFactory>();
    static {
      schemes.put(StandardScheme.class, new statement_executeQuery_argsStandardSchemeFactory());
      schemes.put(TupleScheme.class, new statement_executeQuery_argsTupleSchemeFactory());
    }

    public RStatement statement; // required
    public String sql; // required

    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements org.apache.thrift.TFieldIdEnum {
      STATEMENT((short)1, "statement"),
      SQL((short)2, "sql");

      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        switch(fieldId) {
          case 1: // STATEMENT
            return STATEMENT;
          case 2: // SQL
            return SQL;
          default:
            return null;
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }

    // isset id assignments
    public static final Map<_Fields, org.apache.thrift.meta_data.FieldMetaData> metaDataMap;
    static {
      Map<_Fields, org.apache.thrift.meta_data.FieldMetaData> tmpMap = new EnumMap<_Fields, org.apache.thrift.meta_data.FieldMetaData>(_Fields.class);
      tmpMap.put(_Fields.STATEMENT, new org.apache.thrift.meta_data.FieldMetaData("statement", org.apache.thrift.TFieldRequirementType.DEFAULT, 
          new org.apache.thrift.meta_data.StructMetaData(org.apache.thrift.protocol.TType.STRUCT, RStatement.class)));
      tmpMap.put(_Fields.SQL, new org.apache.thrift.meta_data.FieldMetaData("sql", org.apache.thrift.TFieldRequirementType.DEFAULT, 
          new org.apache.thrift.meta_data.FieldValueMetaData(org.apache.thrift.protocol.TType.STRING)));
      metaDataMap = Collections.unmodifiableMap(tmpMap);
      org.apache.thrift.meta_data.FieldMetaData.addStructMetaDataMap(statement_executeQuery_args.class, metaDataMap);
    }

    public statement_executeQuery_args() {
    }

    public statement_executeQuery_args(
      RStatement statement,
      String sql)
    {
      this();
      this.statement = statement;
      this.sql = sql;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public statement_executeQuery_args(statement_executeQuery_args other) {
      if (other.isSetStatement()) {
        this.statement = new RStatement(other.statement);
      }
      if (other.isSetSql()) {
        this.sql = other.sql;
      }
    }

    public statement_executeQuery_args deepCopy() {
      return new statement_executeQuery_args(this);
    }

    @Override
    public void clear() {
      this.statement = null;
      this.sql = null;
    }

    public RStatement getStatement() {
      return this.statement;
    }

    public statement_executeQuery_args setStatement(RStatement statement) {
      this.statement = statement;
      return this;
    }

    public void unsetStatement() {
      this.statement = null;
    }

    /** Returns true if field statement is set (has been assigned a value) and false otherwise */
    public boolean isSetStatement() {
      return this.statement != null;
    }

    public void setStatementIsSet(boolean value) {
      if (!value) {
        this.statement = null;
      }
    }

    public String getSql() {
      return this.sql;
    }

    public statement_executeQuery_args setSql(String sql) {
      this.sql = sql;
      return this;
    }

    public void unsetSql() {
      this.sql = null;
    }

    /** Returns true if field sql is set (has been assigned a value) and false otherwise */
    public boolean isSetSql() {
      return this.sql != null;
    }

    public void setSqlIsSet(boolean value) {
      if (!value) {
        this.sql = null;
      }
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      case STATEMENT:
        if (value == null) {
          unsetStatement();
        } else {
          setStatement((RStatement)value);
        }
        break;

      case SQL:
        if (value == null) {
          unsetSql();
        } else {
          setSql((String)value);
        }
        break;

      }
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      case STATEMENT:
        return getStatement();

      case SQL:
        return getSql();

      }
      throw new IllegalStateException();
    }

    /** Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      if (field == null) {
        throw new IllegalArgumentException();
      }

      switch (field) {
      case STATEMENT:
        return isSetStatement();
      case SQL:
        return isSetSql();
      }
      throw new IllegalStateException();
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof statement_executeQuery_args)
        return this.equals((statement_executeQuery_args)that);
      return false;
    }

    public boolean equals(statement_executeQuery_args that) {
      if (that == null)
        return false;

      boolean this_present_statement = true && this.isSetStatement();
      boolean that_present_statement = true && that.isSetStatement();
      if (this_present_statement || that_present_statement) {
        if (!(this_present_statement && that_present_statement))
          return false;
        if (!this.statement.equals(that.statement))
          return false;
      }

      boolean this_present_sql = true && this.isSetSql();
      boolean that_present_sql = true && that.isSetSql();
      if (this_present_sql || that_present_sql) {
        if (!(this_present_sql && that_present_sql))
          return false;
        if (!this.sql.equals(that.sql))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      List<Object> list = new ArrayList<Object>();

      boolean present_statement = true && (isSetStatement());
      list.add(present_statement);
      if (present_statement)
        list.add(statement);

      boolean present_sql = true && (isSetSql());
      list.add(present_sql);
      if (present_sql)
        list.add(sql);

      return list.hashCode();
    }

    @Override
    public int compareTo(statement_executeQuery_args other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetStatement()).compareTo(other.isSetStatement());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetStatement()) {
        lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.statement, other.statement);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      lastComparison = Boolean.valueOf(isSetSql()).compareTo(other.isSetSql());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetSql()) {
        lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.sql, other.sql);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      return 0;
    }

    public _Fields fieldForId(int fieldId) {
      return _Fields.findByThriftId(fieldId);
    }

    public void read(org.apache.thrift.protocol.TProtocol iprot) throws org.apache.thrift.TException {
      schemes.get(iprot.getScheme()).getScheme().read(iprot, this);
    }

    public void write(org.apache.thrift.protocol.TProtocol oprot) throws org.apache.thrift.TException {
      schemes.get(oprot.getScheme()).getScheme().write(oprot, this);
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("statement_executeQuery_args(");
      boolean first = true;

      sb.append("statement:");
      if (this.statement == null) {
        sb.append("null");
      } else {
        sb.append(this.statement);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("sql:");
      if (this.sql == null) {
        sb.append("null");
      } else {
        sb.append(this.sql);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws org.apache.thrift.TException {
      // check for required fields
      // check for sub-struct validity
      if (statement != null) {
        statement.validate();
      }
    }

    private void writeObject(java.io.ObjectOutputStream out) throws java.io.IOException {
      try {
        write(new org.apache.thrift.protocol.TCompactProtocol(new org.apache.thrift.transport.TIOStreamTransport(out)));
      } catch (org.apache.thrift.TException te) {
        throw new java.io.IOException(te);
      }
    }

    private void readObject(java.io.ObjectInputStream in) throws java.io.IOException, ClassNotFoundException {
      try {
        read(new org.apache.thrift.protocol.TCompactProtocol(new org.apache.thrift.transport.TIOStreamTransport(in)));
      } catch (org.apache.thrift.TException te) {
        throw new java.io.IOException(te);
      }
    }

    private static class statement_executeQuery_argsStandardSchemeFactory implements SchemeFactory {
      public statement_executeQuery_argsStandardScheme getScheme() {
        return new statement_executeQuery_argsStandardScheme();
      }
    }

    private static class statement_executeQuery_argsStandardScheme extends StandardScheme<statement_executeQuery_args> {

      public void read(org.apache.thrift.protocol.TProtocol iprot, statement_executeQuery_args struct) throws org.apache.thrift.TException {
        org.apache.thrift.protocol.TField schemeField;
        iprot.readStructBegin();
        while (true)
        {
          schemeField = iprot.readFieldBegin();
          if (schemeField.type == org.apache.thrift.protocol.TType.STOP) { 
            break;
          }
          switch (schemeField.id) {
            case 1: // STATEMENT
              if (schemeField.type == org.apache.thrift.protocol.TType.STRUCT) {
                struct.statement = new RStatement();
                struct.statement.read(iprot);
                struct.setStatementIsSet(true);
              } else { 
                org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
              }
              break;
            case 2: // SQL
              if (schemeField.type == org.apache.thrift.protocol.TType.STRING) {
                struct.sql = iprot.readString();
                struct.setSqlIsSet(true);
              } else { 
                org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
              }
              break;
            default:
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
          }
          iprot.readFieldEnd();
        }
        iprot.readStructEnd();

        // check for required fields of primitive type, which can't be checked in the validate method
        struct.validate();
      }

      public void write(org.apache.thrift.protocol.TProtocol oprot, statement_executeQuery_args struct) throws org.apache.thrift.TException {
        struct.validate();

        oprot.writeStructBegin(STRUCT_DESC);
        if (struct.statement != null) {
          oprot.writeFieldBegin(STATEMENT_FIELD_DESC);
          struct.statement.write(oprot);
          oprot.writeFieldEnd();
        }
        if (struct.sql != null) {
          oprot.writeFieldBegin(SQL_FIELD_DESC);
          oprot.writeString(struct.sql);
          oprot.writeFieldEnd();
        }
        oprot.writeFieldStop();
        oprot.writeStructEnd();
      }

    }

    private static class statement_executeQuery_argsTupleSchemeFactory implements SchemeFactory {
      public statement_executeQuery_argsTupleScheme getScheme() {
        return new statement_executeQuery_argsTupleScheme();
      }
    }

    private static class statement_executeQuery_argsTupleScheme extends TupleScheme<statement_executeQuery_args> {

      @Override
      public void write(org.apache.thrift.protocol.TProtocol prot, statement_executeQuery_args struct) throws org.apache.thrift.TException {
        TTupleProtocol oprot = (TTupleProtocol) prot;
        BitSet optionals = new BitSet();
        if (struct.isSetStatement()) {
          optionals.set(0);
        }
        if (struct.isSetSql()) {
          optionals.set(1);
        }
        oprot.writeBitSet(optionals, 2);
        if (struct.isSetStatement()) {
          struct.statement.write(oprot);
        }
        if (struct.isSetSql()) {
          oprot.writeString(struct.sql);
        }
      }

      @Override
      public void read(org.apache.thrift.protocol.TProtocol prot, statement_executeQuery_args struct) throws org.apache.thrift.TException {
        TTupleProtocol iprot = (TTupleProtocol) prot;
        BitSet incoming = iprot.readBitSet(2);
        if (incoming.get(0)) {
          struct.statement = new RStatement();
          struct.statement.read(iprot);
          struct.setStatementIsSet(true);
        }
        if (incoming.get(1)) {
          struct.sql = iprot.readString();
          struct.setSqlIsSet(true);
        }
      }
    }

  }

  public static class statement_executeQuery_result implements org.apache.thrift.TBase<statement_executeQuery_result, statement_executeQuery_result._Fields>, java.io.Serializable, Cloneable, Comparable<statement_executeQuery_result>   {
    private static final org.apache.thrift.protocol.TStruct STRUCT_DESC = new org.apache.thrift.protocol.TStruct("statement_executeQuery_result");

    private static final org.apache.thrift.protocol.TField SUCCESS_FIELD_DESC = new org.apache.thrift.protocol.TField("success", org.apache.thrift.protocol.TType.STRUCT, (short)0);
    private static final org.apache.thrift.protocol.TField SQL_EXCEPTION_FIELD_DESC = new org.apache.thrift.protocol.TField("sqlException", org.apache.thrift.protocol.TType.STRUCT, (short)1);

    private static final Map<Class<? extends IScheme>, SchemeFactory> schemes = new HashMap<Class<? extends IScheme>, SchemeFactory>();
    static {
      schemes.put(StandardScheme.class, new statement_executeQuery_resultStandardSchemeFactory());
      schemes.put(TupleScheme.class, new statement_executeQuery_resultTupleSchemeFactory());
    }

    public RResultSet success; // required
    public RSQLException sqlException; // required

    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements org.apache.thrift.TFieldIdEnum {
      SUCCESS((short)0, "success"),
      SQL_EXCEPTION((short)1, "sqlException");

      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        switch(fieldId) {
          case 0: // SUCCESS
            return SUCCESS;
          case 1: // SQL_EXCEPTION
            return SQL_EXCEPTION;
          default:
            return null;
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }

    // isset id assignments
    public static final Map<_Fields, org.apache.thrift.meta_data.FieldMetaData> metaDataMap;
    static {
      Map<_Fields, org.apache.thrift.meta_data.FieldMetaData> tmpMap = new EnumMap<_Fields, org.apache.thrift.meta_data.FieldMetaData>(_Fields.class);
      tmpMap.put(_Fields.SUCCESS, new org.apache.thrift.meta_data.FieldMetaData("success", org.apache.thrift.TFieldRequirementType.DEFAULT, 
          new org.apache.thrift.meta_data.StructMetaData(org.apache.thrift.protocol.TType.STRUCT, RResultSet.class)));
      tmpMap.put(_Fields.SQL_EXCEPTION, new org.apache.thrift.meta_data.FieldMetaData("sqlException", org.apache.thrift.TFieldRequirementType.DEFAULT, 
          new org.apache.thrift.meta_data.FieldValueMetaData(org.apache.thrift.protocol.TType.STRUCT)));
      metaDataMap = Collections.unmodifiableMap(tmpMap);
      org.apache.thrift.meta_data.FieldMetaData.addStructMetaDataMap(statement_executeQuery_result.class, metaDataMap);
    }

    public statement_executeQuery_result() {
    }

    public statement_executeQuery_result(
      RResultSet success,
      RSQLException sqlException)
    {
      this();
      this.success = success;
      this.sqlException = sqlException;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public statement_executeQuery_result(statement_executeQuery_result other) {
      if (other.isSetSuccess()) {
        this.success = new RResultSet(other.success);
      }
      if (other.isSetSqlException()) {
        this.sqlException = new RSQLException(other.sqlException);
      }
    }

    public statement_executeQuery_result deepCopy() {
      return new statement_executeQuery_result(this);
    }

    @Override
    public void clear() {
      this.success = null;
      this.sqlException = null;
    }

    public RResultSet getSuccess() {
      return this.success;
    }

    public statement_executeQuery_result setSuccess(RResultSet success) {
      this.success = success;
      return this;
    }

    public void unsetSuccess() {
      this.success = null;
    }

    /** Returns true if field success is set (has been assigned a value) and false otherwise */
    public boolean isSetSuccess() {
      return this.success != null;
    }

    public void setSuccessIsSet(boolean value) {
      if (!value) {
        this.success = null;
      }
    }

    public RSQLException getSqlException() {
      return this.sqlException;
    }

    public statement_executeQuery_result setSqlException(RSQLException sqlException) {
      this.sqlException = sqlException;
      return this;
    }

    public void unsetSqlException() {
      this.sqlException = null;
    }

    /** Returns true if field sqlException is set (has been assigned a value) and false otherwise */
    public boolean isSetSqlException() {
      return this.sqlException != null;
    }

    public void setSqlExceptionIsSet(boolean value) {
      if (!value) {
        this.sqlException = null;
      }
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          setSuccess((RResultSet)value);
        }
        break;

      case SQL_EXCEPTION:
        if (value == null) {
          unsetSqlException();
        } else {
          setSqlException((RSQLException)value);
        }
        break;

      }
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      case SUCCESS:
        return getSuccess();

      case SQL_EXCEPTION:
        return getSqlException();

      }
      throw new IllegalStateException();
    }

    /** Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      if (field == null) {
        throw new IllegalArgumentException();
      }

      switch (field) {
      case SUCCESS:
        return isSetSuccess();
      case SQL_EXCEPTION:
        return isSetSqlException();
      }
      throw new IllegalStateException();
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof statement_executeQuery_result)
        return this.equals((statement_executeQuery_result)that);
      return false;
    }

    public boolean equals(statement_executeQuery_result that) {
      if (that == null)
        return false;

      boolean this_present_success = true && this.isSetSuccess();
      boolean that_present_success = true && that.isSetSuccess();
      if (this_present_success || that_present_success) {
        if (!(this_present_success && that_present_success))
          return false;
        if (!this.success.equals(that.success))
          return false;
      }

      boolean this_present_sqlException = true && this.isSetSqlException();
      boolean that_present_sqlException = true && that.isSetSqlException();
      if (this_present_sqlException || that_present_sqlException) {
        if (!(this_present_sqlException && that_present_sqlException))
          return false;
        if (!this.sqlException.equals(that.sqlException))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      List<Object> list = new ArrayList<Object>();

      boolean present_success = true && (isSetSuccess());
      list.add(present_success);
      if (present_success)
        list.add(success);

      boolean present_sqlException = true && (isSetSqlException());
      list.add(present_sqlException);
      if (present_sqlException)
        list.add(sqlException);

      return list.hashCode();
    }

    @Override
    public int compareTo(statement_executeQuery_result other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetSuccess()).compareTo(other.isSetSuccess());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetSuccess()) {
        lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.success, other.success);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      lastComparison = Boolean.valueOf(isSetSqlException()).compareTo(other.isSetSqlException());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetSqlException()) {
        lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.sqlException, other.sqlException);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      return 0;
    }

    public _Fields fieldForId(int fieldId) {
      return _Fields.findByThriftId(fieldId);
    }

    public void read(org.apache.thrift.protocol.TProtocol iprot) throws org.apache.thrift.TException {
      schemes.get(iprot.getScheme()).getScheme().read(iprot, this);
    }

    public void write(org.apache.thrift.protocol.TProtocol oprot) throws org.apache.thrift.TException {
      schemes.get(oprot.getScheme()).getScheme().write(oprot, this);
      }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("statement_executeQuery_result(");
      boolean first = true;

      sb.append("success:");
      if (this.success == null) {
        sb.append("null");
      } else {
        sb.append(this.success);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("sqlException:");
      if (this.sqlException == null) {
        sb.append("null");
      } else {
        sb.append(this.sqlException);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws org.apache.thrift.TException {
      // check for required fields
      // check for sub-struct validity
      if (success != null) {
        success.validate();
      }
    }

    private void writeObject(java.io.ObjectOutputStream out) throws java.io.IOException {
      try {
        write(new org.apache.thrift.protocol.TCompactProtocol(new org.apache.thrift.transport.TIOStreamTransport(out)));
      } catch (org.apache.thrift.TException te) {
        throw new java.io.IOException(te);
      }
    }

    private void readObject(java.io.ObjectInputStream in) throws java.io.IOException, ClassNotFoundException {
      try {
        read(new org.apache.thrift.protocol.TCompactProtocol(new org.apache.thrift.transport.TIOStreamTransport(in)));
      } catch (org.apache.thrift.TException te) {
        throw new java.io.IOException(te);
      }
    }

    private static class statement_executeQuery_resultStandardSchemeFactory implements SchemeFactory {
      public statement_executeQuery_resultStandardScheme getScheme() {
        return new statement_executeQuery_resultStandardScheme();
      }
    }

    private static class statement_executeQuery_resultStandardScheme extends StandardScheme<statement_executeQuery_result> {

      public void read(org.apache.thrift.protocol.TProtocol iprot, statement_executeQuery_result struct) throws org.apache.thrift.TException {
        org.apache.thrift.protocol.TField schemeField;
        iprot.readStructBegin();
        while (true)
        {
          schemeField = iprot.readFieldBegin();
          if (schemeField.type == org.apache.thrift.protocol.TType.STOP) { 
            break;
          }
          switch (schemeField.id) {
            case 0: // SUCCESS
              if (schemeField.type == org.apache.thrift.protocol.TType.STRUCT) {
                struct.success = new RResultSet();
                struct.success.read(iprot);
                struct.setSuccessIsSet(true);
              } else { 
                org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
              }
              break;
            case 1: // SQL_EXCEPTION
              if (schemeField.type == org.apache.thrift.protocol.TType.STRUCT) {
                struct.sqlException = new RSQLException();
                struct.sqlException.read(iprot);
                struct.setSqlExceptionIsSet(true);
              } else { 
                org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
              }
              break;
            default:
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
          }
          iprot.readFieldEnd();
        }
        iprot.readStructEnd();

        // check for required fields of primitive type, which can't be checked in the validate method
        struct.validate();
      }

      public void write(org.apache.thrift.protocol.TProtocol oprot, statement_executeQuery_result struct) throws org.apache.thrift.TException {
        struct.validate();

        oprot.writeStructBegin(STRUCT_DESC);
        if (struct.success != null) {
          oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
          struct.success.write(oprot);
          oprot.writeFieldEnd();
        }
        if (struct.sqlException != null) {
          oprot.writeFieldBegin(SQL_EXCEPTION_FIELD_DESC);
          struct.sqlException.write(oprot);
          oprot.writeFieldEnd();
        }
        oprot.writeFieldStop();
        oprot.writeStructEnd();
      }

    }

    private static class statement_executeQuery_resultTupleSchemeFactory implements SchemeFactory {
      public statement_executeQuery_resultTupleScheme getScheme() {
        return new statement_executeQuery_resultTupleScheme();
      }
    }

    private static class statement_executeQuery_resultTupleScheme extends TupleScheme<statement_executeQuery_result> {

      @Override
      public void write(org.apache.thrift.protocol.TProtocol prot, statement_executeQuery_result struct) throws org.apache.thrift.TException {
        TTupleProtocol oprot = (TTupleProtocol) prot;
        BitSet optionals = new BitSet();
        if (struct.isSetSuccess()) {
          optionals.set(0);
        }
        if (struct.isSetSqlException()) {
          optionals.set(1);
        }
        oprot.writeBitSet(optionals, 2);
        if (struct.isSetSuccess()) {
          struct.success.write(oprot);
        }
        if (struct.isSetSqlException()) {
          struct.sqlException.write(oprot);
        }
      }

      @Override
      public void read(org.apache.thrift.protocol.TProtocol prot, statement_executeQuery_result struct) throws org.apache.thrift.TException {
        TTupleProtocol iprot = (TTupleProtocol) prot;
        BitSet incoming = iprot.readBitSet(2);
        if (incoming.get(0)) {
          struct.success = new RResultSet();
          struct.success.read(iprot);
          struct.setSuccessIsSet(true);
        }
        if (incoming.get(1)) {
          struct.sqlException = new RSQLException();
          struct.sqlException.read(iprot);
          struct.setSqlExceptionIsSet(true);
        }
      }
    }

  }

  public static class statement_executeUpdate_args implements org.apache.thrift.TBase<statement_executeUpdate_args, statement_executeUpdate_args._Fields>, java.io.Serializable, Cloneable, Comparable<statement_executeUpdate_args>   {
    private static final org.apache.thrift.protocol.TStruct STRUCT_DESC = new org.apache.thrift.protocol.TStruct("statement_executeUpdate_args");

    private static final org.apache.thrift.protocol.TField STATEMENT_FIELD_DESC = new org.apache.thrift.protocol.TField("statement", org.apache.thrift.protocol.TType.STRUCT, (short)1);
    private static final org.apache.thrift.protocol.TField SQL_FIELD_DESC = new org.apache.thrift.protocol.TField("sql", org.apache.thrift.protocol.TType.STRING, (short)2);

    private static final Map<Class<? extends IScheme>, SchemeFactory> schemes = new HashMap<Class<? extends IScheme>, SchemeFactory>();
    static {
      schemes.put(StandardScheme.class, new statement_executeUpdate_argsStandardSchemeFactory());
      schemes.put(TupleScheme.class, new statement_executeUpdate_argsTupleSchemeFactory());
    }

    public RStatement statement; // required
    public String sql; // required

    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements org.apache.thrift.TFieldIdEnum {
      STATEMENT((short)1, "statement"),
      SQL((short)2, "sql");

      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        switch(fieldId) {
          case 1: // STATEMENT
            return STATEMENT;
          case 2: // SQL
            return SQL;
          default:
            return null;
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }

    // isset id assignments
    public static final Map<_Fields, org.apache.thrift.meta_data.FieldMetaData> metaDataMap;
    static {
      Map<_Fields, org.apache.thrift.meta_data.FieldMetaData> tmpMap = new EnumMap<_Fields, org.apache.thrift.meta_data.FieldMetaData>(_Fields.class);
      tmpMap.put(_Fields.STATEMENT, new org.apache.thrift.meta_data.FieldMetaData("statement", org.apache.thrift.TFieldRequirementType.DEFAULT, 
          new org.apache.thrift.meta_data.StructMetaData(org.apache.thrift.protocol.TType.STRUCT, RStatement.class)));
      tmpMap.put(_Fields.SQL, new org.apache.thrift.meta_data.FieldMetaData("sql", org.apache.thrift.TFieldRequirementType.DEFAULT, 
          new org.apache.thrift.meta_data.FieldValueMetaData(org.apache.thrift.protocol.TType.STRING)));
      metaDataMap = Collections.unmodifiableMap(tmpMap);
      org.apache.thrift.meta_data.FieldMetaData.addStructMetaDataMap(statement_executeUpdate_args.class, metaDataMap);
    }

    public statement_executeUpdate_args() {
    }

    public statement_executeUpdate_args(
      RStatement statement,
      String sql)
    {
      this();
      this.statement = statement;
      this.sql = sql;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public statement_executeUpdate_args(statement_executeUpdate_args other) {
      if (other.isSetStatement()) {
        this.statement = new RStatement(other.statement);
      }
      if (other.isSetSql()) {
        this.sql = other.sql;
      }
    }

    public statement_executeUpdate_args deepCopy() {
      return new statement_executeUpdate_args(this);
    }

    @Override
    public void clear() {
      this.statement = null;
      this.sql = null;
    }

    public RStatement getStatement() {
      return this.statement;
    }

    public statement_executeUpdate_args setStatement(RStatement statement) {
      this.statement = statement;
      return this;
    }

    public void unsetStatement() {
      this.statement = null;
    }

    /** Returns true if field statement is set (has been assigned a value) and false otherwise */
    public boolean isSetStatement() {
      return this.statement != null;
    }

    public void setStatementIsSet(boolean value) {
      if (!value) {
        this.statement = null;
      }
    }

    public String getSql() {
      return this.sql;
    }

    public statement_executeUpdate_args setSql(String sql) {
      this.sql = sql;
      return this;
    }

    public void unsetSql() {
      this.sql = null;
    }

    /** Returns true if field sql is set (has been assigned a value) and false otherwise */
    public boolean isSetSql() {
      return this.sql != null;
    }

    public void setSqlIsSet(boolean value) {
      if (!value) {
        this.sql = null;
      }
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      case STATEMENT:
        if (value == null) {
          unsetStatement();
        } else {
          setStatement((RStatement)value);
        }
        break;

      case SQL:
        if (value == null) {
          unsetSql();
        } else {
          setSql((String)value);
        }
        break;

      }
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      case STATEMENT:
        return getStatement();

      case SQL:
        return getSql();

      }
      throw new IllegalStateException();
    }

    /** Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      if (field == null) {
        throw new IllegalArgumentException();
      }

      switch (field) {
      case STATEMENT:
        return isSetStatement();
      case SQL:
        return isSetSql();
      }
      throw new IllegalStateException();
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof statement_executeUpdate_args)
        return this.equals((statement_executeUpdate_args)that);
      return false;
    }

    public boolean equals(statement_executeUpdate_args that) {
      if (that == null)
        return false;

      boolean this_present_statement = true && this.isSetStatement();
      boolean that_present_statement = true && that.isSetStatement();
      if (this_present_statement || that_present_statement) {
        if (!(this_present_statement && that_present_statement))
          return false;
        if (!this.statement.equals(that.statement))
          return false;
      }

      boolean this_present_sql = true && this.isSetSql();
      boolean that_present_sql = true && that.isSetSql();
      if (this_present_sql || that_present_sql) {
        if (!(this_present_sql && that_present_sql))
          return false;
        if (!this.sql.equals(that.sql))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      List<Object> list = new ArrayList<Object>();

      boolean present_statement = true && (isSetStatement());
      list.add(present_statement);
      if (present_statement)
        list.add(statement);

      boolean present_sql = true && (isSetSql());
      list.add(present_sql);
      if (present_sql)
        list.add(sql);

      return list.hashCode();
    }

    @Override
    public int compareTo(statement_executeUpdate_args other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetStatement()).compareTo(other.isSetStatement());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetStatement()) {
        lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.statement, other.statement);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      lastComparison = Boolean.valueOf(isSetSql()).compareTo(other.isSetSql());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetSql()) {
        lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.sql, other.sql);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      return 0;
    }

    public _Fields fieldForId(int fieldId) {
      return _Fields.findByThriftId(fieldId);
    }

    public void read(org.apache.thrift.protocol.TProtocol iprot) throws org.apache.thrift.TException {
      schemes.get(iprot.getScheme()).getScheme().read(iprot, this);
    }

    public void write(org.apache.thrift.protocol.TProtocol oprot) throws org.apache.thrift.TException {
      schemes.get(oprot.getScheme()).getScheme().write(oprot, this);
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("statement_executeUpdate_args(");
      boolean first = true;

      sb.append("statement:");
      if (this.statement == null) {
        sb.append("null");
      } else {
        sb.append(this.statement);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("sql:");
      if (this.sql == null) {
        sb.append("null");
      } else {
        sb.append(this.sql);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws org.apache.thrift.TException {
      // check for required fields
      // check for sub-struct validity
      if (statement != null) {
        statement.validate();
      }
    }

    private void writeObject(java.io.ObjectOutputStream out) throws java.io.IOException {
      try {
        write(new org.apache.thrift.protocol.TCompactProtocol(new org.apache.thrift.transport.TIOStreamTransport(out)));
      } catch (org.apache.thrift.TException te) {
        throw new java.io.IOException(te);
      }
    }

    private void readObject(java.io.ObjectInputStream in) throws java.io.IOException, ClassNotFoundException {
      try {
        read(new org.apache.thrift.protocol.TCompactProtocol(new org.apache.thrift.transport.TIOStreamTransport(in)));
      } catch (org.apache.thrift.TException te) {
        throw new java.io.IOException(te);
      }
    }

    private static class statement_executeUpdate_argsStandardSchemeFactory implements SchemeFactory {
      public statement_executeUpdate_argsStandardScheme getScheme() {
        return new statement_executeUpdate_argsStandardScheme();
      }
    }

    private static class statement_executeUpdate_argsStandardScheme extends StandardScheme<statement_executeUpdate_args> {

      public void read(org.apache.thrift.protocol.TProtocol iprot, statement_executeUpdate_args struct) throws org.apache.thrift.TException {
        org.apache.thrift.protocol.TField schemeField;
        iprot.readStructBegin();
        while (true)
        {
          schemeField = iprot.readFieldBegin();
          if (schemeField.type == org.apache.thrift.protocol.TType.STOP) { 
            break;
          }
          switch (schemeField.id) {
            case 1: // STATEMENT
              if (schemeField.type == org.apache.thrift.protocol.TType.STRUCT) {
                struct.statement = new RStatement();
                struct.statement.read(iprot);
                struct.setStatementIsSet(true);
              } else { 
                org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
              }
              break;
            case 2: // SQL
              if (schemeField.type == org.apache.thrift.protocol.TType.STRING) {
                struct.sql = iprot.readString();
                struct.setSqlIsSet(true);
              } else { 
                org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
              }
              break;
            default:
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
          }
          iprot.readFieldEnd();
        }
        iprot.readStructEnd();

        // check for required fields of primitive type, which can't be checked in the validate method
        struct.validate();
      }

      public void write(org.apache.thrift.protocol.TProtocol oprot, statement_executeUpdate_args struct) throws org.apache.thrift.TException {
        struct.validate();

        oprot.writeStructBegin(STRUCT_DESC);
        if (struct.statement != null) {
          oprot.writeFieldBegin(STATEMENT_FIELD_DESC);
          struct.statement.write(oprot);
          oprot.writeFieldEnd();
        }
        if (struct.sql != null) {
          oprot.writeFieldBegin(SQL_FIELD_DESC);
          oprot.writeString(struct.sql);
          oprot.writeFieldEnd();
        }
        oprot.writeFieldStop();
        oprot.writeStructEnd();
      }

    }

    private static class statement_executeUpdate_argsTupleSchemeFactory implements SchemeFactory {
      public statement_executeUpdate_argsTupleScheme getScheme() {
        return new statement_executeUpdate_argsTupleScheme();
      }
    }

    private static class statement_executeUpdate_argsTupleScheme extends TupleScheme<statement_executeUpdate_args> {

      @Override
      public void write(org.apache.thrift.protocol.TProtocol prot, statement_executeUpdate_args struct) throws org.apache.thrift.TException {
        TTupleProtocol oprot = (TTupleProtocol) prot;
        BitSet optionals = new BitSet();
        if (struct.isSetStatement()) {
          optionals.set(0);
        }
        if (struct.isSetSql()) {
          optionals.set(1);
        }
        oprot.writeBitSet(optionals, 2);
        if (struct.isSetStatement()) {
          struct.statement.write(oprot);
        }
        if (struct.isSetSql()) {
          oprot.writeString(struct.sql);
        }
      }

      @Override
      public void read(org.apache.thrift.protocol.TProtocol prot, statement_executeUpdate_args struct) throws org.apache.thrift.TException {
        TTupleProtocol iprot = (TTupleProtocol) prot;
        BitSet incoming = iprot.readBitSet(2);
        if (incoming.get(0)) {
          struct.statement = new RStatement();
          struct.statement.read(iprot);
          struct.setStatementIsSet(true);
        }
        if (incoming.get(1)) {
          struct.sql = iprot.readString();
          struct.setSqlIsSet(true);
        }
      }
    }

  }

  public static class statement_executeUpdate_result implements org.apache.thrift.TBase<statement_executeUpdate_result, statement_executeUpdate_result._Fields>, java.io.Serializable, Cloneable, Comparable<statement_executeUpdate_result>   {
    private static final org.apache.thrift.protocol.TStruct STRUCT_DESC = new org.apache.thrift.protocol.TStruct("statement_executeUpdate_result");

    private static final org.apache.thrift.protocol.TField SUCCESS_FIELD_DESC = new org.apache.thrift.protocol.TField("success", org.apache.thrift.protocol.TType.I32, (short)0);
    private static final org.apache.thrift.protocol.TField SQL_EXCEPTION_FIELD_DESC = new org.apache.thrift.protocol.TField("sqlException", org.apache.thrift.protocol.TType.STRUCT, (short)1);

    private static final Map<Class<? extends IScheme>, SchemeFactory> schemes = new HashMap<Class<? extends IScheme>, SchemeFactory>();
    static {
      schemes.put(StandardScheme.class, new statement_executeUpdate_resultStandardSchemeFactory());
      schemes.put(TupleScheme.class, new statement_executeUpdate_resultTupleSchemeFactory());
    }

    public int success; // required
    public RSQLException sqlException; // required

    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements org.apache.thrift.TFieldIdEnum {
      SUCCESS((short)0, "success"),
      SQL_EXCEPTION((short)1, "sqlException");

      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        switch(fieldId) {
          case 0: // SUCCESS
            return SUCCESS;
          case 1: // SQL_EXCEPTION
            return SQL_EXCEPTION;
          default:
            return null;
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }

    // isset id assignments
    private static final int __SUCCESS_ISSET_ID = 0;
    private byte __isset_bitfield = 0;
    public static final Map<_Fields, org.apache.thrift.meta_data.FieldMetaData> metaDataMap;
    static {
      Map<_Fields, org.apache.thrift.meta_data.FieldMetaData> tmpMap = new EnumMap<_Fields, org.apache.thrift.meta_data.FieldMetaData>(_Fields.class);
      tmpMap.put(_Fields.SUCCESS, new org.apache.thrift.meta_data.FieldMetaData("success", org.apache.thrift.TFieldRequirementType.DEFAULT, 
          new org.apache.thrift.meta_data.FieldValueMetaData(org.apache.thrift.protocol.TType.I32)));
      tmpMap.put(_Fields.SQL_EXCEPTION, new org.apache.thrift.meta_data.FieldMetaData("sqlException", org.apache.thrift.TFieldRequirementType.DEFAULT, 
          new org.apache.thrift.meta_data.FieldValueMetaData(org.apache.thrift.protocol.TType.STRUCT)));
      metaDataMap = Collections.unmodifiableMap(tmpMap);
      org.apache.thrift.meta_data.FieldMetaData.addStructMetaDataMap(statement_executeUpdate_result.class, metaDataMap);
    }

    public statement_executeUpdate_result() {
    }

    public statement_executeUpdate_result(
      int success,
      RSQLException sqlException)
    {
      this();
      this.success = success;
      setSuccessIsSet(true);
      this.sqlException = sqlException;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public statement_executeUpdate_result(statement_executeUpdate_result other) {
      __isset_bitfield = other.__isset_bitfield;
      this.success = other.success;
      if (other.isSetSqlException()) {
        this.sqlException = new RSQLException(other.sqlException);
      }
    }

    public statement_executeUpdate_result deepCopy() {
      return new statement_executeUpdate_result(this);
    }

    @Override
    public void clear() {
      setSuccessIsSet(false);
      this.success = 0;
      this.sqlException = null;
    }

    public int getSuccess() {
      return this.success;
    }

    public statement_executeUpdate_result setSuccess(int success) {
      this.success = success;
      setSuccessIsSet(true);
      return this;
    }

    public void unsetSuccess() {
      __isset_bitfield = EncodingUtils.clearBit(__isset_bitfield, __SUCCESS_ISSET_ID);
    }

    /** Returns true if field success is set (has been assigned a value) and false otherwise */
    public boolean isSetSuccess() {
      return EncodingUtils.testBit(__isset_bitfield, __SUCCESS_ISSET_ID);
    }

    public void setSuccessIsSet(boolean value) {
      __isset_bitfield = EncodingUtils.setBit(__isset_bitfield, __SUCCESS_ISSET_ID, value);
    }

    public RSQLException getSqlException() {
      return this.sqlException;
    }

    public statement_executeUpdate_result setSqlException(RSQLException sqlException) {
      this.sqlException = sqlException;
      return this;
    }

    public void unsetSqlException() {
      this.sqlException = null;
    }

    /** Returns true if field sqlException is set (has been assigned a value) and false otherwise */
    public boolean isSetSqlException() {
      return this.sqlException != null;
    }

    public void setSqlExceptionIsSet(boolean value) {
      if (!value) {
        this.sqlException = null;
      }
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          setSuccess((Integer)value);
        }
        break;

      case SQL_EXCEPTION:
        if (value == null) {
          unsetSqlException();
        } else {
          setSqlException((RSQLException)value);
        }
        break;

      }
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      case SUCCESS:
        return Integer.valueOf(getSuccess());

      case SQL_EXCEPTION:
        return getSqlException();

      }
      throw new IllegalStateException();
    }

    /** Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      if (field == null) {
        throw new IllegalArgumentException();
      }

      switch (field) {
      case SUCCESS:
        return isSetSuccess();
      case SQL_EXCEPTION:
        return isSetSqlException();
      }
      throw new IllegalStateException();
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof statement_executeUpdate_result)
        return this.equals((statement_executeUpdate_result)that);
      return false;
    }

    public boolean equals(statement_executeUpdate_result that) {
      if (that == null)
        return false;

      boolean this_present_success = true;
      boolean that_present_success = true;
      if (this_present_success || that_present_success) {
        if (!(this_present_success && that_present_success))
          return false;
        if (this.success != that.success)
          return false;
      }

      boolean this_present_sqlException = true && this.isSetSqlException();
      boolean that_present_sqlException = true && that.isSetSqlException();
      if (this_present_sqlException || that_present_sqlException) {
        if (!(this_present_sqlException && that_present_sqlException))
          return false;
        if (!this.sqlException.equals(that.sqlException))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      List<Object> list = new ArrayList<Object>();

      boolean present_success = true;
      list.add(present_success);
      if (present_success)
        list.add(success);

      boolean present_sqlException = true && (isSetSqlException());
      list.add(present_sqlException);
      if (present_sqlException)
        list.add(sqlException);

      return list.hashCode();
    }

    @Override
    public int compareTo(statement_executeUpdate_result other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetSuccess()).compareTo(other.isSetSuccess());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetSuccess()) {
        lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.success, other.success);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      lastComparison = Boolean.valueOf(isSetSqlException()).compareTo(other.isSetSqlException());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetSqlException()) {
        lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.sqlException, other.sqlException);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      return 0;
    }

    public _Fields fieldForId(int fieldId) {
      return _Fields.findByThriftId(fieldId);
    }

    public void read(org.apache.thrift.protocol.TProtocol iprot) throws org.apache.thrift.TException {
      schemes.get(iprot.getScheme()).getScheme().read(iprot, this);
    }

    public void write(org.apache.thrift.protocol.TProtocol oprot) throws org.apache.thrift.TException {
      schemes.get(oprot.getScheme()).getScheme().write(oprot, this);
      }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("statement_executeUpdate_result(");
      boolean first = true;

      sb.append("success:");
      sb.append(this.success);
      first = false;
      if (!first) sb.append(", ");
      sb.append("sqlException:");
      if (this.sqlException == null) {
        sb.append("null");
      } else {
        sb.append(this.sqlException);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws org.apache.thrift.TException {
      // check for required fields
      // check for sub-struct validity
    }

    private void writeObject(java.io.ObjectOutputStream out) throws java.io.IOException {
      try {
        write(new org.apache.thrift.protocol.TCompactProtocol(new org.apache.thrift.transport.TIOStreamTransport(out)));
      } catch (org.apache.thrift.TException te) {
        throw new java.io.IOException(te);
      }
    }

    private void readObject(java.io.ObjectInputStream in) throws java.io.IOException, ClassNotFoundException {
      try {
        // it doesn't seem like you should have to do this, but java serialization is wacky, and doesn't call the default constructor.
        __isset_bitfield = 0;
        read(new org.apache.thrift.protocol.TCompactProtocol(new org.apache.thrift.transport.TIOStreamTransport(in)));
      } catch (org.apache.thrift.TException te) {
        throw new java.io.IOException(te);
      }
    }

    private static class statement_executeUpdate_resultStandardSchemeFactory implements SchemeFactory {
      public statement_executeUpdate_resultStandardScheme getScheme() {
        return new statement_executeUpdate_resultStandardScheme();
      }
    }

    private static class statement_executeUpdate_resultStandardScheme extends StandardScheme<statement_executeUpdate_result> {

      public void read(org.apache.thrift.protocol.TProtocol iprot, statement_executeUpdate_result struct) throws org.apache.thrift.TException {
        org.apache.thrift.protocol.TField schemeField;
        iprot.readStructBegin();
        while (true)
        {
          schemeField = iprot.readFieldBegin();
          if (schemeField.type == org.apache.thrift.protocol.TType.STOP) { 
            break;
          }
          switch (schemeField.id) {
            case 0: // SUCCESS
              if (schemeField.type == org.apache.thrift.protocol.TType.I32) {
                struct.success = iprot.readI32();
                struct.setSuccessIsSet(true);
              } else { 
                org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
              }
              break;
            case 1: // SQL_EXCEPTION
              if (schemeField.type == org.apache.thrift.protocol.TType.STRUCT) {
                struct.sqlException = new RSQLException();
                struct.sqlException.read(iprot);
                struct.setSqlExceptionIsSet(true);
              } else { 
                org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
              }
              break;
            default:
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
          }
          iprot.readFieldEnd();
        }
        iprot.readStructEnd();

        // check for required fields of primitive type, which can't be checked in the validate method
        struct.validate();
      }

      public void write(org.apache.thrift.protocol.TProtocol oprot, statement_executeUpdate_result struct) throws org.apache.thrift.TException {
        struct.validate();

        oprot.writeStructBegin(STRUCT_DESC);
        if (struct.isSetSuccess()) {
          oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
          oprot.writeI32(struct.success);
          oprot.writeFieldEnd();
        }
        if (struct.sqlException != null) {
          oprot.writeFieldBegin(SQL_EXCEPTION_FIELD_DESC);
          struct.sqlException.write(oprot);
          oprot.writeFieldEnd();
        }
        oprot.writeFieldStop();
        oprot.writeStructEnd();
      }

    }

    private static class statement_executeUpdate_resultTupleSchemeFactory implements SchemeFactory {
      public statement_executeUpdate_resultTupleScheme getScheme() {
        return new statement_executeUpdate_resultTupleScheme();
      }
    }

    private static class statement_executeUpdate_resultTupleScheme extends TupleScheme<statement_executeUpdate_result> {

      @Override
      public void write(org.apache.thrift.protocol.TProtocol prot, statement_executeUpdate_result struct) throws org.apache.thrift.TException {
        TTupleProtocol oprot = (TTupleProtocol) prot;
        BitSet optionals = new BitSet();
        if (struct.isSetSuccess()) {
          optionals.set(0);
        }
        if (struct.isSetSqlException()) {
          optionals.set(1);
        }
        oprot.writeBitSet(optionals, 2);
        if (struct.isSetSuccess()) {
          oprot.writeI32(struct.success);
        }
        if (struct.isSetSqlException()) {
          struct.sqlException.write(oprot);
        }
      }

      @Override
      public void read(org.apache.thrift.protocol.TProtocol prot, statement_executeUpdate_result struct) throws org.apache.thrift.TException {
        TTupleProtocol iprot = (TTupleProtocol) prot;
        BitSet incoming = iprot.readBitSet(2);
        if (incoming.get(0)) {
          struct.success = iprot.readI32();
          struct.setSuccessIsSet(true);
        }
        if (incoming.get(1)) {
          struct.sqlException = new RSQLException();
          struct.sqlException.read(iprot);
          struct.setSqlExceptionIsSet(true);
        }
      }
    }

  }

  public static class statement_getResultSet_args implements org.apache.thrift.TBase<statement_getResultSet_args, statement_getResultSet_args._Fields>, java.io.Serializable, Cloneable, Comparable<statement_getResultSet_args>   {
    private static final org.apache.thrift.protocol.TStruct STRUCT_DESC = new org.apache.thrift.protocol.TStruct("statement_getResultSet_args");

    private static final org.apache.thrift.protocol.TField STATEMENT_FIELD_DESC = new org.apache.thrift.protocol.TField("statement", org.apache.thrift.protocol.TType.STRUCT, (short)1);

    private static final Map<Class<? extends IScheme>, SchemeFactory> schemes = new HashMap<Class<? extends IScheme>, SchemeFactory>();
    static {
      schemes.put(StandardScheme.class, new statement_getResultSet_argsStandardSchemeFactory());
      schemes.put(TupleScheme.class, new statement_getResultSet_argsTupleSchemeFactory());
    }

    public RStatement statement; // required

    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements org.apache.thrift.TFieldIdEnum {
      STATEMENT((short)1, "statement");

      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        switch(fieldId) {
          case 1: // STATEMENT
            return STATEMENT;
          default:
            return null;
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }

    // isset id assignments
    public static final Map<_Fields, org.apache.thrift.meta_data.FieldMetaData> metaDataMap;
    static {
      Map<_Fields, org.apache.thrift.meta_data.FieldMetaData> tmpMap = new EnumMap<_Fields, org.apache.thrift.meta_data.FieldMetaData>(_Fields.class);
      tmpMap.put(_Fields.STATEMENT, new org.apache.thrift.meta_data.FieldMetaData("statement", org.apache.thrift.TFieldRequirementType.DEFAULT, 
          new org.apache.thrift.meta_data.StructMetaData(org.apache.thrift.protocol.TType.STRUCT, RStatement.class)));
      metaDataMap = Collections.unmodifiableMap(tmpMap);
      org.apache.thrift.meta_data.FieldMetaData.addStructMetaDataMap(statement_getResultSet_args.class, metaDataMap);
    }

    public statement_getResultSet_args() {
    }

    public statement_getResultSet_args(
      RStatement statement)
    {
      this();
      this.statement = statement;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public statement_getResultSet_args(statement_getResultSet_args other) {
      if (other.isSetStatement()) {
        this.statement = new RStatement(other.statement);
      }
    }

    public statement_getResultSet_args deepCopy() {
      return new statement_getResultSet_args(this);
    }

    @Override
    public void clear() {
      this.statement = null;
    }

    public RStatement getStatement() {
      return this.statement;
    }

    public statement_getResultSet_args setStatement(RStatement statement) {
      this.statement = statement;
      return this;
    }

    public void unsetStatement() {
      this.statement = null;
    }

    /** Returns true if field statement is set (has been assigned a value) and false otherwise */
    public boolean isSetStatement() {
      return this.statement != null;
    }

    public void setStatementIsSet(boolean value) {
      if (!value) {
        this.statement = null;
      }
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      case STATEMENT:
        if (value == null) {
          unsetStatement();
        } else {
          setStatement((RStatement)value);
        }
        break;

      }
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      case STATEMENT:
        return getStatement();

      }
      throw new IllegalStateException();
    }

    /** Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      if (field == null) {
        throw new IllegalArgumentException();
      }

      switch (field) {
      case STATEMENT:
        return isSetStatement();
      }
      throw new IllegalStateException();
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof statement_getResultSet_args)
        return this.equals((statement_getResultSet_args)that);
      return false;
    }

    public boolean equals(statement_getResultSet_args that) {
      if (that == null)
        return false;

      boolean this_present_statement = true && this.isSetStatement();
      boolean that_present_statement = true && that.isSetStatement();
      if (this_present_statement || that_present_statement) {
        if (!(this_present_statement && that_present_statement))
          return false;
        if (!this.statement.equals(that.statement))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      List<Object> list = new ArrayList<Object>();

      boolean present_statement = true && (isSetStatement());
      list.add(present_statement);
      if (present_statement)
        list.add(statement);

      return list.hashCode();
    }

    @Override
    public int compareTo(statement_getResultSet_args other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetStatement()).compareTo(other.isSetStatement());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetStatement()) {
        lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.statement, other.statement);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      return 0;
    }

    public _Fields fieldForId(int fieldId) {
      return _Fields.findByThriftId(fieldId);
    }

    public void read(org.apache.thrift.protocol.TProtocol iprot) throws org.apache.thrift.TException {
      schemes.get(iprot.getScheme()).getScheme().read(iprot, this);
    }

    public void write(org.apache.thrift.protocol.TProtocol oprot) throws org.apache.thrift.TException {
      schemes.get(oprot.getScheme()).getScheme().write(oprot, this);
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("statement_getResultSet_args(");
      boolean first = true;

      sb.append("statement:");
      if (this.statement == null) {
        sb.append("null");
      } else {
        sb.append(this.statement);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws org.apache.thrift.TException {
      // check for required fields
      // check for sub-struct validity
      if (statement != null) {
        statement.validate();
      }
    }

    private void writeObject(java.io.ObjectOutputStream out) throws java.io.IOException {
      try {
        write(new org.apache.thrift.protocol.TCompactProtocol(new org.apache.thrift.transport.TIOStreamTransport(out)));
      } catch (org.apache.thrift.TException te) {
        throw new java.io.IOException(te);
      }
    }

    private void readObject(java.io.ObjectInputStream in) throws java.io.IOException, ClassNotFoundException {
      try {
        read(new org.apache.thrift.protocol.TCompactProtocol(new org.apache.thrift.transport.TIOStreamTransport(in)));
      } catch (org.apache.thrift.TException te) {
        throw new java.io.IOException(te);
      }
    }

    private static class statement_getResultSet_argsStandardSchemeFactory implements SchemeFactory {
      public statement_getResultSet_argsStandardScheme getScheme() {
        return new statement_getResultSet_argsStandardScheme();
      }
    }

    private static class statement_getResultSet_argsStandardScheme extends StandardScheme<statement_getResultSet_args> {

      public void read(org.apache.thrift.protocol.TProtocol iprot, statement_getResultSet_args struct) throws org.apache.thrift.TException {
        org.apache.thrift.protocol.TField schemeField;
        iprot.readStructBegin();
        while (true)
        {
          schemeField = iprot.readFieldBegin();
          if (schemeField.type == org.apache.thrift.protocol.TType.STOP) { 
            break;
          }
          switch (schemeField.id) {
            case 1: // STATEMENT
              if (schemeField.type == org.apache.thrift.protocol.TType.STRUCT) {
                struct.statement = new RStatement();
                struct.statement.read(iprot);
                struct.setStatementIsSet(true);
              } else { 
                org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
              }
              break;
            default:
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
          }
          iprot.readFieldEnd();
        }
        iprot.readStructEnd();

        // check for required fields of primitive type, which can't be checked in the validate method
        struct.validate();
      }

      public void write(org.apache.thrift.protocol.TProtocol oprot, statement_getResultSet_args struct) throws org.apache.thrift.TException {
        struct.validate();

        oprot.writeStructBegin(STRUCT_DESC);
        if (struct.statement != null) {
          oprot.writeFieldBegin(STATEMENT_FIELD_DESC);
          struct.statement.write(oprot);
          oprot.writeFieldEnd();
        }
        oprot.writeFieldStop();
        oprot.writeStructEnd();
      }

    }

    private static class statement_getResultSet_argsTupleSchemeFactory implements SchemeFactory {
      public statement_getResultSet_argsTupleScheme getScheme() {
        return new statement_getResultSet_argsTupleScheme();
      }
    }

    private static class statement_getResultSet_argsTupleScheme extends TupleScheme<statement_getResultSet_args> {

      @Override
      public void write(org.apache.thrift.protocol.TProtocol prot, statement_getResultSet_args struct) throws org.apache.thrift.TException {
        TTupleProtocol oprot = (TTupleProtocol) prot;
        BitSet optionals = new BitSet();
        if (struct.isSetStatement()) {
          optionals.set(0);
        }
        oprot.writeBitSet(optionals, 1);
        if (struct.isSetStatement()) {
          struct.statement.write(oprot);
        }
      }

      @Override
      public void read(org.apache.thrift.protocol.TProtocol prot, statement_getResultSet_args struct) throws org.apache.thrift.TException {
        TTupleProtocol iprot = (TTupleProtocol) prot;
        BitSet incoming = iprot.readBitSet(1);
        if (incoming.get(0)) {
          struct.statement = new RStatement();
          struct.statement.read(iprot);
          struct.setStatementIsSet(true);
        }
      }
    }

  }

  public static class statement_getResultSet_result implements org.apache.thrift.TBase<statement_getResultSet_result, statement_getResultSet_result._Fields>, java.io.Serializable, Cloneable, Comparable<statement_getResultSet_result>   {
    private static final org.apache.thrift.protocol.TStruct STRUCT_DESC = new org.apache.thrift.protocol.TStruct("statement_getResultSet_result");

    private static final org.apache.thrift.protocol.TField SUCCESS_FIELD_DESC = new org.apache.thrift.protocol.TField("success", org.apache.thrift.protocol.TType.STRUCT, (short)0);
    private static final org.apache.thrift.protocol.TField SQL_EXCEPTION_FIELD_DESC = new org.apache.thrift.protocol.TField("sqlException", org.apache.thrift.protocol.TType.STRUCT, (short)1);

    private static final Map<Class<? extends IScheme>, SchemeFactory> schemes = new HashMap<Class<? extends IScheme>, SchemeFactory>();
    static {
      schemes.put(StandardScheme.class, new statement_getResultSet_resultStandardSchemeFactory());
      schemes.put(TupleScheme.class, new statement_getResultSet_resultTupleSchemeFactory());
    }

    public RResultSet success; // required
    public RSQLException sqlException; // required

    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements org.apache.thrift.TFieldIdEnum {
      SUCCESS((short)0, "success"),
      SQL_EXCEPTION((short)1, "sqlException");

      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        switch(fieldId) {
          case 0: // SUCCESS
            return SUCCESS;
          case 1: // SQL_EXCEPTION
            return SQL_EXCEPTION;
          default:
            return null;
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }

    // isset id assignments
    public static final Map<_Fields, org.apache.thrift.meta_data.FieldMetaData> metaDataMap;
    static {
      Map<_Fields, org.apache.thrift.meta_data.FieldMetaData> tmpMap = new EnumMap<_Fields, org.apache.thrift.meta_data.FieldMetaData>(_Fields.class);
      tmpMap.put(_Fields.SUCCESS, new org.apache.thrift.meta_data.FieldMetaData("success", org.apache.thrift.TFieldRequirementType.DEFAULT, 
          new org.apache.thrift.meta_data.StructMetaData(org.apache.thrift.protocol.TType.STRUCT, RResultSet.class)));
      tmpMap.put(_Fields.SQL_EXCEPTION, new org.apache.thrift.meta_data.FieldMetaData("sqlException", org.apache.thrift.TFieldRequirementType.DEFAULT, 
          new org.apache.thrift.meta_data.FieldValueMetaData(org.apache.thrift.protocol.TType.STRUCT)));
      metaDataMap = Collections.unmodifiableMap(tmpMap);
      org.apache.thrift.meta_data.FieldMetaData.addStructMetaDataMap(statement_getResultSet_result.class, metaDataMap);
    }

    public statement_getResultSet_result() {
    }

    public statement_getResultSet_result(
      RResultSet success,
      RSQLException sqlException)
    {
      this();
      this.success = success;
      this.sqlException = sqlException;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public statement_getResultSet_result(statement_getResultSet_result other) {
      if (other.isSetSuccess()) {
        this.success = new RResultSet(other.success);
      }
      if (other.isSetSqlException()) {
        this.sqlException = new RSQLException(other.sqlException);
      }
    }

    public statement_getResultSet_result deepCopy() {
      return new statement_getResultSet_result(this);
    }

    @Override
    public void clear() {
      this.success = null;
      this.sqlException = null;
    }

    public RResultSet getSuccess() {
      return this.success;
    }

    public statement_getResultSet_result setSuccess(RResultSet success) {
      this.success = success;
      return this;
    }

    public void unsetSuccess() {
      this.success = null;
    }

    /** Returns true if field success is set (has been assigned a value) and false otherwise */
    public boolean isSetSuccess() {
      return this.success != null;
    }

    public void setSuccessIsSet(boolean value) {
      if (!value) {
        this.success = null;
      }
    }

    public RSQLException getSqlException() {
      return this.sqlException;
    }

    public statement_getResultSet_result setSqlException(RSQLException sqlException) {
      this.sqlException = sqlException;
      return this;
    }

    public void unsetSqlException() {
      this.sqlException = null;
    }

    /** Returns true if field sqlException is set (has been assigned a value) and false otherwise */
    public boolean isSetSqlException() {
      return this.sqlException != null;
    }

    public void setSqlExceptionIsSet(boolean value) {
      if (!value) {
        this.sqlException = null;
      }
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          setSuccess((RResultSet)value);
        }
        break;

      case SQL_EXCEPTION:
        if (value == null) {
          unsetSqlException();
        } else {
          setSqlException((RSQLException)value);
        }
        break;

      }
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      case SUCCESS:
        return getSuccess();

      case SQL_EXCEPTION:
        return getSqlException();

      }
      throw new IllegalStateException();
    }

    /** Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      if (field == null) {
        throw new IllegalArgumentException();
      }

      switch (field) {
      case SUCCESS:
        return isSetSuccess();
      case SQL_EXCEPTION:
        return isSetSqlException();
      }
      throw new IllegalStateException();
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof statement_getResultSet_result)
        return this.equals((statement_getResultSet_result)that);
      return false;
    }

    public boolean equals(statement_getResultSet_result that) {
      if (that == null)
        return false;

      boolean this_present_success = true && this.isSetSuccess();
      boolean that_present_success = true && that.isSetSuccess();
      if (this_present_success || that_present_success) {
        if (!(this_present_success && that_present_success))
          return false;
        if (!this.success.equals(that.success))
          return false;
      }

      boolean this_present_sqlException = true && this.isSetSqlException();
      boolean that_present_sqlException = true && that.isSetSqlException();
      if (this_present_sqlException || that_present_sqlException) {
        if (!(this_present_sqlException && that_present_sqlException))
          return false;
        if (!this.sqlException.equals(that.sqlException))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      List<Object> list = new ArrayList<Object>();

      boolean present_success = true && (isSetSuccess());
      list.add(present_success);
      if (present_success)
        list.add(success);

      boolean present_sqlException = true && (isSetSqlException());
      list.add(present_sqlException);
      if (present_sqlException)
        list.add(sqlException);

      return list.hashCode();
    }

    @Override
    public int compareTo(statement_getResultSet_result other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetSuccess()).compareTo(other.isSetSuccess());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetSuccess()) {
        lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.success, other.success);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      lastComparison = Boolean.valueOf(isSetSqlException()).compareTo(other.isSetSqlException());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetSqlException()) {
        lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.sqlException, other.sqlException);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      return 0;
    }

    public _Fields fieldForId(int fieldId) {
      return _Fields.findByThriftId(fieldId);
    }

    public void read(org.apache.thrift.protocol.TProtocol iprot) throws org.apache.thrift.TException {
      schemes.get(iprot.getScheme()).getScheme().read(iprot, this);
    }

    public void write(org.apache.thrift.protocol.TProtocol oprot) throws org.apache.thrift.TException {
      schemes.get(oprot.getScheme()).getScheme().write(oprot, this);
      }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("statement_getResultSet_result(");
      boolean first = true;

      sb.append("success:");
      if (this.success == null) {
        sb.append("null");
      } else {
        sb.append(this.success);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("sqlException:");
      if (this.sqlException == null) {
        sb.append("null");
      } else {
        sb.append(this.sqlException);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws org.apache.thrift.TException {
      // check for required fields
      // check for sub-struct validity
      if (success != null) {
        success.validate();
      }
    }

    private void writeObject(java.io.ObjectOutputStream out) throws java.io.IOException {
      try {
        write(new org.apache.thrift.protocol.TCompactProtocol(new org.apache.thrift.transport.TIOStreamTransport(out)));
      } catch (org.apache.thrift.TException te) {
        throw new java.io.IOException(te);
      }
    }

    private void readObject(java.io.ObjectInputStream in) throws java.io.IOException, ClassNotFoundException {
      try {
        read(new org.apache.thrift.protocol.TCompactProtocol(new org.apache.thrift.transport.TIOStreamTransport(in)));
      } catch (org.apache.thrift.TException te) {
        throw new java.io.IOException(te);
      }
    }

    private static class statement_getResultSet_resultStandardSchemeFactory implements SchemeFactory {
      public statement_getResultSet_resultStandardScheme getScheme() {
        return new statement_getResultSet_resultStandardScheme();
      }
    }

    private static class statement_getResultSet_resultStandardScheme extends StandardScheme<statement_getResultSet_result> {

      public void read(org.apache.thrift.protocol.TProtocol iprot, statement_getResultSet_result struct) throws org.apache.thrift.TException {
        org.apache.thrift.protocol.TField schemeField;
        iprot.readStructBegin();
        while (true)
        {
          schemeField = iprot.readFieldBegin();
          if (schemeField.type == org.apache.thrift.protocol.TType.STOP) { 
            break;
          }
          switch (schemeField.id) {
            case 0: // SUCCESS
              if (schemeField.type == org.apache.thrift.protocol.TType.STRUCT) {
                struct.success = new RResultSet();
                struct.success.read(iprot);
                struct.setSuccessIsSet(true);
              } else { 
                org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
              }
              break;
            case 1: // SQL_EXCEPTION
              if (schemeField.type == org.apache.thrift.protocol.TType.STRUCT) {
                struct.sqlException = new RSQLException();
                struct.sqlException.read(iprot);
                struct.setSqlExceptionIsSet(true);
              } else { 
                org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
              }
              break;
            default:
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
          }
          iprot.readFieldEnd();
        }
        iprot.readStructEnd();

        // check for required fields of primitive type, which can't be checked in the validate method
        struct.validate();
      }

      public void write(org.apache.thrift.protocol.TProtocol oprot, statement_getResultSet_result struct) throws org.apache.thrift.TException {
        struct.validate();

        oprot.writeStructBegin(STRUCT_DESC);
        if (struct.success != null) {
          oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
          struct.success.write(oprot);
          oprot.writeFieldEnd();
        }
        if (struct.sqlException != null) {
          oprot.writeFieldBegin(SQL_EXCEPTION_FIELD_DESC);
          struct.sqlException.write(oprot);
          oprot.writeFieldEnd();
        }
        oprot.writeFieldStop();
        oprot.writeStructEnd();
      }

    }

    private static class statement_getResultSet_resultTupleSchemeFactory implements SchemeFactory {
      public statement_getResultSet_resultTupleScheme getScheme() {
        return new statement_getResultSet_resultTupleScheme();
      }
    }

    private static class statement_getResultSet_resultTupleScheme extends TupleScheme<statement_getResultSet_result> {

      @Override
      public void write(org.apache.thrift.protocol.TProtocol prot, statement_getResultSet_result struct) throws org.apache.thrift.TException {
        TTupleProtocol oprot = (TTupleProtocol) prot;
        BitSet optionals = new BitSet();
        if (struct.isSetSuccess()) {
          optionals.set(0);
        }
        if (struct.isSetSqlException()) {
          optionals.set(1);
        }
        oprot.writeBitSet(optionals, 2);
        if (struct.isSetSuccess()) {
          struct.success.write(oprot);
        }
        if (struct.isSetSqlException()) {
          struct.sqlException.write(oprot);
        }
      }

      @Override
      public void read(org.apache.thrift.protocol.TProtocol prot, statement_getResultSet_result struct) throws org.apache.thrift.TException {
        TTupleProtocol iprot = (TTupleProtocol) prot;
        BitSet incoming = iprot.readBitSet(2);
        if (incoming.get(0)) {
          struct.success = new RResultSet();
          struct.success.read(iprot);
          struct.setSuccessIsSet(true);
        }
        if (incoming.get(1)) {
          struct.sqlException = new RSQLException();
          struct.sqlException.read(iprot);
          struct.setSqlExceptionIsSet(true);
        }
      }
    }

  }

  public static class statement_getUpdateCount_args implements org.apache.thrift.TBase<statement_getUpdateCount_args, statement_getUpdateCount_args._Fields>, java.io.Serializable, Cloneable, Comparable<statement_getUpdateCount_args>   {
    private static final org.apache.thrift.protocol.TStruct STRUCT_DESC = new org.apache.thrift.protocol.TStruct("statement_getUpdateCount_args");

    private static final org.apache.thrift.protocol.TField STATEMENT_FIELD_DESC = new org.apache.thrift.protocol.TField("statement", org.apache.thrift.protocol.TType.STRUCT, (short)1);

    private static final Map<Class<? extends IScheme>, SchemeFactory> schemes = new HashMap<Class<? extends IScheme>, SchemeFactory>();
    static {
      schemes.put(StandardScheme.class, new statement_getUpdateCount_argsStandardSchemeFactory());
      schemes.put(TupleScheme.class, new statement_getUpdateCount_argsTupleSchemeFactory());
    }

    public RStatement statement; // required

    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements org.apache.thrift.TFieldIdEnum {
      STATEMENT((short)1, "statement");

      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        switch(fieldId) {
          case 1: // STATEMENT
            return STATEMENT;
          default:
            return null;
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }

    // isset id assignments
    public static final Map<_Fields, org.apache.thrift.meta_data.FieldMetaData> metaDataMap;
    static {
      Map<_Fields, org.apache.thrift.meta_data.FieldMetaData> tmpMap = new EnumMap<_Fields, org.apache.thrift.meta_data.FieldMetaData>(_Fields.class);
      tmpMap.put(_Fields.STATEMENT, new org.apache.thrift.meta_data.FieldMetaData("statement", org.apache.thrift.TFieldRequirementType.DEFAULT, 
          new org.apache.thrift.meta_data.StructMetaData(org.apache.thrift.protocol.TType.STRUCT, RStatement.class)));
      metaDataMap = Collections.unmodifiableMap(tmpMap);
      org.apache.thrift.meta_data.FieldMetaData.addStructMetaDataMap(statement_getUpdateCount_args.class, metaDataMap);
    }

    public statement_getUpdateCount_args() {
    }

    public statement_getUpdateCount_args(
      RStatement statement)
    {
      this();
      this.statement = statement;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public statement_getUpdateCount_args(statement_getUpdateCount_args other) {
      if (other.isSetStatement()) {
        this.statement = new RStatement(other.statement);
      }
    }

    public statement_getUpdateCount_args deepCopy() {
      return new statement_getUpdateCount_args(this);
    }

    @Override
    public void clear() {
      this.statement = null;
    }

    public RStatement getStatement() {
      return this.statement;
    }

    public statement_getUpdateCount_args setStatement(RStatement statement) {
      this.statement = statement;
      return this;
    }

    public void unsetStatement() {
      this.statement = null;
    }

    /** Returns true if field statement is set (has been assigned a value) and false otherwise */
    public boolean isSetStatement() {
      return this.statement != null;
    }

    public void setStatementIsSet(boolean value) {
      if (!value) {
        this.statement = null;
      }
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      case STATEMENT:
        if (value == null) {
          unsetStatement();
        } else {
          setStatement((RStatement)value);
        }
        break;

      }
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      case STATEMENT:
        return getStatement();

      }
      throw new IllegalStateException();
    }

    /** Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      if (field == null) {
        throw new IllegalArgumentException();
      }

      switch (field) {
      case STATEMENT:
        return isSetStatement();
      }
      throw new IllegalStateException();
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof statement_getUpdateCount_args)
        return this.equals((statement_getUpdateCount_args)that);
      return false;
    }

    public boolean equals(statement_getUpdateCount_args that) {
      if (that == null)
        return false;

      boolean this_present_statement = true && this.isSetStatement();
      boolean that_present_statement = true && that.isSetStatement();
      if (this_present_statement || that_present_statement) {
        if (!(this_present_statement && that_present_statement))
          return false;
        if (!this.statement.equals(that.statement))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      List<Object> list = new ArrayList<Object>();

      boolean present_statement = true && (isSetStatement());
      list.add(present_statement);
      if (present_statement)
        list.add(statement);

      return list.hashCode();
    }

    @Override
    public int compareTo(statement_getUpdateCount_args other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetStatement()).compareTo(other.isSetStatement());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetStatement()) {
        lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.statement, other.statement);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      return 0;
    }

    public _Fields fieldForId(int fieldId) {
      return _Fields.findByThriftId(fieldId);
    }

    public void read(org.apache.thrift.protocol.TProtocol iprot) throws org.apache.thrift.TException {
      schemes.get(iprot.getScheme()).getScheme().read(iprot, this);
    }

    public void write(org.apache.thrift.protocol.TProtocol oprot) throws org.apache.thrift.TException {
      schemes.get(oprot.getScheme()).getScheme().write(oprot, this);
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("statement_getUpdateCount_args(");
      boolean first = true;

      sb.append("statement:");
      if (this.statement == null) {
        sb.append("null");
      } else {
        sb.append(this.statement);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws org.apache.thrift.TException {
      // check for required fields
      // check for sub-struct validity
      if (statement != null) {
        statement.validate();
      }
    }

    private void writeObject(java.io.ObjectOutputStream out) throws java.io.IOException {
      try {
        write(new org.apache.thrift.protocol.TCompactProtocol(new org.apache.thrift.transport.TIOStreamTransport(out)));
      } catch (org.apache.thrift.TException te) {
        throw new java.io.IOException(te);
      }
    }

    private void readObject(java.io.ObjectInputStream in) throws java.io.IOException, ClassNotFoundException {
      try {
        read(new org.apache.thrift.protocol.TCompactProtocol(new org.apache.thrift.transport.TIOStreamTransport(in)));
      } catch (org.apache.thrift.TException te) {
        throw new java.io.IOException(te);
      }
    }

    private static class statement_getUpdateCount_argsStandardSchemeFactory implements SchemeFactory {
      public statement_getUpdateCount_argsStandardScheme getScheme() {
        return new statement_getUpdateCount_argsStandardScheme();
      }
    }

    private static class statement_getUpdateCount_argsStandardScheme extends StandardScheme<statement_getUpdateCount_args> {

      public void read(org.apache.thrift.protocol.TProtocol iprot, statement_getUpdateCount_args struct) throws org.apache.thrift.TException {
        org.apache.thrift.protocol.TField schemeField;
        iprot.readStructBegin();
        while (true)
        {
          schemeField = iprot.readFieldBegin();
          if (schemeField.type == org.apache.thrift.protocol.TType.STOP) { 
            break;
          }
          switch (schemeField.id) {
            case 1: // STATEMENT
              if (schemeField.type == org.apache.thrift.protocol.TType.STRUCT) {
                struct.statement = new RStatement();
                struct.statement.read(iprot);
                struct.setStatementIsSet(true);
              } else { 
                org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
              }
              break;
            default:
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
          }
          iprot.readFieldEnd();
        }
        iprot.readStructEnd();

        // check for required fields of primitive type, which can't be checked in the validate method
        struct.validate();
      }

      public void write(org.apache.thrift.protocol.TProtocol oprot, statement_getUpdateCount_args struct) throws org.apache.thrift.TException {
        struct.validate();

        oprot.writeStructBegin(STRUCT_DESC);
        if (struct.statement != null) {
          oprot.writeFieldBegin(STATEMENT_FIELD_DESC);
          struct.statement.write(oprot);
          oprot.writeFieldEnd();
        }
        oprot.writeFieldStop();
        oprot.writeStructEnd();
      }

    }

    private static class statement_getUpdateCount_argsTupleSchemeFactory implements SchemeFactory {
      public statement_getUpdateCount_argsTupleScheme getScheme() {
        return new statement_getUpdateCount_argsTupleScheme();
      }
    }

    private static class statement_getUpdateCount_argsTupleScheme extends TupleScheme<statement_getUpdateCount_args> {

      @Override
      public void write(org.apache.thrift.protocol.TProtocol prot, statement_getUpdateCount_args struct) throws org.apache.thrift.TException {
        TTupleProtocol oprot = (TTupleProtocol) prot;
        BitSet optionals = new BitSet();
        if (struct.isSetStatement()) {
          optionals.set(0);
        }
        oprot.writeBitSet(optionals, 1);
        if (struct.isSetStatement()) {
          struct.statement.write(oprot);
        }
      }

      @Override
      public void read(org.apache.thrift.protocol.TProtocol prot, statement_getUpdateCount_args struct) throws org.apache.thrift.TException {
        TTupleProtocol iprot = (TTupleProtocol) prot;
        BitSet incoming = iprot.readBitSet(1);
        if (incoming.get(0)) {
          struct.statement = new RStatement();
          struct.statement.read(iprot);
          struct.setStatementIsSet(true);
        }
      }
    }

  }

  public static class statement_getUpdateCount_result implements org.apache.thrift.TBase<statement_getUpdateCount_result, statement_getUpdateCount_result._Fields>, java.io.Serializable, Cloneable, Comparable<statement_getUpdateCount_result>   {
    private static final org.apache.thrift.protocol.TStruct STRUCT_DESC = new org.apache.thrift.protocol.TStruct("statement_getUpdateCount_result");

    private static final org.apache.thrift.protocol.TField SUCCESS_FIELD_DESC = new org.apache.thrift.protocol.TField("success", org.apache.thrift.protocol.TType.I32, (short)0);
    private static final org.apache.thrift.protocol.TField SQL_EXCEPTION_FIELD_DESC = new org.apache.thrift.protocol.TField("sqlException", org.apache.thrift.protocol.TType.STRUCT, (short)1);

    private static final Map<Class<? extends IScheme>, SchemeFactory> schemes = new HashMap<Class<? extends IScheme>, SchemeFactory>();
    static {
      schemes.put(StandardScheme.class, new statement_getUpdateCount_resultStandardSchemeFactory());
      schemes.put(TupleScheme.class, new statement_getUpdateCount_resultTupleSchemeFactory());
    }

    public int success; // required
    public RSQLException sqlException; // required

    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements org.apache.thrift.TFieldIdEnum {
      SUCCESS((short)0, "success"),
      SQL_EXCEPTION((short)1, "sqlException");

      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        switch(fieldId) {
          case 0: // SUCCESS
            return SUCCESS;
          case 1: // SQL_EXCEPTION
            return SQL_EXCEPTION;
          default:
            return null;
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }

    // isset id assignments
    private static final int __SUCCESS_ISSET_ID = 0;
    private byte __isset_bitfield = 0;
    public static final Map<_Fields, org.apache.thrift.meta_data.FieldMetaData> metaDataMap;
    static {
      Map<_Fields, org.apache.thrift.meta_data.FieldMetaData> tmpMap = new EnumMap<_Fields, org.apache.thrift.meta_data.FieldMetaData>(_Fields.class);
      tmpMap.put(_Fields.SUCCESS, new org.apache.thrift.meta_data.FieldMetaData("success", org.apache.thrift.TFieldRequirementType.DEFAULT, 
          new org.apache.thrift.meta_data.FieldValueMetaData(org.apache.thrift.protocol.TType.I32)));
      tmpMap.put(_Fields.SQL_EXCEPTION, new org.apache.thrift.meta_data.FieldMetaData("sqlException", org.apache.thrift.TFieldRequirementType.DEFAULT, 
          new org.apache.thrift.meta_data.FieldValueMetaData(org.apache.thrift.protocol.TType.STRUCT)));
      metaDataMap = Collections.unmodifiableMap(tmpMap);
      org.apache.thrift.meta_data.FieldMetaData.addStructMetaDataMap(statement_getUpdateCount_result.class, metaDataMap);
    }

    public statement_getUpdateCount_result() {
    }

    public statement_getUpdateCount_result(
      int success,
      RSQLException sqlException)
    {
      this();
      this.success = success;
      setSuccessIsSet(true);
      this.sqlException = sqlException;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public statement_getUpdateCount_result(statement_getUpdateCount_result other) {
      __isset_bitfield = other.__isset_bitfield;
      this.success = other.success;
      if (other.isSetSqlException()) {
        this.sqlException = new RSQLException(other.sqlException);
      }
    }

    public statement_getUpdateCount_result deepCopy() {
      return new statement_getUpdateCount_result(this);
    }

    @Override
    public void clear() {
      setSuccessIsSet(false);
      this.success = 0;
      this.sqlException = null;
    }

    public int getSuccess() {
      return this.success;
    }

    public statement_getUpdateCount_result setSuccess(int success) {
      this.success = success;
      setSuccessIsSet(true);
      return this;
    }

    public void unsetSuccess() {
      __isset_bitfield = EncodingUtils.clearBit(__isset_bitfield, __SUCCESS_ISSET_ID);
    }

    /** Returns true if field success is set (has been assigned a value) and false otherwise */
    public boolean isSetSuccess() {
      return EncodingUtils.testBit(__isset_bitfield, __SUCCESS_ISSET_ID);
    }

    public void setSuccessIsSet(boolean value) {
      __isset_bitfield = EncodingUtils.setBit(__isset_bitfield, __SUCCESS_ISSET_ID, value);
    }

    public RSQLException getSqlException() {
      return this.sqlException;
    }

    public statement_getUpdateCount_result setSqlException(RSQLException sqlException) {
      this.sqlException = sqlException;
      return this;
    }

    public void unsetSqlException() {
      this.sqlException = null;
    }

    /** Returns true if field sqlException is set (has been assigned a value) and false otherwise */
    public boolean isSetSqlException() {
      return this.sqlException != null;
    }

    public void setSqlExceptionIsSet(boolean value) {
      if (!value) {
        this.sqlException = null;
      }
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          setSuccess((Integer)value);
        }
        break;

      case SQL_EXCEPTION:
        if (value == null) {
          unsetSqlException();
        } else {
          setSqlException((RSQLException)value);
        }
        break;

      }
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      case SUCCESS:
        return Integer.valueOf(getSuccess());

      case SQL_EXCEPTION:
        return getSqlException();

      }
      throw new IllegalStateException();
    }

    /** Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      if (field == null) {
        throw new IllegalArgumentException();
      }

      switch (field) {
      case SUCCESS:
        return isSetSuccess();
      case SQL_EXCEPTION:
        return isSetSqlException();
      }
      throw new IllegalStateException();
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof statement_getUpdateCount_result)
        return this.equals((statement_getUpdateCount_result)that);
      return false;
    }

    public boolean equals(statement_getUpdateCount_result that) {
      if (that == null)
        return false;

      boolean this_present_success = true;
      boolean that_present_success = true;
      if (this_present_success || that_present_success) {
        if (!(this_present_success && that_present_success))
          return false;
        if (this.success != that.success)
          return false;
      }

      boolean this_present_sqlException = true && this.isSetSqlException();
      boolean that_present_sqlException = true && that.isSetSqlException();
      if (this_present_sqlException || that_present_sqlException) {
        if (!(this_present_sqlException && that_present_sqlException))
          return false;
        if (!this.sqlException.equals(that.sqlException))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      List<Object> list = new ArrayList<Object>();

      boolean present_success = true;
      list.add(present_success);
      if (present_success)
        list.add(success);

      boolean present_sqlException = true && (isSetSqlException());
      list.add(present_sqlException);
      if (present_sqlException)
        list.add(sqlException);

      return list.hashCode();
    }

    @Override
    public int compareTo(statement_getUpdateCount_result other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetSuccess()).compareTo(other.isSetSuccess());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetSuccess()) {
        lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.success, other.success);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      lastComparison = Boolean.valueOf(isSetSqlException()).compareTo(other.isSetSqlException());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetSqlException()) {
        lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.sqlException, other.sqlException);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      return 0;
    }

    public _Fields fieldForId(int fieldId) {
      return _Fields.findByThriftId(fieldId);
    }

    public void read(org.apache.thrift.protocol.TProtocol iprot) throws org.apache.thrift.TException {
      schemes.get(iprot.getScheme()).getScheme().read(iprot, this);
    }

    public void write(org.apache.thrift.protocol.TProtocol oprot) throws org.apache.thrift.TException {
      schemes.get(oprot.getScheme()).getScheme().write(oprot, this);
      }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("statement_getUpdateCount_result(");
      boolean first = true;

      sb.append("success:");
      sb.append(this.success);
      first = false;
      if (!first) sb.append(", ");
      sb.append("sqlException:");
      if (this.sqlException == null) {
        sb.append("null");
      } else {
        sb.append(this.sqlException);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws org.apache.thrift.TException {
      // check for required fields
      // check for sub-struct validity
    }

    private void writeObject(java.io.ObjectOutputStream out) throws java.io.IOException {
      try {
        write(new org.apache.thrift.protocol.TCompactProtocol(new org.apache.thrift.transport.TIOStreamTransport(out)));
      } catch (org.apache.thrift.TException te) {
        throw new java.io.IOException(te);
      }
    }

    private void readObject(java.io.ObjectInputStream in) throws java.io.IOException, ClassNotFoundException {
      try {
        // it doesn't seem like you should have to do this, but java serialization is wacky, and doesn't call the default constructor.
        __isset_bitfield = 0;
        read(new org.apache.thrift.protocol.TCompactProtocol(new org.apache.thrift.transport.TIOStreamTransport(in)));
      } catch (org.apache.thrift.TException te) {
        throw new java.io.IOException(te);
      }
    }

    private static class statement_getUpdateCount_resultStandardSchemeFactory implements SchemeFactory {
      public statement_getUpdateCount_resultStandardScheme getScheme() {
        return new statement_getUpdateCount_resultStandardScheme();
      }
    }

    private static class statement_getUpdateCount_resultStandardScheme extends StandardScheme<statement_getUpdateCount_result> {

      public void read(org.apache.thrift.protocol.TProtocol iprot, statement_getUpdateCount_result struct) throws org.apache.thrift.TException {
        org.apache.thrift.protocol.TField schemeField;
        iprot.readStructBegin();
        while (true)
        {
          schemeField = iprot.readFieldBegin();
          if (schemeField.type == org.apache.thrift.protocol.TType.STOP) { 
            break;
          }
          switch (schemeField.id) {
            case 0: // SUCCESS
              if (schemeField.type == org.apache.thrift.protocol.TType.I32) {
                struct.success = iprot.readI32();
                struct.setSuccessIsSet(true);
              } else { 
                org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
              }
              break;
            case 1: // SQL_EXCEPTION
              if (schemeField.type == org.apache.thrift.protocol.TType.STRUCT) {
                struct.sqlException = new RSQLException();
                struct.sqlException.read(iprot);
                struct.setSqlExceptionIsSet(true);
              } else { 
                org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
              }
              break;
            default:
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
          }
          iprot.readFieldEnd();
        }
        iprot.readStructEnd();

        // check for required fields of primitive type, which can't be checked in the validate method
        struct.validate();
      }

      public void write(org.apache.thrift.protocol.TProtocol oprot, statement_getUpdateCount_result struct) throws org.apache.thrift.TException {
        struct.validate();

        oprot.writeStructBegin(STRUCT_DESC);
        if (struct.isSetSuccess()) {
          oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
          oprot.writeI32(struct.success);
          oprot.writeFieldEnd();
        }
        if (struct.sqlException != null) {
          oprot.writeFieldBegin(SQL_EXCEPTION_FIELD_DESC);
          struct.sqlException.write(oprot);
          oprot.writeFieldEnd();
        }
        oprot.writeFieldStop();
        oprot.writeStructEnd();
      }

    }

    private static class statement_getUpdateCount_resultTupleSchemeFactory implements SchemeFactory {
      public statement_getUpdateCount_resultTupleScheme getScheme() {
        return new statement_getUpdateCount_resultTupleScheme();
      }
    }

    private static class statement_getUpdateCount_resultTupleScheme extends TupleScheme<statement_getUpdateCount_result> {

      @Override
      public void write(org.apache.thrift.protocol.TProtocol prot, statement_getUpdateCount_result struct) throws org.apache.thrift.TException {
        TTupleProtocol oprot = (TTupleProtocol) prot;
        BitSet optionals = new BitSet();
        if (struct.isSetSuccess()) {
          optionals.set(0);
        }
        if (struct.isSetSqlException()) {
          optionals.set(1);
        }
        oprot.writeBitSet(optionals, 2);
        if (struct.isSetSuccess()) {
          oprot.writeI32(struct.success);
        }
        if (struct.isSetSqlException()) {
          struct.sqlException.write(oprot);
        }
      }

      @Override
      public void read(org.apache.thrift.protocol.TProtocol prot, statement_getUpdateCount_result struct) throws org.apache.thrift.TException {
        TTupleProtocol iprot = (TTupleProtocol) prot;
        BitSet incoming = iprot.readBitSet(2);
        if (incoming.get(0)) {
          struct.success = iprot.readI32();
          struct.setSuccessIsSet(true);
        }
        if (incoming.get(1)) {
          struct.sqlException = new RSQLException();
          struct.sqlException.read(iprot);
          struct.setSqlExceptionIsSet(true);
        }
      }
    }

  }

  public static class statement_getResultSetType_args implements org.apache.thrift.TBase<statement_getResultSetType_args, statement_getResultSetType_args._Fields>, java.io.Serializable, Cloneable, Comparable<statement_getResultSetType_args>   {
    private static final org.apache.thrift.protocol.TStruct STRUCT_DESC = new org.apache.thrift.protocol.TStruct("statement_getResultSetType_args");

    private static final org.apache.thrift.protocol.TField STATEMENT_FIELD_DESC = new org.apache.thrift.protocol.TField("statement", org.apache.thrift.protocol.TType.STRUCT, (short)1);

    private static final Map<Class<? extends IScheme>, SchemeFactory> schemes = new HashMap<Class<? extends IScheme>, SchemeFactory>();
    static {
      schemes.put(StandardScheme.class, new statement_getResultSetType_argsStandardSchemeFactory());
      schemes.put(TupleScheme.class, new statement_getResultSetType_argsTupleSchemeFactory());
    }

    public RStatement statement; // required

    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements org.apache.thrift.TFieldIdEnum {
      STATEMENT((short)1, "statement");

      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        switch(fieldId) {
          case 1: // STATEMENT
            return STATEMENT;
          default:
            return null;
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }

    // isset id assignments
    public static final Map<_Fields, org.apache.thrift.meta_data.FieldMetaData> metaDataMap;
    static {
      Map<_Fields, org.apache.thrift.meta_data.FieldMetaData> tmpMap = new EnumMap<_Fields, org.apache.thrift.meta_data.FieldMetaData>(_Fields.class);
      tmpMap.put(_Fields.STATEMENT, new org.apache.thrift.meta_data.FieldMetaData("statement", org.apache.thrift.TFieldRequirementType.DEFAULT, 
          new org.apache.thrift.meta_data.StructMetaData(org.apache.thrift.protocol.TType.STRUCT, RStatement.class)));
      metaDataMap = Collections.unmodifiableMap(tmpMap);
      org.apache.thrift.meta_data.FieldMetaData.addStructMetaDataMap(statement_getResultSetType_args.class, metaDataMap);
    }

    public statement_getResultSetType_args() {
    }

    public statement_getResultSetType_args(
      RStatement statement)
    {
      this();
      this.statement = statement;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public statement_getResultSetType_args(statement_getResultSetType_args other) {
      if (other.isSetStatement()) {
        this.statement = new RStatement(other.statement);
      }
    }

    public statement_getResultSetType_args deepCopy() {
      return new statement_getResultSetType_args(this);
    }

    @Override
    public void clear() {
      this.statement = null;
    }

    public RStatement getStatement() {
      return this.statement;
    }

    public statement_getResultSetType_args setStatement(RStatement statement) {
      this.statement = statement;
      return this;
    }

    public void unsetStatement() {
      this.statement = null;
    }

    /** Returns true if field statement is set (has been assigned a value) and false otherwise */
    public boolean isSetStatement() {
      return this.statement != null;
    }

    public void setStatementIsSet(boolean value) {
      if (!value) {
        this.statement = null;
      }
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      case STATEMENT:
        if (value == null) {
          unsetStatement();
        } else {
          setStatement((RStatement)value);
        }
        break;

      }
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      case STATEMENT:
        return getStatement();

      }
      throw new IllegalStateException();
    }

    /** Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      if (field == null) {
        throw new IllegalArgumentException();
      }

      switch (field) {
      case STATEMENT:
        return isSetStatement();
      }
      throw new IllegalStateException();
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof statement_getResultSetType_args)
        return this.equals((statement_getResultSetType_args)that);
      return false;
    }

    public boolean equals(statement_getResultSetType_args that) {
      if (that == null)
        return false;

      boolean this_present_statement = true && this.isSetStatement();
      boolean that_present_statement = true && that.isSetStatement();
      if (this_present_statement || that_present_statement) {
        if (!(this_present_statement && that_present_statement))
          return false;
        if (!this.statement.equals(that.statement))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      List<Object> list = new ArrayList<Object>();

      boolean present_statement = true && (isSetStatement());
      list.add(present_statement);
      if (present_statement)
        list.add(statement);

      return list.hashCode();
    }

    @Override
    public int compareTo(statement_getResultSetType_args other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetStatement()).compareTo(other.isSetStatement());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetStatement()) {
        lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.statement, other.statement);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      return 0;
    }

    public _Fields fieldForId(int fieldId) {
      return _Fields.findByThriftId(fieldId);
    }

    public void read(org.apache.thrift.protocol.TProtocol iprot) throws org.apache.thrift.TException {
      schemes.get(iprot.getScheme()).getScheme().read(iprot, this);
    }

    public void write(org.apache.thrift.protocol.TProtocol oprot) throws org.apache.thrift.TException {
      schemes.get(oprot.getScheme()).getScheme().write(oprot, this);
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("statement_getResultSetType_args(");
      boolean first = true;

      sb.append("statement:");
      if (this.statement == null) {
        sb.append("null");
      } else {
        sb.append(this.statement);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws org.apache.thrift.TException {
      // check for required fields
      // check for sub-struct validity
      if (statement != null) {
        statement.validate();
      }
    }

    private void writeObject(java.io.ObjectOutputStream out) throws java.io.IOException {
      try {
        write(new org.apache.thrift.protocol.TCompactProtocol(new org.apache.thrift.transport.TIOStreamTransport(out)));
      } catch (org.apache.thrift.TException te) {
        throw new java.io.IOException(te);
      }
    }

    private void readObject(java.io.ObjectInputStream in) throws java.io.IOException, ClassNotFoundException {
      try {
        read(new org.apache.thrift.protocol.TCompactProtocol(new org.apache.thrift.transport.TIOStreamTransport(in)));
      } catch (org.apache.thrift.TException te) {
        throw new java.io.IOException(te);
      }
    }

    private static class statement_getResultSetType_argsStandardSchemeFactory implements SchemeFactory {
      public statement_getResultSetType_argsStandardScheme getScheme() {
        return new statement_getResultSetType_argsStandardScheme();
      }
    }

    private static class statement_getResultSetType_argsStandardScheme extends StandardScheme<statement_getResultSetType_args> {

      public void read(org.apache.thrift.protocol.TProtocol iprot, statement_getResultSetType_args struct) throws org.apache.thrift.TException {
        org.apache.thrift.protocol.TField schemeField;
        iprot.readStructBegin();
        while (true)
        {
          schemeField = iprot.readFieldBegin();
          if (schemeField.type == org.apache.thrift.protocol.TType.STOP) { 
            break;
          }
          switch (schemeField.id) {
            case 1: // STATEMENT
              if (schemeField.type == org.apache.thrift.protocol.TType.STRUCT) {
                struct.statement = new RStatement();
                struct.statement.read(iprot);
                struct.setStatementIsSet(true);
              } else { 
                org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
              }
              break;
            default:
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
          }
          iprot.readFieldEnd();
        }
        iprot.readStructEnd();

        // check for required fields of primitive type, which can't be checked in the validate method
        struct.validate();
      }

      public void write(org.apache.thrift.protocol.TProtocol oprot, statement_getResultSetType_args struct) throws org.apache.thrift.TException {
        struct.validate();

        oprot.writeStructBegin(STRUCT_DESC);
        if (struct.statement != null) {
          oprot.writeFieldBegin(STATEMENT_FIELD_DESC);
          struct.statement.write(oprot);
          oprot.writeFieldEnd();
        }
        oprot.writeFieldStop();
        oprot.writeStructEnd();
      }

    }

    private static class statement_getResultSetType_argsTupleSchemeFactory implements SchemeFactory {
      public statement_getResultSetType_argsTupleScheme getScheme() {
        return new statement_getResultSetType_argsTupleScheme();
      }
    }

    private static class statement_getResultSetType_argsTupleScheme extends TupleScheme<statement_getResultSetType_args> {

      @Override
      public void write(org.apache.thrift.protocol.TProtocol prot, statement_getResultSetType_args struct) throws org.apache.thrift.TException {
        TTupleProtocol oprot = (TTupleProtocol) prot;
        BitSet optionals = new BitSet();
        if (struct.isSetStatement()) {
          optionals.set(0);
        }
        oprot.writeBitSet(optionals, 1);
        if (struct.isSetStatement()) {
          struct.statement.write(oprot);
        }
      }

      @Override
      public void read(org.apache.thrift.protocol.TProtocol prot, statement_getResultSetType_args struct) throws org.apache.thrift.TException {
        TTupleProtocol iprot = (TTupleProtocol) prot;
        BitSet incoming = iprot.readBitSet(1);
        if (incoming.get(0)) {
          struct.statement = new RStatement();
          struct.statement.read(iprot);
          struct.setStatementIsSet(true);
        }
      }
    }

  }

  public static class statement_getResultSetType_result implements org.apache.thrift.TBase<statement_getResultSetType_result, statement_getResultSetType_result._Fields>, java.io.Serializable, Cloneable, Comparable<statement_getResultSetType_result>   {
    private static final org.apache.thrift.protocol.TStruct STRUCT_DESC = new org.apache.thrift.protocol.TStruct("statement_getResultSetType_result");

    private static final org.apache.thrift.protocol.TField SUCCESS_FIELD_DESC = new org.apache.thrift.protocol.TField("success", org.apache.thrift.protocol.TType.I32, (short)0);
    private static final org.apache.thrift.protocol.TField SQL_EXCEPTION_FIELD_DESC = new org.apache.thrift.protocol.TField("sqlException", org.apache.thrift.protocol.TType.STRUCT, (short)1);

    private static final Map<Class<? extends IScheme>, SchemeFactory> schemes = new HashMap<Class<? extends IScheme>, SchemeFactory>();
    static {
      schemes.put(StandardScheme.class, new statement_getResultSetType_resultStandardSchemeFactory());
      schemes.put(TupleScheme.class, new statement_getResultSetType_resultTupleSchemeFactory());
    }

    public int success; // required
    public RSQLException sqlException; // required

    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements org.apache.thrift.TFieldIdEnum {
      SUCCESS((short)0, "success"),
      SQL_EXCEPTION((short)1, "sqlException");

      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        switch(fieldId) {
          case 0: // SUCCESS
            return SUCCESS;
          case 1: // SQL_EXCEPTION
            return SQL_EXCEPTION;
          default:
            return null;
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }

    // isset id assignments
    private static final int __SUCCESS_ISSET_ID = 0;
    private byte __isset_bitfield = 0;
    public static final Map<_Fields, org.apache.thrift.meta_data.FieldMetaData> metaDataMap;
    static {
      Map<_Fields, org.apache.thrift.meta_data.FieldMetaData> tmpMap = new EnumMap<_Fields, org.apache.thrift.meta_data.FieldMetaData>(_Fields.class);
      tmpMap.put(_Fields.SUCCESS, new org.apache.thrift.meta_data.FieldMetaData("success", org.apache.thrift.TFieldRequirementType.DEFAULT, 
          new org.apache.thrift.meta_data.FieldValueMetaData(org.apache.thrift.protocol.TType.I32)));
      tmpMap.put(_Fields.SQL_EXCEPTION, new org.apache.thrift.meta_data.FieldMetaData("sqlException", org.apache.thrift.TFieldRequirementType.DEFAULT, 
          new org.apache.thrift.meta_data.FieldValueMetaData(org.apache.thrift.protocol.TType.STRUCT)));
      metaDataMap = Collections.unmodifiableMap(tmpMap);
      org.apache.thrift.meta_data.FieldMetaData.addStructMetaDataMap(statement_getResultSetType_result.class, metaDataMap);
    }

    public statement_getResultSetType_result() {
    }

    public statement_getResultSetType_result(
      int success,
      RSQLException sqlException)
    {
      this();
      this.success = success;
      setSuccessIsSet(true);
      this.sqlException = sqlException;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public statement_getResultSetType_result(statement_getResultSetType_result other) {
      __isset_bitfield = other.__isset_bitfield;
      this.success = other.success;
      if (other.isSetSqlException()) {
        this.sqlException = new RSQLException(other.sqlException);
      }
    }

    public statement_getResultSetType_result deepCopy() {
      return new statement_getResultSetType_result(this);
    }

    @Override
    public void clear() {
      setSuccessIsSet(false);
      this.success = 0;
      this.sqlException = null;
    }

    public int getSuccess() {
      return this.success;
    }

    public statement_getResultSetType_result setSuccess(int success) {
      this.success = success;
      setSuccessIsSet(true);
      return this;
    }

    public void unsetSuccess() {
      __isset_bitfield = EncodingUtils.clearBit(__isset_bitfield, __SUCCESS_ISSET_ID);
    }

    /** Returns true if field success is set (has been assigned a value) and false otherwise */
    public boolean isSetSuccess() {
      return EncodingUtils.testBit(__isset_bitfield, __SUCCESS_ISSET_ID);
    }

    public void setSuccessIsSet(boolean value) {
      __isset_bitfield = EncodingUtils.setBit(__isset_bitfield, __SUCCESS_ISSET_ID, value);
    }

    public RSQLException getSqlException() {
      return this.sqlException;
    }

    public statement_getResultSetType_result setSqlException(RSQLException sqlException) {
      this.sqlException = sqlException;
      return this;
    }

    public void unsetSqlException() {
      this.sqlException = null;
    }

    /** Returns true if field sqlException is set (has been assigned a value) and false otherwise */
    public boolean isSetSqlException() {
      return this.sqlException != null;
    }

    public void setSqlExceptionIsSet(boolean value) {
      if (!value) {
        this.sqlException = null;
      }
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          setSuccess((Integer)value);
        }
        break;

      case SQL_EXCEPTION:
        if (value == null) {
          unsetSqlException();
        } else {
          setSqlException((RSQLException)value);
        }
        break;

      }
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      case SUCCESS:
        return Integer.valueOf(getSuccess());

      case SQL_EXCEPTION:
        return getSqlException();

      }
      throw new IllegalStateException();
    }

    /** Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      if (field == null) {
        throw new IllegalArgumentException();
      }

      switch (field) {
      case SUCCESS:
        return isSetSuccess();
      case SQL_EXCEPTION:
        return isSetSqlException();
      }
      throw new IllegalStateException();
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof statement_getResultSetType_result)
        return this.equals((statement_getResultSetType_result)that);
      return false;
    }

    public boolean equals(statement_getResultSetType_result that) {
      if (that == null)
        return false;

      boolean this_present_success = true;
      boolean that_present_success = true;
      if (this_present_success || that_present_success) {
        if (!(this_present_success && that_present_success))
          return false;
        if (this.success != that.success)
          return false;
      }

      boolean this_present_sqlException = true && this.isSetSqlException();
      boolean that_present_sqlException = true && that.isSetSqlException();
      if (this_present_sqlException || that_present_sqlException) {
        if (!(this_present_sqlException && that_present_sqlException))
          return false;
        if (!this.sqlException.equals(that.sqlException))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      List<Object> list = new ArrayList<Object>();

      boolean present_success = true;
      list.add(present_success);
      if (present_success)
        list.add(success);

      boolean present_sqlException = true && (isSetSqlException());
      list.add(present_sqlException);
      if (present_sqlException)
        list.add(sqlException);

      return list.hashCode();
    }

    @Override
    public int compareTo(statement_getResultSetType_result other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetSuccess()).compareTo(other.isSetSuccess());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetSuccess()) {
        lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.success, other.success);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      lastComparison = Boolean.valueOf(isSetSqlException()).compareTo(other.isSetSqlException());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetSqlException()) {
        lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.sqlException, other.sqlException);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      return 0;
    }

    public _Fields fieldForId(int fieldId) {
      return _Fields.findByThriftId(fieldId);
    }

    public void read(org.apache.thrift.protocol.TProtocol iprot) throws org.apache.thrift.TException {
      schemes.get(iprot.getScheme()).getScheme().read(iprot, this);
    }

    public void write(org.apache.thrift.protocol.TProtocol oprot) throws org.apache.thrift.TException {
      schemes.get(oprot.getScheme()).getScheme().write(oprot, this);
      }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("statement_getResultSetType_result(");
      boolean first = true;

      sb.append("success:");
      sb.append(this.success);
      first = false;
      if (!first) sb.append(", ");
      sb.append("sqlException:");
      if (this.sqlException == null) {
        sb.append("null");
      } else {
        sb.append(this.sqlException);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws org.apache.thrift.TException {
      // check for required fields
      // check for sub-struct validity
    }

    private void writeObject(java.io.ObjectOutputStream out) throws java.io.IOException {
      try {
        write(new org.apache.thrift.protocol.TCompactProtocol(new org.apache.thrift.transport.TIOStreamTransport(out)));
      } catch (org.apache.thrift.TException te) {
        throw new java.io.IOException(te);
      }
    }

    private void readObject(java.io.ObjectInputStream in) throws java.io.IOException, ClassNotFoundException {
      try {
        // it doesn't seem like you should have to do this, but java serialization is wacky, and doesn't call the default constructor.
        __isset_bitfield = 0;
        read(new org.apache.thrift.protocol.TCompactProtocol(new org.apache.thrift.transport.TIOStreamTransport(in)));
      } catch (org.apache.thrift.TException te) {
        throw new java.io.IOException(te);
      }
    }

    private static class statement_getResultSetType_resultStandardSchemeFactory implements SchemeFactory {
      public statement_getResultSetType_resultStandardScheme getScheme() {
        return new statement_getResultSetType_resultStandardScheme();
      }
    }

    private static class statement_getResultSetType_resultStandardScheme extends StandardScheme<statement_getResultSetType_result> {

      public void read(org.apache.thrift.protocol.TProtocol iprot, statement_getResultSetType_result struct) throws org.apache.thrift.TException {
        org.apache.thrift.protocol.TField schemeField;
        iprot.readStructBegin();
        while (true)
        {
          schemeField = iprot.readFieldBegin();
          if (schemeField.type == org.apache.thrift.protocol.TType.STOP) { 
            break;
          }
          switch (schemeField.id) {
            case 0: // SUCCESS
              if (schemeField.type == org.apache.thrift.protocol.TType.I32) {
                struct.success = iprot.readI32();
                struct.setSuccessIsSet(true);
              } else { 
                org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
              }
              break;
            case 1: // SQL_EXCEPTION
              if (schemeField.type == org.apache.thrift.protocol.TType.STRUCT) {
                struct.sqlException = new RSQLException();
                struct.sqlException.read(iprot);
                struct.setSqlExceptionIsSet(true);
              } else { 
                org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
              }
              break;
            default:
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
          }
          iprot.readFieldEnd();
        }
        iprot.readStructEnd();

        // check for required fields of primitive type, which can't be checked in the validate method
        struct.validate();
      }

      public void write(org.apache.thrift.protocol.TProtocol oprot, statement_getResultSetType_result struct) throws org.apache.thrift.TException {
        struct.validate();

        oprot.writeStructBegin(STRUCT_DESC);
        if (struct.isSetSuccess()) {
          oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
          oprot.writeI32(struct.success);
          oprot.writeFieldEnd();
        }
        if (struct.sqlException != null) {
          oprot.writeFieldBegin(SQL_EXCEPTION_FIELD_DESC);
          struct.sqlException.write(oprot);
          oprot.writeFieldEnd();
        }
        oprot.writeFieldStop();
        oprot.writeStructEnd();
      }

    }

    private static class statement_getResultSetType_resultTupleSchemeFactory implements SchemeFactory {
      public statement_getResultSetType_resultTupleScheme getScheme() {
        return new statement_getResultSetType_resultTupleScheme();
      }
    }

    private static class statement_getResultSetType_resultTupleScheme extends TupleScheme<statement_getResultSetType_result> {

      @Override
      public void write(org.apache.thrift.protocol.TProtocol prot, statement_getResultSetType_result struct) throws org.apache.thrift.TException {
        TTupleProtocol oprot = (TTupleProtocol) prot;
        BitSet optionals = new BitSet();
        if (struct.isSetSuccess()) {
          optionals.set(0);
        }
        if (struct.isSetSqlException()) {
          optionals.set(1);
        }
        oprot.writeBitSet(optionals, 2);
        if (struct.isSetSuccess()) {
          oprot.writeI32(struct.success);
        }
        if (struct.isSetSqlException()) {
          struct.sqlException.write(oprot);
        }
      }

      @Override
      public void read(org.apache.thrift.protocol.TProtocol prot, statement_getResultSetType_result struct) throws org.apache.thrift.TException {
        TTupleProtocol iprot = (TTupleProtocol) prot;
        BitSet incoming = iprot.readBitSet(2);
        if (incoming.get(0)) {
          struct.success = iprot.readI32();
          struct.setSuccessIsSet(true);
        }
        if (incoming.get(1)) {
          struct.sqlException = new RSQLException();
          struct.sqlException.read(iprot);
          struct.setSqlExceptionIsSet(true);
        }
      }
    }

  }

  public static class statement_cancel_args implements org.apache.thrift.TBase<statement_cancel_args, statement_cancel_args._Fields>, java.io.Serializable, Cloneable, Comparable<statement_cancel_args>   {
    private static final org.apache.thrift.protocol.TStruct STRUCT_DESC = new org.apache.thrift.protocol.TStruct("statement_cancel_args");

    private static final org.apache.thrift.protocol.TField STATEMENT_FIELD_DESC = new org.apache.thrift.protocol.TField("statement", org.apache.thrift.protocol.TType.STRUCT, (short)1);

    private static final Map<Class<? extends IScheme>, SchemeFactory> schemes = new HashMap<Class<? extends IScheme>, SchemeFactory>();
    static {
      schemes.put(StandardScheme.class, new statement_cancel_argsStandardSchemeFactory());
      schemes.put(TupleScheme.class, new statement_cancel_argsTupleSchemeFactory());
    }

    public RStatement statement; // required

    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements org.apache.thrift.TFieldIdEnum {
      STATEMENT((short)1, "statement");

      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        switch(fieldId) {
          case 1: // STATEMENT
            return STATEMENT;
          default:
            return null;
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }

    // isset id assignments
    public static final Map<_Fields, org.apache.thrift.meta_data.FieldMetaData> metaDataMap;
    static {
      Map<_Fields, org.apache.thrift.meta_data.FieldMetaData> tmpMap = new EnumMap<_Fields, org.apache.thrift.meta_data.FieldMetaData>(_Fields.class);
      tmpMap.put(_Fields.STATEMENT, new org.apache.thrift.meta_data.FieldMetaData("statement", org.apache.thrift.TFieldRequirementType.DEFAULT, 
          new org.apache.thrift.meta_data.StructMetaData(org.apache.thrift.protocol.TType.STRUCT, RStatement.class)));
      metaDataMap = Collections.unmodifiableMap(tmpMap);
      org.apache.thrift.meta_data.FieldMetaData.addStructMetaDataMap(statement_cancel_args.class, metaDataMap);
    }

    public statement_cancel_args() {
    }

    public statement_cancel_args(
      RStatement statement)
    {
      this();
      this.statement = statement;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public statement_cancel_args(statement_cancel_args other) {
      if (other.isSetStatement()) {
        this.statement = new RStatement(other.statement);
      }
    }

    public statement_cancel_args deepCopy() {
      return new statement_cancel_args(this);
    }

    @Override
    public void clear() {
      this.statement = null;
    }

    public RStatement getStatement() {
      return this.statement;
    }

    public statement_cancel_args setStatement(RStatement statement) {
      this.statement = statement;
      return this;
    }

    public void unsetStatement() {
      this.statement = null;
    }

    /** Returns true if field statement is set (has been assigned a value) and false otherwise */
    public boolean isSetStatement() {
      return this.statement != null;
    }

    public void setStatementIsSet(boolean value) {
      if (!value) {
        this.statement = null;
      }
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      case STATEMENT:
        if (value == null) {
          unsetStatement();
        } else {
          setStatement((RStatement)value);
        }
        break;

      }
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      case STATEMENT:
        return getStatement();

      }
      throw new IllegalStateException();
    }

    /** Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      if (field == null) {
        throw new IllegalArgumentException();
      }

      switch (field) {
      case STATEMENT:
        return isSetStatement();
      }
      throw new IllegalStateException();
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof statement_cancel_args)
        return this.equals((statement_cancel_args)that);
      return false;
    }

    public boolean equals(statement_cancel_args that) {
      if (that == null)
        return false;

      boolean this_present_statement = true && this.isSetStatement();
      boolean that_present_statement = true && that.isSetStatement();
      if (this_present_statement || that_present_statement) {
        if (!(this_present_statement && that_present_statement))
          return false;
        if (!this.statement.equals(that.statement))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      List<Object> list = new ArrayList<Object>();

      boolean present_statement = true && (isSetStatement());
      list.add(present_statement);
      if (present_statement)
        list.add(statement);

      return list.hashCode();
    }

    @Override
    public int compareTo(statement_cancel_args other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetStatement()).compareTo(other.isSetStatement());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetStatement()) {
        lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.statement, other.statement);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      return 0;
    }

    public _Fields fieldForId(int fieldId) {
      return _Fields.findByThriftId(fieldId);
    }

    public void read(org.apache.thrift.protocol.TProtocol iprot) throws org.apache.thrift.TException {
      schemes.get(iprot.getScheme()).getScheme().read(iprot, this);
    }

    public void write(org.apache.thrift.protocol.TProtocol oprot) throws org.apache.thrift.TException {
      schemes.get(oprot.getScheme()).getScheme().write(oprot, this);
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("statement_cancel_args(");
      boolean first = true;

      sb.append("statement:");
      if (this.statement == null) {
        sb.append("null");
      } else {
        sb.append(this.statement);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws org.apache.thrift.TException {
      // check for required fields
      // check for sub-struct validity
      if (statement != null) {
        statement.validate();
      }
    }

    private void writeObject(java.io.ObjectOutputStream out) throws java.io.IOException {
      try {
        write(new org.apache.thrift.protocol.TCompactProtocol(new org.apache.thrift.transport.TIOStreamTransport(out)));
      } catch (org.apache.thrift.TException te) {
        throw new java.io.IOException(te);
      }
    }

    private void readObject(java.io.ObjectInputStream in) throws java.io.IOException, ClassNotFoundException {
      try {
        read(new org.apache.thrift.protocol.TCompactProtocol(new org.apache.thrift.transport.TIOStreamTransport(in)));
      } catch (org.apache.thrift.TException te) {
        throw new java.io.IOException(te);
      }
    }

    private static class statement_cancel_argsStandardSchemeFactory implements SchemeFactory {
      public statement_cancel_argsStandardScheme getScheme() {
        return new statement_cancel_argsStandardScheme();
      }
    }

    private static class statement_cancel_argsStandardScheme extends StandardScheme<statement_cancel_args> {

      public void read(org.apache.thrift.protocol.TProtocol iprot, statement_cancel_args struct) throws org.apache.thrift.TException {
        org.apache.thrift.protocol.TField schemeField;
        iprot.readStructBegin();
        while (true)
        {
          schemeField = iprot.readFieldBegin();
          if (schemeField.type == org.apache.thrift.protocol.TType.STOP) { 
            break;
          }
          switch (schemeField.id) {
            case 1: // STATEMENT
              if (schemeField.type == org.apache.thrift.protocol.TType.STRUCT) {
                struct.statement = new RStatement();
                struct.statement.read(iprot);
                struct.setStatementIsSet(true);
              } else { 
                org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
              }
              break;
            default:
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
          }
          iprot.readFieldEnd();
        }
        iprot.readStructEnd();

        // check for required fields of primitive type, which can't be checked in the validate method
        struct.validate();
      }

      public void write(org.apache.thrift.protocol.TProtocol oprot, statement_cancel_args struct) throws org.apache.thrift.TException {
        struct.validate();

        oprot.writeStructBegin(STRUCT_DESC);
        if (struct.statement != null) {
          oprot.writeFieldBegin(STATEMENT_FIELD_DESC);
          struct.statement.write(oprot);
          oprot.writeFieldEnd();
        }
        oprot.writeFieldStop();
        oprot.writeStructEnd();
      }

    }

    private static class statement_cancel_argsTupleSchemeFactory implements SchemeFactory {
      public statement_cancel_argsTupleScheme getScheme() {
        return new statement_cancel_argsTupleScheme();
      }
    }

    private static class statement_cancel_argsTupleScheme extends TupleScheme<statement_cancel_args> {

      @Override
      public void write(org.apache.thrift.protocol.TProtocol prot, statement_cancel_args struct) throws org.apache.thrift.TException {
        TTupleProtocol oprot = (TTupleProtocol) prot;
        BitSet optionals = new BitSet();
        if (struct.isSetStatement()) {
          optionals.set(0);
        }
        oprot.writeBitSet(optionals, 1);
        if (struct.isSetStatement()) {
          struct.statement.write(oprot);
        }
      }

      @Override
      public void read(org.apache.thrift.protocol.TProtocol prot, statement_cancel_args struct) throws org.apache.thrift.TException {
        TTupleProtocol iprot = (TTupleProtocol) prot;
        BitSet incoming = iprot.readBitSet(1);
        if (incoming.get(0)) {
          struct.statement = new RStatement();
          struct.statement.read(iprot);
          struct.setStatementIsSet(true);
        }
      }
    }

  }

  public static class statement_cancel_result implements org.apache.thrift.TBase<statement_cancel_result, statement_cancel_result._Fields>, java.io.Serializable, Cloneable, Comparable<statement_cancel_result>   {
    private static final org.apache.thrift.protocol.TStruct STRUCT_DESC = new org.apache.thrift.protocol.TStruct("statement_cancel_result");

    private static final org.apache.thrift.protocol.TField SQL_EXCEPTION_FIELD_DESC = new org.apache.thrift.protocol.TField("sqlException", org.apache.thrift.protocol.TType.STRUCT, (short)1);

    private static final Map<Class<? extends IScheme>, SchemeFactory> schemes = new HashMap<Class<? extends IScheme>, SchemeFactory>();
    static {
      schemes.put(StandardScheme.class, new statement_cancel_resultStandardSchemeFactory());
      schemes.put(TupleScheme.class, new statement_cancel_resultTupleSchemeFactory());
    }

    public RSQLException sqlException; // required

    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements org.apache.thrift.TFieldIdEnum {
      SQL_EXCEPTION((short)1, "sqlException");

      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        switch(fieldId) {
          case 1: // SQL_EXCEPTION
            return SQL_EXCEPTION;
          default:
            return null;
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }

    // isset id assignments
    public static final Map<_Fields, org.apache.thrift.meta_data.FieldMetaData> metaDataMap;
    static {
      Map<_Fields, org.apache.thrift.meta_data.FieldMetaData> tmpMap = new EnumMap<_Fields, org.apache.thrift.meta_data.FieldMetaData>(_Fields.class);
      tmpMap.put(_Fields.SQL_EXCEPTION, new org.apache.thrift.meta_data.FieldMetaData("sqlException", org.apache.thrift.TFieldRequirementType.DEFAULT, 
          new org.apache.thrift.meta_data.FieldValueMetaData(org.apache.thrift.protocol.TType.STRUCT)));
      metaDataMap = Collections.unmodifiableMap(tmpMap);
      org.apache.thrift.meta_data.FieldMetaData.addStructMetaDataMap(statement_cancel_result.class, metaDataMap);
    }

    public statement_cancel_result() {
    }

    public statement_cancel_result(
      RSQLException sqlException)
    {
      this();
      this.sqlException = sqlException;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public statement_cancel_result(statement_cancel_result other) {
      if (other.isSetSqlException()) {
        this.sqlException = new RSQLException(other.sqlException);
      }
    }

    public statement_cancel_result deepCopy() {
      return new statement_cancel_result(this);
    }

    @Override
    public void clear() {
      this.sqlException = null;
    }

    public RSQLException getSqlException() {
      return this.sqlException;
    }

    public statement_cancel_result setSqlException(RSQLException sqlException) {
      this.sqlException = sqlException;
      return this;
    }

    public void unsetSqlException() {
      this.sqlException = null;
    }

    /** Returns true if field sqlException is set (has been assigned a value) and false otherwise */
    public boolean isSetSqlException() {
      return this.sqlException != null;
    }

    public void setSqlExceptionIsSet(boolean value) {
      if (!value) {
        this.sqlException = null;
      }
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      case SQL_EXCEPTION:
        if (value == null) {
          unsetSqlException();
        } else {
          setSqlException((RSQLException)value);
        }
        break;

      }
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      case SQL_EXCEPTION:
        return getSqlException();

      }
      throw new IllegalStateException();
    }

    /** Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      if (field == null) {
        throw new IllegalArgumentException();
      }

      switch (field) {
      case SQL_EXCEPTION:
        return isSetSqlException();
      }
      throw new IllegalStateException();
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof statement_cancel_result)
        return this.equals((statement_cancel_result)that);
      return false;
    }

    public boolean equals(statement_cancel_result that) {
      if (that == null)
        return false;

      boolean this_present_sqlException = true && this.isSetSqlException();
      boolean that_present_sqlException = true && that.isSetSqlException();
      if (this_present_sqlException || that_present_sqlException) {
        if (!(this_present_sqlException && that_present_sqlException))
          return false;
        if (!this.sqlException.equals(that.sqlException))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      List<Object> list = new ArrayList<Object>();

      boolean present_sqlException = true && (isSetSqlException());
      list.add(present_sqlException);
      if (present_sqlException)
        list.add(sqlException);

      return list.hashCode();
    }

    @Override
    public int compareTo(statement_cancel_result other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetSqlException()).compareTo(other.isSetSqlException());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetSqlException()) {
        lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.sqlException, other.sqlException);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      return 0;
    }

    public _Fields fieldForId(int fieldId) {
      return _Fields.findByThriftId(fieldId);
    }

    public void read(org.apache.thrift.protocol.TProtocol iprot) throws org.apache.thrift.TException {
      schemes.get(iprot.getScheme()).getScheme().read(iprot, this);
    }

    public void write(org.apache.thrift.protocol.TProtocol oprot) throws org.apache.thrift.TException {
      schemes.get(oprot.getScheme()).getScheme().write(oprot, this);
      }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("statement_cancel_result(");
      boolean first = true;

      sb.append("sqlException:");
      if (this.sqlException == null) {
        sb.append("null");
      } else {
        sb.append(this.sqlException);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws org.apache.thrift.TException {
      // check for required fields
      // check for sub-struct validity
    }

    private void writeObject(java.io.ObjectOutputStream out) throws java.io.IOException {
      try {
        write(new org.apache.thrift.protocol.TCompactProtocol(new org.apache.thrift.transport.TIOStreamTransport(out)));
      } catch (org.apache.thrift.TException te) {
        throw new java.io.IOException(te);
      }
    }

    private void readObject(java.io.ObjectInputStream in) throws java.io.IOException, ClassNotFoundException {
      try {
        read(new org.apache.thrift.protocol.TCompactProtocol(new org.apache.thrift.transport.TIOStreamTransport(in)));
      } catch (org.apache.thrift.TException te) {
        throw new java.io.IOException(te);
      }
    }

    private static class statement_cancel_resultStandardSchemeFactory implements SchemeFactory {
      public statement_cancel_resultStandardScheme getScheme() {
        return new statement_cancel_resultStandardScheme();
      }
    }

    private static class statement_cancel_resultStandardScheme extends StandardScheme<statement_cancel_result> {

      public void read(org.apache.thrift.protocol.TProtocol iprot, statement_cancel_result struct) throws org.apache.thrift.TException {
        org.apache.thrift.protocol.TField schemeField;
        iprot.readStructBegin();
        while (true)
        {
          schemeField = iprot.readFieldBegin();
          if (schemeField.type == org.apache.thrift.protocol.TType.STOP) { 
            break;
          }
          switch (schemeField.id) {
            case 1: // SQL_EXCEPTION
              if (schemeField.type == org.apache.thrift.protocol.TType.STRUCT) {
                struct.sqlException = new RSQLException();
                struct.sqlException.read(iprot);
                struct.setSqlExceptionIsSet(true);
              } else { 
                org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
              }
              break;
            default:
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
          }
          iprot.readFieldEnd();
        }
        iprot.readStructEnd();

        // check for required fields of primitive type, which can't be checked in the validate method
        struct.validate();
      }

      public void write(org.apache.thrift.protocol.TProtocol oprot, statement_cancel_result struct) throws org.apache.thrift.TException {
        struct.validate();

        oprot.writeStructBegin(STRUCT_DESC);
        if (struct.sqlException != null) {
          oprot.writeFieldBegin(SQL_EXCEPTION_FIELD_DESC);
          struct.sqlException.write(oprot);
          oprot.writeFieldEnd();
        }
        oprot.writeFieldStop();
        oprot.writeStructEnd();
      }

    }

    private static class statement_cancel_resultTupleSchemeFactory implements SchemeFactory {
      public statement_cancel_resultTupleScheme getScheme() {
        return new statement_cancel_resultTupleScheme();
      }
    }

    private static class statement_cancel_resultTupleScheme extends TupleScheme<statement_cancel_result> {

      @Override
      public void write(org.apache.thrift.protocol.TProtocol prot, statement_cancel_result struct) throws org.apache.thrift.TException {
        TTupleProtocol oprot = (TTupleProtocol) prot;
        BitSet optionals = new BitSet();
        if (struct.isSetSqlException()) {
          optionals.set(0);
        }
        oprot.writeBitSet(optionals, 1);
        if (struct.isSetSqlException()) {
          struct.sqlException.write(oprot);
        }
      }

      @Override
      public void read(org.apache.thrift.protocol.TProtocol prot, statement_cancel_result struct) throws org.apache.thrift.TException {
        TTupleProtocol iprot = (TTupleProtocol) prot;
        BitSet incoming = iprot.readBitSet(1);
        if (incoming.get(0)) {
          struct.sqlException = new RSQLException();
          struct.sqlException.read(iprot);
          struct.setSqlExceptionIsSet(true);
        }
      }
    }

  }

  public static class statement_addBatch_args implements org.apache.thrift.TBase<statement_addBatch_args, statement_addBatch_args._Fields>, java.io.Serializable, Cloneable, Comparable<statement_addBatch_args>   {
    private static final org.apache.thrift.protocol.TStruct STRUCT_DESC = new org.apache.thrift.protocol.TStruct("statement_addBatch_args");

    private static final org.apache.thrift.protocol.TField STATEMENT_FIELD_DESC = new org.apache.thrift.protocol.TField("statement", org.apache.thrift.protocol.TType.STRUCT, (short)1);
    private static final org.apache.thrift.protocol.TField SQL_FIELD_DESC = new org.apache.thrift.protocol.TField("sql", org.apache.thrift.protocol.TType.STRING, (short)2);

    private static final Map<Class<? extends IScheme>, SchemeFactory> schemes = new HashMap<Class<? extends IScheme>, SchemeFactory>();
    static {
      schemes.put(StandardScheme.class, new statement_addBatch_argsStandardSchemeFactory());
      schemes.put(TupleScheme.class, new statement_addBatch_argsTupleSchemeFactory());
    }

    public RStatement statement; // required
    public String sql; // required

    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements org.apache.thrift.TFieldIdEnum {
      STATEMENT((short)1, "statement"),
      SQL((short)2, "sql");

      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        switch(fieldId) {
          case 1: // STATEMENT
            return STATEMENT;
          case 2: // SQL
            return SQL;
          default:
            return null;
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }

    // isset id assignments
    public static final Map<_Fields, org.apache.thrift.meta_data.FieldMetaData> metaDataMap;
    static {
      Map<_Fields, org.apache.thrift.meta_data.FieldMetaData> tmpMap = new EnumMap<_Fields, org.apache.thrift.meta_data.FieldMetaData>(_Fields.class);
      tmpMap.put(_Fields.STATEMENT, new org.apache.thrift.meta_data.FieldMetaData("statement", org.apache.thrift.TFieldRequirementType.DEFAULT, 
          new org.apache.thrift.meta_data.StructMetaData(org.apache.thrift.protocol.TType.STRUCT, RStatement.class)));
      tmpMap.put(_Fields.SQL, new org.apache.thrift.meta_data.FieldMetaData("sql", org.apache.thrift.TFieldRequirementType.DEFAULT, 
          new org.apache.thrift.meta_data.FieldValueMetaData(org.apache.thrift.protocol.TType.STRING)));
      metaDataMap = Collections.unmodifiableMap(tmpMap);
      org.apache.thrift.meta_data.FieldMetaData.addStructMetaDataMap(statement_addBatch_args.class, metaDataMap);
    }

    public statement_addBatch_args() {
    }

    public statement_addBatch_args(
      RStatement statement,
      String sql)
    {
      this();
      this.statement = statement;
      this.sql = sql;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public statement_addBatch_args(statement_addBatch_args other) {
      if (other.isSetStatement()) {
        this.statement = new RStatement(other.statement);
      }
      if (other.isSetSql()) {
        this.sql = other.sql;
      }
    }

    public statement_addBatch_args deepCopy() {
      return new statement_addBatch_args(this);
    }

    @Override
    public void clear() {
      this.statement = null;
      this.sql = null;
    }

    public RStatement getStatement() {
      return this.statement;
    }

    public statement_addBatch_args setStatement(RStatement statement) {
      this.statement = statement;
      return this;
    }

    public void unsetStatement() {
      this.statement = null;
    }

    /** Returns true if field statement is set (has been assigned a value) and false otherwise */
    public boolean isSetStatement() {
      return this.statement != null;
    }

    public void setStatementIsSet(boolean value) {
      if (!value) {
        this.statement = null;
      }
    }

    public String getSql() {
      return this.sql;
    }

    public statement_addBatch_args setSql(String sql) {
      this.sql = sql;
      return this;
    }

    public void unsetSql() {
      this.sql = null;
    }

    /** Returns true if field sql is set (has been assigned a value) and false otherwise */
    public boolean isSetSql() {
      return this.sql != null;
    }

    public void setSqlIsSet(boolean value) {
      if (!value) {
        this.sql = null;
      }
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      case STATEMENT:
        if (value == null) {
          unsetStatement();
        } else {
          setStatement((RStatement)value);
        }
        break;

      case SQL:
        if (value == null) {
          unsetSql();
        } else {
          setSql((String)value);
        }
        break;

      }
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      case STATEMENT:
        return getStatement();

      case SQL:
        return getSql();

      }
      throw new IllegalStateException();
    }

    /** Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      if (field == null) {
        throw new IllegalArgumentException();
      }

      switch (field) {
      case STATEMENT:
        return isSetStatement();
      case SQL:
        return isSetSql();
      }
      throw new IllegalStateException();
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof statement_addBatch_args)
        return this.equals((statement_addBatch_args)that);
      return false;
    }

    public boolean equals(statement_addBatch_args that) {
      if (that == null)
        return false;

      boolean this_present_statement = true && this.isSetStatement();
      boolean that_present_statement = true && that.isSetStatement();
      if (this_present_statement || that_present_statement) {
        if (!(this_present_statement && that_present_statement))
          return false;
        if (!this.statement.equals(that.statement))
          return false;
      }

      boolean this_present_sql = true && this.isSetSql();
      boolean that_present_sql = true && that.isSetSql();
      if (this_present_sql || that_present_sql) {
        if (!(this_present_sql && that_present_sql))
          return false;
        if (!this.sql.equals(that.sql))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      List<Object> list = new ArrayList<Object>();

      boolean present_statement = true && (isSetStatement());
      list.add(present_statement);
      if (present_statement)
        list.add(statement);

      boolean present_sql = true && (isSetSql());
      list.add(present_sql);
      if (present_sql)
        list.add(sql);

      return list.hashCode();
    }

    @Override
    public int compareTo(statement_addBatch_args other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetStatement()).compareTo(other.isSetStatement());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetStatement()) {
        lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.statement, other.statement);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      lastComparison = Boolean.valueOf(isSetSql()).compareTo(other.isSetSql());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetSql()) {
        lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.sql, other.sql);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      return 0;
    }

    public _Fields fieldForId(int fieldId) {
      return _Fields.findByThriftId(fieldId);
    }

    public void read(org.apache.thrift.protocol.TProtocol iprot) throws org.apache.thrift.TException {
      schemes.get(iprot.getScheme()).getScheme().read(iprot, this);
    }

    public void write(org.apache.thrift.protocol.TProtocol oprot) throws org.apache.thrift.TException {
      schemes.get(oprot.getScheme()).getScheme().write(oprot, this);
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("statement_addBatch_args(");
      boolean first = true;

      sb.append("statement:");
      if (this.statement == null) {
        sb.append("null");
      } else {
        sb.append(this.statement);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("sql:");
      if (this.sql == null) {
        sb.append("null");
      } else {
        sb.append(this.sql);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws org.apache.thrift.TException {
      // check for required fields
      // check for sub-struct validity
      if (statement != null) {
        statement.validate();
      }
    }

    private void writeObject(java.io.ObjectOutputStream out) throws java.io.IOException {
      try {
        write(new org.apache.thrift.protocol.TCompactProtocol(new org.apache.thrift.transport.TIOStreamTransport(out)));
      } catch (org.apache.thrift.TException te) {
        throw new java.io.IOException(te);
      }
    }

    private void readObject(java.io.ObjectInputStream in) throws java.io.IOException, ClassNotFoundException {
      try {
        read(new org.apache.thrift.protocol.TCompactProtocol(new org.apache.thrift.transport.TIOStreamTransport(in)));
      } catch (org.apache.thrift.TException te) {
        throw new java.io.IOException(te);
      }
    }

    private static class statement_addBatch_argsStandardSchemeFactory implements SchemeFactory {
      public statement_addBatch_argsStandardScheme getScheme() {
        return new statement_addBatch_argsStandardScheme();
      }
    }

    private static class statement_addBatch_argsStandardScheme extends StandardScheme<statement_addBatch_args> {

      public void read(org.apache.thrift.protocol.TProtocol iprot, statement_addBatch_args struct) throws org.apache.thrift.TException {
        org.apache.thrift.protocol.TField schemeField;
        iprot.readStructBegin();
        while (true)
        {
          schemeField = iprot.readFieldBegin();
          if (schemeField.type == org.apache.thrift.protocol.TType.STOP) { 
            break;
          }
          switch (schemeField.id) {
            case 1: // STATEMENT
              if (schemeField.type == org.apache.thrift.protocol.TType.STRUCT) {
                struct.statement = new RStatement();
                struct.statement.read(iprot);
                struct.setStatementIsSet(true);
              } else { 
                org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
              }
              break;
            case 2: // SQL
              if (schemeField.type == org.apache.thrift.protocol.TType.STRING) {
                struct.sql = iprot.readString();
                struct.setSqlIsSet(true);
              } else { 
                org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
              }
              break;
            default:
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
          }
          iprot.readFieldEnd();
        }
        iprot.readStructEnd();

        // check for required fields of primitive type, which can't be checked in the validate method
        struct.validate();
      }

      public void write(org.apache.thrift.protocol.TProtocol oprot, statement_addBatch_args struct) throws org.apache.thrift.TException {
        struct.validate();

        oprot.writeStructBegin(STRUCT_DESC);
        if (struct.statement != null) {
          oprot.writeFieldBegin(STATEMENT_FIELD_DESC);
          struct.statement.write(oprot);
          oprot.writeFieldEnd();
        }
        if (struct.sql != null) {
          oprot.writeFieldBegin(SQL_FIELD_DESC);
          oprot.writeString(struct.sql);
          oprot.writeFieldEnd();
        }
        oprot.writeFieldStop();
        oprot.writeStructEnd();
      }

    }

    private static class statement_addBatch_argsTupleSchemeFactory implements SchemeFactory {
      public statement_addBatch_argsTupleScheme getScheme() {
        return new statement_addBatch_argsTupleScheme();
      }
    }

    private static class statement_addBatch_argsTupleScheme extends TupleScheme<statement_addBatch_args> {

      @Override
      public void write(org.apache.thrift.protocol.TProtocol prot, statement_addBatch_args struct) throws org.apache.thrift.TException {
        TTupleProtocol oprot = (TTupleProtocol) prot;
        BitSet optionals = new BitSet();
        if (struct.isSetStatement()) {
          optionals.set(0);
        }
        if (struct.isSetSql()) {
          optionals.set(1);
        }
        oprot.writeBitSet(optionals, 2);
        if (struct.isSetStatement()) {
          struct.statement.write(oprot);
        }
        if (struct.isSetSql()) {
          oprot.writeString(struct.sql);
        }
      }

      @Override
      public void read(org.apache.thrift.protocol.TProtocol prot, statement_addBatch_args struct) throws org.apache.thrift.TException {
        TTupleProtocol iprot = (TTupleProtocol) prot;
        BitSet incoming = iprot.readBitSet(2);
        if (incoming.get(0)) {
          struct.statement = new RStatement();
          struct.statement.read(iprot);
          struct.setStatementIsSet(true);
        }
        if (incoming.get(1)) {
          struct.sql = iprot.readString();
          struct.setSqlIsSet(true);
        }
      }
    }

  }

  public static class statement_addBatch_result implements org.apache.thrift.TBase<statement_addBatch_result, statement_addBatch_result._Fields>, java.io.Serializable, Cloneable, Comparable<statement_addBatch_result>   {
    private static final org.apache.thrift.protocol.TStruct STRUCT_DESC = new org.apache.thrift.protocol.TStruct("statement_addBatch_result");

    private static final org.apache.thrift.protocol.TField SQL_EXCEPTION_FIELD_DESC = new org.apache.thrift.protocol.TField("sqlException", org.apache.thrift.protocol.TType.STRUCT, (short)1);

    private static final Map<Class<? extends IScheme>, SchemeFactory> schemes = new HashMap<Class<? extends IScheme>, SchemeFactory>();
    static {
      schemes.put(StandardScheme.class, new statement_addBatch_resultStandardSchemeFactory());
      schemes.put(TupleScheme.class, new statement_addBatch_resultTupleSchemeFactory());
    }

    public RSQLException sqlException; // required

    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements org.apache.thrift.TFieldIdEnum {
      SQL_EXCEPTION((short)1, "sqlException");

      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        switch(fieldId) {
          case 1: // SQL_EXCEPTION
            return SQL_EXCEPTION;
          default:
            return null;
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }

    // isset id assignments
    public static final Map<_Fields, org.apache.thrift.meta_data.FieldMetaData> metaDataMap;
    static {
      Map<_Fields, org.apache.thrift.meta_data.FieldMetaData> tmpMap = new EnumMap<_Fields, org.apache.thrift.meta_data.FieldMetaData>(_Fields.class);
      tmpMap.put(_Fields.SQL_EXCEPTION, new org.apache.thrift.meta_data.FieldMetaData("sqlException", org.apache.thrift.TFieldRequirementType.DEFAULT, 
          new org.apache.thrift.meta_data.FieldValueMetaData(org.apache.thrift.protocol.TType.STRUCT)));
      metaDataMap = Collections.unmodifiableMap(tmpMap);
      org.apache.thrift.meta_data.FieldMetaData.addStructMetaDataMap(statement_addBatch_result.class, metaDataMap);
    }

    public statement_addBatch_result() {
    }

    public statement_addBatch_result(
      RSQLException sqlException)
    {
      this();
      this.sqlException = sqlException;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public statement_addBatch_result(statement_addBatch_result other) {
      if (other.isSetSqlException()) {
        this.sqlException = new RSQLException(other.sqlException);
      }
    }

    public statement_addBatch_result deepCopy() {
      return new statement_addBatch_result(this);
    }

    @Override
    public void clear() {
      this.sqlException = null;
    }

    public RSQLException getSqlException() {
      return this.sqlException;
    }

    public statement_addBatch_result setSqlException(RSQLException sqlException) {
      this.sqlException = sqlException;
      return this;
    }

    public void unsetSqlException() {
      this.sqlException = null;
    }

    /** Returns true if field sqlException is set (has been assigned a value) and false otherwise */
    public boolean isSetSqlException() {
      return this.sqlException != null;
    }

    public void setSqlExceptionIsSet(boolean value) {
      if (!value) {
        this.sqlException = null;
      }
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      case SQL_EXCEPTION:
        if (value == null) {
          unsetSqlException();
        } else {
          setSqlException((RSQLException)value);
        }
        break;

      }
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      case SQL_EXCEPTION:
        return getSqlException();

      }
      throw new IllegalStateException();
    }

    /** Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      if (field == null) {
        throw new IllegalArgumentException();
      }

      switch (field) {
      case SQL_EXCEPTION:
        return isSetSqlException();
      }
      throw new IllegalStateException();
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof statement_addBatch_result)
        return this.equals((statement_addBatch_result)that);
      return false;
    }

    public boolean equals(statement_addBatch_result that) {
      if (that == null)
        return false;

      boolean this_present_sqlException = true && this.isSetSqlException();
      boolean that_present_sqlException = true && that.isSetSqlException();
      if (this_present_sqlException || that_present_sqlException) {
        if (!(this_present_sqlException && that_present_sqlException))
          return false;
        if (!this.sqlException.equals(that.sqlException))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      List<Object> list = new ArrayList<Object>();

      boolean present_sqlException = true && (isSetSqlException());
      list.add(present_sqlException);
      if (present_sqlException)
        list.add(sqlException);

      return list.hashCode();
    }

    @Override
    public int compareTo(statement_addBatch_result other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetSqlException()).compareTo(other.isSetSqlException());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetSqlException()) {
        lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.sqlException, other.sqlException);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      return 0;
    }

    public _Fields fieldForId(int fieldId) {
      return _Fields.findByThriftId(fieldId);
    }

    public void read(org.apache.thrift.protocol.TProtocol iprot) throws org.apache.thrift.TException {
      schemes.get(iprot.getScheme()).getScheme().read(iprot, this);
    }

    public void write(org.apache.thrift.protocol.TProtocol oprot) throws org.apache.thrift.TException {
      schemes.get(oprot.getScheme()).getScheme().write(oprot, this);
      }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("statement_addBatch_result(");
      boolean first = true;

      sb.append("sqlException:");
      if (this.sqlException == null) {
        sb.append("null");
      } else {
        sb.append(this.sqlException);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws org.apache.thrift.TException {
      // check for required fields
      // check for sub-struct validity
    }

    private void writeObject(java.io.ObjectOutputStream out) throws java.io.IOException {
      try {
        write(new org.apache.thrift.protocol.TCompactProtocol(new org.apache.thrift.transport.TIOStreamTransport(out)));
      } catch (org.apache.thrift.TException te) {
        throw new java.io.IOException(te);
      }
    }

    private void readObject(java.io.ObjectInputStream in) throws java.io.IOException, ClassNotFoundException {
      try {
        read(new org.apache.thrift.protocol.TCompactProtocol(new org.apache.thrift.transport.TIOStreamTransport(in)));
      } catch (org.apache.thrift.TException te) {
        throw new java.io.IOException(te);
      }
    }

    private static class statement_addBatch_resultStandardSchemeFactory implements SchemeFactory {
      public statement_addBatch_resultStandardScheme getScheme() {
        return new statement_addBatch_resultStandardScheme();
      }
    }

    private static class statement_addBatch_resultStandardScheme extends StandardScheme<statement_addBatch_result> {

      public void read(org.apache.thrift.protocol.TProtocol iprot, statement_addBatch_result struct) throws org.apache.thrift.TException {
        org.apache.thrift.protocol.TField schemeField;
        iprot.readStructBegin();
        while (true)
        {
          schemeField = iprot.readFieldBegin();
          if (schemeField.type == org.apache.thrift.protocol.TType.STOP) { 
            break;
          }
          switch (schemeField.id) {
            case 1: // SQL_EXCEPTION
              if (schemeField.type == org.apache.thrift.protocol.TType.STRUCT) {
                struct.sqlException = new RSQLException();
                struct.sqlException.read(iprot);
                struct.setSqlExceptionIsSet(true);
              } else { 
                org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
              }
              break;
            default:
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
          }
          iprot.readFieldEnd();
        }
        iprot.readStructEnd();

        // check for required fields of primitive type, which can't be checked in the validate method
        struct.validate();
      }

      public void write(org.apache.thrift.protocol.TProtocol oprot, statement_addBatch_result struct) throws org.apache.thrift.TException {
        struct.validate();

        oprot.writeStructBegin(STRUCT_DESC);
        if (struct.sqlException != null) {
          oprot.writeFieldBegin(SQL_EXCEPTION_FIELD_DESC);
          struct.sqlException.write(oprot);
          oprot.writeFieldEnd();
        }
        oprot.writeFieldStop();
        oprot.writeStructEnd();
      }

    }

    private static class statement_addBatch_resultTupleSchemeFactory implements SchemeFactory {
      public statement_addBatch_resultTupleScheme getScheme() {
        return new statement_addBatch_resultTupleScheme();
      }
    }

    private static class statement_addBatch_resultTupleScheme extends TupleScheme<statement_addBatch_result> {

      @Override
      public void write(org.apache.thrift.protocol.TProtocol prot, statement_addBatch_result struct) throws org.apache.thrift.TException {
        TTupleProtocol oprot = (TTupleProtocol) prot;
        BitSet optionals = new BitSet();
        if (struct.isSetSqlException()) {
          optionals.set(0);
        }
        oprot.writeBitSet(optionals, 1);
        if (struct.isSetSqlException()) {
          struct.sqlException.write(oprot);
        }
      }

      @Override
      public void read(org.apache.thrift.protocol.TProtocol prot, statement_addBatch_result struct) throws org.apache.thrift.TException {
        TTupleProtocol iprot = (TTupleProtocol) prot;
        BitSet incoming = iprot.readBitSet(1);
        if (incoming.get(0)) {
          struct.sqlException = new RSQLException();
          struct.sqlException.read(iprot);
          struct.setSqlExceptionIsSet(true);
        }
      }
    }

  }

  public static class statement_addBatches_args implements org.apache.thrift.TBase<statement_addBatches_args, statement_addBatches_args._Fields>, java.io.Serializable, Cloneable, Comparable<statement_addBatches_args>   {
    private static final org.apache.thrift.protocol.TStruct STRUCT_DESC = new org.apache.thrift.protocol.TStruct("statement_addBatches_args");

    private static final org.apache.thrift.protocol.TField STATEMENT_FIELD_DESC = new org.apache.thrift.protocol.TField("statement", org.apache.thrift.protocol.TType.STRUCT, (short)1);
    private static final org.apache.thrift.protocol.TField SQL_LIST_FIELD_DESC = new org.apache.thrift.protocol.TField("sqlList", org.apache.thrift.protocol.TType.LIST, (short)2);

    private static final Map<Class<? extends IScheme>, SchemeFactory> schemes = new HashMap<Class<? extends IScheme>, SchemeFactory>();
    static {
      schemes.put(StandardScheme.class, new statement_addBatches_argsStandardSchemeFactory());
      schemes.put(TupleScheme.class, new statement_addBatches_argsTupleSchemeFactory());
    }

    public RStatement statement; // required
    public List<String> sqlList; // required

    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements org.apache.thrift.TFieldIdEnum {
      STATEMENT((short)1, "statement"),
      SQL_LIST((short)2, "sqlList");

      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        switch(fieldId) {
          case 1: // STATEMENT
            return STATEMENT;
          case 2: // SQL_LIST
            return SQL_LIST;
          default:
            return null;
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }

    // isset id assignments
    public static final Map<_Fields, org.apache.thrift.meta_data.FieldMetaData> metaDataMap;
    static {
      Map<_Fields, org.apache.thrift.meta_data.FieldMetaData> tmpMap = new EnumMap<_Fields, org.apache.thrift.meta_data.FieldMetaData>(_Fields.class);
      tmpMap.put(_Fields.STATEMENT, new org.apache.thrift.meta_data.FieldMetaData("statement", org.apache.thrift.TFieldRequirementType.DEFAULT, 
          new org.apache.thrift.meta_data.StructMetaData(org.apache.thrift.protocol.TType.STRUCT, RStatement.class)));
      tmpMap.put(_Fields.SQL_LIST, new org.apache.thrift.meta_data.FieldMetaData("sqlList", org.apache.thrift.TFieldRequirementType.DEFAULT, 
          new org.apache.thrift.meta_data.ListMetaData(org.apache.thrift.protocol.TType.LIST, 
              new org.apache.thrift.meta_data.FieldValueMetaData(org.apache.thrift.protocol.TType.STRING))));
      metaDataMap = Collections.unmodifiableMap(tmpMap);
      org.apache.thrift.meta_data.FieldMetaData.addStructMetaDataMap(statement_addBatches_args.class, metaDataMap);
    }

    public statement_addBatches_args() {
    }

    public statement_addBatches_args(
      RStatement statement,
      List<String> sqlList)
    {
      this();
      this.statement = statement;
      this.sqlList = sqlList;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public statement_addBatches_args(statement_addBatches_args other) {
      if (other.isSetStatement()) {
        this.statement = new RStatement(other.statement);
      }
      if (other.isSetSqlList()) {
        List<String> __this__sqlList = new ArrayList<String>(other.sqlList);
        this.sqlList = __this__sqlList;
      }
    }

    public statement_addBatches_args deepCopy() {
      return new statement_addBatches_args(this);
    }

    @Override
    public void clear() {
      this.statement = null;
      this.sqlList = null;
    }

    public RStatement getStatement() {
      return this.statement;
    }

    public statement_addBatches_args setStatement(RStatement statement) {
      this.statement = statement;
      return this;
    }

    public void unsetStatement() {
      this.statement = null;
    }

    /** Returns true if field statement is set (has been assigned a value) and false otherwise */
    public boolean isSetStatement() {
      return this.statement != null;
    }

    public void setStatementIsSet(boolean value) {
      if (!value) {
        this.statement = null;
      }
    }

    public int getSqlListSize() {
      return (this.sqlList == null) ? 0 : this.sqlList.size();
    }

    public java.util.Iterator<String> getSqlListIterator() {
      return (this.sqlList == null) ? null : this.sqlList.iterator();
    }

    public void addToSqlList(String elem) {
      if (this.sqlList == null) {
        this.sqlList = new ArrayList<String>();
      }
      this.sqlList.add(elem);
    }

    public List<String> getSqlList() {
      return this.sqlList;
    }

    public statement_addBatches_args setSqlList(List<String> sqlList) {
      this.sqlList = sqlList;
      return this;
    }

    public void unsetSqlList() {
      this.sqlList = null;
    }

    /** Returns true if field sqlList is set (has been assigned a value) and false otherwise */
    public boolean isSetSqlList() {
      return this.sqlList != null;
    }

    public void setSqlListIsSet(boolean value) {
      if (!value) {
        this.sqlList = null;
      }
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      case STATEMENT:
        if (value == null) {
          unsetStatement();
        } else {
          setStatement((RStatement)value);
        }
        break;

      case SQL_LIST:
        if (value == null) {
          unsetSqlList();
        } else {
          setSqlList((List<String>)value);
        }
        break;

      }
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      case STATEMENT:
        return getStatement();

      case SQL_LIST:
        return getSqlList();

      }
      throw new IllegalStateException();
    }

    /** Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      if (field == null) {
        throw new IllegalArgumentException();
      }

      switch (field) {
      case STATEMENT:
        return isSetStatement();
      case SQL_LIST:
        return isSetSqlList();
      }
      throw new IllegalStateException();
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof statement_addBatches_args)
        return this.equals((statement_addBatches_args)that);
      return false;
    }

    public boolean equals(statement_addBatches_args that) {
      if (that == null)
        return false;

      boolean this_present_statement = true && this.isSetStatement();
      boolean that_present_statement = true && that.isSetStatement();
      if (this_present_statement || that_present_statement) {
        if (!(this_present_statement && that_present_statement))
          return false;
        if (!this.statement.equals(that.statement))
          return false;
      }

      boolean this_present_sqlList = true && this.isSetSqlList();
      boolean that_present_sqlList = true && that.isSetSqlList();
      if (this_present_sqlList || that_present_sqlList) {
        if (!(this_present_sqlList && that_present_sqlList))
          return false;
        if (!this.sqlList.equals(that.sqlList))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      List<Object> list = new ArrayList<Object>();

      boolean present_statement = true && (isSetStatement());
      list.add(present_statement);
      if (present_statement)
        list.add(statement);

      boolean present_sqlList = true && (isSetSqlList());
      list.add(present_sqlList);
      if (present_sqlList)
        list.add(sqlList);

      return list.hashCode();
    }

    @Override
    public int compareTo(statement_addBatches_args other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetStatement()).compareTo(other.isSetStatement());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetStatement()) {
        lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.statement, other.statement);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      lastComparison = Boolean.valueOf(isSetSqlList()).compareTo(other.isSetSqlList());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetSqlList()) {
        lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.sqlList, other.sqlList);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      return 0;
    }

    public _Fields fieldForId(int fieldId) {
      return _Fields.findByThriftId(fieldId);
    }

    public void read(org.apache.thrift.protocol.TProtocol iprot) throws org.apache.thrift.TException {
      schemes.get(iprot.getScheme()).getScheme().read(iprot, this);
    }

    public void write(org.apache.thrift.protocol.TProtocol oprot) throws org.apache.thrift.TException {
      schemes.get(oprot.getScheme()).getScheme().write(oprot, this);
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("statement_addBatches_args(");
      boolean first = true;

      sb.append("statement:");
      if (this.statement == null) {
        sb.append("null");
      } else {
        sb.append(this.statement);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("sqlList:");
      if (this.sqlList == null) {
        sb.append("null");
      } else {
        sb.append(this.sqlList);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws org.apache.thrift.TException {
      // check for required fields
      // check for sub-struct validity
      if (statement != null) {
        statement.validate();
      }
    }

    private void writeObject(java.io.ObjectOutputStream out) throws java.io.IOException {
      try {
        write(new org.apache.thrift.protocol.TCompactProtocol(new org.apache.thrift.transport.TIOStreamTransport(out)));
      } catch (org.apache.thrift.TException te) {
        throw new java.io.IOException(te);
      }
    }

    private void readObject(java.io.ObjectInputStream in) throws java.io.IOException, ClassNotFoundException {
      try {
        read(new org.apache.thrift.protocol.TCompactProtocol(new org.apache.thrift.transport.TIOStreamTransport(in)));
      } catch (org.apache.thrift.TException te) {
        throw new java.io.IOException(te);
      }
    }

    private static class statement_addBatches_argsStandardSchemeFactory implements SchemeFactory {
      public statement_addBatches_argsStandardScheme getScheme() {
        return new statement_addBatches_argsStandardScheme();
      }
    }

    private static class statement_addBatches_argsStandardScheme extends StandardScheme<statement_addBatches_args> {

      public void read(org.apache.thrift.protocol.TProtocol iprot, statement_addBatches_args struct) throws org.apache.thrift.TException {
        org.apache.thrift.protocol.TField schemeField;
        iprot.readStructBegin();
        while (true)
        {
          schemeField = iprot.readFieldBegin();
          if (schemeField.type == org.apache.thrift.protocol.TType.STOP) { 
            break;
          }
          switch (schemeField.id) {
            case 1: // STATEMENT
              if (schemeField.type == org.apache.thrift.protocol.TType.STRUCT) {
                struct.statement = new RStatement();
                struct.statement.read(iprot);
                struct.setStatementIsSet(true);
              } else { 
                org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
              }
              break;
            case 2: // SQL_LIST
              if (schemeField.type == org.apache.thrift.protocol.TType.LIST) {
                {
                  org.apache.thrift.protocol.TList _list58 = iprot.readListBegin();
                  struct.sqlList = new ArrayList<String>(_list58.size);
                  String _elem59;
                  for (int _i60 = 0; _i60 < _list58.size; ++_i60)
                  {
                    _elem59 = iprot.readString();
                    struct.sqlList.add(_elem59);
                  }
                  iprot.readListEnd();
                }
                struct.setSqlListIsSet(true);
              } else { 
                org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
              }
              break;
            default:
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
          }
          iprot.readFieldEnd();
        }
        iprot.readStructEnd();

        // check for required fields of primitive type, which can't be checked in the validate method
        struct.validate();
      }

      public void write(org.apache.thrift.protocol.TProtocol oprot, statement_addBatches_args struct) throws org.apache.thrift.TException {
        struct.validate();

        oprot.writeStructBegin(STRUCT_DESC);
        if (struct.statement != null) {
          oprot.writeFieldBegin(STATEMENT_FIELD_DESC);
          struct.statement.write(oprot);
          oprot.writeFieldEnd();
        }
        if (struct.sqlList != null) {
          oprot.writeFieldBegin(SQL_LIST_FIELD_DESC);
          {
            oprot.writeListBegin(new org.apache.thrift.protocol.TList(org.apache.thrift.protocol.TType.STRING, struct.sqlList.size()));
            for (String _iter61 : struct.sqlList)
            {
              oprot.writeString(_iter61);
            }
            oprot.writeListEnd();
          }
          oprot.writeFieldEnd();
        }
        oprot.writeFieldStop();
        oprot.writeStructEnd();
      }

    }

    private static class statement_addBatches_argsTupleSchemeFactory implements SchemeFactory {
      public statement_addBatches_argsTupleScheme getScheme() {
        return new statement_addBatches_argsTupleScheme();
      }
    }

    private static class statement_addBatches_argsTupleScheme extends TupleScheme<statement_addBatches_args> {

      @Override
      public void write(org.apache.thrift.protocol.TProtocol prot, statement_addBatches_args struct) throws org.apache.thrift.TException {
        TTupleProtocol oprot = (TTupleProtocol) prot;
        BitSet optionals = new BitSet();
        if (struct.isSetStatement()) {
          optionals.set(0);
        }
        if (struct.isSetSqlList()) {
          optionals.set(1);
        }
        oprot.writeBitSet(optionals, 2);
        if (struct.isSetStatement()) {
          struct.statement.write(oprot);
        }
        if (struct.isSetSqlList()) {
          {
            oprot.writeI32(struct.sqlList.size());
            for (String _iter62 : struct.sqlList)
            {
              oprot.writeString(_iter62);
            }
          }
        }
      }

      @Override
      public void read(org.apache.thrift.protocol.TProtocol prot, statement_addBatches_args struct) throws org.apache.thrift.TException {
        TTupleProtocol iprot = (TTupleProtocol) prot;
        BitSet incoming = iprot.readBitSet(2);
        if (incoming.get(0)) {
          struct.statement = new RStatement();
          struct.statement.read(iprot);
          struct.setStatementIsSet(true);
        }
        if (incoming.get(1)) {
          {
            org.apache.thrift.protocol.TList _list63 = new org.apache.thrift.protocol.TList(org.apache.thrift.protocol.TType.STRING, iprot.readI32());
            struct.sqlList = new ArrayList<String>(_list63.size);
            String _elem64;
            for (int _i65 = 0; _i65 < _list63.size; ++_i65)
            {
              _elem64 = iprot.readString();
              struct.sqlList.add(_elem64);
            }
          }
          struct.setSqlListIsSet(true);
        }
      }
    }

  }

  public static class statement_addBatches_result implements org.apache.thrift.TBase<statement_addBatches_result, statement_addBatches_result._Fields>, java.io.Serializable, Cloneable, Comparable<statement_addBatches_result>   {
    private static final org.apache.thrift.protocol.TStruct STRUCT_DESC = new org.apache.thrift.protocol.TStruct("statement_addBatches_result");

    private static final org.apache.thrift.protocol.TField SQL_EXCEPTION_FIELD_DESC = new org.apache.thrift.protocol.TField("sqlException", org.apache.thrift.protocol.TType.STRUCT, (short)1);

    private static final Map<Class<? extends IScheme>, SchemeFactory> schemes = new HashMap<Class<? extends IScheme>, SchemeFactory>();
    static {
      schemes.put(StandardScheme.class, new statement_addBatches_resultStandardSchemeFactory());
      schemes.put(TupleScheme.class, new statement_addBatches_resultTupleSchemeFactory());
    }

    public RSQLException sqlException; // required

    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements org.apache.thrift.TFieldIdEnum {
      SQL_EXCEPTION((short)1, "sqlException");

      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        switch(fieldId) {
          case 1: // SQL_EXCEPTION
            return SQL_EXCEPTION;
          default:
            return null;
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }

    // isset id assignments
    public static final Map<_Fields, org.apache.thrift.meta_data.FieldMetaData> metaDataMap;
    static {
      Map<_Fields, org.apache.thrift.meta_data.FieldMetaData> tmpMap = new EnumMap<_Fields, org.apache.thrift.meta_data.FieldMetaData>(_Fields.class);
      tmpMap.put(_Fields.SQL_EXCEPTION, new org.apache.thrift.meta_data.FieldMetaData("sqlException", org.apache.thrift.TFieldRequirementType.DEFAULT, 
          new org.apache.thrift.meta_data.FieldValueMetaData(org.apache.thrift.protocol.TType.STRUCT)));
      metaDataMap = Collections.unmodifiableMap(tmpMap);
      org.apache.thrift.meta_data.FieldMetaData.addStructMetaDataMap(statement_addBatches_result.class, metaDataMap);
    }

    public statement_addBatches_result() {
    }

    public statement_addBatches_result(
      RSQLException sqlException)
    {
      this();
      this.sqlException = sqlException;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public statement_addBatches_result(statement_addBatches_result other) {
      if (other.isSetSqlException()) {
        this.sqlException = new RSQLException(other.sqlException);
      }
    }

    public statement_addBatches_result deepCopy() {
      return new statement_addBatches_result(this);
    }

    @Override
    public void clear() {
      this.sqlException = null;
    }

    public RSQLException getSqlException() {
      return this.sqlException;
    }

    public statement_addBatches_result setSqlException(RSQLException sqlException) {
      this.sqlException = sqlException;
      return this;
    }

    public void unsetSqlException() {
      this.sqlException = null;
    }

    /** Returns true if field sqlException is set (has been assigned a value) and false otherwise */
    public boolean isSetSqlException() {
      return this.sqlException != null;
    }

    public void setSqlExceptionIsSet(boolean value) {
      if (!value) {
        this.sqlException = null;
      }
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      case SQL_EXCEPTION:
        if (value == null) {
          unsetSqlException();
        } else {
          setSqlException((RSQLException)value);
        }
        break;

      }
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      case SQL_EXCEPTION:
        return getSqlException();

      }
      throw new IllegalStateException();
    }

    /** Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      if (field == null) {
        throw new IllegalArgumentException();
      }

      switch (field) {
      case SQL_EXCEPTION:
        return isSetSqlException();
      }
      throw new IllegalStateException();
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof statement_addBatches_result)
        return this.equals((statement_addBatches_result)that);
      return false;
    }

    public boolean equals(statement_addBatches_result that) {
      if (that == null)
        return false;

      boolean this_present_sqlException = true && this.isSetSqlException();
      boolean that_present_sqlException = true && that.isSetSqlException();
      if (this_present_sqlException || that_present_sqlException) {
        if (!(this_present_sqlException && that_present_sqlException))
          return false;
        if (!this.sqlException.equals(that.sqlException))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      List<Object> list = new ArrayList<Object>();

      boolean present_sqlException = true && (isSetSqlException());
      list.add(present_sqlException);
      if (present_sqlException)
        list.add(sqlException);

      return list.hashCode();
    }

    @Override
    public int compareTo(statement_addBatches_result other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetSqlException()).compareTo(other.isSetSqlException());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetSqlException()) {
        lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.sqlException, other.sqlException);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      return 0;
    }

    public _Fields fieldForId(int fieldId) {
      return _Fields.findByThriftId(fieldId);
    }

    public void read(org.apache.thrift.protocol.TProtocol iprot) throws org.apache.thrift.TException {
      schemes.get(iprot.getScheme()).getScheme().read(iprot, this);
    }

    public void write(org.apache.thrift.protocol.TProtocol oprot) throws org.apache.thrift.TException {
      schemes.get(oprot.getScheme()).getScheme().write(oprot, this);
      }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("statement_addBatches_result(");
      boolean first = true;

      sb.append("sqlException:");
      if (this.sqlException == null) {
        sb.append("null");
      } else {
        sb.append(this.sqlException);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws org.apache.thrift.TException {
      // check for required fields
      // check for sub-struct validity
    }

    private void writeObject(java.io.ObjectOutputStream out) throws java.io.IOException {
      try {
        write(new org.apache.thrift.protocol.TCompactProtocol(new org.apache.thrift.transport.TIOStreamTransport(out)));
      } catch (org.apache.thrift.TException te) {
        throw new java.io.IOException(te);
      }
    }

    private void readObject(java.io.ObjectInputStream in) throws java.io.IOException, ClassNotFoundException {
      try {
        read(new org.apache.thrift.protocol.TCompactProtocol(new org.apache.thrift.transport.TIOStreamTransport(in)));
      } catch (org.apache.thrift.TException te) {
        throw new java.io.IOException(te);
      }
    }

    private static class statement_addBatches_resultStandardSchemeFactory implements SchemeFactory {
      public statement_addBatches_resultStandardScheme getScheme() {
        return new statement_addBatches_resultStandardScheme();
      }
    }

    private static class statement_addBatches_resultStandardScheme extends StandardScheme<statement_addBatches_result> {

      public void read(org.apache.thrift.protocol.TProtocol iprot, statement_addBatches_result struct) throws org.apache.thrift.TException {
        org.apache.thrift.protocol.TField schemeField;
        iprot.readStructBegin();
        while (true)
        {
          schemeField = iprot.readFieldBegin();
          if (schemeField.type == org.apache.thrift.protocol.TType.STOP) { 
            break;
          }
          switch (schemeField.id) {
            case 1: // SQL_EXCEPTION
              if (schemeField.type == org.apache.thrift.protocol.TType.STRUCT) {
                struct.sqlException = new RSQLException();
                struct.sqlException.read(iprot);
                struct.setSqlExceptionIsSet(true);
              } else { 
                org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
              }
              break;
            default:
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
          }
          iprot.readFieldEnd();
        }
        iprot.readStructEnd();

        // check for required fields of primitive type, which can't be checked in the validate method
        struct.validate();
      }

      public void write(org.apache.thrift.protocol.TProtocol oprot, statement_addBatches_result struct) throws org.apache.thrift.TException {
        struct.validate();

        oprot.writeStructBegin(STRUCT_DESC);
        if (struct.sqlException != null) {
          oprot.writeFieldBegin(SQL_EXCEPTION_FIELD_DESC);
          struct.sqlException.write(oprot);
          oprot.writeFieldEnd();
        }
        oprot.writeFieldStop();
        oprot.writeStructEnd();
      }

    }

    private static class statement_addBatches_resultTupleSchemeFactory implements SchemeFactory {
      public statement_addBatches_resultTupleScheme getScheme() {
        return new statement_addBatches_resultTupleScheme();
      }
    }

    private static class statement_addBatches_resultTupleScheme extends TupleScheme<statement_addBatches_result> {

      @Override
      public void write(org.apache.thrift.protocol.TProtocol prot, statement_addBatches_result struct) throws org.apache.thrift.TException {
        TTupleProtocol oprot = (TTupleProtocol) prot;
        BitSet optionals = new BitSet();
        if (struct.isSetSqlException()) {
          optionals.set(0);
        }
        oprot.writeBitSet(optionals, 1);
        if (struct.isSetSqlException()) {
          struct.sqlException.write(oprot);
        }
      }

      @Override
      public void read(org.apache.thrift.protocol.TProtocol prot, statement_addBatches_result struct) throws org.apache.thrift.TException {
        TTupleProtocol iprot = (TTupleProtocol) prot;
        BitSet incoming = iprot.readBitSet(1);
        if (incoming.get(0)) {
          struct.sqlException = new RSQLException();
          struct.sqlException.read(iprot);
          struct.setSqlExceptionIsSet(true);
        }
      }
    }

  }

  public static class statement_clearBatch_args implements org.apache.thrift.TBase<statement_clearBatch_args, statement_clearBatch_args._Fields>, java.io.Serializable, Cloneable, Comparable<statement_clearBatch_args>   {
    private static final org.apache.thrift.protocol.TStruct STRUCT_DESC = new org.apache.thrift.protocol.TStruct("statement_clearBatch_args");

    private static final org.apache.thrift.protocol.TField STATEMENT_FIELD_DESC = new org.apache.thrift.protocol.TField("statement", org.apache.thrift.protocol.TType.STRUCT, (short)1);

    private static final Map<Class<? extends IScheme>, SchemeFactory> schemes = new HashMap<Class<? extends IScheme>, SchemeFactory>();
    static {
      schemes.put(StandardScheme.class, new statement_clearBatch_argsStandardSchemeFactory());
      schemes.put(TupleScheme.class, new statement_clearBatch_argsTupleSchemeFactory());
    }

    public RStatement statement; // required

    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements org.apache.thrift.TFieldIdEnum {
      STATEMENT((short)1, "statement");

      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        switch(fieldId) {
          case 1: // STATEMENT
            return STATEMENT;
          default:
            return null;
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }

    // isset id assignments
    public static final Map<_Fields, org.apache.thrift.meta_data.FieldMetaData> metaDataMap;
    static {
      Map<_Fields, org.apache.thrift.meta_data.FieldMetaData> tmpMap = new EnumMap<_Fields, org.apache.thrift.meta_data.FieldMetaData>(_Fields.class);
      tmpMap.put(_Fields.STATEMENT, new org.apache.thrift.meta_data.FieldMetaData("statement", org.apache.thrift.TFieldRequirementType.DEFAULT, 
          new org.apache.thrift.meta_data.StructMetaData(org.apache.thrift.protocol.TType.STRUCT, RStatement.class)));
      metaDataMap = Collections.unmodifiableMap(tmpMap);
      org.apache.thrift.meta_data.FieldMetaData.addStructMetaDataMap(statement_clearBatch_args.class, metaDataMap);
    }

    public statement_clearBatch_args() {
    }

    public statement_clearBatch_args(
      RStatement statement)
    {
      this();
      this.statement = statement;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public statement_clearBatch_args(statement_clearBatch_args other) {
      if (other.isSetStatement()) {
        this.statement = new RStatement(other.statement);
      }
    }

    public statement_clearBatch_args deepCopy() {
      return new statement_clearBatch_args(this);
    }

    @Override
    public void clear() {
      this.statement = null;
    }

    public RStatement getStatement() {
      return this.statement;
    }

    public statement_clearBatch_args setStatement(RStatement statement) {
      this.statement = statement;
      return this;
    }

    public void unsetStatement() {
      this.statement = null;
    }

    /** Returns true if field statement is set (has been assigned a value) and false otherwise */
    public boolean isSetStatement() {
      return this.statement != null;
    }

    public void setStatementIsSet(boolean value) {
      if (!value) {
        this.statement = null;
      }
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      case STATEMENT:
        if (value == null) {
          unsetStatement();
        } else {
          setStatement((RStatement)value);
        }
        break;

      }
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      case STATEMENT:
        return getStatement();

      }
      throw new IllegalStateException();
    }

    /** Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      if (field == null) {
        throw new IllegalArgumentException();
      }

      switch (field) {
      case STATEMENT:
        return isSetStatement();
      }
      throw new IllegalStateException();
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof statement_clearBatch_args)
        return this.equals((statement_clearBatch_args)that);
      return false;
    }

    public boolean equals(statement_clearBatch_args that) {
      if (that == null)
        return false;

      boolean this_present_statement = true && this.isSetStatement();
      boolean that_present_statement = true && that.isSetStatement();
      if (this_present_statement || that_present_statement) {
        if (!(this_present_statement && that_present_statement))
          return false;
        if (!this.statement.equals(that.statement))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      List<Object> list = new ArrayList<Object>();

      boolean present_statement = true && (isSetStatement());
      list.add(present_statement);
      if (present_statement)
        list.add(statement);

      return list.hashCode();
    }

    @Override
    public int compareTo(statement_clearBatch_args other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetStatement()).compareTo(other.isSetStatement());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetStatement()) {
        lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.statement, other.statement);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      return 0;
    }

    public _Fields fieldForId(int fieldId) {
      return _Fields.findByThriftId(fieldId);
    }

    public void read(org.apache.thrift.protocol.TProtocol iprot) throws org.apache.thrift.TException {
      schemes.get(iprot.getScheme()).getScheme().read(iprot, this);
    }

    public void write(org.apache.thrift.protocol.TProtocol oprot) throws org.apache.thrift.TException {
      schemes.get(oprot.getScheme()).getScheme().write(oprot, this);
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("statement_clearBatch_args(");
      boolean first = true;

      sb.append("statement:");
      if (this.statement == null) {
        sb.append("null");
      } else {
        sb.append(this.statement);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws org.apache.thrift.TException {
      // check for required fields
      // check for sub-struct validity
      if (statement != null) {
        statement.validate();
      }
    }

    private void writeObject(java.io.ObjectOutputStream out) throws java.io.IOException {
      try {
        write(new org.apache.thrift.protocol.TCompactProtocol(new org.apache.thrift.transport.TIOStreamTransport(out)));
      } catch (org.apache.thrift.TException te) {
        throw new java.io.IOException(te);
      }
    }

    private void readObject(java.io.ObjectInputStream in) throws java.io.IOException, ClassNotFoundException {
      try {
        read(new org.apache.thrift.protocol.TCompactProtocol(new org.apache.thrift.transport.TIOStreamTransport(in)));
      } catch (org.apache.thrift.TException te) {
        throw new java.io.IOException(te);
      }
    }

    private static class statement_clearBatch_argsStandardSchemeFactory implements SchemeFactory {
      public statement_clearBatch_argsStandardScheme getScheme() {
        return new statement_clearBatch_argsStandardScheme();
      }
    }

    private static class statement_clearBatch_argsStandardScheme extends StandardScheme<statement_clearBatch_args> {

      public void read(org.apache.thrift.protocol.TProtocol iprot, statement_clearBatch_args struct) throws org.apache.thrift.TException {
        org.apache.thrift.protocol.TField schemeField;
        iprot.readStructBegin();
        while (true)
        {
          schemeField = iprot.readFieldBegin();
          if (schemeField.type == org.apache.thrift.protocol.TType.STOP) { 
            break;
          }
          switch (schemeField.id) {
            case 1: // STATEMENT
              if (schemeField.type == org.apache.thrift.protocol.TType.STRUCT) {
                struct.statement = new RStatement();
                struct.statement.read(iprot);
                struct.setStatementIsSet(true);
              } else { 
                org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
              }
              break;
            default:
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
          }
          iprot.readFieldEnd();
        }
        iprot.readStructEnd();

        // check for required fields of primitive type, which can't be checked in the validate method
        struct.validate();
      }

      public void write(org.apache.thrift.protocol.TProtocol oprot, statement_clearBatch_args struct) throws org.apache.thrift.TException {
        struct.validate();

        oprot.writeStructBegin(STRUCT_DESC);
        if (struct.statement != null) {
          oprot.writeFieldBegin(STATEMENT_FIELD_DESC);
          struct.statement.write(oprot);
          oprot.writeFieldEnd();
        }
        oprot.writeFieldStop();
        oprot.writeStructEnd();
      }

    }

    private static class statement_clearBatch_argsTupleSchemeFactory implements SchemeFactory {
      public statement_clearBatch_argsTupleScheme getScheme() {
        return new statement_clearBatch_argsTupleScheme();
      }
    }

    private static class statement_clearBatch_argsTupleScheme extends TupleScheme<statement_clearBatch_args> {

      @Override
      public void write(org.apache.thrift.protocol.TProtocol prot, statement_clearBatch_args struct) throws org.apache.thrift.TException {
        TTupleProtocol oprot = (TTupleProtocol) prot;
        BitSet optionals = new BitSet();
        if (struct.isSetStatement()) {
          optionals.set(0);
        }
        oprot.writeBitSet(optionals, 1);
        if (struct.isSetStatement()) {
          struct.statement.write(oprot);
        }
      }

      @Override
      public void read(org.apache.thrift.protocol.TProtocol prot, statement_clearBatch_args struct) throws org.apache.thrift.TException {
        TTupleProtocol iprot = (TTupleProtocol) prot;
        BitSet incoming = iprot.readBitSet(1);
        if (incoming.get(0)) {
          struct.statement = new RStatement();
          struct.statement.read(iprot);
          struct.setStatementIsSet(true);
        }
      }
    }

  }

  public static class statement_clearBatch_result implements org.apache.thrift.TBase<statement_clearBatch_result, statement_clearBatch_result._Fields>, java.io.Serializable, Cloneable, Comparable<statement_clearBatch_result>   {
    private static final org.apache.thrift.protocol.TStruct STRUCT_DESC = new org.apache.thrift.protocol.TStruct("statement_clearBatch_result");

    private static final org.apache.thrift.protocol.TField SQL_EXCEPTION_FIELD_DESC = new org.apache.thrift.protocol.TField("sqlException", org.apache.thrift.protocol.TType.STRUCT, (short)1);

    private static final Map<Class<? extends IScheme>, SchemeFactory> schemes = new HashMap<Class<? extends IScheme>, SchemeFactory>();
    static {
      schemes.put(StandardScheme.class, new statement_clearBatch_resultStandardSchemeFactory());
      schemes.put(TupleScheme.class, new statement_clearBatch_resultTupleSchemeFactory());
    }

    public RSQLException sqlException; // required

    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements org.apache.thrift.TFieldIdEnum {
      SQL_EXCEPTION((short)1, "sqlException");

      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        switch(fieldId) {
          case 1: // SQL_EXCEPTION
            return SQL_EXCEPTION;
          default:
            return null;
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }

    // isset id assignments
    public static final Map<_Fields, org.apache.thrift.meta_data.FieldMetaData> metaDataMap;
    static {
      Map<_Fields, org.apache.thrift.meta_data.FieldMetaData> tmpMap = new EnumMap<_Fields, org.apache.thrift.meta_data.FieldMetaData>(_Fields.class);
      tmpMap.put(_Fields.SQL_EXCEPTION, new org.apache.thrift.meta_data.FieldMetaData("sqlException", org.apache.thrift.TFieldRequirementType.DEFAULT, 
          new org.apache.thrift.meta_data.FieldValueMetaData(org.apache.thrift.protocol.TType.STRUCT)));
      metaDataMap = Collections.unmodifiableMap(tmpMap);
      org.apache.thrift.meta_data.FieldMetaData.addStructMetaDataMap(statement_clearBatch_result.class, metaDataMap);
    }

    public statement_clearBatch_result() {
    }

    public statement_clearBatch_result(
      RSQLException sqlException)
    {
      this();
      this.sqlException = sqlException;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public statement_clearBatch_result(statement_clearBatch_result other) {
      if (other.isSetSqlException()) {
        this.sqlException = new RSQLException(other.sqlException);
      }
    }

    public statement_clearBatch_result deepCopy() {
      return new statement_clearBatch_result(this);
    }

    @Override
    public void clear() {
      this.sqlException = null;
    }

    public RSQLException getSqlException() {
      return this.sqlException;
    }

    public statement_clearBatch_result setSqlException(RSQLException sqlException) {
      this.sqlException = sqlException;
      return this;
    }

    public void unsetSqlException() {
      this.sqlException = null;
    }

    /** Returns true if field sqlException is set (has been assigned a value) and false otherwise */
    public boolean isSetSqlException() {
      return this.sqlException != null;
    }

    public void setSqlExceptionIsSet(boolean value) {
      if (!value) {
        this.sqlException = null;
      }
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      case SQL_EXCEPTION:
        if (value == null) {
          unsetSqlException();
        } else {
          setSqlException((RSQLException)value);
        }
        break;

      }
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      case SQL_EXCEPTION:
        return getSqlException();

      }
      throw new IllegalStateException();
    }

    /** Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      if (field == null) {
        throw new IllegalArgumentException();
      }

      switch (field) {
      case SQL_EXCEPTION:
        return isSetSqlException();
      }
      throw new IllegalStateException();
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof statement_clearBatch_result)
        return this.equals((statement_clearBatch_result)that);
      return false;
    }

    public boolean equals(statement_clearBatch_result that) {
      if (that == null)
        return false;

      boolean this_present_sqlException = true && this.isSetSqlException();
      boolean that_present_sqlException = true && that.isSetSqlException();
      if (this_present_sqlException || that_present_sqlException) {
        if (!(this_present_sqlException && that_present_sqlException))
          return false;
        if (!this.sqlException.equals(that.sqlException))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      List<Object> list = new ArrayList<Object>();

      boolean present_sqlException = true && (isSetSqlException());
      list.add(present_sqlException);
      if (present_sqlException)
        list.add(sqlException);

      return list.hashCode();
    }

    @Override
    public int compareTo(statement_clearBatch_result other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetSqlException()).compareTo(other.isSetSqlException());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetSqlException()) {
        lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.sqlException, other.sqlException);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      return 0;
    }

    public _Fields fieldForId(int fieldId) {
      return _Fields.findByThriftId(fieldId);
    }

    public void read(org.apache.thrift.protocol.TProtocol iprot) throws org.apache.thrift.TException {
      schemes.get(iprot.getScheme()).getScheme().read(iprot, this);
    }

    public void write(org.apache.thrift.protocol.TProtocol oprot) throws org.apache.thrift.TException {
      schemes.get(oprot.getScheme()).getScheme().write(oprot, this);
      }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("statement_clearBatch_result(");
      boolean first = true;

      sb.append("sqlException:");
      if (this.sqlException == null) {
        sb.append("null");
      } else {
        sb.append(this.sqlException);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws org.apache.thrift.TException {
      // check for required fields
      // check for sub-struct validity
    }

    private void writeObject(java.io.ObjectOutputStream out) throws java.io.IOException {
      try {
        write(new org.apache.thrift.protocol.TCompactProtocol(new org.apache.thrift.transport.TIOStreamTransport(out)));
      } catch (org.apache.thrift.TException te) {
        throw new java.io.IOException(te);
      }
    }

    private void readObject(java.io.ObjectInputStream in) throws java.io.IOException, ClassNotFoundException {
      try {
        read(new org.apache.thrift.protocol.TCompactProtocol(new org.apache.thrift.transport.TIOStreamTransport(in)));
      } catch (org.apache.thrift.TException te) {
        throw new java.io.IOException(te);
      }
    }

    private static class statement_clearBatch_resultStandardSchemeFactory implements SchemeFactory {
      public statement_clearBatch_resultStandardScheme getScheme() {
        return new statement_clearBatch_resultStandardScheme();
      }
    }

    private static class statement_clearBatch_resultStandardScheme extends StandardScheme<statement_clearBatch_result> {

      public void read(org.apache.thrift.protocol.TProtocol iprot, statement_clearBatch_result struct) throws org.apache.thrift.TException {
        org.apache.thrift.protocol.TField schemeField;
        iprot.readStructBegin();
        while (true)
        {
          schemeField = iprot.readFieldBegin();
          if (schemeField.type == org.apache.thrift.protocol.TType.STOP) { 
            break;
          }
          switch (schemeField.id) {
            case 1: // SQL_EXCEPTION
              if (schemeField.type == org.apache.thrift.protocol.TType.STRUCT) {
                struct.sqlException = new RSQLException();
                struct.sqlException.read(iprot);
                struct.setSqlExceptionIsSet(true);
              } else { 
                org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
              }
              break;
            default:
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
          }
          iprot.readFieldEnd();
        }
        iprot.readStructEnd();

        // check for required fields of primitive type, which can't be checked in the validate method
        struct.validate();
      }

      public void write(org.apache.thrift.protocol.TProtocol oprot, statement_clearBatch_result struct) throws org.apache.thrift.TException {
        struct.validate();

        oprot.writeStructBegin(STRUCT_DESC);
        if (struct.sqlException != null) {
          oprot.writeFieldBegin(SQL_EXCEPTION_FIELD_DESC);
          struct.sqlException.write(oprot);
          oprot.writeFieldEnd();
        }
        oprot.writeFieldStop();
        oprot.writeStructEnd();
      }

    }

    private static class statement_clearBatch_resultTupleSchemeFactory implements SchemeFactory {
      public statement_clearBatch_resultTupleScheme getScheme() {
        return new statement_clearBatch_resultTupleScheme();
      }
    }

    private static class statement_clearBatch_resultTupleScheme extends TupleScheme<statement_clearBatch_result> {

      @Override
      public void write(org.apache.thrift.protocol.TProtocol prot, statement_clearBatch_result struct) throws org.apache.thrift.TException {
        TTupleProtocol oprot = (TTupleProtocol) prot;
        BitSet optionals = new BitSet();
        if (struct.isSetSqlException()) {
          optionals.set(0);
        }
        oprot.writeBitSet(optionals, 1);
        if (struct.isSetSqlException()) {
          struct.sqlException.write(oprot);
        }
      }

      @Override
      public void read(org.apache.thrift.protocol.TProtocol prot, statement_clearBatch_result struct) throws org.apache.thrift.TException {
        TTupleProtocol iprot = (TTupleProtocol) prot;
        BitSet incoming = iprot.readBitSet(1);
        if (incoming.get(0)) {
          struct.sqlException = new RSQLException();
          struct.sqlException.read(iprot);
          struct.setSqlExceptionIsSet(true);
        }
      }
    }

  }

  public static class statement_executeBatch_args implements org.apache.thrift.TBase<statement_executeBatch_args, statement_executeBatch_args._Fields>, java.io.Serializable, Cloneable, Comparable<statement_executeBatch_args>   {
    private static final org.apache.thrift.protocol.TStruct STRUCT_DESC = new org.apache.thrift.protocol.TStruct("statement_executeBatch_args");

    private static final org.apache.thrift.protocol.TField STATEMENT_FIELD_DESC = new org.apache.thrift.protocol.TField("statement", org.apache.thrift.protocol.TType.STRUCT, (short)1);

    private static final Map<Class<? extends IScheme>, SchemeFactory> schemes = new HashMap<Class<? extends IScheme>, SchemeFactory>();
    static {
      schemes.put(StandardScheme.class, new statement_executeBatch_argsStandardSchemeFactory());
      schemes.put(TupleScheme.class, new statement_executeBatch_argsTupleSchemeFactory());
    }

    public RStatement statement; // required

    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements org.apache.thrift.TFieldIdEnum {
      STATEMENT((short)1, "statement");

      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        switch(fieldId) {
          case 1: // STATEMENT
            return STATEMENT;
          default:
            return null;
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }

    // isset id assignments
    public static final Map<_Fields, org.apache.thrift.meta_data.FieldMetaData> metaDataMap;
    static {
      Map<_Fields, org.apache.thrift.meta_data.FieldMetaData> tmpMap = new EnumMap<_Fields, org.apache.thrift.meta_data.FieldMetaData>(_Fields.class);
      tmpMap.put(_Fields.STATEMENT, new org.apache.thrift.meta_data.FieldMetaData("statement", org.apache.thrift.TFieldRequirementType.DEFAULT, 
          new org.apache.thrift.meta_data.StructMetaData(org.apache.thrift.protocol.TType.STRUCT, RStatement.class)));
      metaDataMap = Collections.unmodifiableMap(tmpMap);
      org.apache.thrift.meta_data.FieldMetaData.addStructMetaDataMap(statement_executeBatch_args.class, metaDataMap);
    }

    public statement_executeBatch_args() {
    }

    public statement_executeBatch_args(
      RStatement statement)
    {
      this();
      this.statement = statement;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public statement_executeBatch_args(statement_executeBatch_args other) {
      if (other.isSetStatement()) {
        this.statement = new RStatement(other.statement);
      }
    }

    public statement_executeBatch_args deepCopy() {
      return new statement_executeBatch_args(this);
    }

    @Override
    public void clear() {
      this.statement = null;
    }

    public RStatement getStatement() {
      return this.statement;
    }

    public statement_executeBatch_args setStatement(RStatement statement) {
      this.statement = statement;
      return this;
    }

    public void unsetStatement() {
      this.statement = null;
    }

    /** Returns true if field statement is set (has been assigned a value) and false otherwise */
    public boolean isSetStatement() {
      return this.statement != null;
    }

    public void setStatementIsSet(boolean value) {
      if (!value) {
        this.statement = null;
      }
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      case STATEMENT:
        if (value == null) {
          unsetStatement();
        } else {
          setStatement((RStatement)value);
        }
        break;

      }
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      case STATEMENT:
        return getStatement();

      }
      throw new IllegalStateException();
    }

    /** Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      if (field == null) {
        throw new IllegalArgumentException();
      }

      switch (field) {
      case STATEMENT:
        return isSetStatement();
      }
      throw new IllegalStateException();
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof statement_executeBatch_args)
        return this.equals((statement_executeBatch_args)that);
      return false;
    }

    public boolean equals(statement_executeBatch_args that) {
      if (that == null)
        return false;

      boolean this_present_statement = true && this.isSetStatement();
      boolean that_present_statement = true && that.isSetStatement();
      if (this_present_statement || that_present_statement) {
        if (!(this_present_statement && that_present_statement))
          return false;
        if (!this.statement.equals(that.statement))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      List<Object> list = new ArrayList<Object>();

      boolean present_statement = true && (isSetStatement());
      list.add(present_statement);
      if (present_statement)
        list.add(statement);

      return list.hashCode();
    }

    @Override
    public int compareTo(statement_executeBatch_args other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetStatement()).compareTo(other.isSetStatement());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetStatement()) {
        lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.statement, other.statement);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      return 0;
    }

    public _Fields fieldForId(int fieldId) {
      return _Fields.findByThriftId(fieldId);
    }

    public void read(org.apache.thrift.protocol.TProtocol iprot) throws org.apache.thrift.TException {
      schemes.get(iprot.getScheme()).getScheme().read(iprot, this);
    }

    public void write(org.apache.thrift.protocol.TProtocol oprot) throws org.apache.thrift.TException {
      schemes.get(oprot.getScheme()).getScheme().write(oprot, this);
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("statement_executeBatch_args(");
      boolean first = true;

      sb.append("statement:");
      if (this.statement == null) {
        sb.append("null");
      } else {
        sb.append(this.statement);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws org.apache.thrift.TException {
      // check for required fields
      // check for sub-struct validity
      if (statement != null) {
        statement.validate();
      }
    }

    private void writeObject(java.io.ObjectOutputStream out) throws java.io.IOException {
      try {
        write(new org.apache.thrift.protocol.TCompactProtocol(new org.apache.thrift.transport.TIOStreamTransport(out)));
      } catch (org.apache.thrift.TException te) {
        throw new java.io.IOException(te);
      }
    }

    private void readObject(java.io.ObjectInputStream in) throws java.io.IOException, ClassNotFoundException {
      try {
        read(new org.apache.thrift.protocol.TCompactProtocol(new org.apache.thrift.transport.TIOStreamTransport(in)));
      } catch (org.apache.thrift.TException te) {
        throw new java.io.IOException(te);
      }
    }

    private static class statement_executeBatch_argsStandardSchemeFactory implements SchemeFactory {
      public statement_executeBatch_argsStandardScheme getScheme() {
        return new statement_executeBatch_argsStandardScheme();
      }
    }

    private static class statement_executeBatch_argsStandardScheme extends StandardScheme<statement_executeBatch_args> {

      public void read(org.apache.thrift.protocol.TProtocol iprot, statement_executeBatch_args struct) throws org.apache.thrift.TException {
        org.apache.thrift.protocol.TField schemeField;
        iprot.readStructBegin();
        while (true)
        {
          schemeField = iprot.readFieldBegin();
          if (schemeField.type == org.apache.thrift.protocol.TType.STOP) { 
            break;
          }
          switch (schemeField.id) {
            case 1: // STATEMENT
              if (schemeField.type == org.apache.thrift.protocol.TType.STRUCT) {
                struct.statement = new RStatement();
                struct.statement.read(iprot);
                struct.setStatementIsSet(true);
              } else { 
                org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
              }
              break;
            default:
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
          }
          iprot.readFieldEnd();
        }
        iprot.readStructEnd();

        // check for required fields of primitive type, which can't be checked in the validate method
        struct.validate();
      }

      public void write(org.apache.thrift.protocol.TProtocol oprot, statement_executeBatch_args struct) throws org.apache.thrift.TException {
        struct.validate();

        oprot.writeStructBegin(STRUCT_DESC);
        if (struct.statement != null) {
          oprot.writeFieldBegin(STATEMENT_FIELD_DESC);
          struct.statement.write(oprot);
          oprot.writeFieldEnd();
        }
        oprot.writeFieldStop();
        oprot.writeStructEnd();
      }

    }

    private static class statement_executeBatch_argsTupleSchemeFactory implements SchemeFactory {
      public statement_executeBatch_argsTupleScheme getScheme() {
        return new statement_executeBatch_argsTupleScheme();
      }
    }

    private static class statement_executeBatch_argsTupleScheme extends TupleScheme<statement_executeBatch_args> {

      @Override
      public void write(org.apache.thrift.protocol.TProtocol prot, statement_executeBatch_args struct) throws org.apache.thrift.TException {
        TTupleProtocol oprot = (TTupleProtocol) prot;
        BitSet optionals = new BitSet();
        if (struct.isSetStatement()) {
          optionals.set(0);
        }
        oprot.writeBitSet(optionals, 1);
        if (struct.isSetStatement()) {
          struct.statement.write(oprot);
        }
      }

      @Override
      public void read(org.apache.thrift.protocol.TProtocol prot, statement_executeBatch_args struct) throws org.apache.thrift.TException {
        TTupleProtocol iprot = (TTupleProtocol) prot;
        BitSet incoming = iprot.readBitSet(1);
        if (incoming.get(0)) {
          struct.statement = new RStatement();
          struct.statement.read(iprot);
          struct.setStatementIsSet(true);
        }
      }
    }

  }

  public static class statement_executeBatch_result implements org.apache.thrift.TBase<statement_executeBatch_result, statement_executeBatch_result._Fields>, java.io.Serializable, Cloneable, Comparable<statement_executeBatch_result>   {
    private static final org.apache.thrift.protocol.TStruct STRUCT_DESC = new org.apache.thrift.protocol.TStruct("statement_executeBatch_result");

    private static final org.apache.thrift.protocol.TField SUCCESS_FIELD_DESC = new org.apache.thrift.protocol.TField("success", org.apache.thrift.protocol.TType.LIST, (short)0);
    private static final org.apache.thrift.protocol.TField SQL_EXCEPTION_FIELD_DESC = new org.apache.thrift.protocol.TField("sqlException", org.apache.thrift.protocol.TType.STRUCT, (short)1);

    private static final Map<Class<? extends IScheme>, SchemeFactory> schemes = new HashMap<Class<? extends IScheme>, SchemeFactory>();
    static {
      schemes.put(StandardScheme.class, new statement_executeBatch_resultStandardSchemeFactory());
      schemes.put(TupleScheme.class, new statement_executeBatch_resultTupleSchemeFactory());
    }

    public List<Integer> success; // required
    public RSQLException sqlException; // required

    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements org.apache.thrift.TFieldIdEnum {
      SUCCESS((short)0, "success"),
      SQL_EXCEPTION((short)1, "sqlException");

      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        switch(fieldId) {
          case 0: // SUCCESS
            return SUCCESS;
          case 1: // SQL_EXCEPTION
            return SQL_EXCEPTION;
          default:
            return null;
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }

    // isset id assignments
    public static final Map<_Fields, org.apache.thrift.meta_data.FieldMetaData> metaDataMap;
    static {
      Map<_Fields, org.apache.thrift.meta_data.FieldMetaData> tmpMap = new EnumMap<_Fields, org.apache.thrift.meta_data.FieldMetaData>(_Fields.class);
      tmpMap.put(_Fields.SUCCESS, new org.apache.thrift.meta_data.FieldMetaData("success", org.apache.thrift.TFieldRequirementType.DEFAULT, 
          new org.apache.thrift.meta_data.ListMetaData(org.apache.thrift.protocol.TType.LIST, 
              new org.apache.thrift.meta_data.FieldValueMetaData(org.apache.thrift.protocol.TType.I32))));
      tmpMap.put(_Fields.SQL_EXCEPTION, new org.apache.thrift.meta_data.FieldMetaData("sqlException", org.apache.thrift.TFieldRequirementType.DEFAULT, 
          new org.apache.thrift.meta_data.FieldValueMetaData(org.apache.thrift.protocol.TType.STRUCT)));
      metaDataMap = Collections.unmodifiableMap(tmpMap);
      org.apache.thrift.meta_data.FieldMetaData.addStructMetaDataMap(statement_executeBatch_result.class, metaDataMap);
    }

    public statement_executeBatch_result() {
    }

    public statement_executeBatch_result(
      List<Integer> success,
      RSQLException sqlException)
    {
      this();
      this.success = success;
      this.sqlException = sqlException;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public statement_executeBatch_result(statement_executeBatch_result other) {
      if (other.isSetSuccess()) {
        List<Integer> __this__success = new ArrayList<Integer>(other.success);
        this.success = __this__success;
      }
      if (other.isSetSqlException()) {
        this.sqlException = new RSQLException(other.sqlException);
      }
    }

    public statement_executeBatch_result deepCopy() {
      return new statement_executeBatch_result(this);
    }

    @Override
    public void clear() {
      this.success = null;
      this.sqlException = null;
    }

    public int getSuccessSize() {
      return (this.success == null) ? 0 : this.success.size();
    }

    public java.util.Iterator<Integer> getSuccessIterator() {
      return (this.success == null) ? null : this.success.iterator();
    }

    public void addToSuccess(int elem) {
      if (this.success == null) {
        this.success = new ArrayList<Integer>();
      }
      this.success.add(elem);
    }

    public List<Integer> getSuccess() {
      return this.success;
    }

    public statement_executeBatch_result setSuccess(List<Integer> success) {
      this.success = success;
      return this;
    }

    public void unsetSuccess() {
      this.success = null;
    }

    /** Returns true if field success is set (has been assigned a value) and false otherwise */
    public boolean isSetSuccess() {
      return this.success != null;
    }

    public void setSuccessIsSet(boolean value) {
      if (!value) {
        this.success = null;
      }
    }

    public RSQLException getSqlException() {
      return this.sqlException;
    }

    public statement_executeBatch_result setSqlException(RSQLException sqlException) {
      this.sqlException = sqlException;
      return this;
    }

    public void unsetSqlException() {
      this.sqlException = null;
    }

    /** Returns true if field sqlException is set (has been assigned a value) and false otherwise */
    public boolean isSetSqlException() {
      return this.sqlException != null;
    }

    public void setSqlExceptionIsSet(boolean value) {
      if (!value) {
        this.sqlException = null;
      }
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          setSuccess((List<Integer>)value);
        }
        break;

      case SQL_EXCEPTION:
        if (value == null) {
          unsetSqlException();
        } else {
          setSqlException((RSQLException)value);
        }
        break;

      }
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      case SUCCESS:
        return getSuccess();

      case SQL_EXCEPTION:
        return getSqlException();

      }
      throw new IllegalStateException();
    }

    /** Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      if (field == null) {
        throw new IllegalArgumentException();
      }

      switch (field) {
      case SUCCESS:
        return isSetSuccess();
      case SQL_EXCEPTION:
        return isSetSqlException();
      }
      throw new IllegalStateException();
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof statement_executeBatch_result)
        return this.equals((statement_executeBatch_result)that);
      return false;
    }

    public boolean equals(statement_executeBatch_result that) {
      if (that == null)
        return false;

      boolean this_present_success = true && this.isSetSuccess();
      boolean that_present_success = true && that.isSetSuccess();
      if (this_present_success || that_present_success) {
        if (!(this_present_success && that_present_success))
          return false;
        if (!this.success.equals(that.success))
          return false;
      }

      boolean this_present_sqlException = true && this.isSetSqlException();
      boolean that_present_sqlException = true && that.isSetSqlException();
      if (this_present_sqlException || that_present_sqlException) {
        if (!(this_present_sqlException && that_present_sqlException))
          return false;
        if (!this.sqlException.equals(that.sqlException))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      List<Object> list = new ArrayList<Object>();

      boolean present_success = true && (isSetSuccess());
      list.add(present_success);
      if (present_success)
        list.add(success);

      boolean present_sqlException = true && (isSetSqlException());
      list.add(present_sqlException);
      if (present_sqlException)
        list.add(sqlException);

      return list.hashCode();
    }

    @Override
    public int compareTo(statement_executeBatch_result other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetSuccess()).compareTo(other.isSetSuccess());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetSuccess()) {
        lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.success, other.success);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      lastComparison = Boolean.valueOf(isSetSqlException()).compareTo(other.isSetSqlException());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetSqlException()) {
        lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.sqlException, other.sqlException);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      return 0;
    }

    public _Fields fieldForId(int fieldId) {
      return _Fields.findByThriftId(fieldId);
    }

    public void read(org.apache.thrift.protocol.TProtocol iprot) throws org.apache.thrift.TException {
      schemes.get(iprot.getScheme()).getScheme().read(iprot, this);
    }

    public void write(org.apache.thrift.protocol.TProtocol oprot) throws org.apache.thrift.TException {
      schemes.get(oprot.getScheme()).getScheme().write(oprot, this);
      }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("statement_executeBatch_result(");
      boolean first = true;

      sb.append("success:");
      if (this.success == null) {
        sb.append("null");
      } else {
        sb.append(this.success);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("sqlException:");
      if (this.sqlException == null) {
        sb.append("null");
      } else {
        sb.append(this.sqlException);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws org.apache.thrift.TException {
      // check for required fields
      // check for sub-struct validity
    }

    private void writeObject(java.io.ObjectOutputStream out) throws java.io.IOException {
      try {
        write(new org.apache.thrift.protocol.TCompactProtocol(new org.apache.thrift.transport.TIOStreamTransport(out)));
      } catch (org.apache.thrift.TException te) {
        throw new java.io.IOException(te);
      }
    }

    private void readObject(java.io.ObjectInputStream in) throws java.io.IOException, ClassNotFoundException {
      try {
        read(new org.apache.thrift.protocol.TCompactProtocol(new org.apache.thrift.transport.TIOStreamTransport(in)));
      } catch (org.apache.thrift.TException te) {
        throw new java.io.IOException(te);
      }
    }

    private static class statement_executeBatch_resultStandardSchemeFactory implements SchemeFactory {
      public statement_executeBatch_resultStandardScheme getScheme() {
        return new statement_executeBatch_resultStandardScheme();
      }
    }

    private static class statement_executeBatch_resultStandardScheme extends StandardScheme<statement_executeBatch_result> {

      public void read(org.apache.thrift.protocol.TProtocol iprot, statement_executeBatch_result struct) throws org.apache.thrift.TException {
        org.apache.thrift.protocol.TField schemeField;
        iprot.readStructBegin();
        while (true)
        {
          schemeField = iprot.readFieldBegin();
          if (schemeField.type == org.apache.thrift.protocol.TType.STOP) { 
            break;
          }
          switch (schemeField.id) {
            case 0: // SUCCESS
              if (schemeField.type == org.apache.thrift.protocol.TType.LIST) {
                {
                  org.apache.thrift.protocol.TList _list66 = iprot.readListBegin();
                  struct.success = new ArrayList<Integer>(_list66.size);
                  int _elem67;
                  for (int _i68 = 0; _i68 < _list66.size; ++_i68)
                  {
                    _elem67 = iprot.readI32();
                    struct.success.add(_elem67);
                  }
                  iprot.readListEnd();
                }
                struct.setSuccessIsSet(true);
              } else { 
                org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
              }
              break;
            case 1: // SQL_EXCEPTION
              if (schemeField.type == org.apache.thrift.protocol.TType.STRUCT) {
                struct.sqlException = new RSQLException();
                struct.sqlException.read(iprot);
                struct.setSqlExceptionIsSet(true);
              } else { 
                org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
              }
              break;
            default:
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
          }
          iprot.readFieldEnd();
        }
        iprot.readStructEnd();

        // check for required fields of primitive type, which can't be checked in the validate method
        struct.validate();
      }

      public void write(org.apache.thrift.protocol.TProtocol oprot, statement_executeBatch_result struct) throws org.apache.thrift.TException {
        struct.validate();

        oprot.writeStructBegin(STRUCT_DESC);
        if (struct.success != null) {
          oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
          {
            oprot.writeListBegin(new org.apache.thrift.protocol.TList(org.apache.thrift.protocol.TType.I32, struct.success.size()));
            for (int _iter69 : struct.success)
            {
              oprot.writeI32(_iter69);
            }
            oprot.writeListEnd();
          }
          oprot.writeFieldEnd();
        }
        if (struct.sqlException != null) {
          oprot.writeFieldBegin(SQL_EXCEPTION_FIELD_DESC);
          struct.sqlException.write(oprot);
          oprot.writeFieldEnd();
        }
        oprot.writeFieldStop();
        oprot.writeStructEnd();
      }

    }

    private static class statement_executeBatch_resultTupleSchemeFactory implements SchemeFactory {
      public statement_executeBatch_resultTupleScheme getScheme() {
        return new statement_executeBatch_resultTupleScheme();
      }
    }

    private static class statement_executeBatch_resultTupleScheme extends TupleScheme<statement_executeBatch_result> {

      @Override
      public void write(org.apache.thrift.protocol.TProtocol prot, statement_executeBatch_result struct) throws org.apache.thrift.TException {
        TTupleProtocol oprot = (TTupleProtocol) prot;
        BitSet optionals = new BitSet();
        if (struct.isSetSuccess()) {
          optionals.set(0);
        }
        if (struct.isSetSqlException()) {
          optionals.set(1);
        }
        oprot.writeBitSet(optionals, 2);
        if (struct.isSetSuccess()) {
          {
            oprot.writeI32(struct.success.size());
            for (int _iter70 : struct.success)
            {
              oprot.writeI32(_iter70);
            }
          }
        }
        if (struct.isSetSqlException()) {
          struct.sqlException.write(oprot);
        }
      }

      @Override
      public void read(org.apache.thrift.protocol.TProtocol prot, statement_executeBatch_result struct) throws org.apache.thrift.TException {
        TTupleProtocol iprot = (TTupleProtocol) prot;
        BitSet incoming = iprot.readBitSet(2);
        if (incoming.get(0)) {
          {
            org.apache.thrift.protocol.TList _list71 = new org.apache.thrift.protocol.TList(org.apache.thrift.protocol.TType.I32, iprot.readI32());
            struct.success = new ArrayList<Integer>(_list71.size);
            int _elem72;
            for (int _i73 = 0; _i73 < _list71.size; ++_i73)
            {
              _elem72 = iprot.readI32();
              struct.success.add(_elem72);
            }
          }
          struct.setSuccessIsSet(true);
        }
        if (incoming.get(1)) {
          struct.sqlException = new RSQLException();
          struct.sqlException.read(iprot);
          struct.setSqlExceptionIsSet(true);
        }
      }
    }

  }

  public static class preparedstatement_execute_args implements org.apache.thrift.TBase<preparedstatement_execute_args, preparedstatement_execute_args._Fields>, java.io.Serializable, Cloneable, Comparable<preparedstatement_execute_args>   {
    private static final org.apache.thrift.protocol.TStruct STRUCT_DESC = new org.apache.thrift.protocol.TStruct("preparedstatement_execute_args");

    private static final org.apache.thrift.protocol.TField PREPAREDSTATEMENT_FIELD_DESC = new org.apache.thrift.protocol.TField("preparedstatement", org.apache.thrift.protocol.TType.STRUCT, (short)1);

    private static final Map<Class<? extends IScheme>, SchemeFactory> schemes = new HashMap<Class<? extends IScheme>, SchemeFactory>();
    static {
      schemes.put(StandardScheme.class, new preparedstatement_execute_argsStandardSchemeFactory());
      schemes.put(TupleScheme.class, new preparedstatement_execute_argsTupleSchemeFactory());
    }

    public RStatement preparedstatement; // required

    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements org.apache.thrift.TFieldIdEnum {
      PREPAREDSTATEMENT((short)1, "preparedstatement");

      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        switch(fieldId) {
          case 1: // PREPAREDSTATEMENT
            return PREPAREDSTATEMENT;
          default:
            return null;
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }

    // isset id assignments
    public static final Map<_Fields, org.apache.thrift.meta_data.FieldMetaData> metaDataMap;
    static {
      Map<_Fields, org.apache.thrift.meta_data.FieldMetaData> tmpMap = new EnumMap<_Fields, org.apache.thrift.meta_data.FieldMetaData>(_Fields.class);
      tmpMap.put(_Fields.PREPAREDSTATEMENT, new org.apache.thrift.meta_data.FieldMetaData("preparedstatement", org.apache.thrift.TFieldRequirementType.DEFAULT, 
          new org.apache.thrift.meta_data.StructMetaData(org.apache.thrift.protocol.TType.STRUCT, RStatement.class)));
      metaDataMap = Collections.unmodifiableMap(tmpMap);
      org.apache.thrift.meta_data.FieldMetaData.addStructMetaDataMap(preparedstatement_execute_args.class, metaDataMap);
    }

    public preparedstatement_execute_args() {
    }

    public preparedstatement_execute_args(
      RStatement preparedstatement)
    {
      this();
      this.preparedstatement = preparedstatement;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public preparedstatement_execute_args(preparedstatement_execute_args other) {
      if (other.isSetPreparedstatement()) {
        this.preparedstatement = new RStatement(other.preparedstatement);
      }
    }

    public preparedstatement_execute_args deepCopy() {
      return new preparedstatement_execute_args(this);
    }

    @Override
    public void clear() {
      this.preparedstatement = null;
    }

    public RStatement getPreparedstatement() {
      return this.preparedstatement;
    }

    public preparedstatement_execute_args setPreparedstatement(RStatement preparedstatement) {
      this.preparedstatement = preparedstatement;
      return this;
    }

    public void unsetPreparedstatement() {
      this.preparedstatement = null;
    }

    /** Returns true if field preparedstatement is set (has been assigned a value) and false otherwise */
    public boolean isSetPreparedstatement() {
      return this.preparedstatement != null;
    }

    public void setPreparedstatementIsSet(boolean value) {
      if (!value) {
        this.preparedstatement = null;
      }
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      case PREPAREDSTATEMENT:
        if (value == null) {
          unsetPreparedstatement();
        } else {
          setPreparedstatement((RStatement)value);
        }
        break;

      }
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      case PREPAREDSTATEMENT:
        return getPreparedstatement();

      }
      throw new IllegalStateException();
    }

    /** Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      if (field == null) {
        throw new IllegalArgumentException();
      }

      switch (field) {
      case PREPAREDSTATEMENT:
        return isSetPreparedstatement();
      }
      throw new IllegalStateException();
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof preparedstatement_execute_args)
        return this.equals((preparedstatement_execute_args)that);
      return false;
    }

    public boolean equals(preparedstatement_execute_args that) {
      if (that == null)
        return false;

      boolean this_present_preparedstatement = true && this.isSetPreparedstatement();
      boolean that_present_preparedstatement = true && that.isSetPreparedstatement();
      if (this_present_preparedstatement || that_present_preparedstatement) {
        if (!(this_present_preparedstatement && that_present_preparedstatement))
          return false;
        if (!this.preparedstatement.equals(that.preparedstatement))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      List<Object> list = new ArrayList<Object>();

      boolean present_preparedstatement = true && (isSetPreparedstatement());
      list.add(present_preparedstatement);
      if (present_preparedstatement)
        list.add(preparedstatement);

      return list.hashCode();
    }

    @Override
    public int compareTo(preparedstatement_execute_args other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetPreparedstatement()).compareTo(other.isSetPreparedstatement());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetPreparedstatement()) {
        lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.preparedstatement, other.preparedstatement);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      return 0;
    }

    public _Fields fieldForId(int fieldId) {
      return _Fields.findByThriftId(fieldId);
    }

    public void read(org.apache.thrift.protocol.TProtocol iprot) throws org.apache.thrift.TException {
      schemes.get(iprot.getScheme()).getScheme().read(iprot, this);
    }

    public void write(org.apache.thrift.protocol.TProtocol oprot) throws org.apache.thrift.TException {
      schemes.get(oprot.getScheme()).getScheme().write(oprot, this);
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("preparedstatement_execute_args(");
      boolean first = true;

      sb.append("preparedstatement:");
      if (this.preparedstatement == null) {
        sb.append("null");
      } else {
        sb.append(this.preparedstatement);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws org.apache.thrift.TException {
      // check for required fields
      // check for sub-struct validity
      if (preparedstatement != null) {
        preparedstatement.validate();
      }
    }

    private void writeObject(java.io.ObjectOutputStream out) throws java.io.IOException {
      try {
        write(new org.apache.thrift.protocol.TCompactProtocol(new org.apache.thrift.transport.TIOStreamTransport(out)));
      } catch (org.apache.thrift.TException te) {
        throw new java.io.IOException(te);
      }
    }

    private void readObject(java.io.ObjectInputStream in) throws java.io.IOException, ClassNotFoundException {
      try {
        read(new org.apache.thrift.protocol.TCompactProtocol(new org.apache.thrift.transport.TIOStreamTransport(in)));
      } catch (org.apache.thrift.TException te) {
        throw new java.io.IOException(te);
      }
    }

    private static class preparedstatement_execute_argsStandardSchemeFactory implements SchemeFactory {
      public preparedstatement_execute_argsStandardScheme getScheme() {
        return new preparedstatement_execute_argsStandardScheme();
      }
    }

    private static class preparedstatement_execute_argsStandardScheme extends StandardScheme<preparedstatement_execute_args> {

      public void read(org.apache.thrift.protocol.TProtocol iprot, preparedstatement_execute_args struct) throws org.apache.thrift.TException {
        org.apache.thrift.protocol.TField schemeField;
        iprot.readStructBegin();
        while (true)
        {
          schemeField = iprot.readFieldBegin();
          if (schemeField.type == org.apache.thrift.protocol.TType.STOP) { 
            break;
          }
          switch (schemeField.id) {
            case 1: // PREPAREDSTATEMENT
              if (schemeField.type == org.apache.thrift.protocol.TType.STRUCT) {
                struct.preparedstatement = new RStatement();
                struct.preparedstatement.read(iprot);
                struct.setPreparedstatementIsSet(true);
              } else { 
                org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
              }
              break;
            default:
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
          }
          iprot.readFieldEnd();
        }
        iprot.readStructEnd();

        // check for required fields of primitive type, which can't be checked in the validate method
        struct.validate();
      }

      public void write(org.apache.thrift.protocol.TProtocol oprot, preparedstatement_execute_args struct) throws org.apache.thrift.TException {
        struct.validate();

        oprot.writeStructBegin(STRUCT_DESC);
        if (struct.preparedstatement != null) {
          oprot.writeFieldBegin(PREPAREDSTATEMENT_FIELD_DESC);
          struct.preparedstatement.write(oprot);
          oprot.writeFieldEnd();
        }
        oprot.writeFieldStop();
        oprot.writeStructEnd();
      }

    }

    private static class preparedstatement_execute_argsTupleSchemeFactory implements SchemeFactory {
      public preparedstatement_execute_argsTupleScheme getScheme() {
        return new preparedstatement_execute_argsTupleScheme();
      }
    }

    private static class preparedstatement_execute_argsTupleScheme extends TupleScheme<preparedstatement_execute_args> {

      @Override
      public void write(org.apache.thrift.protocol.TProtocol prot, preparedstatement_execute_args struct) throws org.apache.thrift.TException {
        TTupleProtocol oprot = (TTupleProtocol) prot;
        BitSet optionals = new BitSet();
        if (struct.isSetPreparedstatement()) {
          optionals.set(0);
        }
        oprot.writeBitSet(optionals, 1);
        if (struct.isSetPreparedstatement()) {
          struct.preparedstatement.write(oprot);
        }
      }

      @Override
      public void read(org.apache.thrift.protocol.TProtocol prot, preparedstatement_execute_args struct) throws org.apache.thrift.TException {
        TTupleProtocol iprot = (TTupleProtocol) prot;
        BitSet incoming = iprot.readBitSet(1);
        if (incoming.get(0)) {
          struct.preparedstatement = new RStatement();
          struct.preparedstatement.read(iprot);
          struct.setPreparedstatementIsSet(true);
        }
      }
    }

  }

  public static class preparedstatement_execute_result implements org.apache.thrift.TBase<preparedstatement_execute_result, preparedstatement_execute_result._Fields>, java.io.Serializable, Cloneable, Comparable<preparedstatement_execute_result>   {
    private static final org.apache.thrift.protocol.TStruct STRUCT_DESC = new org.apache.thrift.protocol.TStruct("preparedstatement_execute_result");

    private static final org.apache.thrift.protocol.TField SUCCESS_FIELD_DESC = new org.apache.thrift.protocol.TField("success", org.apache.thrift.protocol.TType.BOOL, (short)0);
    private static final org.apache.thrift.protocol.TField SQL_EXCEPTION_FIELD_DESC = new org.apache.thrift.protocol.TField("sqlException", org.apache.thrift.protocol.TType.STRUCT, (short)1);

    private static final Map<Class<? extends IScheme>, SchemeFactory> schemes = new HashMap<Class<? extends IScheme>, SchemeFactory>();
    static {
      schemes.put(StandardScheme.class, new preparedstatement_execute_resultStandardSchemeFactory());
      schemes.put(TupleScheme.class, new preparedstatement_execute_resultTupleSchemeFactory());
    }

    public boolean success; // required
    public RSQLException sqlException; // required

    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements org.apache.thrift.TFieldIdEnum {
      SUCCESS((short)0, "success"),
      SQL_EXCEPTION((short)1, "sqlException");

      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        switch(fieldId) {
          case 0: // SUCCESS
            return SUCCESS;
          case 1: // SQL_EXCEPTION
            return SQL_EXCEPTION;
          default:
            return null;
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }

    // isset id assignments
    private static final int __SUCCESS_ISSET_ID = 0;
    private byte __isset_bitfield = 0;
    public static final Map<_Fields, org.apache.thrift.meta_data.FieldMetaData> metaDataMap;
    static {
      Map<_Fields, org.apache.thrift.meta_data.FieldMetaData> tmpMap = new EnumMap<_Fields, org.apache.thrift.meta_data.FieldMetaData>(_Fields.class);
      tmpMap.put(_Fields.SUCCESS, new org.apache.thrift.meta_data.FieldMetaData("success", org.apache.thrift.TFieldRequirementType.DEFAULT, 
          new org.apache.thrift.meta_data.FieldValueMetaData(org.apache.thrift.protocol.TType.BOOL)));
      tmpMap.put(_Fields.SQL_EXCEPTION, new org.apache.thrift.meta_data.FieldMetaData("sqlException", org.apache.thrift.TFieldRequirementType.DEFAULT, 
          new org.apache.thrift.meta_data.FieldValueMetaData(org.apache.thrift.protocol.TType.STRUCT)));
      metaDataMap = Collections.unmodifiableMap(tmpMap);
      org.apache.thrift.meta_data.FieldMetaData.addStructMetaDataMap(preparedstatement_execute_result.class, metaDataMap);
    }

    public preparedstatement_execute_result() {
    }

    public preparedstatement_execute_result(
      boolean success,
      RSQLException sqlException)
    {
      this();
      this.success = success;
      setSuccessIsSet(true);
      this.sqlException = sqlException;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public preparedstatement_execute_result(preparedstatement_execute_result other) {
      __isset_bitfield = other.__isset_bitfield;
      this.success = other.success;
      if (other.isSetSqlException()) {
        this.sqlException = new RSQLException(other.sqlException);
      }
    }

    public preparedstatement_execute_result deepCopy() {
      return new preparedstatement_execute_result(this);
    }

    @Override
    public void clear() {
      setSuccessIsSet(false);
      this.success = false;
      this.sqlException = null;
    }

    public boolean isSuccess() {
      return this.success;
    }

    public preparedstatement_execute_result setSuccess(boolean success) {
      this.success = success;
      setSuccessIsSet(true);
      return this;
    }

    public void unsetSuccess() {
      __isset_bitfield = EncodingUtils.clearBit(__isset_bitfield, __SUCCESS_ISSET_ID);
    }

    /** Returns true if field success is set (has been assigned a value) and false otherwise */
    public boolean isSetSuccess() {
      return EncodingUtils.testBit(__isset_bitfield, __SUCCESS_ISSET_ID);
    }

    public void setSuccessIsSet(boolean value) {
      __isset_bitfield = EncodingUtils.setBit(__isset_bitfield, __SUCCESS_ISSET_ID, value);
    }

    public RSQLException getSqlException() {
      return this.sqlException;
    }

    public preparedstatement_execute_result setSqlException(RSQLException sqlException) {
      this.sqlException = sqlException;
      return this;
    }

    public void unsetSqlException() {
      this.sqlException = null;
    }

    /** Returns true if field sqlException is set (has been assigned a value) and false otherwise */
    public boolean isSetSqlException() {
      return this.sqlException != null;
    }

    public void setSqlExceptionIsSet(boolean value) {
      if (!value) {
        this.sqlException = null;
      }
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          setSuccess((Boolean)value);
        }
        break;

      case SQL_EXCEPTION:
        if (value == null) {
          unsetSqlException();
        } else {
          setSqlException((RSQLException)value);
        }
        break;

      }
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      case SUCCESS:
        return Boolean.valueOf(isSuccess());

      case SQL_EXCEPTION:
        return getSqlException();

      }
      throw new IllegalStateException();
    }

    /** Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      if (field == null) {
        throw new IllegalArgumentException();
      }

      switch (field) {
      case SUCCESS:
        return isSetSuccess();
      case SQL_EXCEPTION:
        return isSetSqlException();
      }
      throw new IllegalStateException();
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof preparedstatement_execute_result)
        return this.equals((preparedstatement_execute_result)that);
      return false;
    }

    public boolean equals(preparedstatement_execute_result that) {
      if (that == null)
        return false;

      boolean this_present_success = true;
      boolean that_present_success = true;
      if (this_present_success || that_present_success) {
        if (!(this_present_success && that_present_success))
          return false;
        if (this.success != that.success)
          return false;
      }

      boolean this_present_sqlException = true && this.isSetSqlException();
      boolean that_present_sqlException = true && that.isSetSqlException();
      if (this_present_sqlException || that_present_sqlException) {
        if (!(this_present_sqlException && that_present_sqlException))
          return false;
        if (!this.sqlException.equals(that.sqlException))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      List<Object> list = new ArrayList<Object>();

      boolean present_success = true;
      list.add(present_success);
      if (present_success)
        list.add(success);

      boolean present_sqlException = true && (isSetSqlException());
      list.add(present_sqlException);
      if (present_sqlException)
        list.add(sqlException);

      return list.hashCode();
    }

    @Override
    public int compareTo(preparedstatement_execute_result other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetSuccess()).compareTo(other.isSetSuccess());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetSuccess()) {
        lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.success, other.success);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      lastComparison = Boolean.valueOf(isSetSqlException()).compareTo(other.isSetSqlException());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetSqlException()) {
        lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.sqlException, other.sqlException);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      return 0;
    }

    public _Fields fieldForId(int fieldId) {
      return _Fields.findByThriftId(fieldId);
    }

    public void read(org.apache.thrift.protocol.TProtocol iprot) throws org.apache.thrift.TException {
      schemes.get(iprot.getScheme()).getScheme().read(iprot, this);
    }

    public void write(org.apache.thrift.protocol.TProtocol oprot) throws org.apache.thrift.TException {
      schemes.get(oprot.getScheme()).getScheme().write(oprot, this);
      }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("preparedstatement_execute_result(");
      boolean first = true;

      sb.append("success:");
      sb.append(this.success);
      first = false;
      if (!first) sb.append(", ");
      sb.append("sqlException:");
      if (this.sqlException == null) {
        sb.append("null");
      } else {
        sb.append(this.sqlException);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws org.apache.thrift.TException {
      // check for required fields
      // check for sub-struct validity
    }

    private void writeObject(java.io.ObjectOutputStream out) throws java.io.IOException {
      try {
        write(new org.apache.thrift.protocol.TCompactProtocol(new org.apache.thrift.transport.TIOStreamTransport(out)));
      } catch (org.apache.thrift.TException te) {
        throw new java.io.IOException(te);
      }
    }

    private void readObject(java.io.ObjectInputStream in) throws java.io.IOException, ClassNotFoundException {
      try {
        // it doesn't seem like you should have to do this, but java serialization is wacky, and doesn't call the default constructor.
        __isset_bitfield = 0;
        read(new org.apache.thrift.protocol.TCompactProtocol(new org.apache.thrift.transport.TIOStreamTransport(in)));
      } catch (org.apache.thrift.TException te) {
        throw new java.io.IOException(te);
      }
    }

    private static class preparedstatement_execute_resultStandardSchemeFactory implements SchemeFactory {
      public preparedstatement_execute_resultStandardScheme getScheme() {
        return new preparedstatement_execute_resultStandardScheme();
      }
    }

    private static class preparedstatement_execute_resultStandardScheme extends StandardScheme<preparedstatement_execute_result> {

      public void read(org.apache.thrift.protocol.TProtocol iprot, preparedstatement_execute_result struct) throws org.apache.thrift.TException {
        org.apache.thrift.protocol.TField schemeField;
        iprot.readStructBegin();
        while (true)
        {
          schemeField = iprot.readFieldBegin();
          if (schemeField.type == org.apache.thrift.protocol.TType.STOP) { 
            break;
          }
          switch (schemeField.id) {
            case 0: // SUCCESS
              if (schemeField.type == org.apache.thrift.protocol.TType.BOOL) {
                struct.success = iprot.readBool();
                struct.setSuccessIsSet(true);
              } else { 
                org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
              }
              break;
            case 1: // SQL_EXCEPTION
              if (schemeField.type == org.apache.thrift.protocol.TType.STRUCT) {
                struct.sqlException = new RSQLException();
                struct.sqlException.read(iprot);
                struct.setSqlExceptionIsSet(true);
              } else { 
                org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
              }
              break;
            default:
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
          }
          iprot.readFieldEnd();
        }
        iprot.readStructEnd();

        // check for required fields of primitive type, which can't be checked in the validate method
        struct.validate();
      }

      public void write(org.apache.thrift.protocol.TProtocol oprot, preparedstatement_execute_result struct) throws org.apache.thrift.TException {
        struct.validate();

        oprot.writeStructBegin(STRUCT_DESC);
        if (struct.isSetSuccess()) {
          oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
          oprot.writeBool(struct.success);
          oprot.writeFieldEnd();
        }
        if (struct.sqlException != null) {
          oprot.writeFieldBegin(SQL_EXCEPTION_FIELD_DESC);
          struct.sqlException.write(oprot);
          oprot.writeFieldEnd();
        }
        oprot.writeFieldStop();
        oprot.writeStructEnd();
      }

    }

    private static class preparedstatement_execute_resultTupleSchemeFactory implements SchemeFactory {
      public preparedstatement_execute_resultTupleScheme getScheme() {
        return new preparedstatement_execute_resultTupleScheme();
      }
    }

    private static class preparedstatement_execute_resultTupleScheme extends TupleScheme<preparedstatement_execute_result> {

      @Override
      public void write(org.apache.thrift.protocol.TProtocol prot, preparedstatement_execute_result struct) throws org.apache.thrift.TException {
        TTupleProtocol oprot = (TTupleProtocol) prot;
        BitSet optionals = new BitSet();
        if (struct.isSetSuccess()) {
          optionals.set(0);
        }
        if (struct.isSetSqlException()) {
          optionals.set(1);
        }
        oprot.writeBitSet(optionals, 2);
        if (struct.isSetSuccess()) {
          oprot.writeBool(struct.success);
        }
        if (struct.isSetSqlException()) {
          struct.sqlException.write(oprot);
        }
      }

      @Override
      public void read(org.apache.thrift.protocol.TProtocol prot, preparedstatement_execute_result struct) throws org.apache.thrift.TException {
        TTupleProtocol iprot = (TTupleProtocol) prot;
        BitSet incoming = iprot.readBitSet(2);
        if (incoming.get(0)) {
          struct.success = iprot.readBool();
          struct.setSuccessIsSet(true);
        }
        if (incoming.get(1)) {
          struct.sqlException = new RSQLException();
          struct.sqlException.read(iprot);
          struct.setSqlExceptionIsSet(true);
        }
      }
    }

  }

  public static class preparedstatement_executeQuery_args implements org.apache.thrift.TBase<preparedstatement_executeQuery_args, preparedstatement_executeQuery_args._Fields>, java.io.Serializable, Cloneable, Comparable<preparedstatement_executeQuery_args>   {
    private static final org.apache.thrift.protocol.TStruct STRUCT_DESC = new org.apache.thrift.protocol.TStruct("preparedstatement_executeQuery_args");

    private static final org.apache.thrift.protocol.TField PREPAREDSTATEMENT_FIELD_DESC = new org.apache.thrift.protocol.TField("preparedstatement", org.apache.thrift.protocol.TType.STRUCT, (short)1);

    private static final Map<Class<? extends IScheme>, SchemeFactory> schemes = new HashMap<Class<? extends IScheme>, SchemeFactory>();
    static {
      schemes.put(StandardScheme.class, new preparedstatement_executeQuery_argsStandardSchemeFactory());
      schemes.put(TupleScheme.class, new preparedstatement_executeQuery_argsTupleSchemeFactory());
    }

    public RStatement preparedstatement; // required

    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements org.apache.thrift.TFieldIdEnum {
      PREPAREDSTATEMENT((short)1, "preparedstatement");

      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        switch(fieldId) {
          case 1: // PREPAREDSTATEMENT
            return PREPAREDSTATEMENT;
          default:
            return null;
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }

    // isset id assignments
    public static final Map<_Fields, org.apache.thrift.meta_data.FieldMetaData> metaDataMap;
    static {
      Map<_Fields, org.apache.thrift.meta_data.FieldMetaData> tmpMap = new EnumMap<_Fields, org.apache.thrift.meta_data.FieldMetaData>(_Fields.class);
      tmpMap.put(_Fields.PREPAREDSTATEMENT, new org.apache.thrift.meta_data.FieldMetaData("preparedstatement", org.apache.thrift.TFieldRequirementType.DEFAULT, 
          new org.apache.thrift.meta_data.StructMetaData(org.apache.thrift.protocol.TType.STRUCT, RStatement.class)));
      metaDataMap = Collections.unmodifiableMap(tmpMap);
      org.apache.thrift.meta_data.FieldMetaData.addStructMetaDataMap(preparedstatement_executeQuery_args.class, metaDataMap);
    }

    public preparedstatement_executeQuery_args() {
    }

    public preparedstatement_executeQuery_args(
      RStatement preparedstatement)
    {
      this();
      this.preparedstatement = preparedstatement;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public preparedstatement_executeQuery_args(preparedstatement_executeQuery_args other) {
      if (other.isSetPreparedstatement()) {
        this.preparedstatement = new RStatement(other.preparedstatement);
      }
    }

    public preparedstatement_executeQuery_args deepCopy() {
      return new preparedstatement_executeQuery_args(this);
    }

    @Override
    public void clear() {
      this.preparedstatement = null;
    }

    public RStatement getPreparedstatement() {
      return this.preparedstatement;
    }

    public preparedstatement_executeQuery_args setPreparedstatement(RStatement preparedstatement) {
      this.preparedstatement = preparedstatement;
      return this;
    }

    public void unsetPreparedstatement() {
      this.preparedstatement = null;
    }

    /** Returns true if field preparedstatement is set (has been assigned a value) and false otherwise */
    public boolean isSetPreparedstatement() {
      return this.preparedstatement != null;
    }

    public void setPreparedstatementIsSet(boolean value) {
      if (!value) {
        this.preparedstatement = null;
      }
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      case PREPAREDSTATEMENT:
        if (value == null) {
          unsetPreparedstatement();
        } else {
          setPreparedstatement((RStatement)value);
        }
        break;

      }
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      case PREPAREDSTATEMENT:
        return getPreparedstatement();

      }
      throw new IllegalStateException();
    }

    /** Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      if (field == null) {
        throw new IllegalArgumentException();
      }

      switch (field) {
      case PREPAREDSTATEMENT:
        return isSetPreparedstatement();
      }
      throw new IllegalStateException();
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof preparedstatement_executeQuery_args)
        return this.equals((preparedstatement_executeQuery_args)that);
      return false;
    }

    public boolean equals(preparedstatement_executeQuery_args that) {
      if (that == null)
        return false;

      boolean this_present_preparedstatement = true && this.isSetPreparedstatement();
      boolean that_present_preparedstatement = true && that.isSetPreparedstatement();
      if (this_present_preparedstatement || that_present_preparedstatement) {
        if (!(this_present_preparedstatement && that_present_preparedstatement))
          return false;
        if (!this.preparedstatement.equals(that.preparedstatement))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      List<Object> list = new ArrayList<Object>();

      boolean present_preparedstatement = true && (isSetPreparedstatement());
      list.add(present_preparedstatement);
      if (present_preparedstatement)
        list.add(preparedstatement);

      return list.hashCode();
    }

    @Override
    public int compareTo(preparedstatement_executeQuery_args other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetPreparedstatement()).compareTo(other.isSetPreparedstatement());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetPreparedstatement()) {
        lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.preparedstatement, other.preparedstatement);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      return 0;
    }

    public _Fields fieldForId(int fieldId) {
      return _Fields.findByThriftId(fieldId);
    }

    public void read(org.apache.thrift.protocol.TProtocol iprot) throws org.apache.thrift.TException {
      schemes.get(iprot.getScheme()).getScheme().read(iprot, this);
    }

    public void write(org.apache.thrift.protocol.TProtocol oprot) throws org.apache.thrift.TException {
      schemes.get(oprot.getScheme()).getScheme().write(oprot, this);
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("preparedstatement_executeQuery_args(");
      boolean first = true;

      sb.append("preparedstatement:");
      if (this.preparedstatement == null) {
        sb.append("null");
      } else {
        sb.append(this.preparedstatement);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws org.apache.thrift.TException {
      // check for required fields
      // check for sub-struct validity
      if (preparedstatement != null) {
        preparedstatement.validate();
      }
    }

    private void writeObject(java.io.ObjectOutputStream out) throws java.io.IOException {
      try {
        write(new org.apache.thrift.protocol.TCompactProtocol(new org.apache.thrift.transport.TIOStreamTransport(out)));
      } catch (org.apache.thrift.TException te) {
        throw new java.io.IOException(te);
      }
    }

    private void readObject(java.io.ObjectInputStream in) throws java.io.IOException, ClassNotFoundException {
      try {
        read(new org.apache.thrift.protocol.TCompactProtocol(new org.apache.thrift.transport.TIOStreamTransport(in)));
      } catch (org.apache.thrift.TException te) {
        throw new java.io.IOException(te);
      }
    }

    private static class preparedstatement_executeQuery_argsStandardSchemeFactory implements SchemeFactory {
      public preparedstatement_executeQuery_argsStandardScheme getScheme() {
        return new preparedstatement_executeQuery_argsStandardScheme();
      }
    }

    private static class preparedstatement_executeQuery_argsStandardScheme extends StandardScheme<preparedstatement_executeQuery_args> {

      public void read(org.apache.thrift.protocol.TProtocol iprot, preparedstatement_executeQuery_args struct) throws org.apache.thrift.TException {
        org.apache.thrift.protocol.TField schemeField;
        iprot.readStructBegin();
        while (true)
        {
          schemeField = iprot.readFieldBegin();
          if (schemeField.type == org.apache.thrift.protocol.TType.STOP) { 
            break;
          }
          switch (schemeField.id) {
            case 1: // PREPAREDSTATEMENT
              if (schemeField.type == org.apache.thrift.protocol.TType.STRUCT) {
                struct.preparedstatement = new RStatement();
                struct.preparedstatement.read(iprot);
                struct.setPreparedstatementIsSet(true);
              } else { 
                org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
              }
              break;
            default:
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
          }
          iprot.readFieldEnd();
        }
        iprot.readStructEnd();

        // check for required fields of primitive type, which can't be checked in the validate method
        struct.validate();
      }

      public void write(org.apache.thrift.protocol.TProtocol oprot, preparedstatement_executeQuery_args struct) throws org.apache.thrift.TException {
        struct.validate();

        oprot.writeStructBegin(STRUCT_DESC);
        if (struct.preparedstatement != null) {
          oprot.writeFieldBegin(PREPAREDSTATEMENT_FIELD_DESC);
          struct.preparedstatement.write(oprot);
          oprot.writeFieldEnd();
        }
        oprot.writeFieldStop();
        oprot.writeStructEnd();
      }

    }

    private static class preparedstatement_executeQuery_argsTupleSchemeFactory implements SchemeFactory {
      public preparedstatement_executeQuery_argsTupleScheme getScheme() {
        return new preparedstatement_executeQuery_argsTupleScheme();
      }
    }

    private static class preparedstatement_executeQuery_argsTupleScheme extends TupleScheme<preparedstatement_executeQuery_args> {

      @Override
      public void write(org.apache.thrift.protocol.TProtocol prot, preparedstatement_executeQuery_args struct) throws org.apache.thrift.TException {
        TTupleProtocol oprot = (TTupleProtocol) prot;
        BitSet optionals = new BitSet();
        if (struct.isSetPreparedstatement()) {
          optionals.set(0);
        }
        oprot.writeBitSet(optionals, 1);
        if (struct.isSetPreparedstatement()) {
          struct.preparedstatement.write(oprot);
        }
      }

      @Override
      public void read(org.apache.thrift.protocol.TProtocol prot, preparedstatement_executeQuery_args struct) throws org.apache.thrift.TException {
        TTupleProtocol iprot = (TTupleProtocol) prot;
        BitSet incoming = iprot.readBitSet(1);
        if (incoming.get(0)) {
          struct.preparedstatement = new RStatement();
          struct.preparedstatement.read(iprot);
          struct.setPreparedstatementIsSet(true);
        }
      }
    }

  }

  public static class preparedstatement_executeQuery_result implements org.apache.thrift.TBase<preparedstatement_executeQuery_result, preparedstatement_executeQuery_result._Fields>, java.io.Serializable, Cloneable, Comparable<preparedstatement_executeQuery_result>   {
    private static final org.apache.thrift.protocol.TStruct STRUCT_DESC = new org.apache.thrift.protocol.TStruct("preparedstatement_executeQuery_result");

    private static final org.apache.thrift.protocol.TField SUCCESS_FIELD_DESC = new org.apache.thrift.protocol.TField("success", org.apache.thrift.protocol.TType.STRUCT, (short)0);
    private static final org.apache.thrift.protocol.TField SQL_EXCEPTION_FIELD_DESC = new org.apache.thrift.protocol.TField("sqlException", org.apache.thrift.protocol.TType.STRUCT, (short)1);

    private static final Map<Class<? extends IScheme>, SchemeFactory> schemes = new HashMap<Class<? extends IScheme>, SchemeFactory>();
    static {
      schemes.put(StandardScheme.class, new preparedstatement_executeQuery_resultStandardSchemeFactory());
      schemes.put(TupleScheme.class, new preparedstatement_executeQuery_resultTupleSchemeFactory());
    }

    public RResultSet success; // required
    public RSQLException sqlException; // required

    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements org.apache.thrift.TFieldIdEnum {
      SUCCESS((short)0, "success"),
      SQL_EXCEPTION((short)1, "sqlException");

      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        switch(fieldId) {
          case 0: // SUCCESS
            return SUCCESS;
          case 1: // SQL_EXCEPTION
            return SQL_EXCEPTION;
          default:
            return null;
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }

    // isset id assignments
    public static final Map<_Fields, org.apache.thrift.meta_data.FieldMetaData> metaDataMap;
    static {
      Map<_Fields, org.apache.thrift.meta_data.FieldMetaData> tmpMap = new EnumMap<_Fields, org.apache.thrift.meta_data.FieldMetaData>(_Fields.class);
      tmpMap.put(_Fields.SUCCESS, new org.apache.thrift.meta_data.FieldMetaData("success", org.apache.thrift.TFieldRequirementType.DEFAULT, 
          new org.apache.thrift.meta_data.StructMetaData(org.apache.thrift.protocol.TType.STRUCT, RResultSet.class)));
      tmpMap.put(_Fields.SQL_EXCEPTION, new org.apache.thrift.meta_data.FieldMetaData("sqlException", org.apache.thrift.TFieldRequirementType.DEFAULT, 
          new org.apache.thrift.meta_data.FieldValueMetaData(org.apache.thrift.protocol.TType.STRUCT)));
      metaDataMap = Collections.unmodifiableMap(tmpMap);
      org.apache.thrift.meta_data.FieldMetaData.addStructMetaDataMap(preparedstatement_executeQuery_result.class, metaDataMap);
    }

    public preparedstatement_executeQuery_result() {
    }

    public preparedstatement_executeQuery_result(
      RResultSet success,
      RSQLException sqlException)
    {
      this();
      this.success = success;
      this.sqlException = sqlException;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public preparedstatement_executeQuery_result(preparedstatement_executeQuery_result other) {
      if (other.isSetSuccess()) {
        this.success = new RResultSet(other.success);
      }
      if (other.isSetSqlException()) {
        this.sqlException = new RSQLException(other.sqlException);
      }
    }

    public preparedstatement_executeQuery_result deepCopy() {
      return new preparedstatement_executeQuery_result(this);
    }

    @Override
    public void clear() {
      this.success = null;
      this.sqlException = null;
    }

    public RResultSet getSuccess() {
      return this.success;
    }

    public preparedstatement_executeQuery_result setSuccess(RResultSet success) {
      this.success = success;
      return this;
    }

    public void unsetSuccess() {
      this.success = null;
    }

    /** Returns true if field success is set (has been assigned a value) and false otherwise */
    public boolean isSetSuccess() {
      return this.success != null;
    }

    public void setSuccessIsSet(boolean value) {
      if (!value) {
        this.success = null;
      }
    }

    public RSQLException getSqlException() {
      return this.sqlException;
    }

    public preparedstatement_executeQuery_result setSqlException(RSQLException sqlException) {
      this.sqlException = sqlException;
      return this;
    }

    public void unsetSqlException() {
      this.sqlException = null;
    }

    /** Returns true if field sqlException is set (has been assigned a value) and false otherwise */
    public boolean isSetSqlException() {
      return this.sqlException != null;
    }

    public void setSqlExceptionIsSet(boolean value) {
      if (!value) {
        this.sqlException = null;
      }
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          setSuccess((RResultSet)value);
        }
        break;

      case SQL_EXCEPTION:
        if (value == null) {
          unsetSqlException();
        } else {
          setSqlException((RSQLException)value);
        }
        break;

      }
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      case SUCCESS:
        return getSuccess();

      case SQL_EXCEPTION:
        return getSqlException();

      }
      throw new IllegalStateException();
    }

    /** Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      if (field == null) {
        throw new IllegalArgumentException();
      }

      switch (field) {
      case SUCCESS:
        return isSetSuccess();
      case SQL_EXCEPTION:
        return isSetSqlException();
      }
      throw new IllegalStateException();
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof preparedstatement_executeQuery_result)
        return this.equals((preparedstatement_executeQuery_result)that);
      return false;
    }

    public boolean equals(preparedstatement_executeQuery_result that) {
      if (that == null)
        return false;

      boolean this_present_success = true && this.isSetSuccess();
      boolean that_present_success = true && that.isSetSuccess();
      if (this_present_success || that_present_success) {
        if (!(this_present_success && that_present_success))
          return false;
        if (!this.success.equals(that.success))
          return false;
      }

      boolean this_present_sqlException = true && this.isSetSqlException();
      boolean that_present_sqlException = true && that.isSetSqlException();
      if (this_present_sqlException || that_present_sqlException) {
        if (!(this_present_sqlException && that_present_sqlException))
          return false;
        if (!this.sqlException.equals(that.sqlException))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      List<Object> list = new ArrayList<Object>();

      boolean present_success = true && (isSetSuccess());
      list.add(present_success);
      if (present_success)
        list.add(success);

      boolean present_sqlException = true && (isSetSqlException());
      list.add(present_sqlException);
      if (present_sqlException)
        list.add(sqlException);

      return list.hashCode();
    }

    @Override
    public int compareTo(preparedstatement_executeQuery_result other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetSuccess()).compareTo(other.isSetSuccess());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetSuccess()) {
        lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.success, other.success);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      lastComparison = Boolean.valueOf(isSetSqlException()).compareTo(other.isSetSqlException());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetSqlException()) {
        lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.sqlException, other.sqlException);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      return 0;
    }

    public _Fields fieldForId(int fieldId) {
      return _Fields.findByThriftId(fieldId);
    }

    public void read(org.apache.thrift.protocol.TProtocol iprot) throws org.apache.thrift.TException {
      schemes.get(iprot.getScheme()).getScheme().read(iprot, this);
    }

    public void write(org.apache.thrift.protocol.TProtocol oprot) throws org.apache.thrift.TException {
      schemes.get(oprot.getScheme()).getScheme().write(oprot, this);
      }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("preparedstatement_executeQuery_result(");
      boolean first = true;

      sb.append("success:");
      if (this.success == null) {
        sb.append("null");
      } else {
        sb.append(this.success);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("sqlException:");
      if (this.sqlException == null) {
        sb.append("null");
      } else {
        sb.append(this.sqlException);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws org.apache.thrift.TException {
      // check for required fields
      // check for sub-struct validity
      if (success != null) {
        success.validate();
      }
    }

    private void writeObject(java.io.ObjectOutputStream out) throws java.io.IOException {
      try {
        write(new org.apache.thrift.protocol.TCompactProtocol(new org.apache.thrift.transport.TIOStreamTransport(out)));
      } catch (org.apache.thrift.TException te) {
        throw new java.io.IOException(te);
      }
    }

    private void readObject(java.io.ObjectInputStream in) throws java.io.IOException, ClassNotFoundException {
      try {
        read(new org.apache.thrift.protocol.TCompactProtocol(new org.apache.thrift.transport.TIOStreamTransport(in)));
      } catch (org.apache.thrift.TException te) {
        throw new java.io.IOException(te);
      }
    }

    private static class preparedstatement_executeQuery_resultStandardSchemeFactory implements SchemeFactory {
      public preparedstatement_executeQuery_resultStandardScheme getScheme() {
        return new preparedstatement_executeQuery_resultStandardScheme();
      }
    }

    private static class preparedstatement_executeQuery_resultStandardScheme extends StandardScheme<preparedstatement_executeQuery_result> {

      public void read(org.apache.thrift.protocol.TProtocol iprot, preparedstatement_executeQuery_result struct) throws org.apache.thrift.TException {
        org.apache.thrift.protocol.TField schemeField;
        iprot.readStructBegin();
        while (true)
        {
          schemeField = iprot.readFieldBegin();
          if (schemeField.type == org.apache.thrift.protocol.TType.STOP) { 
            break;
          }
          switch (schemeField.id) {
            case 0: // SUCCESS
              if (schemeField.type == org.apache.thrift.protocol.TType.STRUCT) {
                struct.success = new RResultSet();
                struct.success.read(iprot);
                struct.setSuccessIsSet(true);
              } else { 
                org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
              }
              break;
            case 1: // SQL_EXCEPTION
              if (schemeField.type == org.apache.thrift.protocol.TType.STRUCT) {
                struct.sqlException = new RSQLException();
                struct.sqlException.read(iprot);
                struct.setSqlExceptionIsSet(true);
              } else { 
                org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
              }
              break;
            default:
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
          }
          iprot.readFieldEnd();
        }
        iprot.readStructEnd();

        // check for required fields of primitive type, which can't be checked in the validate method
        struct.validate();
      }

      public void write(org.apache.thrift.protocol.TProtocol oprot, preparedstatement_executeQuery_result struct) throws org.apache.thrift.TException {
        struct.validate();

        oprot.writeStructBegin(STRUCT_DESC);
        if (struct.success != null) {
          oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
          struct.success.write(oprot);
          oprot.writeFieldEnd();
        }
        if (struct.sqlException != null) {
          oprot.writeFieldBegin(SQL_EXCEPTION_FIELD_DESC);
          struct.sqlException.write(oprot);
          oprot.writeFieldEnd();
        }
        oprot.writeFieldStop();
        oprot.writeStructEnd();
      }

    }

    private static class preparedstatement_executeQuery_resultTupleSchemeFactory implements SchemeFactory {
      public preparedstatement_executeQuery_resultTupleScheme getScheme() {
        return new preparedstatement_executeQuery_resultTupleScheme();
      }
    }

    private static class preparedstatement_executeQuery_resultTupleScheme extends TupleScheme<preparedstatement_executeQuery_result> {

      @Override
      public void write(org.apache.thrift.protocol.TProtocol prot, preparedstatement_executeQuery_result struct) throws org.apache.thrift.TException {
        TTupleProtocol oprot = (TTupleProtocol) prot;
        BitSet optionals = new BitSet();
        if (struct.isSetSuccess()) {
          optionals.set(0);
        }
        if (struct.isSetSqlException()) {
          optionals.set(1);
        }
        oprot.writeBitSet(optionals, 2);
        if (struct.isSetSuccess()) {
          struct.success.write(oprot);
        }
        if (struct.isSetSqlException()) {
          struct.sqlException.write(oprot);
        }
      }

      @Override
      public void read(org.apache.thrift.protocol.TProtocol prot, preparedstatement_executeQuery_result struct) throws org.apache.thrift.TException {
        TTupleProtocol iprot = (TTupleProtocol) prot;
        BitSet incoming = iprot.readBitSet(2);
        if (incoming.get(0)) {
          struct.success = new RResultSet();
          struct.success.read(iprot);
          struct.setSuccessIsSet(true);
        }
        if (incoming.get(1)) {
          struct.sqlException = new RSQLException();
          struct.sqlException.read(iprot);
          struct.setSqlExceptionIsSet(true);
        }
      }
    }

  }

  public static class preparedstatement_executeUpdate_args implements org.apache.thrift.TBase<preparedstatement_executeUpdate_args, preparedstatement_executeUpdate_args._Fields>, java.io.Serializable, Cloneable, Comparable<preparedstatement_executeUpdate_args>   {
    private static final org.apache.thrift.protocol.TStruct STRUCT_DESC = new org.apache.thrift.protocol.TStruct("preparedstatement_executeUpdate_args");

    private static final org.apache.thrift.protocol.TField PREPAREDSTATEMENT_FIELD_DESC = new org.apache.thrift.protocol.TField("preparedstatement", org.apache.thrift.protocol.TType.STRUCT, (short)1);

    private static final Map<Class<? extends IScheme>, SchemeFactory> schemes = new HashMap<Class<? extends IScheme>, SchemeFactory>();
    static {
      schemes.put(StandardScheme.class, new preparedstatement_executeUpdate_argsStandardSchemeFactory());
      schemes.put(TupleScheme.class, new preparedstatement_executeUpdate_argsTupleSchemeFactory());
    }

    public RStatement preparedstatement; // required

    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements org.apache.thrift.TFieldIdEnum {
      PREPAREDSTATEMENT((short)1, "preparedstatement");

      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        switch(fieldId) {
          case 1: // PREPAREDSTATEMENT
            return PREPAREDSTATEMENT;
          default:
            return null;
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }

    // isset id assignments
    public static final Map<_Fields, org.apache.thrift.meta_data.FieldMetaData> metaDataMap;
    static {
      Map<_Fields, org.apache.thrift.meta_data.FieldMetaData> tmpMap = new EnumMap<_Fields, org.apache.thrift.meta_data.FieldMetaData>(_Fields.class);
      tmpMap.put(_Fields.PREPAREDSTATEMENT, new org.apache.thrift.meta_data.FieldMetaData("preparedstatement", org.apache.thrift.TFieldRequirementType.DEFAULT, 
          new org.apache.thrift.meta_data.StructMetaData(org.apache.thrift.protocol.TType.STRUCT, RStatement.class)));
      metaDataMap = Collections.unmodifiableMap(tmpMap);
      org.apache.thrift.meta_data.FieldMetaData.addStructMetaDataMap(preparedstatement_executeUpdate_args.class, metaDataMap);
    }

    public preparedstatement_executeUpdate_args() {
    }

    public preparedstatement_executeUpdate_args(
      RStatement preparedstatement)
    {
      this();
      this.preparedstatement = preparedstatement;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public preparedstatement_executeUpdate_args(preparedstatement_executeUpdate_args other) {
      if (other.isSetPreparedstatement()) {
        this.preparedstatement = new RStatement(other.preparedstatement);
      }
    }

    public preparedstatement_executeUpdate_args deepCopy() {
      return new preparedstatement_executeUpdate_args(this);
    }

    @Override
    public void clear() {
      this.preparedstatement = null;
    }

    public RStatement getPreparedstatement() {
      return this.preparedstatement;
    }

    public preparedstatement_executeUpdate_args setPreparedstatement(RStatement preparedstatement) {
      this.preparedstatement = preparedstatement;
      return this;
    }

    public void unsetPreparedstatement() {
      this.preparedstatement = null;
    }

    /** Returns true if field preparedstatement is set (has been assigned a value) and false otherwise */
    public boolean isSetPreparedstatement() {
      return this.preparedstatement != null;
    }

    public void setPreparedstatementIsSet(boolean value) {
      if (!value) {
        this.preparedstatement = null;
      }
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      case PREPAREDSTATEMENT:
        if (value == null) {
          unsetPreparedstatement();
        } else {
          setPreparedstatement((RStatement)value);
        }
        break;

      }
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      case PREPAREDSTATEMENT:
        return getPreparedstatement();

      }
      throw new IllegalStateException();
    }

    /** Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      if (field == null) {
        throw new IllegalArgumentException();
      }

      switch (field) {
      case PREPAREDSTATEMENT:
        return isSetPreparedstatement();
      }
      throw new IllegalStateException();
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof preparedstatement_executeUpdate_args)
        return this.equals((preparedstatement_executeUpdate_args)that);
      return false;
    }

    public boolean equals(preparedstatement_executeUpdate_args that) {
      if (that == null)
        return false;

      boolean this_present_preparedstatement = true && this.isSetPreparedstatement();
      boolean that_present_preparedstatement = true && that.isSetPreparedstatement();
      if (this_present_preparedstatement || that_present_preparedstatement) {
        if (!(this_present_preparedstatement && that_present_preparedstatement))
          return false;
        if (!this.preparedstatement.equals(that.preparedstatement))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      List<Object> list = new ArrayList<Object>();

      boolean present_preparedstatement = true && (isSetPreparedstatement());
      list.add(present_preparedstatement);
      if (present_preparedstatement)
        list.add(preparedstatement);

      return list.hashCode();
    }

    @Override
    public int compareTo(preparedstatement_executeUpdate_args other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetPreparedstatement()).compareTo(other.isSetPreparedstatement());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetPreparedstatement()) {
        lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.preparedstatement, other.preparedstatement);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      return 0;
    }

    public _Fields fieldForId(int fieldId) {
      return _Fields.findByThriftId(fieldId);
    }

    public void read(org.apache.thrift.protocol.TProtocol iprot) throws org.apache.thrift.TException {
      schemes.get(iprot.getScheme()).getScheme().read(iprot, this);
    }

    public void write(org.apache.thrift.protocol.TProtocol oprot) throws org.apache.thrift.TException {
      schemes.get(oprot.getScheme()).getScheme().write(oprot, this);
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("preparedstatement_executeUpdate_args(");
      boolean first = true;

      sb.append("preparedstatement:");
      if (this.preparedstatement == null) {
        sb.append("null");
      } else {
        sb.append(this.preparedstatement);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws org.apache.thrift.TException {
      // check for required fields
      // check for sub-struct validity
      if (preparedstatement != null) {
        preparedstatement.validate();
      }
    }

    private void writeObject(java.io.ObjectOutputStream out) throws java.io.IOException {
      try {
        write(new org.apache.thrift.protocol.TCompactProtocol(new org.apache.thrift.transport.TIOStreamTransport(out)));
      } catch (org.apache.thrift.TException te) {
        throw new java.io.IOException(te);
      }
    }

    private void readObject(java.io.ObjectInputStream in) throws java.io.IOException, ClassNotFoundException {
      try {
        read(new org.apache.thrift.protocol.TCompactProtocol(new org.apache.thrift.transport.TIOStreamTransport(in)));
      } catch (org.apache.thrift.TException te) {
        throw new java.io.IOException(te);
      }
    }

    private static class preparedstatement_executeUpdate_argsStandardSchemeFactory implements SchemeFactory {
      public preparedstatement_executeUpdate_argsStandardScheme getScheme() {
        return new preparedstatement_executeUpdate_argsStandardScheme();
      }
    }

    private static class preparedstatement_executeUpdate_argsStandardScheme extends StandardScheme<preparedstatement_executeUpdate_args> {

      public void read(org.apache.thrift.protocol.TProtocol iprot, preparedstatement_executeUpdate_args struct) throws org.apache.thrift.TException {
        org.apache.thrift.protocol.TField schemeField;
        iprot.readStructBegin();
        while (true)
        {
          schemeField = iprot.readFieldBegin();
          if (schemeField.type == org.apache.thrift.protocol.TType.STOP) { 
            break;
          }
          switch (schemeField.id) {
            case 1: // PREPAREDSTATEMENT
              if (schemeField.type == org.apache.thrift.protocol.TType.STRUCT) {
                struct.preparedstatement = new RStatement();
                struct.preparedstatement.read(iprot);
                struct.setPreparedstatementIsSet(true);
              } else { 
                org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
              }
              break;
            default:
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
          }
          iprot.readFieldEnd();
        }
        iprot.readStructEnd();

        // check for required fields of primitive type, which can't be checked in the validate method
        struct.validate();
      }

      public void write(org.apache.thrift.protocol.TProtocol oprot, preparedstatement_executeUpdate_args struct) throws org.apache.thrift.TException {
        struct.validate();

        oprot.writeStructBegin(STRUCT_DESC);
        if (struct.preparedstatement != null) {
          oprot.writeFieldBegin(PREPAREDSTATEMENT_FIELD_DESC);
          struct.preparedstatement.write(oprot);
          oprot.writeFieldEnd();
        }
        oprot.writeFieldStop();
        oprot.writeStructEnd();
      }

    }

    private static class preparedstatement_executeUpdate_argsTupleSchemeFactory implements SchemeFactory {
      public preparedstatement_executeUpdate_argsTupleScheme getScheme() {
        return new preparedstatement_executeUpdate_argsTupleScheme();
      }
    }

    private static class preparedstatement_executeUpdate_argsTupleScheme extends TupleScheme<preparedstatement_executeUpdate_args> {

      @Override
      public void write(org.apache.thrift.protocol.TProtocol prot, preparedstatement_executeUpdate_args struct) throws org.apache.thrift.TException {
        TTupleProtocol oprot = (TTupleProtocol) prot;
        BitSet optionals = new BitSet();
        if (struct.isSetPreparedstatement()) {
          optionals.set(0);
        }
        oprot.writeBitSet(optionals, 1);
        if (struct.isSetPreparedstatement()) {
          struct.preparedstatement.write(oprot);
        }
      }

      @Override
      public void read(org.apache.thrift.protocol.TProtocol prot, preparedstatement_executeUpdate_args struct) throws org.apache.thrift.TException {
        TTupleProtocol iprot = (TTupleProtocol) prot;
        BitSet incoming = iprot.readBitSet(1);
        if (incoming.get(0)) {
          struct.preparedstatement = new RStatement();
          struct.preparedstatement.read(iprot);
          struct.setPreparedstatementIsSet(true);
        }
      }
    }

  }

  public static class preparedstatement_executeUpdate_result implements org.apache.thrift.TBase<preparedstatement_executeUpdate_result, preparedstatement_executeUpdate_result._Fields>, java.io.Serializable, Cloneable, Comparable<preparedstatement_executeUpdate_result>   {
    private static final org.apache.thrift.protocol.TStruct STRUCT_DESC = new org.apache.thrift.protocol.TStruct("preparedstatement_executeUpdate_result");

    private static final org.apache.thrift.protocol.TField SUCCESS_FIELD_DESC = new org.apache.thrift.protocol.TField("success", org.apache.thrift.protocol.TType.I32, (short)0);
    private static final org.apache.thrift.protocol.TField SQL_EXCEPTION_FIELD_DESC = new org.apache.thrift.protocol.TField("sqlException", org.apache.thrift.protocol.TType.STRUCT, (short)1);

    private static final Map<Class<? extends IScheme>, SchemeFactory> schemes = new HashMap<Class<? extends IScheme>, SchemeFactory>();
    static {
      schemes.put(StandardScheme.class, new preparedstatement_executeUpdate_resultStandardSchemeFactory());
      schemes.put(TupleScheme.class, new preparedstatement_executeUpdate_resultTupleSchemeFactory());
    }

    public int success; // required
    public RSQLException sqlException; // required

    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements org.apache.thrift.TFieldIdEnum {
      SUCCESS((short)0, "success"),
      SQL_EXCEPTION((short)1, "sqlException");

      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        switch(fieldId) {
          case 0: // SUCCESS
            return SUCCESS;
          case 1: // SQL_EXCEPTION
            return SQL_EXCEPTION;
          default:
            return null;
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }

    // isset id assignments
    private static final int __SUCCESS_ISSET_ID = 0;
    private byte __isset_bitfield = 0;
    public static final Map<_Fields, org.apache.thrift.meta_data.FieldMetaData> metaDataMap;
    static {
      Map<_Fields, org.apache.thrift.meta_data.FieldMetaData> tmpMap = new EnumMap<_Fields, org.apache.thrift.meta_data.FieldMetaData>(_Fields.class);
      tmpMap.put(_Fields.SUCCESS, new org.apache.thrift.meta_data.FieldMetaData("success", org.apache.thrift.TFieldRequirementType.DEFAULT, 
          new org.apache.thrift.meta_data.FieldValueMetaData(org.apache.thrift.protocol.TType.I32)));
      tmpMap.put(_Fields.SQL_EXCEPTION, new org.apache.thrift.meta_data.FieldMetaData("sqlException", org.apache.thrift.TFieldRequirementType.DEFAULT, 
          new org.apache.thrift.meta_data.FieldValueMetaData(org.apache.thrift.protocol.TType.STRUCT)));
      metaDataMap = Collections.unmodifiableMap(tmpMap);
      org.apache.thrift.meta_data.FieldMetaData.addStructMetaDataMap(preparedstatement_executeUpdate_result.class, metaDataMap);
    }

    public preparedstatement_executeUpdate_result() {
    }

    public preparedstatement_executeUpdate_result(
      int success,
      RSQLException sqlException)
    {
      this();
      this.success = success;
      setSuccessIsSet(true);
      this.sqlException = sqlException;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public preparedstatement_executeUpdate_result(preparedstatement_executeUpdate_result other) {
      __isset_bitfield = other.__isset_bitfield;
      this.success = other.success;
      if (other.isSetSqlException()) {
        this.sqlException = new RSQLException(other.sqlException);
      }
    }

    public preparedstatement_executeUpdate_result deepCopy() {
      return new preparedstatement_executeUpdate_result(this);
    }

    @Override
    public void clear() {
      setSuccessIsSet(false);
      this.success = 0;
      this.sqlException = null;
    }

    public int getSuccess() {
      return this.success;
    }

    public preparedstatement_executeUpdate_result setSuccess(int success) {
      this.success = success;
      setSuccessIsSet(true);
      return this;
    }

    public void unsetSuccess() {
      __isset_bitfield = EncodingUtils.clearBit(__isset_bitfield, __SUCCESS_ISSET_ID);
    }

    /** Returns true if field success is set (has been assigned a value) and false otherwise */
    public boolean isSetSuccess() {
      return EncodingUtils.testBit(__isset_bitfield, __SUCCESS_ISSET_ID);
    }

    public void setSuccessIsSet(boolean value) {
      __isset_bitfield = EncodingUtils.setBit(__isset_bitfield, __SUCCESS_ISSET_ID, value);
    }

    public RSQLException getSqlException() {
      return this.sqlException;
    }

    public preparedstatement_executeUpdate_result setSqlException(RSQLException sqlException) {
      this.sqlException = sqlException;
      return this;
    }

    public void unsetSqlException() {
      this.sqlException = null;
    }

    /** Returns true if field sqlException is set (has been assigned a value) and false otherwise */
    public boolean isSetSqlException() {
      return this.sqlException != null;
    }

    public void setSqlExceptionIsSet(boolean value) {
      if (!value) {
        this.sqlException = null;
      }
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          setSuccess((Integer)value);
        }
        break;

      case SQL_EXCEPTION:
        if (value == null) {
          unsetSqlException();
        } else {
          setSqlException((RSQLException)value);
        }
        break;

      }
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      case SUCCESS:
        return Integer.valueOf(getSuccess());

      case SQL_EXCEPTION:
        return getSqlException();

      }
      throw new IllegalStateException();
    }

    /** Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      if (field == null) {
        throw new IllegalArgumentException();
      }

      switch (field) {
      case SUCCESS:
        return isSetSuccess();
      case SQL_EXCEPTION:
        return isSetSqlException();
      }
      throw new IllegalStateException();
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof preparedstatement_executeUpdate_result)
        return this.equals((preparedstatement_executeUpdate_result)that);
      return false;
    }

    public boolean equals(preparedstatement_executeUpdate_result that) {
      if (that == null)
        return false;

      boolean this_present_success = true;
      boolean that_present_success = true;
      if (this_present_success || that_present_success) {
        if (!(this_present_success && that_present_success))
          return false;
        if (this.success != that.success)
          return false;
      }

      boolean this_present_sqlException = true && this.isSetSqlException();
      boolean that_present_sqlException = true && that.isSetSqlException();
      if (this_present_sqlException || that_present_sqlException) {
        if (!(this_present_sqlException && that_present_sqlException))
          return false;
        if (!this.sqlException.equals(that.sqlException))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      List<Object> list = new ArrayList<Object>();

      boolean present_success = true;
      list.add(present_success);
      if (present_success)
        list.add(success);

      boolean present_sqlException = true && (isSetSqlException());
      list.add(present_sqlException);
      if (present_sqlException)
        list.add(sqlException);

      return list.hashCode();
    }

    @Override
    public int compareTo(preparedstatement_executeUpdate_result other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetSuccess()).compareTo(other.isSetSuccess());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetSuccess()) {
        lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.success, other.success);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      lastComparison = Boolean.valueOf(isSetSqlException()).compareTo(other.isSetSqlException());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetSqlException()) {
        lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.sqlException, other.sqlException);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      return 0;
    }

    public _Fields fieldForId(int fieldId) {
      return _Fields.findByThriftId(fieldId);
    }

    public void read(org.apache.thrift.protocol.TProtocol iprot) throws org.apache.thrift.TException {
      schemes.get(iprot.getScheme()).getScheme().read(iprot, this);
    }

    public void write(org.apache.thrift.protocol.TProtocol oprot) throws org.apache.thrift.TException {
      schemes.get(oprot.getScheme()).getScheme().write(oprot, this);
      }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("preparedstatement_executeUpdate_result(");
      boolean first = true;

      sb.append("success:");
      sb.append(this.success);
      first = false;
      if (!first) sb.append(", ");
      sb.append("sqlException:");
      if (this.sqlException == null) {
        sb.append("null");
      } else {
        sb.append(this.sqlException);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws org.apache.thrift.TException {
      // check for required fields
      // check for sub-struct validity
    }

    private void writeObject(java.io.ObjectOutputStream out) throws java.io.IOException {
      try {
        write(new org.apache.thrift.protocol.TCompactProtocol(new org.apache.thrift.transport.TIOStreamTransport(out)));
      } catch (org.apache.thrift.TException te) {
        throw new java.io.IOException(te);
      }
    }

    private void readObject(java.io.ObjectInputStream in) throws java.io.IOException, ClassNotFoundException {
      try {
        // it doesn't seem like you should have to do this, but java serialization is wacky, and doesn't call the default constructor.
        __isset_bitfield = 0;
        read(new org.apache.thrift.protocol.TCompactProtocol(new org.apache.thrift.transport.TIOStreamTransport(in)));
      } catch (org.apache.thrift.TException te) {
        throw new java.io.IOException(te);
      }
    }

    private static class preparedstatement_executeUpdate_resultStandardSchemeFactory implements SchemeFactory {
      public preparedstatement_executeUpdate_resultStandardScheme getScheme() {
        return new preparedstatement_executeUpdate_resultStandardScheme();
      }
    }

    private static class preparedstatement_executeUpdate_resultStandardScheme extends StandardScheme<preparedstatement_executeUpdate_result> {

      public void read(org.apache.thrift.protocol.TProtocol iprot, preparedstatement_executeUpdate_result struct) throws org.apache.thrift.TException {
        org.apache.thrift.protocol.TField schemeField;
        iprot.readStructBegin();
        while (true)
        {
          schemeField = iprot.readFieldBegin();
          if (schemeField.type == org.apache.thrift.protocol.TType.STOP) { 
            break;
          }
          switch (schemeField.id) {
            case 0: // SUCCESS
              if (schemeField.type == org.apache.thrift.protocol.TType.I32) {
                struct.success = iprot.readI32();
                struct.setSuccessIsSet(true);
              } else { 
                org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
              }
              break;
            case 1: // SQL_EXCEPTION
              if (schemeField.type == org.apache.thrift.protocol.TType.STRUCT) {
                struct.sqlException = new RSQLException();
                struct.sqlException.read(iprot);
                struct.setSqlExceptionIsSet(true);
              } else { 
                org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
              }
              break;
            default:
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
          }
          iprot.readFieldEnd();
        }
        iprot.readStructEnd();

        // check for required fields of primitive type, which can't be checked in the validate method
        struct.validate();
      }

      public void write(org.apache.thrift.protocol.TProtocol oprot, preparedstatement_executeUpdate_result struct) throws org.apache.thrift.TException {
        struct.validate();

        oprot.writeStructBegin(STRUCT_DESC);
        if (struct.isSetSuccess()) {
          oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
          oprot.writeI32(struct.success);
          oprot.writeFieldEnd();
        }
        if (struct.sqlException != null) {
          oprot.writeFieldBegin(SQL_EXCEPTION_FIELD_DESC);
          struct.sqlException.write(oprot);
          oprot.writeFieldEnd();
        }
        oprot.writeFieldStop();
        oprot.writeStructEnd();
      }

    }

    private static class preparedstatement_executeUpdate_resultTupleSchemeFactory implements SchemeFactory {
      public preparedstatement_executeUpdate_resultTupleScheme getScheme() {
        return new preparedstatement_executeUpdate_resultTupleScheme();
      }
    }

    private static class preparedstatement_executeUpdate_resultTupleScheme extends TupleScheme<preparedstatement_executeUpdate_result> {

      @Override
      public void write(org.apache.thrift.protocol.TProtocol prot, preparedstatement_executeUpdate_result struct) throws org.apache.thrift.TException {
        TTupleProtocol oprot = (TTupleProtocol) prot;
        BitSet optionals = new BitSet();
        if (struct.isSetSuccess()) {
          optionals.set(0);
        }
        if (struct.isSetSqlException()) {
          optionals.set(1);
        }
        oprot.writeBitSet(optionals, 2);
        if (struct.isSetSuccess()) {
          oprot.writeI32(struct.success);
        }
        if (struct.isSetSqlException()) {
          struct.sqlException.write(oprot);
        }
      }

      @Override
      public void read(org.apache.thrift.protocol.TProtocol prot, preparedstatement_executeUpdate_result struct) throws org.apache.thrift.TException {
        TTupleProtocol iprot = (TTupleProtocol) prot;
        BitSet incoming = iprot.readBitSet(2);
        if (incoming.get(0)) {
          struct.success = iprot.readI32();
          struct.setSuccessIsSet(true);
        }
        if (incoming.get(1)) {
          struct.sqlException = new RSQLException();
          struct.sqlException.read(iprot);
          struct.setSqlExceptionIsSet(true);
        }
      }
    }

  }

  public static class preparedstatement_setParametersThenExecute_args implements org.apache.thrift.TBase<preparedstatement_setParametersThenExecute_args, preparedstatement_setParametersThenExecute_args._Fields>, java.io.Serializable, Cloneable, Comparable<preparedstatement_setParametersThenExecute_args>   {
    private static final org.apache.thrift.protocol.TStruct STRUCT_DESC = new org.apache.thrift.protocol.TStruct("preparedstatement_setParametersThenExecute_args");

    private static final org.apache.thrift.protocol.TField PREPAREDSTATEMENT_FIELD_DESC = new org.apache.thrift.protocol.TField("preparedstatement", org.apache.thrift.protocol.TType.STRUCT, (short)1);
    private static final org.apache.thrift.protocol.TField PARAMETERS_FIELD_DESC = new org.apache.thrift.protocol.TField("parameters", org.apache.thrift.protocol.TType.LIST, (short)2);

    private static final Map<Class<? extends IScheme>, SchemeFactory> schemes = new HashMap<Class<? extends IScheme>, SchemeFactory>();
    static {
      schemes.put(StandardScheme.class, new preparedstatement_setParametersThenExecute_argsStandardSchemeFactory());
      schemes.put(TupleScheme.class, new preparedstatement_setParametersThenExecute_argsTupleSchemeFactory());
    }

    public RStatement preparedstatement; // required
    public List<RValueSQL> parameters; // required

    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements org.apache.thrift.TFieldIdEnum {
      PREPAREDSTATEMENT((short)1, "preparedstatement"),
      PARAMETERS((short)2, "parameters");

      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        switch(fieldId) {
          case 1: // PREPAREDSTATEMENT
            return PREPAREDSTATEMENT;
          case 2: // PARAMETERS
            return PARAMETERS;
          default:
            return null;
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }

    // isset id assignments
    public static final Map<_Fields, org.apache.thrift.meta_data.FieldMetaData> metaDataMap;
    static {
      Map<_Fields, org.apache.thrift.meta_data.FieldMetaData> tmpMap = new EnumMap<_Fields, org.apache.thrift.meta_data.FieldMetaData>(_Fields.class);
      tmpMap.put(_Fields.PREPAREDSTATEMENT, new org.apache.thrift.meta_data.FieldMetaData("preparedstatement", org.apache.thrift.TFieldRequirementType.DEFAULT, 
          new org.apache.thrift.meta_data.StructMetaData(org.apache.thrift.protocol.TType.STRUCT, RStatement.class)));
      tmpMap.put(_Fields.PARAMETERS, new org.apache.thrift.meta_data.FieldMetaData("parameters", org.apache.thrift.TFieldRequirementType.DEFAULT, 
          new org.apache.thrift.meta_data.ListMetaData(org.apache.thrift.protocol.TType.LIST, 
              new org.apache.thrift.meta_data.StructMetaData(org.apache.thrift.protocol.TType.STRUCT, RValueSQL.class))));
      metaDataMap = Collections.unmodifiableMap(tmpMap);
      org.apache.thrift.meta_data.FieldMetaData.addStructMetaDataMap(preparedstatement_setParametersThenExecute_args.class, metaDataMap);
    }

    public preparedstatement_setParametersThenExecute_args() {
    }

    public preparedstatement_setParametersThenExecute_args(
      RStatement preparedstatement,
      List<RValueSQL> parameters)
    {
      this();
      this.preparedstatement = preparedstatement;
      this.parameters = parameters;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public preparedstatement_setParametersThenExecute_args(preparedstatement_setParametersThenExecute_args other) {
      if (other.isSetPreparedstatement()) {
        this.preparedstatement = new RStatement(other.preparedstatement);
      }
      if (other.isSetParameters()) {
        List<RValueSQL> __this__parameters = new ArrayList<RValueSQL>(other.parameters.size());
        for (RValueSQL other_element : other.parameters) {
          __this__parameters.add(new RValueSQL(other_element));
        }
        this.parameters = __this__parameters;
      }
    }

    public preparedstatement_setParametersThenExecute_args deepCopy() {
      return new preparedstatement_setParametersThenExecute_args(this);
    }

    @Override
    public void clear() {
      this.preparedstatement = null;
      this.parameters = null;
    }

    public RStatement getPreparedstatement() {
      return this.preparedstatement;
    }

    public preparedstatement_setParametersThenExecute_args setPreparedstatement(RStatement preparedstatement) {
      this.preparedstatement = preparedstatement;
      return this;
    }

    public void unsetPreparedstatement() {
      this.preparedstatement = null;
    }

    /** Returns true if field preparedstatement is set (has been assigned a value) and false otherwise */
    public boolean isSetPreparedstatement() {
      return this.preparedstatement != null;
    }

    public void setPreparedstatementIsSet(boolean value) {
      if (!value) {
        this.preparedstatement = null;
      }
    }

    public int getParametersSize() {
      return (this.parameters == null) ? 0 : this.parameters.size();
    }

    public java.util.Iterator<RValueSQL> getParametersIterator() {
      return (this.parameters == null) ? null : this.parameters.iterator();
    }

    public void addToParameters(RValueSQL elem) {
      if (this.parameters == null) {
        this.parameters = new ArrayList<RValueSQL>();
      }
      this.parameters.add(elem);
    }

    public List<RValueSQL> getParameters() {
      return this.parameters;
    }

    public preparedstatement_setParametersThenExecute_args setParameters(List<RValueSQL> parameters) {
      this.parameters = parameters;
      return this;
    }

    public void unsetParameters() {
      this.parameters = null;
    }

    /** Returns true if field parameters is set (has been assigned a value) and false otherwise */
    public boolean isSetParameters() {
      return this.parameters != null;
    }

    public void setParametersIsSet(boolean value) {
      if (!value) {
        this.parameters = null;
      }
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      case PREPAREDSTATEMENT:
        if (value == null) {
          unsetPreparedstatement();
        } else {
          setPreparedstatement((RStatement)value);
        }
        break;

      case PARAMETERS:
        if (value == null) {
          unsetParameters();
        } else {
          setParameters((List<RValueSQL>)value);
        }
        break;

      }
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      case PREPAREDSTATEMENT:
        return getPreparedstatement();

      case PARAMETERS:
        return getParameters();

      }
      throw new IllegalStateException();
    }

    /** Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      if (field == null) {
        throw new IllegalArgumentException();
      }

      switch (field) {
      case PREPAREDSTATEMENT:
        return isSetPreparedstatement();
      case PARAMETERS:
        return isSetParameters();
      }
      throw new IllegalStateException();
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof preparedstatement_setParametersThenExecute_args)
        return this.equals((preparedstatement_setParametersThenExecute_args)that);
      return false;
    }

    public boolean equals(preparedstatement_setParametersThenExecute_args that) {
      if (that == null)
        return false;

      boolean this_present_preparedstatement = true && this.isSetPreparedstatement();
      boolean that_present_preparedstatement = true && that.isSetPreparedstatement();
      if (this_present_preparedstatement || that_present_preparedstatement) {
        if (!(this_present_preparedstatement && that_present_preparedstatement))
          return false;
        if (!this.preparedstatement.equals(that.preparedstatement))
          return false;
      }

      boolean this_present_parameters = true && this.isSetParameters();
      boolean that_present_parameters = true && that.isSetParameters();
      if (this_present_parameters || that_present_parameters) {
        if (!(this_present_parameters && that_present_parameters))
          return false;
        if (!this.parameters.equals(that.parameters))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      List<Object> list = new ArrayList<Object>();

      boolean present_preparedstatement = true && (isSetPreparedstatement());
      list.add(present_preparedstatement);
      if (present_preparedstatement)
        list.add(preparedstatement);

      boolean present_parameters = true && (isSetParameters());
      list.add(present_parameters);
      if (present_parameters)
        list.add(parameters);

      return list.hashCode();
    }

    @Override
    public int compareTo(preparedstatement_setParametersThenExecute_args other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetPreparedstatement()).compareTo(other.isSetPreparedstatement());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetPreparedstatement()) {
        lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.preparedstatement, other.preparedstatement);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      lastComparison = Boolean.valueOf(isSetParameters()).compareTo(other.isSetParameters());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetParameters()) {
        lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.parameters, other.parameters);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      return 0;
    }

    public _Fields fieldForId(int fieldId) {
      return _Fields.findByThriftId(fieldId);
    }

    public void read(org.apache.thrift.protocol.TProtocol iprot) throws org.apache.thrift.TException {
      schemes.get(iprot.getScheme()).getScheme().read(iprot, this);
    }

    public void write(org.apache.thrift.protocol.TProtocol oprot) throws org.apache.thrift.TException {
      schemes.get(oprot.getScheme()).getScheme().write(oprot, this);
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("preparedstatement_setParametersThenExecute_args(");
      boolean first = true;

      sb.append("preparedstatement:");
      if (this.preparedstatement == null) {
        sb.append("null");
      } else {
        sb.append(this.preparedstatement);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("parameters:");
      if (this.parameters == null) {
        sb.append("null");
      } else {
        sb.append(this.parameters);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws org.apache.thrift.TException {
      // check for required fields
      // check for sub-struct validity
      if (preparedstatement != null) {
        preparedstatement.validate();
      }
    }

    private void writeObject(java.io.ObjectOutputStream out) throws java.io.IOException {
      try {
        write(new org.apache.thrift.protocol.TCompactProtocol(new org.apache.thrift.transport.TIOStreamTransport(out)));
      } catch (org.apache.thrift.TException te) {
        throw new java.io.IOException(te);
      }
    }

    private void readObject(java.io.ObjectInputStream in) throws java.io.IOException, ClassNotFoundException {
      try {
        read(new org.apache.thrift.protocol.TCompactProtocol(new org.apache.thrift.transport.TIOStreamTransport(in)));
      } catch (org.apache.thrift.TException te) {
        throw new java.io.IOException(te);
      }
    }

    private static class preparedstatement_setParametersThenExecute_argsStandardSchemeFactory implements SchemeFactory {
      public preparedstatement_setParametersThenExecute_argsStandardScheme getScheme() {
        return new preparedstatement_setParametersThenExecute_argsStandardScheme();
      }
    }

    private static class preparedstatement_setParametersThenExecute_argsStandardScheme extends StandardScheme<preparedstatement_setParametersThenExecute_args> {

      public void read(org.apache.thrift.protocol.TProtocol iprot, preparedstatement_setParametersThenExecute_args struct) throws org.apache.thrift.TException {
        org.apache.thrift.protocol.TField schemeField;
        iprot.readStructBegin();
        while (true)
        {
          schemeField = iprot.readFieldBegin();
          if (schemeField.type == org.apache.thrift.protocol.TType.STOP) { 
            break;
          }
          switch (schemeField.id) {
            case 1: // PREPAREDSTATEMENT
              if (schemeField.type == org.apache.thrift.protocol.TType.STRUCT) {
                struct.preparedstatement = new RStatement();
                struct.preparedstatement.read(iprot);
                struct.setPreparedstatementIsSet(true);
              } else { 
                org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
              }
              break;
            case 2: // PARAMETERS
              if (schemeField.type == org.apache.thrift.protocol.TType.LIST) {
                {
                  org.apache.thrift.protocol.TList _list74 = iprot.readListBegin();
                  struct.parameters = new ArrayList<RValueSQL>(_list74.size);
                  RValueSQL _elem75;
                  for (int _i76 = 0; _i76 < _list74.size; ++_i76)
                  {
                    _elem75 = new RValueSQL();
                    _elem75.read(iprot);
                    struct.parameters.add(_elem75);
                  }
                  iprot.readListEnd();
                }
                struct.setParametersIsSet(true);
              } else { 
                org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
              }
              break;
            default:
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
          }
          iprot.readFieldEnd();
        }
        iprot.readStructEnd();

        // check for required fields of primitive type, which can't be checked in the validate method
        struct.validate();
      }

      public void write(org.apache.thrift.protocol.TProtocol oprot, preparedstatement_setParametersThenExecute_args struct) throws org.apache.thrift.TException {
        struct.validate();

        oprot.writeStructBegin(STRUCT_DESC);
        if (struct.preparedstatement != null) {
          oprot.writeFieldBegin(PREPAREDSTATEMENT_FIELD_DESC);
          struct.preparedstatement.write(oprot);
          oprot.writeFieldEnd();
        }
        if (struct.parameters != null) {
          oprot.writeFieldBegin(PARAMETERS_FIELD_DESC);
          {
            oprot.writeListBegin(new org.apache.thrift.protocol.TList(org.apache.thrift.protocol.TType.STRUCT, struct.parameters.size()));
            for (RValueSQL _iter77 : struct.parameters)
            {
              _iter77.write(oprot);
            }
            oprot.writeListEnd();
          }
          oprot.writeFieldEnd();
        }
        oprot.writeFieldStop();
        oprot.writeStructEnd();
      }

    }

    private static class preparedstatement_setParametersThenExecute_argsTupleSchemeFactory implements SchemeFactory {
      public preparedstatement_setParametersThenExecute_argsTupleScheme getScheme() {
        return new preparedstatement_setParametersThenExecute_argsTupleScheme();
      }
    }

    private static class preparedstatement_setParametersThenExecute_argsTupleScheme extends TupleScheme<preparedstatement_setParametersThenExecute_args> {

      @Override
      public void write(org.apache.thrift.protocol.TProtocol prot, preparedstatement_setParametersThenExecute_args struct) throws org.apache.thrift.TException {
        TTupleProtocol oprot = (TTupleProtocol) prot;
        BitSet optionals = new BitSet();
        if (struct.isSetPreparedstatement()) {
          optionals.set(0);
        }
        if (struct.isSetParameters()) {
          optionals.set(1);
        }
        oprot.writeBitSet(optionals, 2);
        if (struct.isSetPreparedstatement()) {
          struct.preparedstatement.write(oprot);
        }
        if (struct.isSetParameters()) {
          {
            oprot.writeI32(struct.parameters.size());
            for (RValueSQL _iter78 : struct.parameters)
            {
              _iter78.write(oprot);
            }
          }
        }
      }

      @Override
      public void read(org.apache.thrift.protocol.TProtocol prot, preparedstatement_setParametersThenExecute_args struct) throws org.apache.thrift.TException {
        TTupleProtocol iprot = (TTupleProtocol) prot;
        BitSet incoming = iprot.readBitSet(2);
        if (incoming.get(0)) {
          struct.preparedstatement = new RStatement();
          struct.preparedstatement.read(iprot);
          struct.setPreparedstatementIsSet(true);
        }
        if (incoming.get(1)) {
          {
            org.apache.thrift.protocol.TList _list79 = new org.apache.thrift.protocol.TList(org.apache.thrift.protocol.TType.STRUCT, iprot.readI32());
            struct.parameters = new ArrayList<RValueSQL>(_list79.size);
            RValueSQL _elem80;
            for (int _i81 = 0; _i81 < _list79.size; ++_i81)
            {
              _elem80 = new RValueSQL();
              _elem80.read(iprot);
              struct.parameters.add(_elem80);
            }
          }
          struct.setParametersIsSet(true);
        }
      }
    }

  }

  public static class preparedstatement_setParametersThenExecute_result implements org.apache.thrift.TBase<preparedstatement_setParametersThenExecute_result, preparedstatement_setParametersThenExecute_result._Fields>, java.io.Serializable, Cloneable, Comparable<preparedstatement_setParametersThenExecute_result>   {
    private static final org.apache.thrift.protocol.TStruct STRUCT_DESC = new org.apache.thrift.protocol.TStruct("preparedstatement_setParametersThenExecute_result");

    private static final org.apache.thrift.protocol.TField SUCCESS_FIELD_DESC = new org.apache.thrift.protocol.TField("success", org.apache.thrift.protocol.TType.BOOL, (short)0);
    private static final org.apache.thrift.protocol.TField SQL_EXCEPTION_FIELD_DESC = new org.apache.thrift.protocol.TField("sqlException", org.apache.thrift.protocol.TType.STRUCT, (short)1);

    private static final Map<Class<? extends IScheme>, SchemeFactory> schemes = new HashMap<Class<? extends IScheme>, SchemeFactory>();
    static {
      schemes.put(StandardScheme.class, new preparedstatement_setParametersThenExecute_resultStandardSchemeFactory());
      schemes.put(TupleScheme.class, new preparedstatement_setParametersThenExecute_resultTupleSchemeFactory());
    }

    public boolean success; // required
    public RSQLException sqlException; // required

    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements org.apache.thrift.TFieldIdEnum {
      SUCCESS((short)0, "success"),
      SQL_EXCEPTION((short)1, "sqlException");

      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        switch(fieldId) {
          case 0: // SUCCESS
            return SUCCESS;
          case 1: // SQL_EXCEPTION
            return SQL_EXCEPTION;
          default:
            return null;
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }

    // isset id assignments
    private static final int __SUCCESS_ISSET_ID = 0;
    private byte __isset_bitfield = 0;
    public static final Map<_Fields, org.apache.thrift.meta_data.FieldMetaData> metaDataMap;
    static {
      Map<_Fields, org.apache.thrift.meta_data.FieldMetaData> tmpMap = new EnumMap<_Fields, org.apache.thrift.meta_data.FieldMetaData>(_Fields.class);
      tmpMap.put(_Fields.SUCCESS, new org.apache.thrift.meta_data.FieldMetaData("success", org.apache.thrift.TFieldRequirementType.DEFAULT, 
          new org.apache.thrift.meta_data.FieldValueMetaData(org.apache.thrift.protocol.TType.BOOL)));
      tmpMap.put(_Fields.SQL_EXCEPTION, new org.apache.thrift.meta_data.FieldMetaData("sqlException", org.apache.thrift.TFieldRequirementType.DEFAULT, 
          new org.apache.thrift.meta_data.FieldValueMetaData(org.apache.thrift.protocol.TType.STRUCT)));
      metaDataMap = Collections.unmodifiableMap(tmpMap);
      org.apache.thrift.meta_data.FieldMetaData.addStructMetaDataMap(preparedstatement_setParametersThenExecute_result.class, metaDataMap);
    }

    public preparedstatement_setParametersThenExecute_result() {
    }

    public preparedstatement_setParametersThenExecute_result(
      boolean success,
      RSQLException sqlException)
    {
      this();
      this.success = success;
      setSuccessIsSet(true);
      this.sqlException = sqlException;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public preparedstatement_setParametersThenExecute_result(preparedstatement_setParametersThenExecute_result other) {
      __isset_bitfield = other.__isset_bitfield;
      this.success = other.success;
      if (other.isSetSqlException()) {
        this.sqlException = new RSQLException(other.sqlException);
      }
    }

    public preparedstatement_setParametersThenExecute_result deepCopy() {
      return new preparedstatement_setParametersThenExecute_result(this);
    }

    @Override
    public void clear() {
      setSuccessIsSet(false);
      this.success = false;
      this.sqlException = null;
    }

    public boolean isSuccess() {
      return this.success;
    }

    public preparedstatement_setParametersThenExecute_result setSuccess(boolean success) {
      this.success = success;
      setSuccessIsSet(true);
      return this;
    }

    public void unsetSuccess() {
      __isset_bitfield = EncodingUtils.clearBit(__isset_bitfield, __SUCCESS_ISSET_ID);
    }

    /** Returns true if field success is set (has been assigned a value) and false otherwise */
    public boolean isSetSuccess() {
      return EncodingUtils.testBit(__isset_bitfield, __SUCCESS_ISSET_ID);
    }

    public void setSuccessIsSet(boolean value) {
      __isset_bitfield = EncodingUtils.setBit(__isset_bitfield, __SUCCESS_ISSET_ID, value);
    }

    public RSQLException getSqlException() {
      return this.sqlException;
    }

    public preparedstatement_setParametersThenExecute_result setSqlException(RSQLException sqlException) {
      this.sqlException = sqlException;
      return this;
    }

    public void unsetSqlException() {
      this.sqlException = null;
    }

    /** Returns true if field sqlException is set (has been assigned a value) and false otherwise */
    public boolean isSetSqlException() {
      return this.sqlException != null;
    }

    public void setSqlExceptionIsSet(boolean value) {
      if (!value) {
        this.sqlException = null;
      }
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          setSuccess((Boolean)value);
        }
        break;

      case SQL_EXCEPTION:
        if (value == null) {
          unsetSqlException();
        } else {
          setSqlException((RSQLException)value);
        }
        break;

      }
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      case SUCCESS:
        return Boolean.valueOf(isSuccess());

      case SQL_EXCEPTION:
        return getSqlException();

      }
      throw new IllegalStateException();
    }

    /** Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      if (field == null) {
        throw new IllegalArgumentException();
      }

      switch (field) {
      case SUCCESS:
        return isSetSuccess();
      case SQL_EXCEPTION:
        return isSetSqlException();
      }
      throw new IllegalStateException();
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof preparedstatement_setParametersThenExecute_result)
        return this.equals((preparedstatement_setParametersThenExecute_result)that);
      return false;
    }

    public boolean equals(preparedstatement_setParametersThenExecute_result that) {
      if (that == null)
        return false;

      boolean this_present_success = true;
      boolean that_present_success = true;
      if (this_present_success || that_present_success) {
        if (!(this_present_success && that_present_success))
          return false;
        if (this.success != that.success)
          return false;
      }

      boolean this_present_sqlException = true && this.isSetSqlException();
      boolean that_present_sqlException = true && that.isSetSqlException();
      if (this_present_sqlException || that_present_sqlException) {
        if (!(this_present_sqlException && that_present_sqlException))
          return false;
        if (!this.sqlException.equals(that.sqlException))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      List<Object> list = new ArrayList<Object>();

      boolean present_success = true;
      list.add(present_success);
      if (present_success)
        list.add(success);

      boolean present_sqlException = true && (isSetSqlException());
      list.add(present_sqlException);
      if (present_sqlException)
        list.add(sqlException);

      return list.hashCode();
    }

    @Override
    public int compareTo(preparedstatement_setParametersThenExecute_result other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetSuccess()).compareTo(other.isSetSuccess());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetSuccess()) {
        lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.success, other.success);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      lastComparison = Boolean.valueOf(isSetSqlException()).compareTo(other.isSetSqlException());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetSqlException()) {
        lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.sqlException, other.sqlException);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      return 0;
    }

    public _Fields fieldForId(int fieldId) {
      return _Fields.findByThriftId(fieldId);
    }

    public void read(org.apache.thrift.protocol.TProtocol iprot) throws org.apache.thrift.TException {
      schemes.get(iprot.getScheme()).getScheme().read(iprot, this);
    }

    public void write(org.apache.thrift.protocol.TProtocol oprot) throws org.apache.thrift.TException {
      schemes.get(oprot.getScheme()).getScheme().write(oprot, this);
      }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("preparedstatement_setParametersThenExecute_result(");
      boolean first = true;

      sb.append("success:");
      sb.append(this.success);
      first = false;
      if (!first) sb.append(", ");
      sb.append("sqlException:");
      if (this.sqlException == null) {
        sb.append("null");
      } else {
        sb.append(this.sqlException);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws org.apache.thrift.TException {
      // check for required fields
      // check for sub-struct validity
    }

    private void writeObject(java.io.ObjectOutputStream out) throws java.io.IOException {
      try {
        write(new org.apache.thrift.protocol.TCompactProtocol(new org.apache.thrift.transport.TIOStreamTransport(out)));
      } catch (org.apache.thrift.TException te) {
        throw new java.io.IOException(te);
      }
    }

    private void readObject(java.io.ObjectInputStream in) throws java.io.IOException, ClassNotFoundException {
      try {
        // it doesn't seem like you should have to do this, but java serialization is wacky, and doesn't call the default constructor.
        __isset_bitfield = 0;
        read(new org.apache.thrift.protocol.TCompactProtocol(new org.apache.thrift.transport.TIOStreamTransport(in)));
      } catch (org.apache.thrift.TException te) {
        throw new java.io.IOException(te);
      }
    }

    private static class preparedstatement_setParametersThenExecute_resultStandardSchemeFactory implements SchemeFactory {
      public preparedstatement_setParametersThenExecute_resultStandardScheme getScheme() {
        return new preparedstatement_setParametersThenExecute_resultStandardScheme();
      }
    }

    private static class preparedstatement_setParametersThenExecute_resultStandardScheme extends StandardScheme<preparedstatement_setParametersThenExecute_result> {

      public void read(org.apache.thrift.protocol.TProtocol iprot, preparedstatement_setParametersThenExecute_result struct) throws org.apache.thrift.TException {
        org.apache.thrift.protocol.TField schemeField;
        iprot.readStructBegin();
        while (true)
        {
          schemeField = iprot.readFieldBegin();
          if (schemeField.type == org.apache.thrift.protocol.TType.STOP) { 
            break;
          }
          switch (schemeField.id) {
            case 0: // SUCCESS
              if (schemeField.type == org.apache.thrift.protocol.TType.BOOL) {
                struct.success = iprot.readBool();
                struct.setSuccessIsSet(true);
              } else { 
                org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
              }
              break;
            case 1: // SQL_EXCEPTION
              if (schemeField.type == org.apache.thrift.protocol.TType.STRUCT) {
                struct.sqlException = new RSQLException();
                struct.sqlException.read(iprot);
                struct.setSqlExceptionIsSet(true);
              } else { 
                org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
              }
              break;
            default:
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
          }
          iprot.readFieldEnd();
        }
        iprot.readStructEnd();

        // check for required fields of primitive type, which can't be checked in the validate method
        struct.validate();
      }

      public void write(org.apache.thrift.protocol.TProtocol oprot, preparedstatement_setParametersThenExecute_result struct) throws org.apache.thrift.TException {
        struct.validate();

        oprot.writeStructBegin(STRUCT_DESC);
        if (struct.isSetSuccess()) {
          oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
          oprot.writeBool(struct.success);
          oprot.writeFieldEnd();
        }
        if (struct.sqlException != null) {
          oprot.writeFieldBegin(SQL_EXCEPTION_FIELD_DESC);
          struct.sqlException.write(oprot);
          oprot.writeFieldEnd();
        }
        oprot.writeFieldStop();
        oprot.writeStructEnd();
      }

    }

    private static class preparedstatement_setParametersThenExecute_resultTupleSchemeFactory implements SchemeFactory {
      public preparedstatement_setParametersThenExecute_resultTupleScheme getScheme() {
        return new preparedstatement_setParametersThenExecute_resultTupleScheme();
      }
    }

    private static class preparedstatement_setParametersThenExecute_resultTupleScheme extends TupleScheme<preparedstatement_setParametersThenExecute_result> {

      @Override
      public void write(org.apache.thrift.protocol.TProtocol prot, preparedstatement_setParametersThenExecute_result struct) throws org.apache.thrift.TException {
        TTupleProtocol oprot = (TTupleProtocol) prot;
        BitSet optionals = new BitSet();
        if (struct.isSetSuccess()) {
          optionals.set(0);
        }
        if (struct.isSetSqlException()) {
          optionals.set(1);
        }
        oprot.writeBitSet(optionals, 2);
        if (struct.isSetSuccess()) {
          oprot.writeBool(struct.success);
        }
        if (struct.isSetSqlException()) {
          struct.sqlException.write(oprot);
        }
      }

      @Override
      public void read(org.apache.thrift.protocol.TProtocol prot, preparedstatement_setParametersThenExecute_result struct) throws org.apache.thrift.TException {
        TTupleProtocol iprot = (TTupleProtocol) prot;
        BitSet incoming = iprot.readBitSet(2);
        if (incoming.get(0)) {
          struct.success = iprot.readBool();
          struct.setSuccessIsSet(true);
        }
        if (incoming.get(1)) {
          struct.sqlException = new RSQLException();
          struct.sqlException.read(iprot);
          struct.setSqlExceptionIsSet(true);
        }
      }
    }

  }

  public static class preparedstatement_setParametersThenExecuteQuery_args implements org.apache.thrift.TBase<preparedstatement_setParametersThenExecuteQuery_args, preparedstatement_setParametersThenExecuteQuery_args._Fields>, java.io.Serializable, Cloneable, Comparable<preparedstatement_setParametersThenExecuteQuery_args>   {
    private static final org.apache.thrift.protocol.TStruct STRUCT_DESC = new org.apache.thrift.protocol.TStruct("preparedstatement_setParametersThenExecuteQuery_args");

    private static final org.apache.thrift.protocol.TField PREPAREDSTATEMENT_FIELD_DESC = new org.apache.thrift.protocol.TField("preparedstatement", org.apache.thrift.protocol.TType.STRUCT, (short)1);
    private static final org.apache.thrift.protocol.TField PARAMETERS_FIELD_DESC = new org.apache.thrift.protocol.TField("parameters", org.apache.thrift.protocol.TType.LIST, (short)2);

    private static final Map<Class<? extends IScheme>, SchemeFactory> schemes = new HashMap<Class<? extends IScheme>, SchemeFactory>();
    static {
      schemes.put(StandardScheme.class, new preparedstatement_setParametersThenExecuteQuery_argsStandardSchemeFactory());
      schemes.put(TupleScheme.class, new preparedstatement_setParametersThenExecuteQuery_argsTupleSchemeFactory());
    }

    public RStatement preparedstatement; // required
    public List<RValueSQL> parameters; // required

    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements org.apache.thrift.TFieldIdEnum {
      PREPAREDSTATEMENT((short)1, "preparedstatement"),
      PARAMETERS((short)2, "parameters");

      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        switch(fieldId) {
          case 1: // PREPAREDSTATEMENT
            return PREPAREDSTATEMENT;
          case 2: // PARAMETERS
            return PARAMETERS;
          default:
            return null;
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }

    // isset id assignments
    public static final Map<_Fields, org.apache.thrift.meta_data.FieldMetaData> metaDataMap;
    static {
      Map<_Fields, org.apache.thrift.meta_data.FieldMetaData> tmpMap = new EnumMap<_Fields, org.apache.thrift.meta_data.FieldMetaData>(_Fields.class);
      tmpMap.put(_Fields.PREPAREDSTATEMENT, new org.apache.thrift.meta_data.FieldMetaData("preparedstatement", org.apache.thrift.TFieldRequirementType.DEFAULT, 
          new org.apache.thrift.meta_data.StructMetaData(org.apache.thrift.protocol.TType.STRUCT, RStatement.class)));
      tmpMap.put(_Fields.PARAMETERS, new org.apache.thrift.meta_data.FieldMetaData("parameters", org.apache.thrift.TFieldRequirementType.DEFAULT, 
          new org.apache.thrift.meta_data.ListMetaData(org.apache.thrift.protocol.TType.LIST, 
              new org.apache.thrift.meta_data.StructMetaData(org.apache.thrift.protocol.TType.STRUCT, RValueSQL.class))));
      metaDataMap = Collections.unmodifiableMap(tmpMap);
      org.apache.thrift.meta_data.FieldMetaData.addStructMetaDataMap(preparedstatement_setParametersThenExecuteQuery_args.class, metaDataMap);
    }

    public preparedstatement_setParametersThenExecuteQuery_args() {
    }

    public preparedstatement_setParametersThenExecuteQuery_args(
      RStatement preparedstatement,
      List<RValueSQL> parameters)
    {
      this();
      this.preparedstatement = preparedstatement;
      this.parameters = parameters;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public preparedstatement_setParametersThenExecuteQuery_args(preparedstatement_setParametersThenExecuteQuery_args other) {
      if (other.isSetPreparedstatement()) {
        this.preparedstatement = new RStatement(other.preparedstatement);
      }
      if (other.isSetParameters()) {
        List<RValueSQL> __this__parameters = new ArrayList<RValueSQL>(other.parameters.size());
        for (RValueSQL other_element : other.parameters) {
          __this__parameters.add(new RValueSQL(other_element));
        }
        this.parameters = __this__parameters;
      }
    }

    public preparedstatement_setParametersThenExecuteQuery_args deepCopy() {
      return new preparedstatement_setParametersThenExecuteQuery_args(this);
    }

    @Override
    public void clear() {
      this.preparedstatement = null;
      this.parameters = null;
    }

    public RStatement getPreparedstatement() {
      return this.preparedstatement;
    }

    public preparedstatement_setParametersThenExecuteQuery_args setPreparedstatement(RStatement preparedstatement) {
      this.preparedstatement = preparedstatement;
      return this;
    }

    public void unsetPreparedstatement() {
      this.preparedstatement = null;
    }

    /** Returns true if field preparedstatement is set (has been assigned a value) and false otherwise */
    public boolean isSetPreparedstatement() {
      return this.preparedstatement != null;
    }

    public void setPreparedstatementIsSet(boolean value) {
      if (!value) {
        this.preparedstatement = null;
      }
    }

    public int getParametersSize() {
      return (this.parameters == null) ? 0 : this.parameters.size();
    }

    public java.util.Iterator<RValueSQL> getParametersIterator() {
      return (this.parameters == null) ? null : this.parameters.iterator();
    }

    public void addToParameters(RValueSQL elem) {
      if (this.parameters == null) {
        this.parameters = new ArrayList<RValueSQL>();
      }
      this.parameters.add(elem);
    }

    public List<RValueSQL> getParameters() {
      return this.parameters;
    }

    public preparedstatement_setParametersThenExecuteQuery_args setParameters(List<RValueSQL> parameters) {
      this.parameters = parameters;
      return this;
    }

    public void unsetParameters() {
      this.parameters = null;
    }

    /** Returns true if field parameters is set (has been assigned a value) and false otherwise */
    public boolean isSetParameters() {
      return this.parameters != null;
    }

    public void setParametersIsSet(boolean value) {
      if (!value) {
        this.parameters = null;
      }
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      case PREPAREDSTATEMENT:
        if (value == null) {
          unsetPreparedstatement();
        } else {
          setPreparedstatement((RStatement)value);
        }
        break;

      case PARAMETERS:
        if (value == null) {
          unsetParameters();
        } else {
          setParameters((List<RValueSQL>)value);
        }
        break;

      }
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      case PREPAREDSTATEMENT:
        return getPreparedstatement();

      case PARAMETERS:
        return getParameters();

      }
      throw new IllegalStateException();
    }

    /** Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      if (field == null) {
        throw new IllegalArgumentException();
      }

      switch (field) {
      case PREPAREDSTATEMENT:
        return isSetPreparedstatement();
      case PARAMETERS:
        return isSetParameters();
      }
      throw new IllegalStateException();
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof preparedstatement_setParametersThenExecuteQuery_args)
        return this.equals((preparedstatement_setParametersThenExecuteQuery_args)that);
      return false;
    }

    public boolean equals(preparedstatement_setParametersThenExecuteQuery_args that) {
      if (that == null)
        return false;

      boolean this_present_preparedstatement = true && this.isSetPreparedstatement();
      boolean that_present_preparedstatement = true && that.isSetPreparedstatement();
      if (this_present_preparedstatement || that_present_preparedstatement) {
        if (!(this_present_preparedstatement && that_present_preparedstatement))
          return false;
        if (!this.preparedstatement.equals(that.preparedstatement))
          return false;
      }

      boolean this_present_parameters = true && this.isSetParameters();
      boolean that_present_parameters = true && that.isSetParameters();
      if (this_present_parameters || that_present_parameters) {
        if (!(this_present_parameters && that_present_parameters))
          return false;
        if (!this.parameters.equals(that.parameters))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      List<Object> list = new ArrayList<Object>();

      boolean present_preparedstatement = true && (isSetPreparedstatement());
      list.add(present_preparedstatement);
      if (present_preparedstatement)
        list.add(preparedstatement);

      boolean present_parameters = true && (isSetParameters());
      list.add(present_parameters);
      if (present_parameters)
        list.add(parameters);

      return list.hashCode();
    }

    @Override
    public int compareTo(preparedstatement_setParametersThenExecuteQuery_args other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetPreparedstatement()).compareTo(other.isSetPreparedstatement());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetPreparedstatement()) {
        lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.preparedstatement, other.preparedstatement);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      lastComparison = Boolean.valueOf(isSetParameters()).compareTo(other.isSetParameters());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetParameters()) {
        lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.parameters, other.parameters);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      return 0;
    }

    public _Fields fieldForId(int fieldId) {
      return _Fields.findByThriftId(fieldId);
    }

    public void read(org.apache.thrift.protocol.TProtocol iprot) throws org.apache.thrift.TException {
      schemes.get(iprot.getScheme()).getScheme().read(iprot, this);
    }

    public void write(org.apache.thrift.protocol.TProtocol oprot) throws org.apache.thrift.TException {
      schemes.get(oprot.getScheme()).getScheme().write(oprot, this);
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("preparedstatement_setParametersThenExecuteQuery_args(");
      boolean first = true;

      sb.append("preparedstatement:");
      if (this.preparedstatement == null) {
        sb.append("null");
      } else {
        sb.append(this.preparedstatement);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("parameters:");
      if (this.parameters == null) {
        sb.append("null");
      } else {
        sb.append(this.parameters);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws org.apache.thrift.TException {
      // check for required fields
      // check for sub-struct validity
      if (preparedstatement != null) {
        preparedstatement.validate();
      }
    }

    private void writeObject(java.io.ObjectOutputStream out) throws java.io.IOException {
      try {
        write(new org.apache.thrift.protocol.TCompactProtocol(new org.apache.thrift.transport.TIOStreamTransport(out)));
      } catch (org.apache.thrift.TException te) {
        throw new java.io.IOException(te);
      }
    }

    private void readObject(java.io.ObjectInputStream in) throws java.io.IOException, ClassNotFoundException {
      try {
        read(new org.apache.thrift.protocol.TCompactProtocol(new org.apache.thrift.transport.TIOStreamTransport(in)));
      } catch (org.apache.thrift.TException te) {
        throw new java.io.IOException(te);
      }
    }

    private static class preparedstatement_setParametersThenExecuteQuery_argsStandardSchemeFactory implements SchemeFactory {
      public preparedstatement_setParametersThenExecuteQuery_argsStandardScheme getScheme() {
        return new preparedstatement_setParametersThenExecuteQuery_argsStandardScheme();
      }
    }

    private static class preparedstatement_setParametersThenExecuteQuery_argsStandardScheme extends StandardScheme<preparedstatement_setParametersThenExecuteQuery_args> {

      public void read(org.apache.thrift.protocol.TProtocol iprot, preparedstatement_setParametersThenExecuteQuery_args struct) throws org.apache.thrift.TException {
        org.apache.thrift.protocol.TField schemeField;
        iprot.readStructBegin();
        while (true)
        {
          schemeField = iprot.readFieldBegin();
          if (schemeField.type == org.apache.thrift.protocol.TType.STOP) { 
            break;
          }
          switch (schemeField.id) {
            case 1: // PREPAREDSTATEMENT
              if (schemeField.type == org.apache.thrift.protocol.TType.STRUCT) {
                struct.preparedstatement = new RStatement();
                struct.preparedstatement.read(iprot);
                struct.setPreparedstatementIsSet(true);
              } else { 
                org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
              }
              break;
            case 2: // PARAMETERS
              if (schemeField.type == org.apache.thrift.protocol.TType.LIST) {
                {
                  org.apache.thrift.protocol.TList _list82 = iprot.readListBegin();
                  struct.parameters = new ArrayList<RValueSQL>(_list82.size);
                  RValueSQL _elem83;
                  for (int _i84 = 0; _i84 < _list82.size; ++_i84)
                  {
                    _elem83 = new RValueSQL();
                    _elem83.read(iprot);
                    struct.parameters.add(_elem83);
                  }
                  iprot.readListEnd();
                }
                struct.setParametersIsSet(true);
              } else { 
                org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
              }
              break;
            default:
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
          }
          iprot.readFieldEnd();
        }
        iprot.readStructEnd();

        // check for required fields of primitive type, which can't be checked in the validate method
        struct.validate();
      }

      public void write(org.apache.thrift.protocol.TProtocol oprot, preparedstatement_setParametersThenExecuteQuery_args struct) throws org.apache.thrift.TException {
        struct.validate();

        oprot.writeStructBegin(STRUCT_DESC);
        if (struct.preparedstatement != null) {
          oprot.writeFieldBegin(PREPAREDSTATEMENT_FIELD_DESC);
          struct.preparedstatement.write(oprot);
          oprot.writeFieldEnd();
        }
        if (struct.parameters != null) {
          oprot.writeFieldBegin(PARAMETERS_FIELD_DESC);
          {
            oprot.writeListBegin(new org.apache.thrift.protocol.TList(org.apache.thrift.protocol.TType.STRUCT, struct.parameters.size()));
            for (RValueSQL _iter85 : struct.parameters)
            {
              _iter85.write(oprot);
            }
            oprot.writeListEnd();
          }
          oprot.writeFieldEnd();
        }
        oprot.writeFieldStop();
        oprot.writeStructEnd();
      }

    }

    private static class preparedstatement_setParametersThenExecuteQuery_argsTupleSchemeFactory implements SchemeFactory {
      public preparedstatement_setParametersThenExecuteQuery_argsTupleScheme getScheme() {
        return new preparedstatement_setParametersThenExecuteQuery_argsTupleScheme();
      }
    }

    private static class preparedstatement_setParametersThenExecuteQuery_argsTupleScheme extends TupleScheme<preparedstatement_setParametersThenExecuteQuery_args> {

      @Override
      public void write(org.apache.thrift.protocol.TProtocol prot, preparedstatement_setParametersThenExecuteQuery_args struct) throws org.apache.thrift.TException {
        TTupleProtocol oprot = (TTupleProtocol) prot;
        BitSet optionals = new BitSet();
        if (struct.isSetPreparedstatement()) {
          optionals.set(0);
        }
        if (struct.isSetParameters()) {
          optionals.set(1);
        }
        oprot.writeBitSet(optionals, 2);
        if (struct.isSetPreparedstatement()) {
          struct.preparedstatement.write(oprot);
        }
        if (struct.isSetParameters()) {
          {
            oprot.writeI32(struct.parameters.size());
            for (RValueSQL _iter86 : struct.parameters)
            {
              _iter86.write(oprot);
            }
          }
        }
      }

      @Override
      public void read(org.apache.thrift.protocol.TProtocol prot, preparedstatement_setParametersThenExecuteQuery_args struct) throws org.apache.thrift.TException {
        TTupleProtocol iprot = (TTupleProtocol) prot;
        BitSet incoming = iprot.readBitSet(2);
        if (incoming.get(0)) {
          struct.preparedstatement = new RStatement();
          struct.preparedstatement.read(iprot);
          struct.setPreparedstatementIsSet(true);
        }
        if (incoming.get(1)) {
          {
            org.apache.thrift.protocol.TList _list87 = new org.apache.thrift.protocol.TList(org.apache.thrift.protocol.TType.STRUCT, iprot.readI32());
            struct.parameters = new ArrayList<RValueSQL>(_list87.size);
            RValueSQL _elem88;
            for (int _i89 = 0; _i89 < _list87.size; ++_i89)
            {
              _elem88 = new RValueSQL();
              _elem88.read(iprot);
              struct.parameters.add(_elem88);
            }
          }
          struct.setParametersIsSet(true);
        }
      }
    }

  }

  public static class preparedstatement_setParametersThenExecuteQuery_result implements org.apache.thrift.TBase<preparedstatement_setParametersThenExecuteQuery_result, preparedstatement_setParametersThenExecuteQuery_result._Fields>, java.io.Serializable, Cloneable, Comparable<preparedstatement_setParametersThenExecuteQuery_result>   {
    private static final org.apache.thrift.protocol.TStruct STRUCT_DESC = new org.apache.thrift.protocol.TStruct("preparedstatement_setParametersThenExecuteQuery_result");

    private static final org.apache.thrift.protocol.TField SUCCESS_FIELD_DESC = new org.apache.thrift.protocol.TField("success", org.apache.thrift.protocol.TType.STRUCT, (short)0);
    private static final org.apache.thrift.protocol.TField SQL_EXCEPTION_FIELD_DESC = new org.apache.thrift.protocol.TField("sqlException", org.apache.thrift.protocol.TType.STRUCT, (short)1);

    private static final Map<Class<? extends IScheme>, SchemeFactory> schemes = new HashMap<Class<? extends IScheme>, SchemeFactory>();
    static {
      schemes.put(StandardScheme.class, new preparedstatement_setParametersThenExecuteQuery_resultStandardSchemeFactory());
      schemes.put(TupleScheme.class, new preparedstatement_setParametersThenExecuteQuery_resultTupleSchemeFactory());
    }

    public RResultSet success; // required
    public RSQLException sqlException; // required

    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements org.apache.thrift.TFieldIdEnum {
      SUCCESS((short)0, "success"),
      SQL_EXCEPTION((short)1, "sqlException");

      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        switch(fieldId) {
          case 0: // SUCCESS
            return SUCCESS;
          case 1: // SQL_EXCEPTION
            return SQL_EXCEPTION;
          default:
            return null;
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }

    // isset id assignments
    public static final Map<_Fields, org.apache.thrift.meta_data.FieldMetaData> metaDataMap;
    static {
      Map<_Fields, org.apache.thrift.meta_data.FieldMetaData> tmpMap = new EnumMap<_Fields, org.apache.thrift.meta_data.FieldMetaData>(_Fields.class);
      tmpMap.put(_Fields.SUCCESS, new org.apache.thrift.meta_data.FieldMetaData("success", org.apache.thrift.TFieldRequirementType.DEFAULT, 
          new org.apache.thrift.meta_data.StructMetaData(org.apache.thrift.protocol.TType.STRUCT, RResultSet.class)));
      tmpMap.put(_Fields.SQL_EXCEPTION, new org.apache.thrift.meta_data.FieldMetaData("sqlException", org.apache.thrift.TFieldRequirementType.DEFAULT, 
          new org.apache.thrift.meta_data.FieldValueMetaData(org.apache.thrift.protocol.TType.STRUCT)));
      metaDataMap = Collections.unmodifiableMap(tmpMap);
      org.apache.thrift.meta_data.FieldMetaData.addStructMetaDataMap(preparedstatement_setParametersThenExecuteQuery_result.class, metaDataMap);
    }

    public preparedstatement_setParametersThenExecuteQuery_result() {
    }

    public preparedstatement_setParametersThenExecuteQuery_result(
      RResultSet success,
      RSQLException sqlException)
    {
      this();
      this.success = success;
      this.sqlException = sqlException;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public preparedstatement_setParametersThenExecuteQuery_result(preparedstatement_setParametersThenExecuteQuery_result other) {
      if (other.isSetSuccess()) {
        this.success = new RResultSet(other.success);
      }
      if (other.isSetSqlException()) {
        this.sqlException = new RSQLException(other.sqlException);
      }
    }

    public preparedstatement_setParametersThenExecuteQuery_result deepCopy() {
      return new preparedstatement_setParametersThenExecuteQuery_result(this);
    }

    @Override
    public void clear() {
      this.success = null;
      this.sqlException = null;
    }

    public RResultSet getSuccess() {
      return this.success;
    }

    public preparedstatement_setParametersThenExecuteQuery_result setSuccess(RResultSet success) {
      this.success = success;
      return this;
    }

    public void unsetSuccess() {
      this.success = null;
    }

    /** Returns true if field success is set (has been assigned a value) and false otherwise */
    public boolean isSetSuccess() {
      return this.success != null;
    }

    public void setSuccessIsSet(boolean value) {
      if (!value) {
        this.success = null;
      }
    }

    public RSQLException getSqlException() {
      return this.sqlException;
    }

    public preparedstatement_setParametersThenExecuteQuery_result setSqlException(RSQLException sqlException) {
      this.sqlException = sqlException;
      return this;
    }

    public void unsetSqlException() {
      this.sqlException = null;
    }

    /** Returns true if field sqlException is set (has been assigned a value) and false otherwise */
    public boolean isSetSqlException() {
      return this.sqlException != null;
    }

    public void setSqlExceptionIsSet(boolean value) {
      if (!value) {
        this.sqlException = null;
      }
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          setSuccess((RResultSet)value);
        }
        break;

      case SQL_EXCEPTION:
        if (value == null) {
          unsetSqlException();
        } else {
          setSqlException((RSQLException)value);
        }
        break;

      }
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      case SUCCESS:
        return getSuccess();

      case SQL_EXCEPTION:
        return getSqlException();

      }
      throw new IllegalStateException();
    }

    /** Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      if (field == null) {
        throw new IllegalArgumentException();
      }

      switch (field) {
      case SUCCESS:
        return isSetSuccess();
      case SQL_EXCEPTION:
        return isSetSqlException();
      }
      throw new IllegalStateException();
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof preparedstatement_setParametersThenExecuteQuery_result)
        return this.equals((preparedstatement_setParametersThenExecuteQuery_result)that);
      return false;
    }

    public boolean equals(preparedstatement_setParametersThenExecuteQuery_result that) {
      if (that == null)
        return false;

      boolean this_present_success = true && this.isSetSuccess();
      boolean that_present_success = true && that.isSetSuccess();
      if (this_present_success || that_present_success) {
        if (!(this_present_success && that_present_success))
          return false;
        if (!this.success.equals(that.success))
          return false;
      }

      boolean this_present_sqlException = true && this.isSetSqlException();
      boolean that_present_sqlException = true && that.isSetSqlException();
      if (this_present_sqlException || that_present_sqlException) {
        if (!(this_present_sqlException && that_present_sqlException))
          return false;
        if (!this.sqlException.equals(that.sqlException))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      List<Object> list = new ArrayList<Object>();

      boolean present_success = true && (isSetSuccess());
      list.add(present_success);
      if (present_success)
        list.add(success);

      boolean present_sqlException = true && (isSetSqlException());
      list.add(present_sqlException);
      if (present_sqlException)
        list.add(sqlException);

      return list.hashCode();
    }

    @Override
    public int compareTo(preparedstatement_setParametersThenExecuteQuery_result other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetSuccess()).compareTo(other.isSetSuccess());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetSuccess()) {
        lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.success, other.success);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      lastComparison = Boolean.valueOf(isSetSqlException()).compareTo(other.isSetSqlException());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetSqlException()) {
        lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.sqlException, other.sqlException);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      return 0;
    }

    public _Fields fieldForId(int fieldId) {
      return _Fields.findByThriftId(fieldId);
    }

    public void read(org.apache.thrift.protocol.TProtocol iprot) throws org.apache.thrift.TException {
      schemes.get(iprot.getScheme()).getScheme().read(iprot, this);
    }

    public void write(org.apache.thrift.protocol.TProtocol oprot) throws org.apache.thrift.TException {
      schemes.get(oprot.getScheme()).getScheme().write(oprot, this);
      }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("preparedstatement_setParametersThenExecuteQuery_result(");
      boolean first = true;

      sb.append("success:");
      if (this.success == null) {
        sb.append("null");
      } else {
        sb.append(this.success);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("sqlException:");
      if (this.sqlException == null) {
        sb.append("null");
      } else {
        sb.append(this.sqlException);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws org.apache.thrift.TException {
      // check for required fields
      // check for sub-struct validity
      if (success != null) {
        success.validate();
      }
    }

    private void writeObject(java.io.ObjectOutputStream out) throws java.io.IOException {
      try {
        write(new org.apache.thrift.protocol.TCompactProtocol(new org.apache.thrift.transport.TIOStreamTransport(out)));
      } catch (org.apache.thrift.TException te) {
        throw new java.io.IOException(te);
      }
    }

    private void readObject(java.io.ObjectInputStream in) throws java.io.IOException, ClassNotFoundException {
      try {
        read(new org.apache.thrift.protocol.TCompactProtocol(new org.apache.thrift.transport.TIOStreamTransport(in)));
      } catch (org.apache.thrift.TException te) {
        throw new java.io.IOException(te);
      }
    }

    private static class preparedstatement_setParametersThenExecuteQuery_resultStandardSchemeFactory implements SchemeFactory {
      public preparedstatement_setParametersThenExecuteQuery_resultStandardScheme getScheme() {
        return new preparedstatement_setParametersThenExecuteQuery_resultStandardScheme();
      }
    }

    private static class preparedstatement_setParametersThenExecuteQuery_resultStandardScheme extends StandardScheme<preparedstatement_setParametersThenExecuteQuery_result> {

      public void read(org.apache.thrift.protocol.TProtocol iprot, preparedstatement_setParametersThenExecuteQuery_result struct) throws org.apache.thrift.TException {
        org.apache.thrift.protocol.TField schemeField;
        iprot.readStructBegin();
        while (true)
        {
          schemeField = iprot.readFieldBegin();
          if (schemeField.type == org.apache.thrift.protocol.TType.STOP) { 
            break;
          }
          switch (schemeField.id) {
            case 0: // SUCCESS
              if (schemeField.type == org.apache.thrift.protocol.TType.STRUCT) {
                struct.success = new RResultSet();
                struct.success.read(iprot);
                struct.setSuccessIsSet(true);
              } else { 
                org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
              }
              break;
            case 1: // SQL_EXCEPTION
              if (schemeField.type == org.apache.thrift.protocol.TType.STRUCT) {
                struct.sqlException = new RSQLException();
                struct.sqlException.read(iprot);
                struct.setSqlExceptionIsSet(true);
              } else { 
                org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
              }
              break;
            default:
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
          }
          iprot.readFieldEnd();
        }
        iprot.readStructEnd();

        // check for required fields of primitive type, which can't be checked in the validate method
        struct.validate();
      }

      public void write(org.apache.thrift.protocol.TProtocol oprot, preparedstatement_setParametersThenExecuteQuery_result struct) throws org.apache.thrift.TException {
        struct.validate();

        oprot.writeStructBegin(STRUCT_DESC);
        if (struct.success != null) {
          oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
          struct.success.write(oprot);
          oprot.writeFieldEnd();
        }
        if (struct.sqlException != null) {
          oprot.writeFieldBegin(SQL_EXCEPTION_FIELD_DESC);
          struct.sqlException.write(oprot);
          oprot.writeFieldEnd();
        }
        oprot.writeFieldStop();
        oprot.writeStructEnd();
      }

    }

    private static class preparedstatement_setParametersThenExecuteQuery_resultTupleSchemeFactory implements SchemeFactory {
      public preparedstatement_setParametersThenExecuteQuery_resultTupleScheme getScheme() {
        return new preparedstatement_setParametersThenExecuteQuery_resultTupleScheme();
      }
    }

    private static class preparedstatement_setParametersThenExecuteQuery_resultTupleScheme extends TupleScheme<preparedstatement_setParametersThenExecuteQuery_result> {

      @Override
      public void write(org.apache.thrift.protocol.TProtocol prot, preparedstatement_setParametersThenExecuteQuery_result struct) throws org.apache.thrift.TException {
        TTupleProtocol oprot = (TTupleProtocol) prot;
        BitSet optionals = new BitSet();
        if (struct.isSetSuccess()) {
          optionals.set(0);
        }
        if (struct.isSetSqlException()) {
          optionals.set(1);
        }
        oprot.writeBitSet(optionals, 2);
        if (struct.isSetSuccess()) {
          struct.success.write(oprot);
        }
        if (struct.isSetSqlException()) {
          struct.sqlException.write(oprot);
        }
      }

      @Override
      public void read(org.apache.thrift.protocol.TProtocol prot, preparedstatement_setParametersThenExecuteQuery_result struct) throws org.apache.thrift.TException {
        TTupleProtocol iprot = (TTupleProtocol) prot;
        BitSet incoming = iprot.readBitSet(2);
        if (incoming.get(0)) {
          struct.success = new RResultSet();
          struct.success.read(iprot);
          struct.setSuccessIsSet(true);
        }
        if (incoming.get(1)) {
          struct.sqlException = new RSQLException();
          struct.sqlException.read(iprot);
          struct.setSqlExceptionIsSet(true);
        }
      }
    }

  }

  public static class preparedstatement_setParametersThenExecuteUpdate_args implements org.apache.thrift.TBase<preparedstatement_setParametersThenExecuteUpdate_args, preparedstatement_setParametersThenExecuteUpdate_args._Fields>, java.io.Serializable, Cloneable, Comparable<preparedstatement_setParametersThenExecuteUpdate_args>   {
    private static final org.apache.thrift.protocol.TStruct STRUCT_DESC = new org.apache.thrift.protocol.TStruct("preparedstatement_setParametersThenExecuteUpdate_args");

    private static final org.apache.thrift.protocol.TField PREPAREDSTATEMENT_FIELD_DESC = new org.apache.thrift.protocol.TField("preparedstatement", org.apache.thrift.protocol.TType.STRUCT, (short)1);
    private static final org.apache.thrift.protocol.TField PARAMETERS_FIELD_DESC = new org.apache.thrift.protocol.TField("parameters", org.apache.thrift.protocol.TType.LIST, (short)2);

    private static final Map<Class<? extends IScheme>, SchemeFactory> schemes = new HashMap<Class<? extends IScheme>, SchemeFactory>();
    static {
      schemes.put(StandardScheme.class, new preparedstatement_setParametersThenExecuteUpdate_argsStandardSchemeFactory());
      schemes.put(TupleScheme.class, new preparedstatement_setParametersThenExecuteUpdate_argsTupleSchemeFactory());
    }

    public RStatement preparedstatement; // required
    public List<RValueSQL> parameters; // required

    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements org.apache.thrift.TFieldIdEnum {
      PREPAREDSTATEMENT((short)1, "preparedstatement"),
      PARAMETERS((short)2, "parameters");

      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        switch(fieldId) {
          case 1: // PREPAREDSTATEMENT
            return PREPAREDSTATEMENT;
          case 2: // PARAMETERS
            return PARAMETERS;
          default:
            return null;
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }

    // isset id assignments
    public static final Map<_Fields, org.apache.thrift.meta_data.FieldMetaData> metaDataMap;
    static {
      Map<_Fields, org.apache.thrift.meta_data.FieldMetaData> tmpMap = new EnumMap<_Fields, org.apache.thrift.meta_data.FieldMetaData>(_Fields.class);
      tmpMap.put(_Fields.PREPAREDSTATEMENT, new org.apache.thrift.meta_data.FieldMetaData("preparedstatement", org.apache.thrift.TFieldRequirementType.DEFAULT, 
          new org.apache.thrift.meta_data.StructMetaData(org.apache.thrift.protocol.TType.STRUCT, RStatement.class)));
      tmpMap.put(_Fields.PARAMETERS, new org.apache.thrift.meta_data.FieldMetaData("parameters", org.apache.thrift.TFieldRequirementType.DEFAULT, 
          new org.apache.thrift.meta_data.ListMetaData(org.apache.thrift.protocol.TType.LIST, 
              new org.apache.thrift.meta_data.StructMetaData(org.apache.thrift.protocol.TType.STRUCT, RValueSQL.class))));
      metaDataMap = Collections.unmodifiableMap(tmpMap);
      org.apache.thrift.meta_data.FieldMetaData.addStructMetaDataMap(preparedstatement_setParametersThenExecuteUpdate_args.class, metaDataMap);
    }

    public preparedstatement_setParametersThenExecuteUpdate_args() {
    }

    public preparedstatement_setParametersThenExecuteUpdate_args(
      RStatement preparedstatement,
      List<RValueSQL> parameters)
    {
      this();
      this.preparedstatement = preparedstatement;
      this.parameters = parameters;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public preparedstatement_setParametersThenExecuteUpdate_args(preparedstatement_setParametersThenExecuteUpdate_args other) {
      if (other.isSetPreparedstatement()) {
        this.preparedstatement = new RStatement(other.preparedstatement);
      }
      if (other.isSetParameters()) {
        List<RValueSQL> __this__parameters = new ArrayList<RValueSQL>(other.parameters.size());
        for (RValueSQL other_element : other.parameters) {
          __this__parameters.add(new RValueSQL(other_element));
        }
        this.parameters = __this__parameters;
      }
    }

    public preparedstatement_setParametersThenExecuteUpdate_args deepCopy() {
      return new preparedstatement_setParametersThenExecuteUpdate_args(this);
    }

    @Override
    public void clear() {
      this.preparedstatement = null;
      this.parameters = null;
    }

    public RStatement getPreparedstatement() {
      return this.preparedstatement;
    }

    public preparedstatement_setParametersThenExecuteUpdate_args setPreparedstatement(RStatement preparedstatement) {
      this.preparedstatement = preparedstatement;
      return this;
    }

    public void unsetPreparedstatement() {
      this.preparedstatement = null;
    }

    /** Returns true if field preparedstatement is set (has been assigned a value) and false otherwise */
    public boolean isSetPreparedstatement() {
      return this.preparedstatement != null;
    }

    public void setPreparedstatementIsSet(boolean value) {
      if (!value) {
        this.preparedstatement = null;
      }
    }

    public int getParametersSize() {
      return (this.parameters == null) ? 0 : this.parameters.size();
    }

    public java.util.Iterator<RValueSQL> getParametersIterator() {
      return (this.parameters == null) ? null : this.parameters.iterator();
    }

    public void addToParameters(RValueSQL elem) {
      if (this.parameters == null) {
        this.parameters = new ArrayList<RValueSQL>();
      }
      this.parameters.add(elem);
    }

    public List<RValueSQL> getParameters() {
      return this.parameters;
    }

    public preparedstatement_setParametersThenExecuteUpdate_args setParameters(List<RValueSQL> parameters) {
      this.parameters = parameters;
      return this;
    }

    public void unsetParameters() {
      this.parameters = null;
    }

    /** Returns true if field parameters is set (has been assigned a value) and false otherwise */
    public boolean isSetParameters() {
      return this.parameters != null;
    }

    public void setParametersIsSet(boolean value) {
      if (!value) {
        this.parameters = null;
      }
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      case PREPAREDSTATEMENT:
        if (value == null) {
          unsetPreparedstatement();
        } else {
          setPreparedstatement((RStatement)value);
        }
        break;

      case PARAMETERS:
        if (value == null) {
          unsetParameters();
        } else {
          setParameters((List<RValueSQL>)value);
        }
        break;

      }
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      case PREPAREDSTATEMENT:
        return getPreparedstatement();

      case PARAMETERS:
        return getParameters();

      }
      throw new IllegalStateException();
    }

    /** Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      if (field == null) {
        throw new IllegalArgumentException();
      }

      switch (field) {
      case PREPAREDSTATEMENT:
        return isSetPreparedstatement();
      case PARAMETERS:
        return isSetParameters();
      }
      throw new IllegalStateException();
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof preparedstatement_setParametersThenExecuteUpdate_args)
        return this.equals((preparedstatement_setParametersThenExecuteUpdate_args)that);
      return false;
    }

    public boolean equals(preparedstatement_setParametersThenExecuteUpdate_args that) {
      if (that == null)
        return false;

      boolean this_present_preparedstatement = true && this.isSetPreparedstatement();
      boolean that_present_preparedstatement = true && that.isSetPreparedstatement();
      if (this_present_preparedstatement || that_present_preparedstatement) {
        if (!(this_present_preparedstatement && that_present_preparedstatement))
          return false;
        if (!this.preparedstatement.equals(that.preparedstatement))
          return false;
      }

      boolean this_present_parameters = true && this.isSetParameters();
      boolean that_present_parameters = true && that.isSetParameters();
      if (this_present_parameters || that_present_parameters) {
        if (!(this_present_parameters && that_present_parameters))
          return false;
        if (!this.parameters.equals(that.parameters))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      List<Object> list = new ArrayList<Object>();

      boolean present_preparedstatement = true && (isSetPreparedstatement());
      list.add(present_preparedstatement);
      if (present_preparedstatement)
        list.add(preparedstatement);

      boolean present_parameters = true && (isSetParameters());
      list.add(present_parameters);
      if (present_parameters)
        list.add(parameters);

      return list.hashCode();
    }

    @Override
    public int compareTo(preparedstatement_setParametersThenExecuteUpdate_args other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetPreparedstatement()).compareTo(other.isSetPreparedstatement());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetPreparedstatement()) {
        lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.preparedstatement, other.preparedstatement);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      lastComparison = Boolean.valueOf(isSetParameters()).compareTo(other.isSetParameters());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetParameters()) {
        lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.parameters, other.parameters);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      return 0;
    }

    public _Fields fieldForId(int fieldId) {
      return _Fields.findByThriftId(fieldId);
    }

    public void read(org.apache.thrift.protocol.TProtocol iprot) throws org.apache.thrift.TException {
      schemes.get(iprot.getScheme()).getScheme().read(iprot, this);
    }

    public void write(org.apache.thrift.protocol.TProtocol oprot) throws org.apache.thrift.TException {
      schemes.get(oprot.getScheme()).getScheme().write(oprot, this);
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("preparedstatement_setParametersThenExecuteUpdate_args(");
      boolean first = true;

      sb.append("preparedstatement:");
      if (this.preparedstatement == null) {
        sb.append("null");
      } else {
        sb.append(this.preparedstatement);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("parameters:");
      if (this.parameters == null) {
        sb.append("null");
      } else {
        sb.append(this.parameters);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws org.apache.thrift.TException {
      // check for required fields
      // check for sub-struct validity
      if (preparedstatement != null) {
        preparedstatement.validate();
      }
    }

    private void writeObject(java.io.ObjectOutputStream out) throws java.io.IOException {
      try {
        write(new org.apache.thrift.protocol.TCompactProtocol(new org.apache.thrift.transport.TIOStreamTransport(out)));
      } catch (org.apache.thrift.TException te) {
        throw new java.io.IOException(te);
      }
    }

    private void readObject(java.io.ObjectInputStream in) throws java.io.IOException, ClassNotFoundException {
      try {
        read(new org.apache.thrift.protocol.TCompactProtocol(new org.apache.thrift.transport.TIOStreamTransport(in)));
      } catch (org.apache.thrift.TException te) {
        throw new java.io.IOException(te);
      }
    }

    private static class preparedstatement_setParametersThenExecuteUpdate_argsStandardSchemeFactory implements SchemeFactory {
      public preparedstatement_setParametersThenExecuteUpdate_argsStandardScheme getScheme() {
        return new preparedstatement_setParametersThenExecuteUpdate_argsStandardScheme();
      }
    }

    private static class preparedstatement_setParametersThenExecuteUpdate_argsStandardScheme extends StandardScheme<preparedstatement_setParametersThenExecuteUpdate_args> {

      public void read(org.apache.thrift.protocol.TProtocol iprot, preparedstatement_setParametersThenExecuteUpdate_args struct) throws org.apache.thrift.TException {
        org.apache.thrift.protocol.TField schemeField;
        iprot.readStructBegin();
        while (true)
        {
          schemeField = iprot.readFieldBegin();
          if (schemeField.type == org.apache.thrift.protocol.TType.STOP) { 
            break;
          }
          switch (schemeField.id) {
            case 1: // PREPAREDSTATEMENT
              if (schemeField.type == org.apache.thrift.protocol.TType.STRUCT) {
                struct.preparedstatement = new RStatement();
                struct.preparedstatement.read(iprot);
                struct.setPreparedstatementIsSet(true);
              } else { 
                org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
              }
              break;
            case 2: // PARAMETERS
              if (schemeField.type == org.apache.thrift.protocol.TType.LIST) {
                {
                  org.apache.thrift.protocol.TList _list90 = iprot.readListBegin();
                  struct.parameters = new ArrayList<RValueSQL>(_list90.size);
                  RValueSQL _elem91;
                  for (int _i92 = 0; _i92 < _list90.size; ++_i92)
                  {
                    _elem91 = new RValueSQL();
                    _elem91.read(iprot);
                    struct.parameters.add(_elem91);
                  }
                  iprot.readListEnd();
                }
                struct.setParametersIsSet(true);
              } else { 
                org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
              }
              break;
            default:
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
          }
          iprot.readFieldEnd();
        }
        iprot.readStructEnd();

        // check for required fields of primitive type, which can't be checked in the validate method
        struct.validate();
      }

      public void write(org.apache.thrift.protocol.TProtocol oprot, preparedstatement_setParametersThenExecuteUpdate_args struct) throws org.apache.thrift.TException {
        struct.validate();

        oprot.writeStructBegin(STRUCT_DESC);
        if (struct.preparedstatement != null) {
          oprot.writeFieldBegin(PREPAREDSTATEMENT_FIELD_DESC);
          struct.preparedstatement.write(oprot);
          oprot.writeFieldEnd();
        }
        if (struct.parameters != null) {
          oprot.writeFieldBegin(PARAMETERS_FIELD_DESC);
          {
            oprot.writeListBegin(new org.apache.thrift.protocol.TList(org.apache.thrift.protocol.TType.STRUCT, struct.parameters.size()));
            for (RValueSQL _iter93 : struct.parameters)
            {
              _iter93.write(oprot);
            }
            oprot.writeListEnd();
          }
          oprot.writeFieldEnd();
        }
        oprot.writeFieldStop();
        oprot.writeStructEnd();
      }

    }

    private static class preparedstatement_setParametersThenExecuteUpdate_argsTupleSchemeFactory implements SchemeFactory {
      public preparedstatement_setParametersThenExecuteUpdate_argsTupleScheme getScheme() {
        return new preparedstatement_setParametersThenExecuteUpdate_argsTupleScheme();
      }
    }

    private static class preparedstatement_setParametersThenExecuteUpdate_argsTupleScheme extends TupleScheme<preparedstatement_setParametersThenExecuteUpdate_args> {

      @Override
      public void write(org.apache.thrift.protocol.TProtocol prot, preparedstatement_setParametersThenExecuteUpdate_args struct) throws org.apache.thrift.TException {
        TTupleProtocol oprot = (TTupleProtocol) prot;
        BitSet optionals = new BitSet();
        if (struct.isSetPreparedstatement()) {
          optionals.set(0);
        }
        if (struct.isSetParameters()) {
          optionals.set(1);
        }
        oprot.writeBitSet(optionals, 2);
        if (struct.isSetPreparedstatement()) {
          struct.preparedstatement.write(oprot);
        }
        if (struct.isSetParameters()) {
          {
            oprot.writeI32(struct.parameters.size());
            for (RValueSQL _iter94 : struct.parameters)
            {
              _iter94.write(oprot);
            }
          }
        }
      }

      @Override
      public void read(org.apache.thrift.protocol.TProtocol prot, preparedstatement_setParametersThenExecuteUpdate_args struct) throws org.apache.thrift.TException {
        TTupleProtocol iprot = (TTupleProtocol) prot;
        BitSet incoming = iprot.readBitSet(2);
        if (incoming.get(0)) {
          struct.preparedstatement = new RStatement();
          struct.preparedstatement.read(iprot);
          struct.setPreparedstatementIsSet(true);
        }
        if (incoming.get(1)) {
          {
            org.apache.thrift.protocol.TList _list95 = new org.apache.thrift.protocol.TList(org.apache.thrift.protocol.TType.STRUCT, iprot.readI32());
            struct.parameters = new ArrayList<RValueSQL>(_list95.size);
            RValueSQL _elem96;
            for (int _i97 = 0; _i97 < _list95.size; ++_i97)
            {
              _elem96 = new RValueSQL();
              _elem96.read(iprot);
              struct.parameters.add(_elem96);
            }
          }
          struct.setParametersIsSet(true);
        }
      }
    }

  }

  public static class preparedstatement_setParametersThenExecuteUpdate_result implements org.apache.thrift.TBase<preparedstatement_setParametersThenExecuteUpdate_result, preparedstatement_setParametersThenExecuteUpdate_result._Fields>, java.io.Serializable, Cloneable, Comparable<preparedstatement_setParametersThenExecuteUpdate_result>   {
    private static final org.apache.thrift.protocol.TStruct STRUCT_DESC = new org.apache.thrift.protocol.TStruct("preparedstatement_setParametersThenExecuteUpdate_result");

    private static final org.apache.thrift.protocol.TField SUCCESS_FIELD_DESC = new org.apache.thrift.protocol.TField("success", org.apache.thrift.protocol.TType.I32, (short)0);
    private static final org.apache.thrift.protocol.TField SQL_EXCEPTION_FIELD_DESC = new org.apache.thrift.protocol.TField("sqlException", org.apache.thrift.protocol.TType.STRUCT, (short)1);

    private static final Map<Class<? extends IScheme>, SchemeFactory> schemes = new HashMap<Class<? extends IScheme>, SchemeFactory>();
    static {
      schemes.put(StandardScheme.class, new preparedstatement_setParametersThenExecuteUpdate_resultStandardSchemeFactory());
      schemes.put(TupleScheme.class, new preparedstatement_setParametersThenExecuteUpdate_resultTupleSchemeFactory());
    }

    public int success; // required
    public RSQLException sqlException; // required

    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements org.apache.thrift.TFieldIdEnum {
      SUCCESS((short)0, "success"),
      SQL_EXCEPTION((short)1, "sqlException");

      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        switch(fieldId) {
          case 0: // SUCCESS
            return SUCCESS;
          case 1: // SQL_EXCEPTION
            return SQL_EXCEPTION;
          default:
            return null;
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }

    // isset id assignments
    private static final int __SUCCESS_ISSET_ID = 0;
    private byte __isset_bitfield = 0;
    public static final Map<_Fields, org.apache.thrift.meta_data.FieldMetaData> metaDataMap;
    static {
      Map<_Fields, org.apache.thrift.meta_data.FieldMetaData> tmpMap = new EnumMap<_Fields, org.apache.thrift.meta_data.FieldMetaData>(_Fields.class);
      tmpMap.put(_Fields.SUCCESS, new org.apache.thrift.meta_data.FieldMetaData("success", org.apache.thrift.TFieldRequirementType.DEFAULT, 
          new org.apache.thrift.meta_data.FieldValueMetaData(org.apache.thrift.protocol.TType.I32)));
      tmpMap.put(_Fields.SQL_EXCEPTION, new org.apache.thrift.meta_data.FieldMetaData("sqlException", org.apache.thrift.TFieldRequirementType.DEFAULT, 
          new org.apache.thrift.meta_data.FieldValueMetaData(org.apache.thrift.protocol.TType.STRUCT)));
      metaDataMap = Collections.unmodifiableMap(tmpMap);
      org.apache.thrift.meta_data.FieldMetaData.addStructMetaDataMap(preparedstatement_setParametersThenExecuteUpdate_result.class, metaDataMap);
    }

    public preparedstatement_setParametersThenExecuteUpdate_result() {
    }

    public preparedstatement_setParametersThenExecuteUpdate_result(
      int success,
      RSQLException sqlException)
    {
      this();
      this.success = success;
      setSuccessIsSet(true);
      this.sqlException = sqlException;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public preparedstatement_setParametersThenExecuteUpdate_result(preparedstatement_setParametersThenExecuteUpdate_result other) {
      __isset_bitfield = other.__isset_bitfield;
      this.success = other.success;
      if (other.isSetSqlException()) {
        this.sqlException = new RSQLException(other.sqlException);
      }
    }

    public preparedstatement_setParametersThenExecuteUpdate_result deepCopy() {
      return new preparedstatement_setParametersThenExecuteUpdate_result(this);
    }

    @Override
    public void clear() {
      setSuccessIsSet(false);
      this.success = 0;
      this.sqlException = null;
    }

    public int getSuccess() {
      return this.success;
    }

    public preparedstatement_setParametersThenExecuteUpdate_result setSuccess(int success) {
      this.success = success;
      setSuccessIsSet(true);
      return this;
    }

    public void unsetSuccess() {
      __isset_bitfield = EncodingUtils.clearBit(__isset_bitfield, __SUCCESS_ISSET_ID);
    }

    /** Returns true if field success is set (has been assigned a value) and false otherwise */
    public boolean isSetSuccess() {
      return EncodingUtils.testBit(__isset_bitfield, __SUCCESS_ISSET_ID);
    }

    public void setSuccessIsSet(boolean value) {
      __isset_bitfield = EncodingUtils.setBit(__isset_bitfield, __SUCCESS_ISSET_ID, value);
    }

    public RSQLException getSqlException() {
      return this.sqlException;
    }

    public preparedstatement_setParametersThenExecuteUpdate_result setSqlException(RSQLException sqlException) {
      this.sqlException = sqlException;
      return this;
    }

    public void unsetSqlException() {
      this.sqlException = null;
    }

    /** Returns true if field sqlException is set (has been assigned a value) and false otherwise */
    public boolean isSetSqlException() {
      return this.sqlException != null;
    }

    public void setSqlExceptionIsSet(boolean value) {
      if (!value) {
        this.sqlException = null;
      }
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          setSuccess((Integer)value);
        }
        break;

      case SQL_EXCEPTION:
        if (value == null) {
          unsetSqlException();
        } else {
          setSqlException((RSQLException)value);
        }
        break;

      }
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      case SUCCESS:
        return Integer.valueOf(getSuccess());

      case SQL_EXCEPTION:
        return getSqlException();

      }
      throw new IllegalStateException();
    }

    /** Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      if (field == null) {
        throw new IllegalArgumentException();
      }

      switch (field) {
      case SUCCESS:
        return isSetSuccess();
      case SQL_EXCEPTION:
        return isSetSqlException();
      }
      throw new IllegalStateException();
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof preparedstatement_setParametersThenExecuteUpdate_result)
        return this.equals((preparedstatement_setParametersThenExecuteUpdate_result)that);
      return false;
    }

    public boolean equals(preparedstatement_setParametersThenExecuteUpdate_result that) {
      if (that == null)
        return false;

      boolean this_present_success = true;
      boolean that_present_success = true;
      if (this_present_success || that_present_success) {
        if (!(this_present_success && that_present_success))
          return false;
        if (this.success != that.success)
          return false;
      }

      boolean this_present_sqlException = true && this.isSetSqlException();
      boolean that_present_sqlException = true && that.isSetSqlException();
      if (this_present_sqlException || that_present_sqlException) {
        if (!(this_present_sqlException && that_present_sqlException))
          return false;
        if (!this.sqlException.equals(that.sqlException))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      List<Object> list = new ArrayList<Object>();

      boolean present_success = true;
      list.add(present_success);
      if (present_success)
        list.add(success);

      boolean present_sqlException = true && (isSetSqlException());
      list.add(present_sqlException);
      if (present_sqlException)
        list.add(sqlException);

      return list.hashCode();
    }

    @Override
    public int compareTo(preparedstatement_setParametersThenExecuteUpdate_result other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetSuccess()).compareTo(other.isSetSuccess());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetSuccess()) {
        lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.success, other.success);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      lastComparison = Boolean.valueOf(isSetSqlException()).compareTo(other.isSetSqlException());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetSqlException()) {
        lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.sqlException, other.sqlException);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      return 0;
    }

    public _Fields fieldForId(int fieldId) {
      return _Fields.findByThriftId(fieldId);
    }

    public void read(org.apache.thrift.protocol.TProtocol iprot) throws org.apache.thrift.TException {
      schemes.get(iprot.getScheme()).getScheme().read(iprot, this);
    }

    public void write(org.apache.thrift.protocol.TProtocol oprot) throws org.apache.thrift.TException {
      schemes.get(oprot.getScheme()).getScheme().write(oprot, this);
      }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("preparedstatement_setParametersThenExecuteUpdate_result(");
      boolean first = true;

      sb.append("success:");
      sb.append(this.success);
      first = false;
      if (!first) sb.append(", ");
      sb.append("sqlException:");
      if (this.sqlException == null) {
        sb.append("null");
      } else {
        sb.append(this.sqlException);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws org.apache.thrift.TException {
      // check for required fields
      // check for sub-struct validity
    }

    private void writeObject(java.io.ObjectOutputStream out) throws java.io.IOException {
      try {
        write(new org.apache.thrift.protocol.TCompactProtocol(new org.apache.thrift.transport.TIOStreamTransport(out)));
      } catch (org.apache.thrift.TException te) {
        throw new java.io.IOException(te);
      }
    }

    private void readObject(java.io.ObjectInputStream in) throws java.io.IOException, ClassNotFoundException {
      try {
        // it doesn't seem like you should have to do this, but java serialization is wacky, and doesn't call the default constructor.
        __isset_bitfield = 0;
        read(new org.apache.thrift.protocol.TCompactProtocol(new org.apache.thrift.transport.TIOStreamTransport(in)));
      } catch (org.apache.thrift.TException te) {
        throw new java.io.IOException(te);
      }
    }

    private static class preparedstatement_setParametersThenExecuteUpdate_resultStandardSchemeFactory implements SchemeFactory {
      public preparedstatement_setParametersThenExecuteUpdate_resultStandardScheme getScheme() {
        return new preparedstatement_setParametersThenExecuteUpdate_resultStandardScheme();
      }
    }

    private static class preparedstatement_setParametersThenExecuteUpdate_resultStandardScheme extends StandardScheme<preparedstatement_setParametersThenExecuteUpdate_result> {

      public void read(org.apache.thrift.protocol.TProtocol iprot, preparedstatement_setParametersThenExecuteUpdate_result struct) throws org.apache.thrift.TException {
        org.apache.thrift.protocol.TField schemeField;
        iprot.readStructBegin();
        while (true)
        {
          schemeField = iprot.readFieldBegin();
          if (schemeField.type == org.apache.thrift.protocol.TType.STOP) { 
            break;
          }
          switch (schemeField.id) {
            case 0: // SUCCESS
              if (schemeField.type == org.apache.thrift.protocol.TType.I32) {
                struct.success = iprot.readI32();
                struct.setSuccessIsSet(true);
              } else { 
                org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
              }
              break;
            case 1: // SQL_EXCEPTION
              if (schemeField.type == org.apache.thrift.protocol.TType.STRUCT) {
                struct.sqlException = new RSQLException();
                struct.sqlException.read(iprot);
                struct.setSqlExceptionIsSet(true);
              } else { 
                org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
              }
              break;
            default:
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
          }
          iprot.readFieldEnd();
        }
        iprot.readStructEnd();

        // check for required fields of primitive type, which can't be checked in the validate method
        struct.validate();
      }

      public void write(org.apache.thrift.protocol.TProtocol oprot, preparedstatement_setParametersThenExecuteUpdate_result struct) throws org.apache.thrift.TException {
        struct.validate();

        oprot.writeStructBegin(STRUCT_DESC);
        if (struct.isSetSuccess()) {
          oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
          oprot.writeI32(struct.success);
          oprot.writeFieldEnd();
        }
        if (struct.sqlException != null) {
          oprot.writeFieldBegin(SQL_EXCEPTION_FIELD_DESC);
          struct.sqlException.write(oprot);
          oprot.writeFieldEnd();
        }
        oprot.writeFieldStop();
        oprot.writeStructEnd();
      }

    }

    private static class preparedstatement_setParametersThenExecuteUpdate_resultTupleSchemeFactory implements SchemeFactory {
      public preparedstatement_setParametersThenExecuteUpdate_resultTupleScheme getScheme() {
        return new preparedstatement_setParametersThenExecuteUpdate_resultTupleScheme();
      }
    }

    private static class preparedstatement_setParametersThenExecuteUpdate_resultTupleScheme extends TupleScheme<preparedstatement_setParametersThenExecuteUpdate_result> {

      @Override
      public void write(org.apache.thrift.protocol.TProtocol prot, preparedstatement_setParametersThenExecuteUpdate_result struct) throws org.apache.thrift.TException {
        TTupleProtocol oprot = (TTupleProtocol) prot;
        BitSet optionals = new BitSet();
        if (struct.isSetSuccess()) {
          optionals.set(0);
        }
        if (struct.isSetSqlException()) {
          optionals.set(1);
        }
        oprot.writeBitSet(optionals, 2);
        if (struct.isSetSuccess()) {
          oprot.writeI32(struct.success);
        }
        if (struct.isSetSqlException()) {
          struct.sqlException.write(oprot);
        }
      }

      @Override
      public void read(org.apache.thrift.protocol.TProtocol prot, preparedstatement_setParametersThenExecuteUpdate_result struct) throws org.apache.thrift.TException {
        TTupleProtocol iprot = (TTupleProtocol) prot;
        BitSet incoming = iprot.readBitSet(2);
        if (incoming.get(0)) {
          struct.success = iprot.readI32();
          struct.setSuccessIsSet(true);
        }
        if (incoming.get(1)) {
          struct.sqlException = new RSQLException();
          struct.sqlException.read(iprot);
          struct.setSqlExceptionIsSet(true);
        }
      }
    }

  }

  public static class preparedstatement_setParameters_args implements org.apache.thrift.TBase<preparedstatement_setParameters_args, preparedstatement_setParameters_args._Fields>, java.io.Serializable, Cloneable, Comparable<preparedstatement_setParameters_args>   {
    private static final org.apache.thrift.protocol.TStruct STRUCT_DESC = new org.apache.thrift.protocol.TStruct("preparedstatement_setParameters_args");

    private static final org.apache.thrift.protocol.TField PREPARED_STATEMENT_FIELD_DESC = new org.apache.thrift.protocol.TField("preparedStatement", org.apache.thrift.protocol.TType.STRUCT, (short)1);
    private static final org.apache.thrift.protocol.TField PARAMETERS_FIELD_DESC = new org.apache.thrift.protocol.TField("parameters", org.apache.thrift.protocol.TType.LIST, (short)2);

    private static final Map<Class<? extends IScheme>, SchemeFactory> schemes = new HashMap<Class<? extends IScheme>, SchemeFactory>();
    static {
      schemes.put(StandardScheme.class, new preparedstatement_setParameters_argsStandardSchemeFactory());
      schemes.put(TupleScheme.class, new preparedstatement_setParameters_argsTupleSchemeFactory());
    }

    public RStatement preparedStatement; // required
    public List<RValueSQL> parameters; // required

    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements org.apache.thrift.TFieldIdEnum {
      PREPARED_STATEMENT((short)1, "preparedStatement"),
      PARAMETERS((short)2, "parameters");

      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        switch(fieldId) {
          case 1: // PREPARED_STATEMENT
            return PREPARED_STATEMENT;
          case 2: // PARAMETERS
            return PARAMETERS;
          default:
            return null;
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }

    // isset id assignments
    public static final Map<_Fields, org.apache.thrift.meta_data.FieldMetaData> metaDataMap;
    static {
      Map<_Fields, org.apache.thrift.meta_data.FieldMetaData> tmpMap = new EnumMap<_Fields, org.apache.thrift.meta_data.FieldMetaData>(_Fields.class);
      tmpMap.put(_Fields.PREPARED_STATEMENT, new org.apache.thrift.meta_data.FieldMetaData("preparedStatement", org.apache.thrift.TFieldRequirementType.DEFAULT, 
          new org.apache.thrift.meta_data.StructMetaData(org.apache.thrift.protocol.TType.STRUCT, RStatement.class)));
      tmpMap.put(_Fields.PARAMETERS, new org.apache.thrift.meta_data.FieldMetaData("parameters", org.apache.thrift.TFieldRequirementType.DEFAULT, 
          new org.apache.thrift.meta_data.ListMetaData(org.apache.thrift.protocol.TType.LIST, 
              new org.apache.thrift.meta_data.StructMetaData(org.apache.thrift.protocol.TType.STRUCT, RValueSQL.class))));
      metaDataMap = Collections.unmodifiableMap(tmpMap);
      org.apache.thrift.meta_data.FieldMetaData.addStructMetaDataMap(preparedstatement_setParameters_args.class, metaDataMap);
    }

    public preparedstatement_setParameters_args() {
    }

    public preparedstatement_setParameters_args(
      RStatement preparedStatement,
      List<RValueSQL> parameters)
    {
      this();
      this.preparedStatement = preparedStatement;
      this.parameters = parameters;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public preparedstatement_setParameters_args(preparedstatement_setParameters_args other) {
      if (other.isSetPreparedStatement()) {
        this.preparedStatement = new RStatement(other.preparedStatement);
      }
      if (other.isSetParameters()) {
        List<RValueSQL> __this__parameters = new ArrayList<RValueSQL>(other.parameters.size());
        for (RValueSQL other_element : other.parameters) {
          __this__parameters.add(new RValueSQL(other_element));
        }
        this.parameters = __this__parameters;
      }
    }

    public preparedstatement_setParameters_args deepCopy() {
      return new preparedstatement_setParameters_args(this);
    }

    @Override
    public void clear() {
      this.preparedStatement = null;
      this.parameters = null;
    }

    public RStatement getPreparedStatement() {
      return this.preparedStatement;
    }

    public preparedstatement_setParameters_args setPreparedStatement(RStatement preparedStatement) {
      this.preparedStatement = preparedStatement;
      return this;
    }

    public void unsetPreparedStatement() {
      this.preparedStatement = null;
    }

    /** Returns true if field preparedStatement is set (has been assigned a value) and false otherwise */
    public boolean isSetPreparedStatement() {
      return this.preparedStatement != null;
    }

    public void setPreparedStatementIsSet(boolean value) {
      if (!value) {
        this.preparedStatement = null;
      }
    }

    public int getParametersSize() {
      return (this.parameters == null) ? 0 : this.parameters.size();
    }

    public java.util.Iterator<RValueSQL> getParametersIterator() {
      return (this.parameters == null) ? null : this.parameters.iterator();
    }

    public void addToParameters(RValueSQL elem) {
      if (this.parameters == null) {
        this.parameters = new ArrayList<RValueSQL>();
      }
      this.parameters.add(elem);
    }

    public List<RValueSQL> getParameters() {
      return this.parameters;
    }

    public preparedstatement_setParameters_args setParameters(List<RValueSQL> parameters) {
      this.parameters = parameters;
      return this;
    }

    public void unsetParameters() {
      this.parameters = null;
    }

    /** Returns true if field parameters is set (has been assigned a value) and false otherwise */
    public boolean isSetParameters() {
      return this.parameters != null;
    }

    public void setParametersIsSet(boolean value) {
      if (!value) {
        this.parameters = null;
      }
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      case PREPARED_STATEMENT:
        if (value == null) {
          unsetPreparedStatement();
        } else {
          setPreparedStatement((RStatement)value);
        }
        break;

      case PARAMETERS:
        if (value == null) {
          unsetParameters();
        } else {
          setParameters((List<RValueSQL>)value);
        }
        break;

      }
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      case PREPARED_STATEMENT:
        return getPreparedStatement();

      case PARAMETERS:
        return getParameters();

      }
      throw new IllegalStateException();
    }

    /** Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      if (field == null) {
        throw new IllegalArgumentException();
      }

      switch (field) {
      case PREPARED_STATEMENT:
        return isSetPreparedStatement();
      case PARAMETERS:
        return isSetParameters();
      }
      throw new IllegalStateException();
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof preparedstatement_setParameters_args)
        return this.equals((preparedstatement_setParameters_args)that);
      return false;
    }

    public boolean equals(preparedstatement_setParameters_args that) {
      if (that == null)
        return false;

      boolean this_present_preparedStatement = true && this.isSetPreparedStatement();
      boolean that_present_preparedStatement = true && that.isSetPreparedStatement();
      if (this_present_preparedStatement || that_present_preparedStatement) {
        if (!(this_present_preparedStatement && that_present_preparedStatement))
          return false;
        if (!this.preparedStatement.equals(that.preparedStatement))
          return false;
      }

      boolean this_present_parameters = true && this.isSetParameters();
      boolean that_present_parameters = true && that.isSetParameters();
      if (this_present_parameters || that_present_parameters) {
        if (!(this_present_parameters && that_present_parameters))
          return false;
        if (!this.parameters.equals(that.parameters))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      List<Object> list = new ArrayList<Object>();

      boolean present_preparedStatement = true && (isSetPreparedStatement());
      list.add(present_preparedStatement);
      if (present_preparedStatement)
        list.add(preparedStatement);

      boolean present_parameters = true && (isSetParameters());
      list.add(present_parameters);
      if (present_parameters)
        list.add(parameters);

      return list.hashCode();
    }

    @Override
    public int compareTo(preparedstatement_setParameters_args other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetPreparedStatement()).compareTo(other.isSetPreparedStatement());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetPreparedStatement()) {
        lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.preparedStatement, other.preparedStatement);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      lastComparison = Boolean.valueOf(isSetParameters()).compareTo(other.isSetParameters());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetParameters()) {
        lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.parameters, other.parameters);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      return 0;
    }

    public _Fields fieldForId(int fieldId) {
      return _Fields.findByThriftId(fieldId);
    }

    public void read(org.apache.thrift.protocol.TProtocol iprot) throws org.apache.thrift.TException {
      schemes.get(iprot.getScheme()).getScheme().read(iprot, this);
    }

    public void write(org.apache.thrift.protocol.TProtocol oprot) throws org.apache.thrift.TException {
      schemes.get(oprot.getScheme()).getScheme().write(oprot, this);
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("preparedstatement_setParameters_args(");
      boolean first = true;

      sb.append("preparedStatement:");
      if (this.preparedStatement == null) {
        sb.append("null");
      } else {
        sb.append(this.preparedStatement);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("parameters:");
      if (this.parameters == null) {
        sb.append("null");
      } else {
        sb.append(this.parameters);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws org.apache.thrift.TException {
      // check for required fields
      // check for sub-struct validity
      if (preparedStatement != null) {
        preparedStatement.validate();
      }
    }

    private void writeObject(java.io.ObjectOutputStream out) throws java.io.IOException {
      try {
        write(new org.apache.thrift.protocol.TCompactProtocol(new org.apache.thrift.transport.TIOStreamTransport(out)));
      } catch (org.apache.thrift.TException te) {
        throw new java.io.IOException(te);
      }
    }

    private void readObject(java.io.ObjectInputStream in) throws java.io.IOException, ClassNotFoundException {
      try {
        read(new org.apache.thrift.protocol.TCompactProtocol(new org.apache.thrift.transport.TIOStreamTransport(in)));
      } catch (org.apache.thrift.TException te) {
        throw new java.io.IOException(te);
      }
    }

    private static class preparedstatement_setParameters_argsStandardSchemeFactory implements SchemeFactory {
      public preparedstatement_setParameters_argsStandardScheme getScheme() {
        return new preparedstatement_setParameters_argsStandardScheme();
      }
    }

    private static class preparedstatement_setParameters_argsStandardScheme extends StandardScheme<preparedstatement_setParameters_args> {

      public void read(org.apache.thrift.protocol.TProtocol iprot, preparedstatement_setParameters_args struct) throws org.apache.thrift.TException {
        org.apache.thrift.protocol.TField schemeField;
        iprot.readStructBegin();
        while (true)
        {
          schemeField = iprot.readFieldBegin();
          if (schemeField.type == org.apache.thrift.protocol.TType.STOP) { 
            break;
          }
          switch (schemeField.id) {
            case 1: // PREPARED_STATEMENT
              if (schemeField.type == org.apache.thrift.protocol.TType.STRUCT) {
                struct.preparedStatement = new RStatement();
                struct.preparedStatement.read(iprot);
                struct.setPreparedStatementIsSet(true);
              } else { 
                org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
              }
              break;
            case 2: // PARAMETERS
              if (schemeField.type == org.apache.thrift.protocol.TType.LIST) {
                {
                  org.apache.thrift.protocol.TList _list98 = iprot.readListBegin();
                  struct.parameters = new ArrayList<RValueSQL>(_list98.size);
                  RValueSQL _elem99;
                  for (int _i100 = 0; _i100 < _list98.size; ++_i100)
                  {
                    _elem99 = new RValueSQL();
                    _elem99.read(iprot);
                    struct.parameters.add(_elem99);
                  }
                  iprot.readListEnd();
                }
                struct.setParametersIsSet(true);
              } else { 
                org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
              }
              break;
            default:
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
          }
          iprot.readFieldEnd();
        }
        iprot.readStructEnd();

        // check for required fields of primitive type, which can't be checked in the validate method
        struct.validate();
      }

      public void write(org.apache.thrift.protocol.TProtocol oprot, preparedstatement_setParameters_args struct) throws org.apache.thrift.TException {
        struct.validate();

        oprot.writeStructBegin(STRUCT_DESC);
        if (struct.preparedStatement != null) {
          oprot.writeFieldBegin(PREPARED_STATEMENT_FIELD_DESC);
          struct.preparedStatement.write(oprot);
          oprot.writeFieldEnd();
        }
        if (struct.parameters != null) {
          oprot.writeFieldBegin(PARAMETERS_FIELD_DESC);
          {
            oprot.writeListBegin(new org.apache.thrift.protocol.TList(org.apache.thrift.protocol.TType.STRUCT, struct.parameters.size()));
            for (RValueSQL _iter101 : struct.parameters)
            {
              _iter101.write(oprot);
            }
            oprot.writeListEnd();
          }
          oprot.writeFieldEnd();
        }
        oprot.writeFieldStop();
        oprot.writeStructEnd();
      }

    }

    private static class preparedstatement_setParameters_argsTupleSchemeFactory implements SchemeFactory {
      public preparedstatement_setParameters_argsTupleScheme getScheme() {
        return new preparedstatement_setParameters_argsTupleScheme();
      }
    }

    private static class preparedstatement_setParameters_argsTupleScheme extends TupleScheme<preparedstatement_setParameters_args> {

      @Override
      public void write(org.apache.thrift.protocol.TProtocol prot, preparedstatement_setParameters_args struct) throws org.apache.thrift.TException {
        TTupleProtocol oprot = (TTupleProtocol) prot;
        BitSet optionals = new BitSet();
        if (struct.isSetPreparedStatement()) {
          optionals.set(0);
        }
        if (struct.isSetParameters()) {
          optionals.set(1);
        }
        oprot.writeBitSet(optionals, 2);
        if (struct.isSetPreparedStatement()) {
          struct.preparedStatement.write(oprot);
        }
        if (struct.isSetParameters()) {
          {
            oprot.writeI32(struct.parameters.size());
            for (RValueSQL _iter102 : struct.parameters)
            {
              _iter102.write(oprot);
            }
          }
        }
      }

      @Override
      public void read(org.apache.thrift.protocol.TProtocol prot, preparedstatement_setParameters_args struct) throws org.apache.thrift.TException {
        TTupleProtocol iprot = (TTupleProtocol) prot;
        BitSet incoming = iprot.readBitSet(2);
        if (incoming.get(0)) {
          struct.preparedStatement = new RStatement();
          struct.preparedStatement.read(iprot);
          struct.setPreparedStatementIsSet(true);
        }
        if (incoming.get(1)) {
          {
            org.apache.thrift.protocol.TList _list103 = new org.apache.thrift.protocol.TList(org.apache.thrift.protocol.TType.STRUCT, iprot.readI32());
            struct.parameters = new ArrayList<RValueSQL>(_list103.size);
            RValueSQL _elem104;
            for (int _i105 = 0; _i105 < _list103.size; ++_i105)
            {
              _elem104 = new RValueSQL();
              _elem104.read(iprot);
              struct.parameters.add(_elem104);
            }
          }
          struct.setParametersIsSet(true);
        }
      }
    }

  }

  public static class preparedstatement_setParameters_result implements org.apache.thrift.TBase<preparedstatement_setParameters_result, preparedstatement_setParameters_result._Fields>, java.io.Serializable, Cloneable, Comparable<preparedstatement_setParameters_result>   {
    private static final org.apache.thrift.protocol.TStruct STRUCT_DESC = new org.apache.thrift.protocol.TStruct("preparedstatement_setParameters_result");

    private static final org.apache.thrift.protocol.TField SQL_EXCEPTION_FIELD_DESC = new org.apache.thrift.protocol.TField("sqlException", org.apache.thrift.protocol.TType.STRUCT, (short)1);

    private static final Map<Class<? extends IScheme>, SchemeFactory> schemes = new HashMap<Class<? extends IScheme>, SchemeFactory>();
    static {
      schemes.put(StandardScheme.class, new preparedstatement_setParameters_resultStandardSchemeFactory());
      schemes.put(TupleScheme.class, new preparedstatement_setParameters_resultTupleSchemeFactory());
    }

    public RSQLException sqlException; // required

    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements org.apache.thrift.TFieldIdEnum {
      SQL_EXCEPTION((short)1, "sqlException");

      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        switch(fieldId) {
          case 1: // SQL_EXCEPTION
            return SQL_EXCEPTION;
          default:
            return null;
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }

    // isset id assignments
    public static final Map<_Fields, org.apache.thrift.meta_data.FieldMetaData> metaDataMap;
    static {
      Map<_Fields, org.apache.thrift.meta_data.FieldMetaData> tmpMap = new EnumMap<_Fields, org.apache.thrift.meta_data.FieldMetaData>(_Fields.class);
      tmpMap.put(_Fields.SQL_EXCEPTION, new org.apache.thrift.meta_data.FieldMetaData("sqlException", org.apache.thrift.TFieldRequirementType.DEFAULT, 
          new org.apache.thrift.meta_data.FieldValueMetaData(org.apache.thrift.protocol.TType.STRUCT)));
      metaDataMap = Collections.unmodifiableMap(tmpMap);
      org.apache.thrift.meta_data.FieldMetaData.addStructMetaDataMap(preparedstatement_setParameters_result.class, metaDataMap);
    }

    public preparedstatement_setParameters_result() {
    }

    public preparedstatement_setParameters_result(
      RSQLException sqlException)
    {
      this();
      this.sqlException = sqlException;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public preparedstatement_setParameters_result(preparedstatement_setParameters_result other) {
      if (other.isSetSqlException()) {
        this.sqlException = new RSQLException(other.sqlException);
      }
    }

    public preparedstatement_setParameters_result deepCopy() {
      return new preparedstatement_setParameters_result(this);
    }

    @Override
    public void clear() {
      this.sqlException = null;
    }

    public RSQLException getSqlException() {
      return this.sqlException;
    }

    public preparedstatement_setParameters_result setSqlException(RSQLException sqlException) {
      this.sqlException = sqlException;
      return this;
    }

    public void unsetSqlException() {
      this.sqlException = null;
    }

    /** Returns true if field sqlException is set (has been assigned a value) and false otherwise */
    public boolean isSetSqlException() {
      return this.sqlException != null;
    }

    public void setSqlExceptionIsSet(boolean value) {
      if (!value) {
        this.sqlException = null;
      }
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      case SQL_EXCEPTION:
        if (value == null) {
          unsetSqlException();
        } else {
          setSqlException((RSQLException)value);
        }
        break;

      }
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      case SQL_EXCEPTION:
        return getSqlException();

      }
      throw new IllegalStateException();
    }

    /** Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      if (field == null) {
        throw new IllegalArgumentException();
      }

      switch (field) {
      case SQL_EXCEPTION:
        return isSetSqlException();
      }
      throw new IllegalStateException();
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof preparedstatement_setParameters_result)
        return this.equals((preparedstatement_setParameters_result)that);
      return false;
    }

    public boolean equals(preparedstatement_setParameters_result that) {
      if (that == null)
        return false;

      boolean this_present_sqlException = true && this.isSetSqlException();
      boolean that_present_sqlException = true && that.isSetSqlException();
      if (this_present_sqlException || that_present_sqlException) {
        if (!(this_present_sqlException && that_present_sqlException))
          return false;
        if (!this.sqlException.equals(that.sqlException))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      List<Object> list = new ArrayList<Object>();

      boolean present_sqlException = true && (isSetSqlException());
      list.add(present_sqlException);
      if (present_sqlException)
        list.add(sqlException);

      return list.hashCode();
    }

    @Override
    public int compareTo(preparedstatement_setParameters_result other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetSqlException()).compareTo(other.isSetSqlException());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetSqlException()) {
        lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.sqlException, other.sqlException);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      return 0;
    }

    public _Fields fieldForId(int fieldId) {
      return _Fields.findByThriftId(fieldId);
    }

    public void read(org.apache.thrift.protocol.TProtocol iprot) throws org.apache.thrift.TException {
      schemes.get(iprot.getScheme()).getScheme().read(iprot, this);
    }

    public void write(org.apache.thrift.protocol.TProtocol oprot) throws org.apache.thrift.TException {
      schemes.get(oprot.getScheme()).getScheme().write(oprot, this);
      }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("preparedstatement_setParameters_result(");
      boolean first = true;

      sb.append("sqlException:");
      if (this.sqlException == null) {
        sb.append("null");
      } else {
        sb.append(this.sqlException);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws org.apache.thrift.TException {
      // check for required fields
      // check for sub-struct validity
    }

    private void writeObject(java.io.ObjectOutputStream out) throws java.io.IOException {
      try {
        write(new org.apache.thrift.protocol.TCompactProtocol(new org.apache.thrift.transport.TIOStreamTransport(out)));
      } catch (org.apache.thrift.TException te) {
        throw new java.io.IOException(te);
      }
    }

    private void readObject(java.io.ObjectInputStream in) throws java.io.IOException, ClassNotFoundException {
      try {
        read(new org.apache.thrift.protocol.TCompactProtocol(new org.apache.thrift.transport.TIOStreamTransport(in)));
      } catch (org.apache.thrift.TException te) {
        throw new java.io.IOException(te);
      }
    }

    private static class preparedstatement_setParameters_resultStandardSchemeFactory implements SchemeFactory {
      public preparedstatement_setParameters_resultStandardScheme getScheme() {
        return new preparedstatement_setParameters_resultStandardScheme();
      }
    }

    private static class preparedstatement_setParameters_resultStandardScheme extends StandardScheme<preparedstatement_setParameters_result> {

      public void read(org.apache.thrift.protocol.TProtocol iprot, preparedstatement_setParameters_result struct) throws org.apache.thrift.TException {
        org.apache.thrift.protocol.TField schemeField;
        iprot.readStructBegin();
        while (true)
        {
          schemeField = iprot.readFieldBegin();
          if (schemeField.type == org.apache.thrift.protocol.TType.STOP) { 
            break;
          }
          switch (schemeField.id) {
            case 1: // SQL_EXCEPTION
              if (schemeField.type == org.apache.thrift.protocol.TType.STRUCT) {
                struct.sqlException = new RSQLException();
                struct.sqlException.read(iprot);
                struct.setSqlExceptionIsSet(true);
              } else { 
                org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
              }
              break;
            default:
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
          }
          iprot.readFieldEnd();
        }
        iprot.readStructEnd();

        // check for required fields of primitive type, which can't be checked in the validate method
        struct.validate();
      }

      public void write(org.apache.thrift.protocol.TProtocol oprot, preparedstatement_setParameters_result struct) throws org.apache.thrift.TException {
        struct.validate();

        oprot.writeStructBegin(STRUCT_DESC);
        if (struct.sqlException != null) {
          oprot.writeFieldBegin(SQL_EXCEPTION_FIELD_DESC);
          struct.sqlException.write(oprot);
          oprot.writeFieldEnd();
        }
        oprot.writeFieldStop();
        oprot.writeStructEnd();
      }

    }

    private static class preparedstatement_setParameters_resultTupleSchemeFactory implements SchemeFactory {
      public preparedstatement_setParameters_resultTupleScheme getScheme() {
        return new preparedstatement_setParameters_resultTupleScheme();
      }
    }

    private static class preparedstatement_setParameters_resultTupleScheme extends TupleScheme<preparedstatement_setParameters_result> {

      @Override
      public void write(org.apache.thrift.protocol.TProtocol prot, preparedstatement_setParameters_result struct) throws org.apache.thrift.TException {
        TTupleProtocol oprot = (TTupleProtocol) prot;
        BitSet optionals = new BitSet();
        if (struct.isSetSqlException()) {
          optionals.set(0);
        }
        oprot.writeBitSet(optionals, 1);
        if (struct.isSetSqlException()) {
          struct.sqlException.write(oprot);
        }
      }

      @Override
      public void read(org.apache.thrift.protocol.TProtocol prot, preparedstatement_setParameters_result struct) throws org.apache.thrift.TException {
        TTupleProtocol iprot = (TTupleProtocol) prot;
        BitSet incoming = iprot.readBitSet(1);
        if (incoming.get(0)) {
          struct.sqlException = new RSQLException();
          struct.sqlException.read(iprot);
          struct.setSqlExceptionIsSet(true);
        }
      }
    }

  }

  public static class preparedstatement_setParameter_args implements org.apache.thrift.TBase<preparedstatement_setParameter_args, preparedstatement_setParameter_args._Fields>, java.io.Serializable, Cloneable, Comparable<preparedstatement_setParameter_args>   {
    private static final org.apache.thrift.protocol.TStruct STRUCT_DESC = new org.apache.thrift.protocol.TStruct("preparedstatement_setParameter_args");

    private static final org.apache.thrift.protocol.TField PREPARED_STATEMENT_FIELD_DESC = new org.apache.thrift.protocol.TField("preparedStatement", org.apache.thrift.protocol.TType.STRUCT, (short)1);
    private static final org.apache.thrift.protocol.TField PARAMETER_FIELD_DESC = new org.apache.thrift.protocol.TField("parameter", org.apache.thrift.protocol.TType.STRUCT, (short)2);
    private static final org.apache.thrift.protocol.TField POSITION_FIELD_DESC = new org.apache.thrift.protocol.TField("position", org.apache.thrift.protocol.TType.I32, (short)3);

    private static final Map<Class<? extends IScheme>, SchemeFactory> schemes = new HashMap<Class<? extends IScheme>, SchemeFactory>();
    static {
      schemes.put(StandardScheme.class, new preparedstatement_setParameter_argsStandardSchemeFactory());
      schemes.put(TupleScheme.class, new preparedstatement_setParameter_argsTupleSchemeFactory());
    }

    public RStatement preparedStatement; // required
    public RValueSQL parameter; // required
    public int position; // required

    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements org.apache.thrift.TFieldIdEnum {
      PREPARED_STATEMENT((short)1, "preparedStatement"),
      PARAMETER((short)2, "parameter"),
      POSITION((short)3, "position");

      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        switch(fieldId) {
          case 1: // PREPARED_STATEMENT
            return PREPARED_STATEMENT;
          case 2: // PARAMETER
            return PARAMETER;
          case 3: // POSITION
            return POSITION;
          default:
            return null;
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }

    // isset id assignments
    private static final int __POSITION_ISSET_ID = 0;
    private byte __isset_bitfield = 0;
    public static final Map<_Fields, org.apache.thrift.meta_data.FieldMetaData> metaDataMap;
    static {
      Map<_Fields, org.apache.thrift.meta_data.FieldMetaData> tmpMap = new EnumMap<_Fields, org.apache.thrift.meta_data.FieldMetaData>(_Fields.class);
      tmpMap.put(_Fields.PREPARED_STATEMENT, new org.apache.thrift.meta_data.FieldMetaData("preparedStatement", org.apache.thrift.TFieldRequirementType.DEFAULT, 
          new org.apache.thrift.meta_data.StructMetaData(org.apache.thrift.protocol.TType.STRUCT, RStatement.class)));
      tmpMap.put(_Fields.PARAMETER, new org.apache.thrift.meta_data.FieldMetaData("parameter", org.apache.thrift.TFieldRequirementType.DEFAULT, 
          new org.apache.thrift.meta_data.StructMetaData(org.apache.thrift.protocol.TType.STRUCT, RValueSQL.class)));
      tmpMap.put(_Fields.POSITION, new org.apache.thrift.meta_data.FieldMetaData("position", org.apache.thrift.TFieldRequirementType.DEFAULT, 
          new org.apache.thrift.meta_data.FieldValueMetaData(org.apache.thrift.protocol.TType.I32)));
      metaDataMap = Collections.unmodifiableMap(tmpMap);
      org.apache.thrift.meta_data.FieldMetaData.addStructMetaDataMap(preparedstatement_setParameter_args.class, metaDataMap);
    }

    public preparedstatement_setParameter_args() {
    }

    public preparedstatement_setParameter_args(
      RStatement preparedStatement,
      RValueSQL parameter,
      int position)
    {
      this();
      this.preparedStatement = preparedStatement;
      this.parameter = parameter;
      this.position = position;
      setPositionIsSet(true);
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public preparedstatement_setParameter_args(preparedstatement_setParameter_args other) {
      __isset_bitfield = other.__isset_bitfield;
      if (other.isSetPreparedStatement()) {
        this.preparedStatement = new RStatement(other.preparedStatement);
      }
      if (other.isSetParameter()) {
        this.parameter = new RValueSQL(other.parameter);
      }
      this.position = other.position;
    }

    public preparedstatement_setParameter_args deepCopy() {
      return new preparedstatement_setParameter_args(this);
    }

    @Override
    public void clear() {
      this.preparedStatement = null;
      this.parameter = null;
      setPositionIsSet(false);
      this.position = 0;
    }

    public RStatement getPreparedStatement() {
      return this.preparedStatement;
    }

    public preparedstatement_setParameter_args setPreparedStatement(RStatement preparedStatement) {
      this.preparedStatement = preparedStatement;
      return this;
    }

    public void unsetPreparedStatement() {
      this.preparedStatement = null;
    }

    /** Returns true if field preparedStatement is set (has been assigned a value) and false otherwise */
    public boolean isSetPreparedStatement() {
      return this.preparedStatement != null;
    }

    public void setPreparedStatementIsSet(boolean value) {
      if (!value) {
        this.preparedStatement = null;
      }
    }

    public RValueSQL getParameter() {
      return this.parameter;
    }

    public preparedstatement_setParameter_args setParameter(RValueSQL parameter) {
      this.parameter = parameter;
      return this;
    }

    public void unsetParameter() {
      this.parameter = null;
    }

    /** Returns true if field parameter is set (has been assigned a value) and false otherwise */
    public boolean isSetParameter() {
      return this.parameter != null;
    }

    public void setParameterIsSet(boolean value) {
      if (!value) {
        this.parameter = null;
      }
    }

    public int getPosition() {
      return this.position;
    }

    public preparedstatement_setParameter_args setPosition(int position) {
      this.position = position;
      setPositionIsSet(true);
      return this;
    }

    public void unsetPosition() {
      __isset_bitfield = EncodingUtils.clearBit(__isset_bitfield, __POSITION_ISSET_ID);
    }

    /** Returns true if field position is set (has been assigned a value) and false otherwise */
    public boolean isSetPosition() {
      return EncodingUtils.testBit(__isset_bitfield, __POSITION_ISSET_ID);
    }

    public void setPositionIsSet(boolean value) {
      __isset_bitfield = EncodingUtils.setBit(__isset_bitfield, __POSITION_ISSET_ID, value);
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      case PREPARED_STATEMENT:
        if (value == null) {
          unsetPreparedStatement();
        } else {
          setPreparedStatement((RStatement)value);
        }
        break;

      case PARAMETER:
        if (value == null) {
          unsetParameter();
        } else {
          setParameter((RValueSQL)value);
        }
        break;

      case POSITION:
        if (value == null) {
          unsetPosition();
        } else {
          setPosition((Integer)value);
        }
        break;

      }
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      case PREPARED_STATEMENT:
        return getPreparedStatement();

      case PARAMETER:
        return getParameter();

      case POSITION:
        return Integer.valueOf(getPosition());

      }
      throw new IllegalStateException();
    }

    /** Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      if (field == null) {
        throw new IllegalArgumentException();
      }

      switch (field) {
      case PREPARED_STATEMENT:
        return isSetPreparedStatement();
      case PARAMETER:
        return isSetParameter();
      case POSITION:
        return isSetPosition();
      }
      throw new IllegalStateException();
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof preparedstatement_setParameter_args)
        return this.equals((preparedstatement_setParameter_args)that);
      return false;
    }

    public boolean equals(preparedstatement_setParameter_args that) {
      if (that == null)
        return false;

      boolean this_present_preparedStatement = true && this.isSetPreparedStatement();
      boolean that_present_preparedStatement = true && that.isSetPreparedStatement();
      if (this_present_preparedStatement || that_present_preparedStatement) {
        if (!(this_present_preparedStatement && that_present_preparedStatement))
          return false;
        if (!this.preparedStatement.equals(that.preparedStatement))
          return false;
      }

      boolean this_present_parameter = true && this.isSetParameter();
      boolean that_present_parameter = true && that.isSetParameter();
      if (this_present_parameter || that_present_parameter) {
        if (!(this_present_parameter && that_present_parameter))
          return false;
        if (!this.parameter.equals(that.parameter))
          return false;
      }

      boolean this_present_position = true;
      boolean that_present_position = true;
      if (this_present_position || that_present_position) {
        if (!(this_present_position && that_present_position))
          return false;
        if (this.position != that.position)
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      List<Object> list = new ArrayList<Object>();

      boolean present_preparedStatement = true && (isSetPreparedStatement());
      list.add(present_preparedStatement);
      if (present_preparedStatement)
        list.add(preparedStatement);

      boolean present_parameter = true && (isSetParameter());
      list.add(present_parameter);
      if (present_parameter)
        list.add(parameter);

      boolean present_position = true;
      list.add(present_position);
      if (present_position)
        list.add(position);

      return list.hashCode();
    }

    @Override
    public int compareTo(preparedstatement_setParameter_args other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetPreparedStatement()).compareTo(other.isSetPreparedStatement());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetPreparedStatement()) {
        lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.preparedStatement, other.preparedStatement);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      lastComparison = Boolean.valueOf(isSetParameter()).compareTo(other.isSetParameter());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetParameter()) {
        lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.parameter, other.parameter);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      lastComparison = Boolean.valueOf(isSetPosition()).compareTo(other.isSetPosition());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetPosition()) {
        lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.position, other.position);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      return 0;
    }

    public _Fields fieldForId(int fieldId) {
      return _Fields.findByThriftId(fieldId);
    }

    public void read(org.apache.thrift.protocol.TProtocol iprot) throws org.apache.thrift.TException {
      schemes.get(iprot.getScheme()).getScheme().read(iprot, this);
    }

    public void write(org.apache.thrift.protocol.TProtocol oprot) throws org.apache.thrift.TException {
      schemes.get(oprot.getScheme()).getScheme().write(oprot, this);
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("preparedstatement_setParameter_args(");
      boolean first = true;

      sb.append("preparedStatement:");
      if (this.preparedStatement == null) {
        sb.append("null");
      } else {
        sb.append(this.preparedStatement);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("parameter:");
      if (this.parameter == null) {
        sb.append("null");
      } else {
        sb.append(this.parameter);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("position:");
      sb.append(this.position);
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws org.apache.thrift.TException {
      // check for required fields
      // check for sub-struct validity
      if (preparedStatement != null) {
        preparedStatement.validate();
      }
      if (parameter != null) {
        parameter.validate();
      }
    }

    private void writeObject(java.io.ObjectOutputStream out) throws java.io.IOException {
      try {
        write(new org.apache.thrift.protocol.TCompactProtocol(new org.apache.thrift.transport.TIOStreamTransport(out)));
      } catch (org.apache.thrift.TException te) {
        throw new java.io.IOException(te);
      }
    }

    private void readObject(java.io.ObjectInputStream in) throws java.io.IOException, ClassNotFoundException {
      try {
        // it doesn't seem like you should have to do this, but java serialization is wacky, and doesn't call the default constructor.
        __isset_bitfield = 0;
        read(new org.apache.thrift.protocol.TCompactProtocol(new org.apache.thrift.transport.TIOStreamTransport(in)));
      } catch (org.apache.thrift.TException te) {
        throw new java.io.IOException(te);
      }
    }

    private static class preparedstatement_setParameter_argsStandardSchemeFactory implements SchemeFactory {
      public preparedstatement_setParameter_argsStandardScheme getScheme() {
        return new preparedstatement_setParameter_argsStandardScheme();
      }
    }

    private static class preparedstatement_setParameter_argsStandardScheme extends StandardScheme<preparedstatement_setParameter_args> {

      public void read(org.apache.thrift.protocol.TProtocol iprot, preparedstatement_setParameter_args struct) throws org.apache.thrift.TException {
        org.apache.thrift.protocol.TField schemeField;
        iprot.readStructBegin();
        while (true)
        {
          schemeField = iprot.readFieldBegin();
          if (schemeField.type == org.apache.thrift.protocol.TType.STOP) { 
            break;
          }
          switch (schemeField.id) {
            case 1: // PREPARED_STATEMENT
              if (schemeField.type == org.apache.thrift.protocol.TType.STRUCT) {
                struct.preparedStatement = new RStatement();
                struct.preparedStatement.read(iprot);
                struct.setPreparedStatementIsSet(true);
              } else { 
                org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
              }
              break;
            case 2: // PARAMETER
              if (schemeField.type == org.apache.thrift.protocol.TType.STRUCT) {
                struct.parameter = new RValueSQL();
                struct.parameter.read(iprot);
                struct.setParameterIsSet(true);
              } else { 
                org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
              }
              break;
            case 3: // POSITION
              if (schemeField.type == org.apache.thrift.protocol.TType.I32) {
                struct.position = iprot.readI32();
                struct.setPositionIsSet(true);
              } else { 
                org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
              }
              break;
            default:
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
          }
          iprot.readFieldEnd();
        }
        iprot.readStructEnd();

        // check for required fields of primitive type, which can't be checked in the validate method
        struct.validate();
      }

      public void write(org.apache.thrift.protocol.TProtocol oprot, preparedstatement_setParameter_args struct) throws org.apache.thrift.TException {
        struct.validate();

        oprot.writeStructBegin(STRUCT_DESC);
        if (struct.preparedStatement != null) {
          oprot.writeFieldBegin(PREPARED_STATEMENT_FIELD_DESC);
          struct.preparedStatement.write(oprot);
          oprot.writeFieldEnd();
        }
        if (struct.parameter != null) {
          oprot.writeFieldBegin(PARAMETER_FIELD_DESC);
          struct.parameter.write(oprot);
          oprot.writeFieldEnd();
        }
        oprot.writeFieldBegin(POSITION_FIELD_DESC);
        oprot.writeI32(struct.position);
        oprot.writeFieldEnd();
        oprot.writeFieldStop();
        oprot.writeStructEnd();
      }

    }

    private static class preparedstatement_setParameter_argsTupleSchemeFactory implements SchemeFactory {
      public preparedstatement_setParameter_argsTupleScheme getScheme() {
        return new preparedstatement_setParameter_argsTupleScheme();
      }
    }

    private static class preparedstatement_setParameter_argsTupleScheme extends TupleScheme<preparedstatement_setParameter_args> {

      @Override
      public void write(org.apache.thrift.protocol.TProtocol prot, preparedstatement_setParameter_args struct) throws org.apache.thrift.TException {
        TTupleProtocol oprot = (TTupleProtocol) prot;
        BitSet optionals = new BitSet();
        if (struct.isSetPreparedStatement()) {
          optionals.set(0);
        }
        if (struct.isSetParameter()) {
          optionals.set(1);
        }
        if (struct.isSetPosition()) {
          optionals.set(2);
        }
        oprot.writeBitSet(optionals, 3);
        if (struct.isSetPreparedStatement()) {
          struct.preparedStatement.write(oprot);
        }
        if (struct.isSetParameter()) {
          struct.parameter.write(oprot);
        }
        if (struct.isSetPosition()) {
          oprot.writeI32(struct.position);
        }
      }

      @Override
      public void read(org.apache.thrift.protocol.TProtocol prot, preparedstatement_setParameter_args struct) throws org.apache.thrift.TException {
        TTupleProtocol iprot = (TTupleProtocol) prot;
        BitSet incoming = iprot.readBitSet(3);
        if (incoming.get(0)) {
          struct.preparedStatement = new RStatement();
          struct.preparedStatement.read(iprot);
          struct.setPreparedStatementIsSet(true);
        }
        if (incoming.get(1)) {
          struct.parameter = new RValueSQL();
          struct.parameter.read(iprot);
          struct.setParameterIsSet(true);
        }
        if (incoming.get(2)) {
          struct.position = iprot.readI32();
          struct.setPositionIsSet(true);
        }
      }
    }

  }

  public static class preparedstatement_setParameter_result implements org.apache.thrift.TBase<preparedstatement_setParameter_result, preparedstatement_setParameter_result._Fields>, java.io.Serializable, Cloneable, Comparable<preparedstatement_setParameter_result>   {
    private static final org.apache.thrift.protocol.TStruct STRUCT_DESC = new org.apache.thrift.protocol.TStruct("preparedstatement_setParameter_result");

    private static final org.apache.thrift.protocol.TField SQL_EXCEPTION_FIELD_DESC = new org.apache.thrift.protocol.TField("sqlException", org.apache.thrift.protocol.TType.STRUCT, (short)1);

    private static final Map<Class<? extends IScheme>, SchemeFactory> schemes = new HashMap<Class<? extends IScheme>, SchemeFactory>();
    static {
      schemes.put(StandardScheme.class, new preparedstatement_setParameter_resultStandardSchemeFactory());
      schemes.put(TupleScheme.class, new preparedstatement_setParameter_resultTupleSchemeFactory());
    }

    public RSQLException sqlException; // required

    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements org.apache.thrift.TFieldIdEnum {
      SQL_EXCEPTION((short)1, "sqlException");

      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        switch(fieldId) {
          case 1: // SQL_EXCEPTION
            return SQL_EXCEPTION;
          default:
            return null;
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }

    // isset id assignments
    public static final Map<_Fields, org.apache.thrift.meta_data.FieldMetaData> metaDataMap;
    static {
      Map<_Fields, org.apache.thrift.meta_data.FieldMetaData> tmpMap = new EnumMap<_Fields, org.apache.thrift.meta_data.FieldMetaData>(_Fields.class);
      tmpMap.put(_Fields.SQL_EXCEPTION, new org.apache.thrift.meta_data.FieldMetaData("sqlException", org.apache.thrift.TFieldRequirementType.DEFAULT, 
          new org.apache.thrift.meta_data.FieldValueMetaData(org.apache.thrift.protocol.TType.STRUCT)));
      metaDataMap = Collections.unmodifiableMap(tmpMap);
      org.apache.thrift.meta_data.FieldMetaData.addStructMetaDataMap(preparedstatement_setParameter_result.class, metaDataMap);
    }

    public preparedstatement_setParameter_result() {
    }

    public preparedstatement_setParameter_result(
      RSQLException sqlException)
    {
      this();
      this.sqlException = sqlException;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public preparedstatement_setParameter_result(preparedstatement_setParameter_result other) {
      if (other.isSetSqlException()) {
        this.sqlException = new RSQLException(other.sqlException);
      }
    }

    public preparedstatement_setParameter_result deepCopy() {
      return new preparedstatement_setParameter_result(this);
    }

    @Override
    public void clear() {
      this.sqlException = null;
    }

    public RSQLException getSqlException() {
      return this.sqlException;
    }

    public preparedstatement_setParameter_result setSqlException(RSQLException sqlException) {
      this.sqlException = sqlException;
      return this;
    }

    public void unsetSqlException() {
      this.sqlException = null;
    }

    /** Returns true if field sqlException is set (has been assigned a value) and false otherwise */
    public boolean isSetSqlException() {
      return this.sqlException != null;
    }

    public void setSqlExceptionIsSet(boolean value) {
      if (!value) {
        this.sqlException = null;
      }
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      case SQL_EXCEPTION:
        if (value == null) {
          unsetSqlException();
        } else {
          setSqlException((RSQLException)value);
        }
        break;

      }
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      case SQL_EXCEPTION:
        return getSqlException();

      }
      throw new IllegalStateException();
    }

    /** Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      if (field == null) {
        throw new IllegalArgumentException();
      }

      switch (field) {
      case SQL_EXCEPTION:
        return isSetSqlException();
      }
      throw new IllegalStateException();
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof preparedstatement_setParameter_result)
        return this.equals((preparedstatement_setParameter_result)that);
      return false;
    }

    public boolean equals(preparedstatement_setParameter_result that) {
      if (that == null)
        return false;

      boolean this_present_sqlException = true && this.isSetSqlException();
      boolean that_present_sqlException = true && that.isSetSqlException();
      if (this_present_sqlException || that_present_sqlException) {
        if (!(this_present_sqlException && that_present_sqlException))
          return false;
        if (!this.sqlException.equals(that.sqlException))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      List<Object> list = new ArrayList<Object>();

      boolean present_sqlException = true && (isSetSqlException());
      list.add(present_sqlException);
      if (present_sqlException)
        list.add(sqlException);

      return list.hashCode();
    }

    @Override
    public int compareTo(preparedstatement_setParameter_result other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetSqlException()).compareTo(other.isSetSqlException());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetSqlException()) {
        lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.sqlException, other.sqlException);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      return 0;
    }

    public _Fields fieldForId(int fieldId) {
      return _Fields.findByThriftId(fieldId);
    }

    public void read(org.apache.thrift.protocol.TProtocol iprot) throws org.apache.thrift.TException {
      schemes.get(iprot.getScheme()).getScheme().read(iprot, this);
    }

    public void write(org.apache.thrift.protocol.TProtocol oprot) throws org.apache.thrift.TException {
      schemes.get(oprot.getScheme()).getScheme().write(oprot, this);
      }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("preparedstatement_setParameter_result(");
      boolean first = true;

      sb.append("sqlException:");
      if (this.sqlException == null) {
        sb.append("null");
      } else {
        sb.append(this.sqlException);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws org.apache.thrift.TException {
      // check for required fields
      // check for sub-struct validity
    }

    private void writeObject(java.io.ObjectOutputStream out) throws java.io.IOException {
      try {
        write(new org.apache.thrift.protocol.TCompactProtocol(new org.apache.thrift.transport.TIOStreamTransport(out)));
      } catch (org.apache.thrift.TException te) {
        throw new java.io.IOException(te);
      }
    }

    private void readObject(java.io.ObjectInputStream in) throws java.io.IOException, ClassNotFoundException {
      try {
        read(new org.apache.thrift.protocol.TCompactProtocol(new org.apache.thrift.transport.TIOStreamTransport(in)));
      } catch (org.apache.thrift.TException te) {
        throw new java.io.IOException(te);
      }
    }

    private static class preparedstatement_setParameter_resultStandardSchemeFactory implements SchemeFactory {
      public preparedstatement_setParameter_resultStandardScheme getScheme() {
        return new preparedstatement_setParameter_resultStandardScheme();
      }
    }

    private static class preparedstatement_setParameter_resultStandardScheme extends StandardScheme<preparedstatement_setParameter_result> {

      public void read(org.apache.thrift.protocol.TProtocol iprot, preparedstatement_setParameter_result struct) throws org.apache.thrift.TException {
        org.apache.thrift.protocol.TField schemeField;
        iprot.readStructBegin();
        while (true)
        {
          schemeField = iprot.readFieldBegin();
          if (schemeField.type == org.apache.thrift.protocol.TType.STOP) { 
            break;
          }
          switch (schemeField.id) {
            case 1: // SQL_EXCEPTION
              if (schemeField.type == org.apache.thrift.protocol.TType.STRUCT) {
                struct.sqlException = new RSQLException();
                struct.sqlException.read(iprot);
                struct.setSqlExceptionIsSet(true);
              } else { 
                org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
              }
              break;
            default:
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
          }
          iprot.readFieldEnd();
        }
        iprot.readStructEnd();

        // check for required fields of primitive type, which can't be checked in the validate method
        struct.validate();
      }

      public void write(org.apache.thrift.protocol.TProtocol oprot, preparedstatement_setParameter_result struct) throws org.apache.thrift.TException {
        struct.validate();

        oprot.writeStructBegin(STRUCT_DESC);
        if (struct.sqlException != null) {
          oprot.writeFieldBegin(SQL_EXCEPTION_FIELD_DESC);
          struct.sqlException.write(oprot);
          oprot.writeFieldEnd();
        }
        oprot.writeFieldStop();
        oprot.writeStructEnd();
      }

    }

    private static class preparedstatement_setParameter_resultTupleSchemeFactory implements SchemeFactory {
      public preparedstatement_setParameter_resultTupleScheme getScheme() {
        return new preparedstatement_setParameter_resultTupleScheme();
      }
    }

    private static class preparedstatement_setParameter_resultTupleScheme extends TupleScheme<preparedstatement_setParameter_result> {

      @Override
      public void write(org.apache.thrift.protocol.TProtocol prot, preparedstatement_setParameter_result struct) throws org.apache.thrift.TException {
        TTupleProtocol oprot = (TTupleProtocol) prot;
        BitSet optionals = new BitSet();
        if (struct.isSetSqlException()) {
          optionals.set(0);
        }
        oprot.writeBitSet(optionals, 1);
        if (struct.isSetSqlException()) {
          struct.sqlException.write(oprot);
        }
      }

      @Override
      public void read(org.apache.thrift.protocol.TProtocol prot, preparedstatement_setParameter_result struct) throws org.apache.thrift.TException {
        TTupleProtocol iprot = (TTupleProtocol) prot;
        BitSet incoming = iprot.readBitSet(1);
        if (incoming.get(0)) {
          struct.sqlException = new RSQLException();
          struct.sqlException.read(iprot);
          struct.setSqlExceptionIsSet(true);
        }
      }
    }

  }

  public static class preparedstatement_clearParameters_args implements org.apache.thrift.TBase<preparedstatement_clearParameters_args, preparedstatement_clearParameters_args._Fields>, java.io.Serializable, Cloneable, Comparable<preparedstatement_clearParameters_args>   {
    private static final org.apache.thrift.protocol.TStruct STRUCT_DESC = new org.apache.thrift.protocol.TStruct("preparedstatement_clearParameters_args");

    private static final org.apache.thrift.protocol.TField PREPARED_STATEMENT_FIELD_DESC = new org.apache.thrift.protocol.TField("preparedStatement", org.apache.thrift.protocol.TType.STRUCT, (short)1);

    private static final Map<Class<? extends IScheme>, SchemeFactory> schemes = new HashMap<Class<? extends IScheme>, SchemeFactory>();
    static {
      schemes.put(StandardScheme.class, new preparedstatement_clearParameters_argsStandardSchemeFactory());
      schemes.put(TupleScheme.class, new preparedstatement_clearParameters_argsTupleSchemeFactory());
    }

    public RStatement preparedStatement; // required

    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements org.apache.thrift.TFieldIdEnum {
      PREPARED_STATEMENT((short)1, "preparedStatement");

      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        switch(fieldId) {
          case 1: // PREPARED_STATEMENT
            return PREPARED_STATEMENT;
          default:
            return null;
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }

    // isset id assignments
    public static final Map<_Fields, org.apache.thrift.meta_data.FieldMetaData> metaDataMap;
    static {
      Map<_Fields, org.apache.thrift.meta_data.FieldMetaData> tmpMap = new EnumMap<_Fields, org.apache.thrift.meta_data.FieldMetaData>(_Fields.class);
      tmpMap.put(_Fields.PREPARED_STATEMENT, new org.apache.thrift.meta_data.FieldMetaData("preparedStatement", org.apache.thrift.TFieldRequirementType.DEFAULT, 
          new org.apache.thrift.meta_data.StructMetaData(org.apache.thrift.protocol.TType.STRUCT, RStatement.class)));
      metaDataMap = Collections.unmodifiableMap(tmpMap);
      org.apache.thrift.meta_data.FieldMetaData.addStructMetaDataMap(preparedstatement_clearParameters_args.class, metaDataMap);
    }

    public preparedstatement_clearParameters_args() {
    }

    public preparedstatement_clearParameters_args(
      RStatement preparedStatement)
    {
      this();
      this.preparedStatement = preparedStatement;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public preparedstatement_clearParameters_args(preparedstatement_clearParameters_args other) {
      if (other.isSetPreparedStatement()) {
        this.preparedStatement = new RStatement(other.preparedStatement);
      }
    }

    public preparedstatement_clearParameters_args deepCopy() {
      return new preparedstatement_clearParameters_args(this);
    }

    @Override
    public void clear() {
      this.preparedStatement = null;
    }

    public RStatement getPreparedStatement() {
      return this.preparedStatement;
    }

    public preparedstatement_clearParameters_args setPreparedStatement(RStatement preparedStatement) {
      this.preparedStatement = preparedStatement;
      return this;
    }

    public void unsetPreparedStatement() {
      this.preparedStatement = null;
    }

    /** Returns true if field preparedStatement is set (has been assigned a value) and false otherwise */
    public boolean isSetPreparedStatement() {
      return this.preparedStatement != null;
    }

    public void setPreparedStatementIsSet(boolean value) {
      if (!value) {
        this.preparedStatement = null;
      }
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      case PREPARED_STATEMENT:
        if (value == null) {
          unsetPreparedStatement();
        } else {
          setPreparedStatement((RStatement)value);
        }
        break;

      }
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      case PREPARED_STATEMENT:
        return getPreparedStatement();

      }
      throw new IllegalStateException();
    }

    /** Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      if (field == null) {
        throw new IllegalArgumentException();
      }

      switch (field) {
      case PREPARED_STATEMENT:
        return isSetPreparedStatement();
      }
      throw new IllegalStateException();
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof preparedstatement_clearParameters_args)
        return this.equals((preparedstatement_clearParameters_args)that);
      return false;
    }

    public boolean equals(preparedstatement_clearParameters_args that) {
      if (that == null)
        return false;

      boolean this_present_preparedStatement = true && this.isSetPreparedStatement();
      boolean that_present_preparedStatement = true && that.isSetPreparedStatement();
      if (this_present_preparedStatement || that_present_preparedStatement) {
        if (!(this_present_preparedStatement && that_present_preparedStatement))
          return false;
        if (!this.preparedStatement.equals(that.preparedStatement))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      List<Object> list = new ArrayList<Object>();

      boolean present_preparedStatement = true && (isSetPreparedStatement());
      list.add(present_preparedStatement);
      if (present_preparedStatement)
        list.add(preparedStatement);

      return list.hashCode();
    }

    @Override
    public int compareTo(preparedstatement_clearParameters_args other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetPreparedStatement()).compareTo(other.isSetPreparedStatement());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetPreparedStatement()) {
        lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.preparedStatement, other.preparedStatement);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      return 0;
    }

    public _Fields fieldForId(int fieldId) {
      return _Fields.findByThriftId(fieldId);
    }

    public void read(org.apache.thrift.protocol.TProtocol iprot) throws org.apache.thrift.TException {
      schemes.get(iprot.getScheme()).getScheme().read(iprot, this);
    }

    public void write(org.apache.thrift.protocol.TProtocol oprot) throws org.apache.thrift.TException {
      schemes.get(oprot.getScheme()).getScheme().write(oprot, this);
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("preparedstatement_clearParameters_args(");
      boolean first = true;

      sb.append("preparedStatement:");
      if (this.preparedStatement == null) {
        sb.append("null");
      } else {
        sb.append(this.preparedStatement);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws org.apache.thrift.TException {
      // check for required fields
      // check for sub-struct validity
      if (preparedStatement != null) {
        preparedStatement.validate();
      }
    }

    private void writeObject(java.io.ObjectOutputStream out) throws java.io.IOException {
      try {
        write(new org.apache.thrift.protocol.TCompactProtocol(new org.apache.thrift.transport.TIOStreamTransport(out)));
      } catch (org.apache.thrift.TException te) {
        throw new java.io.IOException(te);
      }
    }

    private void readObject(java.io.ObjectInputStream in) throws java.io.IOException, ClassNotFoundException {
      try {
        read(new org.apache.thrift.protocol.TCompactProtocol(new org.apache.thrift.transport.TIOStreamTransport(in)));
      } catch (org.apache.thrift.TException te) {
        throw new java.io.IOException(te);
      }
    }

    private static class preparedstatement_clearParameters_argsStandardSchemeFactory implements SchemeFactory {
      public preparedstatement_clearParameters_argsStandardScheme getScheme() {
        return new preparedstatement_clearParameters_argsStandardScheme();
      }
    }

    private static class preparedstatement_clearParameters_argsStandardScheme extends StandardScheme<preparedstatement_clearParameters_args> {

      public void read(org.apache.thrift.protocol.TProtocol iprot, preparedstatement_clearParameters_args struct) throws org.apache.thrift.TException {
        org.apache.thrift.protocol.TField schemeField;
        iprot.readStructBegin();
        while (true)
        {
          schemeField = iprot.readFieldBegin();
          if (schemeField.type == org.apache.thrift.protocol.TType.STOP) { 
            break;
          }
          switch (schemeField.id) {
            case 1: // PREPARED_STATEMENT
              if (schemeField.type == org.apache.thrift.protocol.TType.STRUCT) {
                struct.preparedStatement = new RStatement();
                struct.preparedStatement.read(iprot);
                struct.setPreparedStatementIsSet(true);
              } else { 
                org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
              }
              break;
            default:
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
          }
          iprot.readFieldEnd();
        }
        iprot.readStructEnd();

        // check for required fields of primitive type, which can't be checked in the validate method
        struct.validate();
      }

      public void write(org.apache.thrift.protocol.TProtocol oprot, preparedstatement_clearParameters_args struct) throws org.apache.thrift.TException {
        struct.validate();

        oprot.writeStructBegin(STRUCT_DESC);
        if (struct.preparedStatement != null) {
          oprot.writeFieldBegin(PREPARED_STATEMENT_FIELD_DESC);
          struct.preparedStatement.write(oprot);
          oprot.writeFieldEnd();
        }
        oprot.writeFieldStop();
        oprot.writeStructEnd();
      }

    }

    private static class preparedstatement_clearParameters_argsTupleSchemeFactory implements SchemeFactory {
      public preparedstatement_clearParameters_argsTupleScheme getScheme() {
        return new preparedstatement_clearParameters_argsTupleScheme();
      }
    }

    private static class preparedstatement_clearParameters_argsTupleScheme extends TupleScheme<preparedstatement_clearParameters_args> {

      @Override
      public void write(org.apache.thrift.protocol.TProtocol prot, preparedstatement_clearParameters_args struct) throws org.apache.thrift.TException {
        TTupleProtocol oprot = (TTupleProtocol) prot;
        BitSet optionals = new BitSet();
        if (struct.isSetPreparedStatement()) {
          optionals.set(0);
        }
        oprot.writeBitSet(optionals, 1);
        if (struct.isSetPreparedStatement()) {
          struct.preparedStatement.write(oprot);
        }
      }

      @Override
      public void read(org.apache.thrift.protocol.TProtocol prot, preparedstatement_clearParameters_args struct) throws org.apache.thrift.TException {
        TTupleProtocol iprot = (TTupleProtocol) prot;
        BitSet incoming = iprot.readBitSet(1);
        if (incoming.get(0)) {
          struct.preparedStatement = new RStatement();
          struct.preparedStatement.read(iprot);
          struct.setPreparedStatementIsSet(true);
        }
      }
    }

  }

  public static class preparedstatement_clearParameters_result implements org.apache.thrift.TBase<preparedstatement_clearParameters_result, preparedstatement_clearParameters_result._Fields>, java.io.Serializable, Cloneable, Comparable<preparedstatement_clearParameters_result>   {
    private static final org.apache.thrift.protocol.TStruct STRUCT_DESC = new org.apache.thrift.protocol.TStruct("preparedstatement_clearParameters_result");

    private static final org.apache.thrift.protocol.TField SQL_EXCEPTION_FIELD_DESC = new org.apache.thrift.protocol.TField("sqlException", org.apache.thrift.protocol.TType.STRUCT, (short)1);

    private static final Map<Class<? extends IScheme>, SchemeFactory> schemes = new HashMap<Class<? extends IScheme>, SchemeFactory>();
    static {
      schemes.put(StandardScheme.class, new preparedstatement_clearParameters_resultStandardSchemeFactory());
      schemes.put(TupleScheme.class, new preparedstatement_clearParameters_resultTupleSchemeFactory());
    }

    public RSQLException sqlException; // required

    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements org.apache.thrift.TFieldIdEnum {
      SQL_EXCEPTION((short)1, "sqlException");

      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        switch(fieldId) {
          case 1: // SQL_EXCEPTION
            return SQL_EXCEPTION;
          default:
            return null;
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }

    // isset id assignments
    public static final Map<_Fields, org.apache.thrift.meta_data.FieldMetaData> metaDataMap;
    static {
      Map<_Fields, org.apache.thrift.meta_data.FieldMetaData> tmpMap = new EnumMap<_Fields, org.apache.thrift.meta_data.FieldMetaData>(_Fields.class);
      tmpMap.put(_Fields.SQL_EXCEPTION, new org.apache.thrift.meta_data.FieldMetaData("sqlException", org.apache.thrift.TFieldRequirementType.DEFAULT, 
          new org.apache.thrift.meta_data.FieldValueMetaData(org.apache.thrift.protocol.TType.STRUCT)));
      metaDataMap = Collections.unmodifiableMap(tmpMap);
      org.apache.thrift.meta_data.FieldMetaData.addStructMetaDataMap(preparedstatement_clearParameters_result.class, metaDataMap);
    }

    public preparedstatement_clearParameters_result() {
    }

    public preparedstatement_clearParameters_result(
      RSQLException sqlException)
    {
      this();
      this.sqlException = sqlException;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public preparedstatement_clearParameters_result(preparedstatement_clearParameters_result other) {
      if (other.isSetSqlException()) {
        this.sqlException = new RSQLException(other.sqlException);
      }
    }

    public preparedstatement_clearParameters_result deepCopy() {
      return new preparedstatement_clearParameters_result(this);
    }

    @Override
    public void clear() {
      this.sqlException = null;
    }

    public RSQLException getSqlException() {
      return this.sqlException;
    }

    public preparedstatement_clearParameters_result setSqlException(RSQLException sqlException) {
      this.sqlException = sqlException;
      return this;
    }

    public void unsetSqlException() {
      this.sqlException = null;
    }

    /** Returns true if field sqlException is set (has been assigned a value) and false otherwise */
    public boolean isSetSqlException() {
      return this.sqlException != null;
    }

    public void setSqlExceptionIsSet(boolean value) {
      if (!value) {
        this.sqlException = null;
      }
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      case SQL_EXCEPTION:
        if (value == null) {
          unsetSqlException();
        } else {
          setSqlException((RSQLException)value);
        }
        break;

      }
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      case SQL_EXCEPTION:
        return getSqlException();

      }
      throw new IllegalStateException();
    }

    /** Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      if (field == null) {
        throw new IllegalArgumentException();
      }

      switch (field) {
      case SQL_EXCEPTION:
        return isSetSqlException();
      }
      throw new IllegalStateException();
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof preparedstatement_clearParameters_result)
        return this.equals((preparedstatement_clearParameters_result)that);
      return false;
    }

    public boolean equals(preparedstatement_clearParameters_result that) {
      if (that == null)
        return false;

      boolean this_present_sqlException = true && this.isSetSqlException();
      boolean that_present_sqlException = true && that.isSetSqlException();
      if (this_present_sqlException || that_present_sqlException) {
        if (!(this_present_sqlException && that_present_sqlException))
          return false;
        if (!this.sqlException.equals(that.sqlException))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      List<Object> list = new ArrayList<Object>();

      boolean present_sqlException = true && (isSetSqlException());
      list.add(present_sqlException);
      if (present_sqlException)
        list.add(sqlException);

      return list.hashCode();
    }

    @Override
    public int compareTo(preparedstatement_clearParameters_result other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetSqlException()).compareTo(other.isSetSqlException());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetSqlException()) {
        lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.sqlException, other.sqlException);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      return 0;
    }

    public _Fields fieldForId(int fieldId) {
      return _Fields.findByThriftId(fieldId);
    }

    public void read(org.apache.thrift.protocol.TProtocol iprot) throws org.apache.thrift.TException {
      schemes.get(iprot.getScheme()).getScheme().read(iprot, this);
    }

    public void write(org.apache.thrift.protocol.TProtocol oprot) throws org.apache.thrift.TException {
      schemes.get(oprot.getScheme()).getScheme().write(oprot, this);
      }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("preparedstatement_clearParameters_result(");
      boolean first = true;

      sb.append("sqlException:");
      if (this.sqlException == null) {
        sb.append("null");
      } else {
        sb.append(this.sqlException);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws org.apache.thrift.TException {
      // check for required fields
      // check for sub-struct validity
    }

    private void writeObject(java.io.ObjectOutputStream out) throws java.io.IOException {
      try {
        write(new org.apache.thrift.protocol.TCompactProtocol(new org.apache.thrift.transport.TIOStreamTransport(out)));
      } catch (org.apache.thrift.TException te) {
        throw new java.io.IOException(te);
      }
    }

    private void readObject(java.io.ObjectInputStream in) throws java.io.IOException, ClassNotFoundException {
      try {
        read(new org.apache.thrift.protocol.TCompactProtocol(new org.apache.thrift.transport.TIOStreamTransport(in)));
      } catch (org.apache.thrift.TException te) {
        throw new java.io.IOException(te);
      }
    }

    private static class preparedstatement_clearParameters_resultStandardSchemeFactory implements SchemeFactory {
      public preparedstatement_clearParameters_resultStandardScheme getScheme() {
        return new preparedstatement_clearParameters_resultStandardScheme();
      }
    }

    private static class preparedstatement_clearParameters_resultStandardScheme extends StandardScheme<preparedstatement_clearParameters_result> {

      public void read(org.apache.thrift.protocol.TProtocol iprot, preparedstatement_clearParameters_result struct) throws org.apache.thrift.TException {
        org.apache.thrift.protocol.TField schemeField;
        iprot.readStructBegin();
        while (true)
        {
          schemeField = iprot.readFieldBegin();
          if (schemeField.type == org.apache.thrift.protocol.TType.STOP) { 
            break;
          }
          switch (schemeField.id) {
            case 1: // SQL_EXCEPTION
              if (schemeField.type == org.apache.thrift.protocol.TType.STRUCT) {
                struct.sqlException = new RSQLException();
                struct.sqlException.read(iprot);
                struct.setSqlExceptionIsSet(true);
              } else { 
                org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
              }
              break;
            default:
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
          }
          iprot.readFieldEnd();
        }
        iprot.readStructEnd();

        // check for required fields of primitive type, which can't be checked in the validate method
        struct.validate();
      }

      public void write(org.apache.thrift.protocol.TProtocol oprot, preparedstatement_clearParameters_result struct) throws org.apache.thrift.TException {
        struct.validate();

        oprot.writeStructBegin(STRUCT_DESC);
        if (struct.sqlException != null) {
          oprot.writeFieldBegin(SQL_EXCEPTION_FIELD_DESC);
          struct.sqlException.write(oprot);
          oprot.writeFieldEnd();
        }
        oprot.writeFieldStop();
        oprot.writeStructEnd();
      }

    }

    private static class preparedstatement_clearParameters_resultTupleSchemeFactory implements SchemeFactory {
      public preparedstatement_clearParameters_resultTupleScheme getScheme() {
        return new preparedstatement_clearParameters_resultTupleScheme();
      }
    }

    private static class preparedstatement_clearParameters_resultTupleScheme extends TupleScheme<preparedstatement_clearParameters_result> {

      @Override
      public void write(org.apache.thrift.protocol.TProtocol prot, preparedstatement_clearParameters_result struct) throws org.apache.thrift.TException {
        TTupleProtocol oprot = (TTupleProtocol) prot;
        BitSet optionals = new BitSet();
        if (struct.isSetSqlException()) {
          optionals.set(0);
        }
        oprot.writeBitSet(optionals, 1);
        if (struct.isSetSqlException()) {
          struct.sqlException.write(oprot);
        }
      }

      @Override
      public void read(org.apache.thrift.protocol.TProtocol prot, preparedstatement_clearParameters_result struct) throws org.apache.thrift.TException {
        TTupleProtocol iprot = (TTupleProtocol) prot;
        BitSet incoming = iprot.readBitSet(1);
        if (incoming.get(0)) {
          struct.sqlException = new RSQLException();
          struct.sqlException.read(iprot);
          struct.setSqlExceptionIsSet(true);
        }
      }
    }

  }

  public static class preparedstatement_addBatchWithParameters_args implements org.apache.thrift.TBase<preparedstatement_addBatchWithParameters_args, preparedstatement_addBatchWithParameters_args._Fields>, java.io.Serializable, Cloneable, Comparable<preparedstatement_addBatchWithParameters_args>   {
    private static final org.apache.thrift.protocol.TStruct STRUCT_DESC = new org.apache.thrift.protocol.TStruct("preparedstatement_addBatchWithParameters_args");

    private static final org.apache.thrift.protocol.TField PREPARED_STATEMENT_FIELD_DESC = new org.apache.thrift.protocol.TField("preparedStatement", org.apache.thrift.protocol.TType.STRUCT, (short)1);
    private static final org.apache.thrift.protocol.TField PARAMETERS_FIELD_DESC = new org.apache.thrift.protocol.TField("parameters", org.apache.thrift.protocol.TType.LIST, (short)2);

    private static final Map<Class<? extends IScheme>, SchemeFactory> schemes = new HashMap<Class<? extends IScheme>, SchemeFactory>();
    static {
      schemes.put(StandardScheme.class, new preparedstatement_addBatchWithParameters_argsStandardSchemeFactory());
      schemes.put(TupleScheme.class, new preparedstatement_addBatchWithParameters_argsTupleSchemeFactory());
    }

    public RStatement preparedStatement; // required
    public List<RValueSQL> parameters; // required

    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements org.apache.thrift.TFieldIdEnum {
      PREPARED_STATEMENT((short)1, "preparedStatement"),
      PARAMETERS((short)2, "parameters");

      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        switch(fieldId) {
          case 1: // PREPARED_STATEMENT
            return PREPARED_STATEMENT;
          case 2: // PARAMETERS
            return PARAMETERS;
          default:
            return null;
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }

    // isset id assignments
    public static final Map<_Fields, org.apache.thrift.meta_data.FieldMetaData> metaDataMap;
    static {
      Map<_Fields, org.apache.thrift.meta_data.FieldMetaData> tmpMap = new EnumMap<_Fields, org.apache.thrift.meta_data.FieldMetaData>(_Fields.class);
      tmpMap.put(_Fields.PREPARED_STATEMENT, new org.apache.thrift.meta_data.FieldMetaData("preparedStatement", org.apache.thrift.TFieldRequirementType.DEFAULT, 
          new org.apache.thrift.meta_data.StructMetaData(org.apache.thrift.protocol.TType.STRUCT, RStatement.class)));
      tmpMap.put(_Fields.PARAMETERS, new org.apache.thrift.meta_data.FieldMetaData("parameters", org.apache.thrift.TFieldRequirementType.DEFAULT, 
          new org.apache.thrift.meta_data.ListMetaData(org.apache.thrift.protocol.TType.LIST, 
              new org.apache.thrift.meta_data.StructMetaData(org.apache.thrift.protocol.TType.STRUCT, RValueSQL.class))));
      metaDataMap = Collections.unmodifiableMap(tmpMap);
      org.apache.thrift.meta_data.FieldMetaData.addStructMetaDataMap(preparedstatement_addBatchWithParameters_args.class, metaDataMap);
    }

    public preparedstatement_addBatchWithParameters_args() {
    }

    public preparedstatement_addBatchWithParameters_args(
      RStatement preparedStatement,
      List<RValueSQL> parameters)
    {
      this();
      this.preparedStatement = preparedStatement;
      this.parameters = parameters;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public preparedstatement_addBatchWithParameters_args(preparedstatement_addBatchWithParameters_args other) {
      if (other.isSetPreparedStatement()) {
        this.preparedStatement = new RStatement(other.preparedStatement);
      }
      if (other.isSetParameters()) {
        List<RValueSQL> __this__parameters = new ArrayList<RValueSQL>(other.parameters.size());
        for (RValueSQL other_element : other.parameters) {
          __this__parameters.add(new RValueSQL(other_element));
        }
        this.parameters = __this__parameters;
      }
    }

    public preparedstatement_addBatchWithParameters_args deepCopy() {
      return new preparedstatement_addBatchWithParameters_args(this);
    }

    @Override
    public void clear() {
      this.preparedStatement = null;
      this.parameters = null;
    }

    public RStatement getPreparedStatement() {
      return this.preparedStatement;
    }

    public preparedstatement_addBatchWithParameters_args setPreparedStatement(RStatement preparedStatement) {
      this.preparedStatement = preparedStatement;
      return this;
    }

    public void unsetPreparedStatement() {
      this.preparedStatement = null;
    }

    /** Returns true if field preparedStatement is set (has been assigned a value) and false otherwise */
    public boolean isSetPreparedStatement() {
      return this.preparedStatement != null;
    }

    public void setPreparedStatementIsSet(boolean value) {
      if (!value) {
        this.preparedStatement = null;
      }
    }

    public int getParametersSize() {
      return (this.parameters == null) ? 0 : this.parameters.size();
    }

    public java.util.Iterator<RValueSQL> getParametersIterator() {
      return (this.parameters == null) ? null : this.parameters.iterator();
    }

    public void addToParameters(RValueSQL elem) {
      if (this.parameters == null) {
        this.parameters = new ArrayList<RValueSQL>();
      }
      this.parameters.add(elem);
    }

    public List<RValueSQL> getParameters() {
      return this.parameters;
    }

    public preparedstatement_addBatchWithParameters_args setParameters(List<RValueSQL> parameters) {
      this.parameters = parameters;
      return this;
    }

    public void unsetParameters() {
      this.parameters = null;
    }

    /** Returns true if field parameters is set (has been assigned a value) and false otherwise */
    public boolean isSetParameters() {
      return this.parameters != null;
    }

    public void setParametersIsSet(boolean value) {
      if (!value) {
        this.parameters = null;
      }
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      case PREPARED_STATEMENT:
        if (value == null) {
          unsetPreparedStatement();
        } else {
          setPreparedStatement((RStatement)value);
        }
        break;

      case PARAMETERS:
        if (value == null) {
          unsetParameters();
        } else {
          setParameters((List<RValueSQL>)value);
        }
        break;

      }
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      case PREPARED_STATEMENT:
        return getPreparedStatement();

      case PARAMETERS:
        return getParameters();

      }
      throw new IllegalStateException();
    }

    /** Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      if (field == null) {
        throw new IllegalArgumentException();
      }

      switch (field) {
      case PREPARED_STATEMENT:
        return isSetPreparedStatement();
      case PARAMETERS:
        return isSetParameters();
      }
      throw new IllegalStateException();
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof preparedstatement_addBatchWithParameters_args)
        return this.equals((preparedstatement_addBatchWithParameters_args)that);
      return false;
    }

    public boolean equals(preparedstatement_addBatchWithParameters_args that) {
      if (that == null)
        return false;

      boolean this_present_preparedStatement = true && this.isSetPreparedStatement();
      boolean that_present_preparedStatement = true && that.isSetPreparedStatement();
      if (this_present_preparedStatement || that_present_preparedStatement) {
        if (!(this_present_preparedStatement && that_present_preparedStatement))
          return false;
        if (!this.preparedStatement.equals(that.preparedStatement))
          return false;
      }

      boolean this_present_parameters = true && this.isSetParameters();
      boolean that_present_parameters = true && that.isSetParameters();
      if (this_present_parameters || that_present_parameters) {
        if (!(this_present_parameters && that_present_parameters))
          return false;
        if (!this.parameters.equals(that.parameters))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      List<Object> list = new ArrayList<Object>();

      boolean present_preparedStatement = true && (isSetPreparedStatement());
      list.add(present_preparedStatement);
      if (present_preparedStatement)
        list.add(preparedStatement);

      boolean present_parameters = true && (isSetParameters());
      list.add(present_parameters);
      if (present_parameters)
        list.add(parameters);

      return list.hashCode();
    }

    @Override
    public int compareTo(preparedstatement_addBatchWithParameters_args other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetPreparedStatement()).compareTo(other.isSetPreparedStatement());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetPreparedStatement()) {
        lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.preparedStatement, other.preparedStatement);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      lastComparison = Boolean.valueOf(isSetParameters()).compareTo(other.isSetParameters());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetParameters()) {
        lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.parameters, other.parameters);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      return 0;
    }

    public _Fields fieldForId(int fieldId) {
      return _Fields.findByThriftId(fieldId);
    }

    public void read(org.apache.thrift.protocol.TProtocol iprot) throws org.apache.thrift.TException {
      schemes.get(iprot.getScheme()).getScheme().read(iprot, this);
    }

    public void write(org.apache.thrift.protocol.TProtocol oprot) throws org.apache.thrift.TException {
      schemes.get(oprot.getScheme()).getScheme().write(oprot, this);
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("preparedstatement_addBatchWithParameters_args(");
      boolean first = true;

      sb.append("preparedStatement:");
      if (this.preparedStatement == null) {
        sb.append("null");
      } else {
        sb.append(this.preparedStatement);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("parameters:");
      if (this.parameters == null) {
        sb.append("null");
      } else {
        sb.append(this.parameters);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws org.apache.thrift.TException {
      // check for required fields
      // check for sub-struct validity
      if (preparedStatement != null) {
        preparedStatement.validate();
      }
    }

    private void writeObject(java.io.ObjectOutputStream out) throws java.io.IOException {
      try {
        write(new org.apache.thrift.protocol.TCompactProtocol(new org.apache.thrift.transport.TIOStreamTransport(out)));
      } catch (org.apache.thrift.TException te) {
        throw new java.io.IOException(te);
      }
    }

    private void readObject(java.io.ObjectInputStream in) throws java.io.IOException, ClassNotFoundException {
      try {
        read(new org.apache.thrift.protocol.TCompactProtocol(new org.apache.thrift.transport.TIOStreamTransport(in)));
      } catch (org.apache.thrift.TException te) {
        throw new java.io.IOException(te);
      }
    }

    private static class preparedstatement_addBatchWithParameters_argsStandardSchemeFactory implements SchemeFactory {
      public preparedstatement_addBatchWithParameters_argsStandardScheme getScheme() {
        return new preparedstatement_addBatchWithParameters_argsStandardScheme();
      }
    }

    private static class preparedstatement_addBatchWithParameters_argsStandardScheme extends StandardScheme<preparedstatement_addBatchWithParameters_args> {

      public void read(org.apache.thrift.protocol.TProtocol iprot, preparedstatement_addBatchWithParameters_args struct) throws org.apache.thrift.TException {
        org.apache.thrift.protocol.TField schemeField;
        iprot.readStructBegin();
        while (true)
        {
          schemeField = iprot.readFieldBegin();
          if (schemeField.type == org.apache.thrift.protocol.TType.STOP) { 
            break;
          }
          switch (schemeField.id) {
            case 1: // PREPARED_STATEMENT
              if (schemeField.type == org.apache.thrift.protocol.TType.STRUCT) {
                struct.preparedStatement = new RStatement();
                struct.preparedStatement.read(iprot);
                struct.setPreparedStatementIsSet(true);
              } else { 
                org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
              }
              break;
            case 2: // PARAMETERS
              if (schemeField.type == org.apache.thrift.protocol.TType.LIST) {
                {
                  org.apache.thrift.protocol.TList _list106 = iprot.readListBegin();
                  struct.parameters = new ArrayList<RValueSQL>(_list106.size);
                  RValueSQL _elem107;
                  for (int _i108 = 0; _i108 < _list106.size; ++_i108)
                  {
                    _elem107 = new RValueSQL();
                    _elem107.read(iprot);
                    struct.parameters.add(_elem107);
                  }
                  iprot.readListEnd();
                }
                struct.setParametersIsSet(true);
              } else { 
                org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
              }
              break;
            default:
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
          }
          iprot.readFieldEnd();
        }
        iprot.readStructEnd();

        // check for required fields of primitive type, which can't be checked in the validate method
        struct.validate();
      }

      public void write(org.apache.thrift.protocol.TProtocol oprot, preparedstatement_addBatchWithParameters_args struct) throws org.apache.thrift.TException {
        struct.validate();

        oprot.writeStructBegin(STRUCT_DESC);
        if (struct.preparedStatement != null) {
          oprot.writeFieldBegin(PREPARED_STATEMENT_FIELD_DESC);
          struct.preparedStatement.write(oprot);
          oprot.writeFieldEnd();
        }
        if (struct.parameters != null) {
          oprot.writeFieldBegin(PARAMETERS_FIELD_DESC);
          {
            oprot.writeListBegin(new org.apache.thrift.protocol.TList(org.apache.thrift.protocol.TType.STRUCT, struct.parameters.size()));
            for (RValueSQL _iter109 : struct.parameters)
            {
              _iter109.write(oprot);
            }
            oprot.writeListEnd();
          }
          oprot.writeFieldEnd();
        }
        oprot.writeFieldStop();
        oprot.writeStructEnd();
      }

    }

    private static class preparedstatement_addBatchWithParameters_argsTupleSchemeFactory implements SchemeFactory {
      public preparedstatement_addBatchWithParameters_argsTupleScheme getScheme() {
        return new preparedstatement_addBatchWithParameters_argsTupleScheme();
      }
    }

    private static class preparedstatement_addBatchWithParameters_argsTupleScheme extends TupleScheme<preparedstatement_addBatchWithParameters_args> {

      @Override
      public void write(org.apache.thrift.protocol.TProtocol prot, preparedstatement_addBatchWithParameters_args struct) throws org.apache.thrift.TException {
        TTupleProtocol oprot = (TTupleProtocol) prot;
        BitSet optionals = new BitSet();
        if (struct.isSetPreparedStatement()) {
          optionals.set(0);
        }
        if (struct.isSetParameters()) {
          optionals.set(1);
        }
        oprot.writeBitSet(optionals, 2);
        if (struct.isSetPreparedStatement()) {
          struct.preparedStatement.write(oprot);
        }
        if (struct.isSetParameters()) {
          {
            oprot.writeI32(struct.parameters.size());
            for (RValueSQL _iter110 : struct.parameters)
            {
              _iter110.write(oprot);
            }
          }
        }
      }

      @Override
      public void read(org.apache.thrift.protocol.TProtocol prot, preparedstatement_addBatchWithParameters_args struct) throws org.apache.thrift.TException {
        TTupleProtocol iprot = (TTupleProtocol) prot;
        BitSet incoming = iprot.readBitSet(2);
        if (incoming.get(0)) {
          struct.preparedStatement = new RStatement();
          struct.preparedStatement.read(iprot);
          struct.setPreparedStatementIsSet(true);
        }
        if (incoming.get(1)) {
          {
            org.apache.thrift.protocol.TList _list111 = new org.apache.thrift.protocol.TList(org.apache.thrift.protocol.TType.STRUCT, iprot.readI32());
            struct.parameters = new ArrayList<RValueSQL>(_list111.size);
            RValueSQL _elem112;
            for (int _i113 = 0; _i113 < _list111.size; ++_i113)
            {
              _elem112 = new RValueSQL();
              _elem112.read(iprot);
              struct.parameters.add(_elem112);
            }
          }
          struct.setParametersIsSet(true);
        }
      }
    }

  }

  public static class preparedstatement_addBatchWithParameters_result implements org.apache.thrift.TBase<preparedstatement_addBatchWithParameters_result, preparedstatement_addBatchWithParameters_result._Fields>, java.io.Serializable, Cloneable, Comparable<preparedstatement_addBatchWithParameters_result>   {
    private static final org.apache.thrift.protocol.TStruct STRUCT_DESC = new org.apache.thrift.protocol.TStruct("preparedstatement_addBatchWithParameters_result");

    private static final org.apache.thrift.protocol.TField SQL_EXCEPTION_FIELD_DESC = new org.apache.thrift.protocol.TField("sqlException", org.apache.thrift.protocol.TType.STRUCT, (short)1);

    private static final Map<Class<? extends IScheme>, SchemeFactory> schemes = new HashMap<Class<? extends IScheme>, SchemeFactory>();
    static {
      schemes.put(StandardScheme.class, new preparedstatement_addBatchWithParameters_resultStandardSchemeFactory());
      schemes.put(TupleScheme.class, new preparedstatement_addBatchWithParameters_resultTupleSchemeFactory());
    }

    public RSQLException sqlException; // required

    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements org.apache.thrift.TFieldIdEnum {
      SQL_EXCEPTION((short)1, "sqlException");

      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        switch(fieldId) {
          case 1: // SQL_EXCEPTION
            return SQL_EXCEPTION;
          default:
            return null;
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }

    // isset id assignments
    public static final Map<_Fields, org.apache.thrift.meta_data.FieldMetaData> metaDataMap;
    static {
      Map<_Fields, org.apache.thrift.meta_data.FieldMetaData> tmpMap = new EnumMap<_Fields, org.apache.thrift.meta_data.FieldMetaData>(_Fields.class);
      tmpMap.put(_Fields.SQL_EXCEPTION, new org.apache.thrift.meta_data.FieldMetaData("sqlException", org.apache.thrift.TFieldRequirementType.DEFAULT, 
          new org.apache.thrift.meta_data.FieldValueMetaData(org.apache.thrift.protocol.TType.STRUCT)));
      metaDataMap = Collections.unmodifiableMap(tmpMap);
      org.apache.thrift.meta_data.FieldMetaData.addStructMetaDataMap(preparedstatement_addBatchWithParameters_result.class, metaDataMap);
    }

    public preparedstatement_addBatchWithParameters_result() {
    }

    public preparedstatement_addBatchWithParameters_result(
      RSQLException sqlException)
    {
      this();
      this.sqlException = sqlException;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public preparedstatement_addBatchWithParameters_result(preparedstatement_addBatchWithParameters_result other) {
      if (other.isSetSqlException()) {
        this.sqlException = new RSQLException(other.sqlException);
      }
    }

    public preparedstatement_addBatchWithParameters_result deepCopy() {
      return new preparedstatement_addBatchWithParameters_result(this);
    }

    @Override
    public void clear() {
      this.sqlException = null;
    }

    public RSQLException getSqlException() {
      return this.sqlException;
    }

    public preparedstatement_addBatchWithParameters_result setSqlException(RSQLException sqlException) {
      this.sqlException = sqlException;
      return this;
    }

    public void unsetSqlException() {
      this.sqlException = null;
    }

    /** Returns true if field sqlException is set (has been assigned a value) and false otherwise */
    public boolean isSetSqlException() {
      return this.sqlException != null;
    }

    public void setSqlExceptionIsSet(boolean value) {
      if (!value) {
        this.sqlException = null;
      }
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      case SQL_EXCEPTION:
        if (value == null) {
          unsetSqlException();
        } else {
          setSqlException((RSQLException)value);
        }
        break;

      }
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      case SQL_EXCEPTION:
        return getSqlException();

      }
      throw new IllegalStateException();
    }

    /** Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      if (field == null) {
        throw new IllegalArgumentException();
      }

      switch (field) {
      case SQL_EXCEPTION:
        return isSetSqlException();
      }
      throw new IllegalStateException();
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof preparedstatement_addBatchWithParameters_result)
        return this.equals((preparedstatement_addBatchWithParameters_result)that);
      return false;
    }

    public boolean equals(preparedstatement_addBatchWithParameters_result that) {
      if (that == null)
        return false;

      boolean this_present_sqlException = true && this.isSetSqlException();
      boolean that_present_sqlException = true && that.isSetSqlException();
      if (this_present_sqlException || that_present_sqlException) {
        if (!(this_present_sqlException && that_present_sqlException))
          return false;
        if (!this.sqlException.equals(that.sqlException))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      List<Object> list = new ArrayList<Object>();

      boolean present_sqlException = true && (isSetSqlException());
      list.add(present_sqlException);
      if (present_sqlException)
        list.add(sqlException);

      return list.hashCode();
    }

    @Override
    public int compareTo(preparedstatement_addBatchWithParameters_result other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetSqlException()).compareTo(other.isSetSqlException());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetSqlException()) {
        lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.sqlException, other.sqlException);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      return 0;
    }

    public _Fields fieldForId(int fieldId) {
      return _Fields.findByThriftId(fieldId);
    }

    public void read(org.apache.thrift.protocol.TProtocol iprot) throws org.apache.thrift.TException {
      schemes.get(iprot.getScheme()).getScheme().read(iprot, this);
    }

    public void write(org.apache.thrift.protocol.TProtocol oprot) throws org.apache.thrift.TException {
      schemes.get(oprot.getScheme()).getScheme().write(oprot, this);
      }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("preparedstatement_addBatchWithParameters_result(");
      boolean first = true;

      sb.append("sqlException:");
      if (this.sqlException == null) {
        sb.append("null");
      } else {
        sb.append(this.sqlException);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws org.apache.thrift.TException {
      // check for required fields
      // check for sub-struct validity
    }

    private void writeObject(java.io.ObjectOutputStream out) throws java.io.IOException {
      try {
        write(new org.apache.thrift.protocol.TCompactProtocol(new org.apache.thrift.transport.TIOStreamTransport(out)));
      } catch (org.apache.thrift.TException te) {
        throw new java.io.IOException(te);
      }
    }

    private void readObject(java.io.ObjectInputStream in) throws java.io.IOException, ClassNotFoundException {
      try {
        read(new org.apache.thrift.protocol.TCompactProtocol(new org.apache.thrift.transport.TIOStreamTransport(in)));
      } catch (org.apache.thrift.TException te) {
        throw new java.io.IOException(te);
      }
    }

    private static class preparedstatement_addBatchWithParameters_resultStandardSchemeFactory implements SchemeFactory {
      public preparedstatement_addBatchWithParameters_resultStandardScheme getScheme() {
        return new preparedstatement_addBatchWithParameters_resultStandardScheme();
      }
    }

    private static class preparedstatement_addBatchWithParameters_resultStandardScheme extends StandardScheme<preparedstatement_addBatchWithParameters_result> {

      public void read(org.apache.thrift.protocol.TProtocol iprot, preparedstatement_addBatchWithParameters_result struct) throws org.apache.thrift.TException {
        org.apache.thrift.protocol.TField schemeField;
        iprot.readStructBegin();
        while (true)
        {
          schemeField = iprot.readFieldBegin();
          if (schemeField.type == org.apache.thrift.protocol.TType.STOP) { 
            break;
          }
          switch (schemeField.id) {
            case 1: // SQL_EXCEPTION
              if (schemeField.type == org.apache.thrift.protocol.TType.STRUCT) {
                struct.sqlException = new RSQLException();
                struct.sqlException.read(iprot);
                struct.setSqlExceptionIsSet(true);
              } else { 
                org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
              }
              break;
            default:
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
          }
          iprot.readFieldEnd();
        }
        iprot.readStructEnd();

        // check for required fields of primitive type, which can't be checked in the validate method
        struct.validate();
      }

      public void write(org.apache.thrift.protocol.TProtocol oprot, preparedstatement_addBatchWithParameters_result struct) throws org.apache.thrift.TException {
        struct.validate();

        oprot.writeStructBegin(STRUCT_DESC);
        if (struct.sqlException != null) {
          oprot.writeFieldBegin(SQL_EXCEPTION_FIELD_DESC);
          struct.sqlException.write(oprot);
          oprot.writeFieldEnd();
        }
        oprot.writeFieldStop();
        oprot.writeStructEnd();
      }

    }

    private static class preparedstatement_addBatchWithParameters_resultTupleSchemeFactory implements SchemeFactory {
      public preparedstatement_addBatchWithParameters_resultTupleScheme getScheme() {
        return new preparedstatement_addBatchWithParameters_resultTupleScheme();
      }
    }

    private static class preparedstatement_addBatchWithParameters_resultTupleScheme extends TupleScheme<preparedstatement_addBatchWithParameters_result> {

      @Override
      public void write(org.apache.thrift.protocol.TProtocol prot, preparedstatement_addBatchWithParameters_result struct) throws org.apache.thrift.TException {
        TTupleProtocol oprot = (TTupleProtocol) prot;
        BitSet optionals = new BitSet();
        if (struct.isSetSqlException()) {
          optionals.set(0);
        }
        oprot.writeBitSet(optionals, 1);
        if (struct.isSetSqlException()) {
          struct.sqlException.write(oprot);
        }
      }

      @Override
      public void read(org.apache.thrift.protocol.TProtocol prot, preparedstatement_addBatchWithParameters_result struct) throws org.apache.thrift.TException {
        TTupleProtocol iprot = (TTupleProtocol) prot;
        BitSet incoming = iprot.readBitSet(1);
        if (incoming.get(0)) {
          struct.sqlException = new RSQLException();
          struct.sqlException.read(iprot);
          struct.setSqlExceptionIsSet(true);
        }
      }
    }

  }

  public static class preparedstatement_addBatch_args implements org.apache.thrift.TBase<preparedstatement_addBatch_args, preparedstatement_addBatch_args._Fields>, java.io.Serializable, Cloneable, Comparable<preparedstatement_addBatch_args>   {
    private static final org.apache.thrift.protocol.TStruct STRUCT_DESC = new org.apache.thrift.protocol.TStruct("preparedstatement_addBatch_args");

    private static final org.apache.thrift.protocol.TField PREPARED_STATEMENT_FIELD_DESC = new org.apache.thrift.protocol.TField("preparedStatement", org.apache.thrift.protocol.TType.STRUCT, (short)1);

    private static final Map<Class<? extends IScheme>, SchemeFactory> schemes = new HashMap<Class<? extends IScheme>, SchemeFactory>();
    static {
      schemes.put(StandardScheme.class, new preparedstatement_addBatch_argsStandardSchemeFactory());
      schemes.put(TupleScheme.class, new preparedstatement_addBatch_argsTupleSchemeFactory());
    }

    public RStatement preparedStatement; // required

    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements org.apache.thrift.TFieldIdEnum {
      PREPARED_STATEMENT((short)1, "preparedStatement");

      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        switch(fieldId) {
          case 1: // PREPARED_STATEMENT
            return PREPARED_STATEMENT;
          default:
            return null;
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }

    // isset id assignments
    public static final Map<_Fields, org.apache.thrift.meta_data.FieldMetaData> metaDataMap;
    static {
      Map<_Fields, org.apache.thrift.meta_data.FieldMetaData> tmpMap = new EnumMap<_Fields, org.apache.thrift.meta_data.FieldMetaData>(_Fields.class);
      tmpMap.put(_Fields.PREPARED_STATEMENT, new org.apache.thrift.meta_data.FieldMetaData("preparedStatement", org.apache.thrift.TFieldRequirementType.DEFAULT, 
          new org.apache.thrift.meta_data.StructMetaData(org.apache.thrift.protocol.TType.STRUCT, RStatement.class)));
      metaDataMap = Collections.unmodifiableMap(tmpMap);
      org.apache.thrift.meta_data.FieldMetaData.addStructMetaDataMap(preparedstatement_addBatch_args.class, metaDataMap);
    }

    public preparedstatement_addBatch_args() {
    }

    public preparedstatement_addBatch_args(
      RStatement preparedStatement)
    {
      this();
      this.preparedStatement = preparedStatement;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public preparedstatement_addBatch_args(preparedstatement_addBatch_args other) {
      if (other.isSetPreparedStatement()) {
        this.preparedStatement = new RStatement(other.preparedStatement);
      }
    }

    public preparedstatement_addBatch_args deepCopy() {
      return new preparedstatement_addBatch_args(this);
    }

    @Override
    public void clear() {
      this.preparedStatement = null;
    }

    public RStatement getPreparedStatement() {
      return this.preparedStatement;
    }

    public preparedstatement_addBatch_args setPreparedStatement(RStatement preparedStatement) {
      this.preparedStatement = preparedStatement;
      return this;
    }

    public void unsetPreparedStatement() {
      this.preparedStatement = null;
    }

    /** Returns true if field preparedStatement is set (has been assigned a value) and false otherwise */
    public boolean isSetPreparedStatement() {
      return this.preparedStatement != null;
    }

    public void setPreparedStatementIsSet(boolean value) {
      if (!value) {
        this.preparedStatement = null;
      }
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      case PREPARED_STATEMENT:
        if (value == null) {
          unsetPreparedStatement();
        } else {
          setPreparedStatement((RStatement)value);
        }
        break;

      }
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      case PREPARED_STATEMENT:
        return getPreparedStatement();

      }
      throw new IllegalStateException();
    }

    /** Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      if (field == null) {
        throw new IllegalArgumentException();
      }

      switch (field) {
      case PREPARED_STATEMENT:
        return isSetPreparedStatement();
      }
      throw new IllegalStateException();
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof preparedstatement_addBatch_args)
        return this.equals((preparedstatement_addBatch_args)that);
      return false;
    }

    public boolean equals(preparedstatement_addBatch_args that) {
      if (that == null)
        return false;

      boolean this_present_preparedStatement = true && this.isSetPreparedStatement();
      boolean that_present_preparedStatement = true && that.isSetPreparedStatement();
      if (this_present_preparedStatement || that_present_preparedStatement) {
        if (!(this_present_preparedStatement && that_present_preparedStatement))
          return false;
        if (!this.preparedStatement.equals(that.preparedStatement))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      List<Object> list = new ArrayList<Object>();

      boolean present_preparedStatement = true && (isSetPreparedStatement());
      list.add(present_preparedStatement);
      if (present_preparedStatement)
        list.add(preparedStatement);

      return list.hashCode();
    }

    @Override
    public int compareTo(preparedstatement_addBatch_args other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetPreparedStatement()).compareTo(other.isSetPreparedStatement());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetPreparedStatement()) {
        lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.preparedStatement, other.preparedStatement);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      return 0;
    }

    public _Fields fieldForId(int fieldId) {
      return _Fields.findByThriftId(fieldId);
    }

    public void read(org.apache.thrift.protocol.TProtocol iprot) throws org.apache.thrift.TException {
      schemes.get(iprot.getScheme()).getScheme().read(iprot, this);
    }

    public void write(org.apache.thrift.protocol.TProtocol oprot) throws org.apache.thrift.TException {
      schemes.get(oprot.getScheme()).getScheme().write(oprot, this);
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("preparedstatement_addBatch_args(");
      boolean first = true;

      sb.append("preparedStatement:");
      if (this.preparedStatement == null) {
        sb.append("null");
      } else {
        sb.append(this.preparedStatement);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws org.apache.thrift.TException {
      // check for required fields
      // check for sub-struct validity
      if (preparedStatement != null) {
        preparedStatement.validate();
      }
    }

    private void writeObject(java.io.ObjectOutputStream out) throws java.io.IOException {
      try {
        write(new org.apache.thrift.protocol.TCompactProtocol(new org.apache.thrift.transport.TIOStreamTransport(out)));
      } catch (org.apache.thrift.TException te) {
        throw new java.io.IOException(te);
      }
    }

    private void readObject(java.io.ObjectInputStream in) throws java.io.IOException, ClassNotFoundException {
      try {
        read(new org.apache.thrift.protocol.TCompactProtocol(new org.apache.thrift.transport.TIOStreamTransport(in)));
      } catch (org.apache.thrift.TException te) {
        throw new java.io.IOException(te);
      }
    }

    private static class preparedstatement_addBatch_argsStandardSchemeFactory implements SchemeFactory {
      public preparedstatement_addBatch_argsStandardScheme getScheme() {
        return new preparedstatement_addBatch_argsStandardScheme();
      }
    }

    private static class preparedstatement_addBatch_argsStandardScheme extends StandardScheme<preparedstatement_addBatch_args> {

      public void read(org.apache.thrift.protocol.TProtocol iprot, preparedstatement_addBatch_args struct) throws org.apache.thrift.TException {
        org.apache.thrift.protocol.TField schemeField;
        iprot.readStructBegin();
        while (true)
        {
          schemeField = iprot.readFieldBegin();
          if (schemeField.type == org.apache.thrift.protocol.TType.STOP) { 
            break;
          }
          switch (schemeField.id) {
            case 1: // PREPARED_STATEMENT
              if (schemeField.type == org.apache.thrift.protocol.TType.STRUCT) {
                struct.preparedStatement = new RStatement();
                struct.preparedStatement.read(iprot);
                struct.setPreparedStatementIsSet(true);
              } else { 
                org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
              }
              break;
            default:
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
          }
          iprot.readFieldEnd();
        }
        iprot.readStructEnd();

        // check for required fields of primitive type, which can't be checked in the validate method
        struct.validate();
      }

      public void write(org.apache.thrift.protocol.TProtocol oprot, preparedstatement_addBatch_args struct) throws org.apache.thrift.TException {
        struct.validate();

        oprot.writeStructBegin(STRUCT_DESC);
        if (struct.preparedStatement != null) {
          oprot.writeFieldBegin(PREPARED_STATEMENT_FIELD_DESC);
          struct.preparedStatement.write(oprot);
          oprot.writeFieldEnd();
        }
        oprot.writeFieldStop();
        oprot.writeStructEnd();
      }

    }

    private static class preparedstatement_addBatch_argsTupleSchemeFactory implements SchemeFactory {
      public preparedstatement_addBatch_argsTupleScheme getScheme() {
        return new preparedstatement_addBatch_argsTupleScheme();
      }
    }

    private static class preparedstatement_addBatch_argsTupleScheme extends TupleScheme<preparedstatement_addBatch_args> {

      @Override
      public void write(org.apache.thrift.protocol.TProtocol prot, preparedstatement_addBatch_args struct) throws org.apache.thrift.TException {
        TTupleProtocol oprot = (TTupleProtocol) prot;
        BitSet optionals = new BitSet();
        if (struct.isSetPreparedStatement()) {
          optionals.set(0);
        }
        oprot.writeBitSet(optionals, 1);
        if (struct.isSetPreparedStatement()) {
          struct.preparedStatement.write(oprot);
        }
      }

      @Override
      public void read(org.apache.thrift.protocol.TProtocol prot, preparedstatement_addBatch_args struct) throws org.apache.thrift.TException {
        TTupleProtocol iprot = (TTupleProtocol) prot;
        BitSet incoming = iprot.readBitSet(1);
        if (incoming.get(0)) {
          struct.preparedStatement = new RStatement();
          struct.preparedStatement.read(iprot);
          struct.setPreparedStatementIsSet(true);
        }
      }
    }

  }

  public static class preparedstatement_addBatch_result implements org.apache.thrift.TBase<preparedstatement_addBatch_result, preparedstatement_addBatch_result._Fields>, java.io.Serializable, Cloneable, Comparable<preparedstatement_addBatch_result>   {
    private static final org.apache.thrift.protocol.TStruct STRUCT_DESC = new org.apache.thrift.protocol.TStruct("preparedstatement_addBatch_result");

    private static final org.apache.thrift.protocol.TField SQL_EXCEPTION_FIELD_DESC = new org.apache.thrift.protocol.TField("sqlException", org.apache.thrift.protocol.TType.STRUCT, (short)1);

    private static final Map<Class<? extends IScheme>, SchemeFactory> schemes = new HashMap<Class<? extends IScheme>, SchemeFactory>();
    static {
      schemes.put(StandardScheme.class, new preparedstatement_addBatch_resultStandardSchemeFactory());
      schemes.put(TupleScheme.class, new preparedstatement_addBatch_resultTupleSchemeFactory());
    }

    public RSQLException sqlException; // required

    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements org.apache.thrift.TFieldIdEnum {
      SQL_EXCEPTION((short)1, "sqlException");

      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        switch(fieldId) {
          case 1: // SQL_EXCEPTION
            return SQL_EXCEPTION;
          default:
            return null;
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }

    // isset id assignments
    public static final Map<_Fields, org.apache.thrift.meta_data.FieldMetaData> metaDataMap;
    static {
      Map<_Fields, org.apache.thrift.meta_data.FieldMetaData> tmpMap = new EnumMap<_Fields, org.apache.thrift.meta_data.FieldMetaData>(_Fields.class);
      tmpMap.put(_Fields.SQL_EXCEPTION, new org.apache.thrift.meta_data.FieldMetaData("sqlException", org.apache.thrift.TFieldRequirementType.DEFAULT, 
          new org.apache.thrift.meta_data.FieldValueMetaData(org.apache.thrift.protocol.TType.STRUCT)));
      metaDataMap = Collections.unmodifiableMap(tmpMap);
      org.apache.thrift.meta_data.FieldMetaData.addStructMetaDataMap(preparedstatement_addBatch_result.class, metaDataMap);
    }

    public preparedstatement_addBatch_result() {
    }

    public preparedstatement_addBatch_result(
      RSQLException sqlException)
    {
      this();
      this.sqlException = sqlException;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public preparedstatement_addBatch_result(preparedstatement_addBatch_result other) {
      if (other.isSetSqlException()) {
        this.sqlException = new RSQLException(other.sqlException);
      }
    }

    public preparedstatement_addBatch_result deepCopy() {
      return new preparedstatement_addBatch_result(this);
    }

    @Override
    public void clear() {
      this.sqlException = null;
    }

    public RSQLException getSqlException() {
      return this.sqlException;
    }

    public preparedstatement_addBatch_result setSqlException(RSQLException sqlException) {
      this.sqlException = sqlException;
      return this;
    }

    public void unsetSqlException() {
      this.sqlException = null;
    }

    /** Returns true if field sqlException is set (has been assigned a value) and false otherwise */
    public boolean isSetSqlException() {
      return this.sqlException != null;
    }

    public void setSqlExceptionIsSet(boolean value) {
      if (!value) {
        this.sqlException = null;
      }
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      case SQL_EXCEPTION:
        if (value == null) {
          unsetSqlException();
        } else {
          setSqlException((RSQLException)value);
        }
        break;

      }
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      case SQL_EXCEPTION:
        return getSqlException();

      }
      throw new IllegalStateException();
    }

    /** Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      if (field == null) {
        throw new IllegalArgumentException();
      }

      switch (field) {
      case SQL_EXCEPTION:
        return isSetSqlException();
      }
      throw new IllegalStateException();
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof preparedstatement_addBatch_result)
        return this.equals((preparedstatement_addBatch_result)that);
      return false;
    }

    public boolean equals(preparedstatement_addBatch_result that) {
      if (that == null)
        return false;

      boolean this_present_sqlException = true && this.isSetSqlException();
      boolean that_present_sqlException = true && that.isSetSqlException();
      if (this_present_sqlException || that_present_sqlException) {
        if (!(this_present_sqlException && that_present_sqlException))
          return false;
        if (!this.sqlException.equals(that.sqlException))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      List<Object> list = new ArrayList<Object>();

      boolean present_sqlException = true && (isSetSqlException());
      list.add(present_sqlException);
      if (present_sqlException)
        list.add(sqlException);

      return list.hashCode();
    }

    @Override
    public int compareTo(preparedstatement_addBatch_result other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetSqlException()).compareTo(other.isSetSqlException());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetSqlException()) {
        lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.sqlException, other.sqlException);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      return 0;
    }

    public _Fields fieldForId(int fieldId) {
      return _Fields.findByThriftId(fieldId);
    }

    public void read(org.apache.thrift.protocol.TProtocol iprot) throws org.apache.thrift.TException {
      schemes.get(iprot.getScheme()).getScheme().read(iprot, this);
    }

    public void write(org.apache.thrift.protocol.TProtocol oprot) throws org.apache.thrift.TException {
      schemes.get(oprot.getScheme()).getScheme().write(oprot, this);
      }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("preparedstatement_addBatch_result(");
      boolean first = true;

      sb.append("sqlException:");
      if (this.sqlException == null) {
        sb.append("null");
      } else {
        sb.append(this.sqlException);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws org.apache.thrift.TException {
      // check for required fields
      // check for sub-struct validity
    }

    private void writeObject(java.io.ObjectOutputStream out) throws java.io.IOException {
      try {
        write(new org.apache.thrift.protocol.TCompactProtocol(new org.apache.thrift.transport.TIOStreamTransport(out)));
      } catch (org.apache.thrift.TException te) {
        throw new java.io.IOException(te);
      }
    }

    private void readObject(java.io.ObjectInputStream in) throws java.io.IOException, ClassNotFoundException {
      try {
        read(new org.apache.thrift.protocol.TCompactProtocol(new org.apache.thrift.transport.TIOStreamTransport(in)));
      } catch (org.apache.thrift.TException te) {
        throw new java.io.IOException(te);
      }
    }

    private static class preparedstatement_addBatch_resultStandardSchemeFactory implements SchemeFactory {
      public preparedstatement_addBatch_resultStandardScheme getScheme() {
        return new preparedstatement_addBatch_resultStandardScheme();
      }
    }

    private static class preparedstatement_addBatch_resultStandardScheme extends StandardScheme<preparedstatement_addBatch_result> {

      public void read(org.apache.thrift.protocol.TProtocol iprot, preparedstatement_addBatch_result struct) throws org.apache.thrift.TException {
        org.apache.thrift.protocol.TField schemeField;
        iprot.readStructBegin();
        while (true)
        {
          schemeField = iprot.readFieldBegin();
          if (schemeField.type == org.apache.thrift.protocol.TType.STOP) { 
            break;
          }
          switch (schemeField.id) {
            case 1: // SQL_EXCEPTION
              if (schemeField.type == org.apache.thrift.protocol.TType.STRUCT) {
                struct.sqlException = new RSQLException();
                struct.sqlException.read(iprot);
                struct.setSqlExceptionIsSet(true);
              } else { 
                org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
              }
              break;
            default:
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
          }
          iprot.readFieldEnd();
        }
        iprot.readStructEnd();

        // check for required fields of primitive type, which can't be checked in the validate method
        struct.validate();
      }

      public void write(org.apache.thrift.protocol.TProtocol oprot, preparedstatement_addBatch_result struct) throws org.apache.thrift.TException {
        struct.validate();

        oprot.writeStructBegin(STRUCT_DESC);
        if (struct.sqlException != null) {
          oprot.writeFieldBegin(SQL_EXCEPTION_FIELD_DESC);
          struct.sqlException.write(oprot);
          oprot.writeFieldEnd();
        }
        oprot.writeFieldStop();
        oprot.writeStructEnd();
      }

    }

    private static class preparedstatement_addBatch_resultTupleSchemeFactory implements SchemeFactory {
      public preparedstatement_addBatch_resultTupleScheme getScheme() {
        return new preparedstatement_addBatch_resultTupleScheme();
      }
    }

    private static class preparedstatement_addBatch_resultTupleScheme extends TupleScheme<preparedstatement_addBatch_result> {

      @Override
      public void write(org.apache.thrift.protocol.TProtocol prot, preparedstatement_addBatch_result struct) throws org.apache.thrift.TException {
        TTupleProtocol oprot = (TTupleProtocol) prot;
        BitSet optionals = new BitSet();
        if (struct.isSetSqlException()) {
          optionals.set(0);
        }
        oprot.writeBitSet(optionals, 1);
        if (struct.isSetSqlException()) {
          struct.sqlException.write(oprot);
        }
      }

      @Override
      public void read(org.apache.thrift.protocol.TProtocol prot, preparedstatement_addBatch_result struct) throws org.apache.thrift.TException {
        TTupleProtocol iprot = (TTupleProtocol) prot;
        BitSet incoming = iprot.readBitSet(1);
        if (incoming.get(0)) {
          struct.sqlException = new RSQLException();
          struct.sqlException.read(iprot);
          struct.setSqlExceptionIsSet(true);
        }
      }
    }

  }

  public static class preparedstatement_executeBatch_args implements org.apache.thrift.TBase<preparedstatement_executeBatch_args, preparedstatement_executeBatch_args._Fields>, java.io.Serializable, Cloneable, Comparable<preparedstatement_executeBatch_args>   {
    private static final org.apache.thrift.protocol.TStruct STRUCT_DESC = new org.apache.thrift.protocol.TStruct("preparedstatement_executeBatch_args");

    private static final org.apache.thrift.protocol.TField STATEMENT_FIELD_DESC = new org.apache.thrift.protocol.TField("statement", org.apache.thrift.protocol.TType.STRUCT, (short)1);
    private static final org.apache.thrift.protocol.TField PARAMETERS_FIELD_DESC = new org.apache.thrift.protocol.TField("parameters", org.apache.thrift.protocol.TType.LIST, (short)2);

    private static final Map<Class<? extends IScheme>, SchemeFactory> schemes = new HashMap<Class<? extends IScheme>, SchemeFactory>();
    static {
      schemes.put(StandardScheme.class, new preparedstatement_executeBatch_argsStandardSchemeFactory());
      schemes.put(TupleScheme.class, new preparedstatement_executeBatch_argsTupleSchemeFactory());
    }

    public RStatement statement; // required
    public List<List<RValueSQL>> parameters; // required

    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements org.apache.thrift.TFieldIdEnum {
      STATEMENT((short)1, "statement"),
      PARAMETERS((short)2, "parameters");

      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        switch(fieldId) {
          case 1: // STATEMENT
            return STATEMENT;
          case 2: // PARAMETERS
            return PARAMETERS;
          default:
            return null;
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }

    // isset id assignments
    public static final Map<_Fields, org.apache.thrift.meta_data.FieldMetaData> metaDataMap;
    static {
      Map<_Fields, org.apache.thrift.meta_data.FieldMetaData> tmpMap = new EnumMap<_Fields, org.apache.thrift.meta_data.FieldMetaData>(_Fields.class);
      tmpMap.put(_Fields.STATEMENT, new org.apache.thrift.meta_data.FieldMetaData("statement", org.apache.thrift.TFieldRequirementType.DEFAULT, 
          new org.apache.thrift.meta_data.StructMetaData(org.apache.thrift.protocol.TType.STRUCT, RStatement.class)));
      tmpMap.put(_Fields.PARAMETERS, new org.apache.thrift.meta_data.FieldMetaData("parameters", org.apache.thrift.TFieldRequirementType.DEFAULT, 
          new org.apache.thrift.meta_data.ListMetaData(org.apache.thrift.protocol.TType.LIST, 
              new org.apache.thrift.meta_data.ListMetaData(org.apache.thrift.protocol.TType.LIST, 
                  new org.apache.thrift.meta_data.StructMetaData(org.apache.thrift.protocol.TType.STRUCT, RValueSQL.class)))));
      metaDataMap = Collections.unmodifiableMap(tmpMap);
      org.apache.thrift.meta_data.FieldMetaData.addStructMetaDataMap(preparedstatement_executeBatch_args.class, metaDataMap);
    }

    public preparedstatement_executeBatch_args() {
    }

    public preparedstatement_executeBatch_args(
      RStatement statement,
      List<List<RValueSQL>> parameters)
    {
      this();
      this.statement = statement;
      this.parameters = parameters;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public preparedstatement_executeBatch_args(preparedstatement_executeBatch_args other) {
      if (other.isSetStatement()) {
        this.statement = new RStatement(other.statement);
      }
      if (other.isSetParameters()) {
        List<List<RValueSQL>> __this__parameters = new ArrayList<List<RValueSQL>>(other.parameters.size());
        for (List<RValueSQL> other_element : other.parameters) {
          List<RValueSQL> __this__parameters_copy = new ArrayList<RValueSQL>(other_element.size());
          for (RValueSQL other_element_element : other_element) {
            __this__parameters_copy.add(new RValueSQL(other_element_element));
          }
          __this__parameters.add(__this__parameters_copy);
        }
        this.parameters = __this__parameters;
      }
    }

    public preparedstatement_executeBatch_args deepCopy() {
      return new preparedstatement_executeBatch_args(this);
    }

    @Override
    public void clear() {
      this.statement = null;
      this.parameters = null;
    }

    public RStatement getStatement() {
      return this.statement;
    }

    public preparedstatement_executeBatch_args setStatement(RStatement statement) {
      this.statement = statement;
      return this;
    }

    public void unsetStatement() {
      this.statement = null;
    }

    /** Returns true if field statement is set (has been assigned a value) and false otherwise */
    public boolean isSetStatement() {
      return this.statement != null;
    }

    public void setStatementIsSet(boolean value) {
      if (!value) {
        this.statement = null;
      }
    }

    public int getParametersSize() {
      return (this.parameters == null) ? 0 : this.parameters.size();
    }

    public java.util.Iterator<List<RValueSQL>> getParametersIterator() {
      return (this.parameters == null) ? null : this.parameters.iterator();
    }

    public void addToParameters(List<RValueSQL> elem) {
      if (this.parameters == null) {
        this.parameters = new ArrayList<List<RValueSQL>>();
      }
      this.parameters.add(elem);
    }

    public List<List<RValueSQL>> getParameters() {
      return this.parameters;
    }

    public preparedstatement_executeBatch_args setParameters(List<List<RValueSQL>> parameters) {
      this.parameters = parameters;
      return this;
    }

    public void unsetParameters() {
      this.parameters = null;
    }

    /** Returns true if field parameters is set (has been assigned a value) and false otherwise */
    public boolean isSetParameters() {
      return this.parameters != null;
    }

    public void setParametersIsSet(boolean value) {
      if (!value) {
        this.parameters = null;
      }
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      case STATEMENT:
        if (value == null) {
          unsetStatement();
        } else {
          setStatement((RStatement)value);
        }
        break;

      case PARAMETERS:
        if (value == null) {
          unsetParameters();
        } else {
          setParameters((List<List<RValueSQL>>)value);
        }
        break;

      }
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      case STATEMENT:
        return getStatement();

      case PARAMETERS:
        return getParameters();

      }
      throw new IllegalStateException();
    }

    /** Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      if (field == null) {
        throw new IllegalArgumentException();
      }

      switch (field) {
      case STATEMENT:
        return isSetStatement();
      case PARAMETERS:
        return isSetParameters();
      }
      throw new IllegalStateException();
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof preparedstatement_executeBatch_args)
        return this.equals((preparedstatement_executeBatch_args)that);
      return false;
    }

    public boolean equals(preparedstatement_executeBatch_args that) {
      if (that == null)
        return false;

      boolean this_present_statement = true && this.isSetStatement();
      boolean that_present_statement = true && that.isSetStatement();
      if (this_present_statement || that_present_statement) {
        if (!(this_present_statement && that_present_statement))
          return false;
        if (!this.statement.equals(that.statement))
          return false;
      }

      boolean this_present_parameters = true && this.isSetParameters();
      boolean that_present_parameters = true && that.isSetParameters();
      if (this_present_parameters || that_present_parameters) {
        if (!(this_present_parameters && that_present_parameters))
          return false;
        if (!this.parameters.equals(that.parameters))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      List<Object> list = new ArrayList<Object>();

      boolean present_statement = true && (isSetStatement());
      list.add(present_statement);
      if (present_statement)
        list.add(statement);

      boolean present_parameters = true && (isSetParameters());
      list.add(present_parameters);
      if (present_parameters)
        list.add(parameters);

      return list.hashCode();
    }

    @Override
    public int compareTo(preparedstatement_executeBatch_args other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetStatement()).compareTo(other.isSetStatement());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetStatement()) {
        lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.statement, other.statement);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      lastComparison = Boolean.valueOf(isSetParameters()).compareTo(other.isSetParameters());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetParameters()) {
        lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.parameters, other.parameters);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      return 0;
    }

    public _Fields fieldForId(int fieldId) {
      return _Fields.findByThriftId(fieldId);
    }

    public void read(org.apache.thrift.protocol.TProtocol iprot) throws org.apache.thrift.TException {
      schemes.get(iprot.getScheme()).getScheme().read(iprot, this);
    }

    public void write(org.apache.thrift.protocol.TProtocol oprot) throws org.apache.thrift.TException {
      schemes.get(oprot.getScheme()).getScheme().write(oprot, this);
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("preparedstatement_executeBatch_args(");
      boolean first = true;

      sb.append("statement:");
      if (this.statement == null) {
        sb.append("null");
      } else {
        sb.append(this.statement);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("parameters:");
      if (this.parameters == null) {
        sb.append("null");
      } else {
        sb.append(this.parameters);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws org.apache.thrift.TException {
      // check for required fields
      // check for sub-struct validity
      if (statement != null) {
        statement.validate();
      }
    }

    private void writeObject(java.io.ObjectOutputStream out) throws java.io.IOException {
      try {
        write(new org.apache.thrift.protocol.TCompactProtocol(new org.apache.thrift.transport.TIOStreamTransport(out)));
      } catch (org.apache.thrift.TException te) {
        throw new java.io.IOException(te);
      }
    }

    private void readObject(java.io.ObjectInputStream in) throws java.io.IOException, ClassNotFoundException {
      try {
        read(new org.apache.thrift.protocol.TCompactProtocol(new org.apache.thrift.transport.TIOStreamTransport(in)));
      } catch (org.apache.thrift.TException te) {
        throw new java.io.IOException(te);
      }
    }

    private static class preparedstatement_executeBatch_argsStandardSchemeFactory implements SchemeFactory {
      public preparedstatement_executeBatch_argsStandardScheme getScheme() {
        return new preparedstatement_executeBatch_argsStandardScheme();
      }
    }

    private static class preparedstatement_executeBatch_argsStandardScheme extends StandardScheme<preparedstatement_executeBatch_args> {

      public void read(org.apache.thrift.protocol.TProtocol iprot, preparedstatement_executeBatch_args struct) throws org.apache.thrift.TException {
        org.apache.thrift.protocol.TField schemeField;
        iprot.readStructBegin();
        while (true)
        {
          schemeField = iprot.readFieldBegin();
          if (schemeField.type == org.apache.thrift.protocol.TType.STOP) { 
            break;
          }
          switch (schemeField.id) {
            case 1: // STATEMENT
              if (schemeField.type == org.apache.thrift.protocol.TType.STRUCT) {
                struct.statement = new RStatement();
                struct.statement.read(iprot);
                struct.setStatementIsSet(true);
              } else { 
                org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
              }
              break;
            case 2: // PARAMETERS
              if (schemeField.type == org.apache.thrift.protocol.TType.LIST) {
                {
                  org.apache.thrift.protocol.TList _list114 = iprot.readListBegin();
                  struct.parameters = new ArrayList<List<RValueSQL>>(_list114.size);
                  List<RValueSQL> _elem115;
                  for (int _i116 = 0; _i116 < _list114.size; ++_i116)
                  {
                    {
                      org.apache.thrift.protocol.TList _list117 = iprot.readListBegin();
                      _elem115 = new ArrayList<RValueSQL>(_list117.size);
                      RValueSQL _elem118;
                      for (int _i119 = 0; _i119 < _list117.size; ++_i119)
                      {
                        _elem118 = new RValueSQL();
                        _elem118.read(iprot);
                        _elem115.add(_elem118);
                      }
                      iprot.readListEnd();
                    }
                    struct.parameters.add(_elem115);
                  }
                  iprot.readListEnd();
                }
                struct.setParametersIsSet(true);
              } else { 
                org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
              }
              break;
            default:
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
          }
          iprot.readFieldEnd();
        }
        iprot.readStructEnd();

        // check for required fields of primitive type, which can't be checked in the validate method
        struct.validate();
      }

      public void write(org.apache.thrift.protocol.TProtocol oprot, preparedstatement_executeBatch_args struct) throws org.apache.thrift.TException {
        struct.validate();

        oprot.writeStructBegin(STRUCT_DESC);
        if (struct.statement != null) {
          oprot.writeFieldBegin(STATEMENT_FIELD_DESC);
          struct.statement.write(oprot);
          oprot.writeFieldEnd();
        }
        if (struct.parameters != null) {
          oprot.writeFieldBegin(PARAMETERS_FIELD_DESC);
          {
            oprot.writeListBegin(new org.apache.thrift.protocol.TList(org.apache.thrift.protocol.TType.LIST, struct.parameters.size()));
            for (List<RValueSQL> _iter120 : struct.parameters)
            {
              {
                oprot.writeListBegin(new org.apache.thrift.protocol.TList(org.apache.thrift.protocol.TType.STRUCT, _iter120.size()));
                for (RValueSQL _iter121 : _iter120)
                {
                  _iter121.write(oprot);
                }
                oprot.writeListEnd();
              }
            }
            oprot.writeListEnd();
          }
          oprot.writeFieldEnd();
        }
        oprot.writeFieldStop();
        oprot.writeStructEnd();
      }

    }

    private static class preparedstatement_executeBatch_argsTupleSchemeFactory implements SchemeFactory {
      public preparedstatement_executeBatch_argsTupleScheme getScheme() {
        return new preparedstatement_executeBatch_argsTupleScheme();
      }
    }

    private static class preparedstatement_executeBatch_argsTupleScheme extends TupleScheme<preparedstatement_executeBatch_args> {

      @Override
      public void write(org.apache.thrift.protocol.TProtocol prot, preparedstatement_executeBatch_args struct) throws org.apache.thrift.TException {
        TTupleProtocol oprot = (TTupleProtocol) prot;
        BitSet optionals = new BitSet();
        if (struct.isSetStatement()) {
          optionals.set(0);
        }
        if (struct.isSetParameters()) {
          optionals.set(1);
        }
        oprot.writeBitSet(optionals, 2);
        if (struct.isSetStatement()) {
          struct.statement.write(oprot);
        }
        if (struct.isSetParameters()) {
          {
            oprot.writeI32(struct.parameters.size());
            for (List<RValueSQL> _iter122 : struct.parameters)
            {
              {
                oprot.writeI32(_iter122.size());
                for (RValueSQL _iter123 : _iter122)
                {
                  _iter123.write(oprot);
                }
              }
            }
          }
        }
      }

      @Override
      public void read(org.apache.thrift.protocol.TProtocol prot, preparedstatement_executeBatch_args struct) throws org.apache.thrift.TException {
        TTupleProtocol iprot = (TTupleProtocol) prot;
        BitSet incoming = iprot.readBitSet(2);
        if (incoming.get(0)) {
          struct.statement = new RStatement();
          struct.statement.read(iprot);
          struct.setStatementIsSet(true);
        }
        if (incoming.get(1)) {
          {
            org.apache.thrift.protocol.TList _list124 = new org.apache.thrift.protocol.TList(org.apache.thrift.protocol.TType.LIST, iprot.readI32());
            struct.parameters = new ArrayList<List<RValueSQL>>(_list124.size);
            List<RValueSQL> _elem125;
            for (int _i126 = 0; _i126 < _list124.size; ++_i126)
            {
              {
                org.apache.thrift.protocol.TList _list127 = new org.apache.thrift.protocol.TList(org.apache.thrift.protocol.TType.STRUCT, iprot.readI32());
                _elem125 = new ArrayList<RValueSQL>(_list127.size);
                RValueSQL _elem128;
                for (int _i129 = 0; _i129 < _list127.size; ++_i129)
                {
                  _elem128 = new RValueSQL();
                  _elem128.read(iprot);
                  _elem125.add(_elem128);
                }
              }
              struct.parameters.add(_elem125);
            }
          }
          struct.setParametersIsSet(true);
        }
      }
    }

  }

  public static class preparedstatement_executeBatch_result implements org.apache.thrift.TBase<preparedstatement_executeBatch_result, preparedstatement_executeBatch_result._Fields>, java.io.Serializable, Cloneable, Comparable<preparedstatement_executeBatch_result>   {
    private static final org.apache.thrift.protocol.TStruct STRUCT_DESC = new org.apache.thrift.protocol.TStruct("preparedstatement_executeBatch_result");

    private static final org.apache.thrift.protocol.TField SUCCESS_FIELD_DESC = new org.apache.thrift.protocol.TField("success", org.apache.thrift.protocol.TType.LIST, (short)0);
    private static final org.apache.thrift.protocol.TField SQL_EXCEPTION_FIELD_DESC = new org.apache.thrift.protocol.TField("sqlException", org.apache.thrift.protocol.TType.STRUCT, (short)1);

    private static final Map<Class<? extends IScheme>, SchemeFactory> schemes = new HashMap<Class<? extends IScheme>, SchemeFactory>();
    static {
      schemes.put(StandardScheme.class, new preparedstatement_executeBatch_resultStandardSchemeFactory());
      schemes.put(TupleScheme.class, new preparedstatement_executeBatch_resultTupleSchemeFactory());
    }

    public List<Integer> success; // required
    public RSQLException sqlException; // required

    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements org.apache.thrift.TFieldIdEnum {
      SUCCESS((short)0, "success"),
      SQL_EXCEPTION((short)1, "sqlException");

      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        switch(fieldId) {
          case 0: // SUCCESS
            return SUCCESS;
          case 1: // SQL_EXCEPTION
            return SQL_EXCEPTION;
          default:
            return null;
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }

    // isset id assignments
    public static final Map<_Fields, org.apache.thrift.meta_data.FieldMetaData> metaDataMap;
    static {
      Map<_Fields, org.apache.thrift.meta_data.FieldMetaData> tmpMap = new EnumMap<_Fields, org.apache.thrift.meta_data.FieldMetaData>(_Fields.class);
      tmpMap.put(_Fields.SUCCESS, new org.apache.thrift.meta_data.FieldMetaData("success", org.apache.thrift.TFieldRequirementType.DEFAULT, 
          new org.apache.thrift.meta_data.ListMetaData(org.apache.thrift.protocol.TType.LIST, 
              new org.apache.thrift.meta_data.FieldValueMetaData(org.apache.thrift.protocol.TType.I32))));
      tmpMap.put(_Fields.SQL_EXCEPTION, new org.apache.thrift.meta_data.FieldMetaData("sqlException", org.apache.thrift.TFieldRequirementType.DEFAULT, 
          new org.apache.thrift.meta_data.FieldValueMetaData(org.apache.thrift.protocol.TType.STRUCT)));
      metaDataMap = Collections.unmodifiableMap(tmpMap);
      org.apache.thrift.meta_data.FieldMetaData.addStructMetaDataMap(preparedstatement_executeBatch_result.class, metaDataMap);
    }

    public preparedstatement_executeBatch_result() {
    }

    public preparedstatement_executeBatch_result(
      List<Integer> success,
      RSQLException sqlException)
    {
      this();
      this.success = success;
      this.sqlException = sqlException;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public preparedstatement_executeBatch_result(preparedstatement_executeBatch_result other) {
      if (other.isSetSuccess()) {
        List<Integer> __this__success = new ArrayList<Integer>(other.success);
        this.success = __this__success;
      }
      if (other.isSetSqlException()) {
        this.sqlException = new RSQLException(other.sqlException);
      }
    }

    public preparedstatement_executeBatch_result deepCopy() {
      return new preparedstatement_executeBatch_result(this);
    }

    @Override
    public void clear() {
      this.success = null;
      this.sqlException = null;
    }

    public int getSuccessSize() {
      return (this.success == null) ? 0 : this.success.size();
    }

    public java.util.Iterator<Integer> getSuccessIterator() {
      return (this.success == null) ? null : this.success.iterator();
    }

    public void addToSuccess(int elem) {
      if (this.success == null) {
        this.success = new ArrayList<Integer>();
      }
      this.success.add(elem);
    }

    public List<Integer> getSuccess() {
      return this.success;
    }

    public preparedstatement_executeBatch_result setSuccess(List<Integer> success) {
      this.success = success;
      return this;
    }

    public void unsetSuccess() {
      this.success = null;
    }

    /** Returns true if field success is set (has been assigned a value) and false otherwise */
    public boolean isSetSuccess() {
      return this.success != null;
    }

    public void setSuccessIsSet(boolean value) {
      if (!value) {
        this.success = null;
      }
    }

    public RSQLException getSqlException() {
      return this.sqlException;
    }

    public preparedstatement_executeBatch_result setSqlException(RSQLException sqlException) {
      this.sqlException = sqlException;
      return this;
    }

    public void unsetSqlException() {
      this.sqlException = null;
    }

    /** Returns true if field sqlException is set (has been assigned a value) and false otherwise */
    public boolean isSetSqlException() {
      return this.sqlException != null;
    }

    public void setSqlExceptionIsSet(boolean value) {
      if (!value) {
        this.sqlException = null;
      }
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          setSuccess((List<Integer>)value);
        }
        break;

      case SQL_EXCEPTION:
        if (value == null) {
          unsetSqlException();
        } else {
          setSqlException((RSQLException)value);
        }
        break;

      }
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      case SUCCESS:
        return getSuccess();

      case SQL_EXCEPTION:
        return getSqlException();

      }
      throw new IllegalStateException();
    }

    /** Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      if (field == null) {
        throw new IllegalArgumentException();
      }

      switch (field) {
      case SUCCESS:
        return isSetSuccess();
      case SQL_EXCEPTION:
        return isSetSqlException();
      }
      throw new IllegalStateException();
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof preparedstatement_executeBatch_result)
        return this.equals((preparedstatement_executeBatch_result)that);
      return false;
    }

    public boolean equals(preparedstatement_executeBatch_result that) {
      if (that == null)
        return false;

      boolean this_present_success = true && this.isSetSuccess();
      boolean that_present_success = true && that.isSetSuccess();
      if (this_present_success || that_present_success) {
        if (!(this_present_success && that_present_success))
          return false;
        if (!this.success.equals(that.success))
          return false;
      }

      boolean this_present_sqlException = true && this.isSetSqlException();
      boolean that_present_sqlException = true && that.isSetSqlException();
      if (this_present_sqlException || that_present_sqlException) {
        if (!(this_present_sqlException && that_present_sqlException))
          return false;
        if (!this.sqlException.equals(that.sqlException))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      List<Object> list = new ArrayList<Object>();

      boolean present_success = true && (isSetSuccess());
      list.add(present_success);
      if (present_success)
        list.add(success);

      boolean present_sqlException = true && (isSetSqlException());
      list.add(present_sqlException);
      if (present_sqlException)
        list.add(sqlException);

      return list.hashCode();
    }

    @Override
    public int compareTo(preparedstatement_executeBatch_result other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetSuccess()).compareTo(other.isSetSuccess());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetSuccess()) {
        lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.success, other.success);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      lastComparison = Boolean.valueOf(isSetSqlException()).compareTo(other.isSetSqlException());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetSqlException()) {
        lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.sqlException, other.sqlException);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      return 0;
    }

    public _Fields fieldForId(int fieldId) {
      return _Fields.findByThriftId(fieldId);
    }

    public void read(org.apache.thrift.protocol.TProtocol iprot) throws org.apache.thrift.TException {
      schemes.get(iprot.getScheme()).getScheme().read(iprot, this);
    }

    public void write(org.apache.thrift.protocol.TProtocol oprot) throws org.apache.thrift.TException {
      schemes.get(oprot.getScheme()).getScheme().write(oprot, this);
      }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("preparedstatement_executeBatch_result(");
      boolean first = true;

      sb.append("success:");
      if (this.success == null) {
        sb.append("null");
      } else {
        sb.append(this.success);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("sqlException:");
      if (this.sqlException == null) {
        sb.append("null");
      } else {
        sb.append(this.sqlException);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws org.apache.thrift.TException {
      // check for required fields
      // check for sub-struct validity
    }

    private void writeObject(java.io.ObjectOutputStream out) throws java.io.IOException {
      try {
        write(new org.apache.thrift.protocol.TCompactProtocol(new org.apache.thrift.transport.TIOStreamTransport(out)));
      } catch (org.apache.thrift.TException te) {
        throw new java.io.IOException(te);
      }
    }

    private void readObject(java.io.ObjectInputStream in) throws java.io.IOException, ClassNotFoundException {
      try {
        read(new org.apache.thrift.protocol.TCompactProtocol(new org.apache.thrift.transport.TIOStreamTransport(in)));
      } catch (org.apache.thrift.TException te) {
        throw new java.io.IOException(te);
      }
    }

    private static class preparedstatement_executeBatch_resultStandardSchemeFactory implements SchemeFactory {
      public preparedstatement_executeBatch_resultStandardScheme getScheme() {
        return new preparedstatement_executeBatch_resultStandardScheme();
      }
    }

    private static class preparedstatement_executeBatch_resultStandardScheme extends StandardScheme<preparedstatement_executeBatch_result> {

      public void read(org.apache.thrift.protocol.TProtocol iprot, preparedstatement_executeBatch_result struct) throws org.apache.thrift.TException {
        org.apache.thrift.protocol.TField schemeField;
        iprot.readStructBegin();
        while (true)
        {
          schemeField = iprot.readFieldBegin();
          if (schemeField.type == org.apache.thrift.protocol.TType.STOP) { 
            break;
          }
          switch (schemeField.id) {
            case 0: // SUCCESS
              if (schemeField.type == org.apache.thrift.protocol.TType.LIST) {
                {
                  org.apache.thrift.protocol.TList _list130 = iprot.readListBegin();
                  struct.success = new ArrayList<Integer>(_list130.size);
                  int _elem131;
                  for (int _i132 = 0; _i132 < _list130.size; ++_i132)
                  {
                    _elem131 = iprot.readI32();
                    struct.success.add(_elem131);
                  }
                  iprot.readListEnd();
                }
                struct.setSuccessIsSet(true);
              } else { 
                org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
              }
              break;
            case 1: // SQL_EXCEPTION
              if (schemeField.type == org.apache.thrift.protocol.TType.STRUCT) {
                struct.sqlException = new RSQLException();
                struct.sqlException.read(iprot);
                struct.setSqlExceptionIsSet(true);
              } else { 
                org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
              }
              break;
            default:
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
          }
          iprot.readFieldEnd();
        }
        iprot.readStructEnd();

        // check for required fields of primitive type, which can't be checked in the validate method
        struct.validate();
      }

      public void write(org.apache.thrift.protocol.TProtocol oprot, preparedstatement_executeBatch_result struct) throws org.apache.thrift.TException {
        struct.validate();

        oprot.writeStructBegin(STRUCT_DESC);
        if (struct.success != null) {
          oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
          {
            oprot.writeListBegin(new org.apache.thrift.protocol.TList(org.apache.thrift.protocol.TType.I32, struct.success.size()));
            for (int _iter133 : struct.success)
            {
              oprot.writeI32(_iter133);
            }
            oprot.writeListEnd();
          }
          oprot.writeFieldEnd();
        }
        if (struct.sqlException != null) {
          oprot.writeFieldBegin(SQL_EXCEPTION_FIELD_DESC);
          struct.sqlException.write(oprot);
          oprot.writeFieldEnd();
        }
        oprot.writeFieldStop();
        oprot.writeStructEnd();
      }

    }

    private static class preparedstatement_executeBatch_resultTupleSchemeFactory implements SchemeFactory {
      public preparedstatement_executeBatch_resultTupleScheme getScheme() {
        return new preparedstatement_executeBatch_resultTupleScheme();
      }
    }

    private static class preparedstatement_executeBatch_resultTupleScheme extends TupleScheme<preparedstatement_executeBatch_result> {

      @Override
      public void write(org.apache.thrift.protocol.TProtocol prot, preparedstatement_executeBatch_result struct) throws org.apache.thrift.TException {
        TTupleProtocol oprot = (TTupleProtocol) prot;
        BitSet optionals = new BitSet();
        if (struct.isSetSuccess()) {
          optionals.set(0);
        }
        if (struct.isSetSqlException()) {
          optionals.set(1);
        }
        oprot.writeBitSet(optionals, 2);
        if (struct.isSetSuccess()) {
          {
            oprot.writeI32(struct.success.size());
            for (int _iter134 : struct.success)
            {
              oprot.writeI32(_iter134);
            }
          }
        }
        if (struct.isSetSqlException()) {
          struct.sqlException.write(oprot);
        }
      }

      @Override
      public void read(org.apache.thrift.protocol.TProtocol prot, preparedstatement_executeBatch_result struct) throws org.apache.thrift.TException {
        TTupleProtocol iprot = (TTupleProtocol) prot;
        BitSet incoming = iprot.readBitSet(2);
        if (incoming.get(0)) {
          {
            org.apache.thrift.protocol.TList _list135 = new org.apache.thrift.protocol.TList(org.apache.thrift.protocol.TType.I32, iprot.readI32());
            struct.success = new ArrayList<Integer>(_list135.size);
            int _elem136;
            for (int _i137 = 0; _i137 < _list135.size; ++_i137)
            {
              _elem136 = iprot.readI32();
              struct.success.add(_elem136);
            }
          }
          struct.setSuccessIsSet(true);
        }
        if (incoming.get(1)) {
          struct.sqlException = new RSQLException();
          struct.sqlException.read(iprot);
          struct.setSqlExceptionIsSet(true);
        }
      }
    }

  }

  public static class statement_getWarnings_args implements org.apache.thrift.TBase<statement_getWarnings_args, statement_getWarnings_args._Fields>, java.io.Serializable, Cloneable, Comparable<statement_getWarnings_args>   {
    private static final org.apache.thrift.protocol.TStruct STRUCT_DESC = new org.apache.thrift.protocol.TStruct("statement_getWarnings_args");

    private static final org.apache.thrift.protocol.TField STATEMENT_FIELD_DESC = new org.apache.thrift.protocol.TField("statement", org.apache.thrift.protocol.TType.STRUCT, (short)1);

    private static final Map<Class<? extends IScheme>, SchemeFactory> schemes = new HashMap<Class<? extends IScheme>, SchemeFactory>();
    static {
      schemes.put(StandardScheme.class, new statement_getWarnings_argsStandardSchemeFactory());
      schemes.put(TupleScheme.class, new statement_getWarnings_argsTupleSchemeFactory());
    }

    public RStatement statement; // required

    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements org.apache.thrift.TFieldIdEnum {
      STATEMENT((short)1, "statement");

      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        switch(fieldId) {
          case 1: // STATEMENT
            return STATEMENT;
          default:
            return null;
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }

    // isset id assignments
    public static final Map<_Fields, org.apache.thrift.meta_data.FieldMetaData> metaDataMap;
    static {
      Map<_Fields, org.apache.thrift.meta_data.FieldMetaData> tmpMap = new EnumMap<_Fields, org.apache.thrift.meta_data.FieldMetaData>(_Fields.class);
      tmpMap.put(_Fields.STATEMENT, new org.apache.thrift.meta_data.FieldMetaData("statement", org.apache.thrift.TFieldRequirementType.DEFAULT, 
          new org.apache.thrift.meta_data.StructMetaData(org.apache.thrift.protocol.TType.STRUCT, RStatement.class)));
      metaDataMap = Collections.unmodifiableMap(tmpMap);
      org.apache.thrift.meta_data.FieldMetaData.addStructMetaDataMap(statement_getWarnings_args.class, metaDataMap);
    }

    public statement_getWarnings_args() {
    }

    public statement_getWarnings_args(
      RStatement statement)
    {
      this();
      this.statement = statement;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public statement_getWarnings_args(statement_getWarnings_args other) {
      if (other.isSetStatement()) {
        this.statement = new RStatement(other.statement);
      }
    }

    public statement_getWarnings_args deepCopy() {
      return new statement_getWarnings_args(this);
    }

    @Override
    public void clear() {
      this.statement = null;
    }

    public RStatement getStatement() {
      return this.statement;
    }

    public statement_getWarnings_args setStatement(RStatement statement) {
      this.statement = statement;
      return this;
    }

    public void unsetStatement() {
      this.statement = null;
    }

    /** Returns true if field statement is set (has been assigned a value) and false otherwise */
    public boolean isSetStatement() {
      return this.statement != null;
    }

    public void setStatementIsSet(boolean value) {
      if (!value) {
        this.statement = null;
      }
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      case STATEMENT:
        if (value == null) {
          unsetStatement();
        } else {
          setStatement((RStatement)value);
        }
        break;

      }
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      case STATEMENT:
        return getStatement();

      }
      throw new IllegalStateException();
    }

    /** Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      if (field == null) {
        throw new IllegalArgumentException();
      }

      switch (field) {
      case STATEMENT:
        return isSetStatement();
      }
      throw new IllegalStateException();
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof statement_getWarnings_args)
        return this.equals((statement_getWarnings_args)that);
      return false;
    }

    public boolean equals(statement_getWarnings_args that) {
      if (that == null)
        return false;

      boolean this_present_statement = true && this.isSetStatement();
      boolean that_present_statement = true && that.isSetStatement();
      if (this_present_statement || that_present_statement) {
        if (!(this_present_statement && that_present_statement))
          return false;
        if (!this.statement.equals(that.statement))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      List<Object> list = new ArrayList<Object>();

      boolean present_statement = true && (isSetStatement());
      list.add(present_statement);
      if (present_statement)
        list.add(statement);

      return list.hashCode();
    }

    @Override
    public int compareTo(statement_getWarnings_args other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetStatement()).compareTo(other.isSetStatement());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetStatement()) {
        lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.statement, other.statement);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      return 0;
    }

    public _Fields fieldForId(int fieldId) {
      return _Fields.findByThriftId(fieldId);
    }

    public void read(org.apache.thrift.protocol.TProtocol iprot) throws org.apache.thrift.TException {
      schemes.get(iprot.getScheme()).getScheme().read(iprot, this);
    }

    public void write(org.apache.thrift.protocol.TProtocol oprot) throws org.apache.thrift.TException {
      schemes.get(oprot.getScheme()).getScheme().write(oprot, this);
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("statement_getWarnings_args(");
      boolean first = true;

      sb.append("statement:");
      if (this.statement == null) {
        sb.append("null");
      } else {
        sb.append(this.statement);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws org.apache.thrift.TException {
      // check for required fields
      // check for sub-struct validity
      if (statement != null) {
        statement.validate();
      }
    }

    private void writeObject(java.io.ObjectOutputStream out) throws java.io.IOException {
      try {
        write(new org.apache.thrift.protocol.TCompactProtocol(new org.apache.thrift.transport.TIOStreamTransport(out)));
      } catch (org.apache.thrift.TException te) {
        throw new java.io.IOException(te);
      }
    }

    private void readObject(java.io.ObjectInputStream in) throws java.io.IOException, ClassNotFoundException {
      try {
        read(new org.apache.thrift.protocol.TCompactProtocol(new org.apache.thrift.transport.TIOStreamTransport(in)));
      } catch (org.apache.thrift.TException te) {
        throw new java.io.IOException(te);
      }
    }

    private static class statement_getWarnings_argsStandardSchemeFactory implements SchemeFactory {
      public statement_getWarnings_argsStandardScheme getScheme() {
        return new statement_getWarnings_argsStandardScheme();
      }
    }

    private static class statement_getWarnings_argsStandardScheme extends StandardScheme<statement_getWarnings_args> {

      public void read(org.apache.thrift.protocol.TProtocol iprot, statement_getWarnings_args struct) throws org.apache.thrift.TException {
        org.apache.thrift.protocol.TField schemeField;
        iprot.readStructBegin();
        while (true)
        {
          schemeField = iprot.readFieldBegin();
          if (schemeField.type == org.apache.thrift.protocol.TType.STOP) { 
            break;
          }
          switch (schemeField.id) {
            case 1: // STATEMENT
              if (schemeField.type == org.apache.thrift.protocol.TType.STRUCT) {
                struct.statement = new RStatement();
                struct.statement.read(iprot);
                struct.setStatementIsSet(true);
              } else { 
                org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
              }
              break;
            default:
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
          }
          iprot.readFieldEnd();
        }
        iprot.readStructEnd();

        // check for required fields of primitive type, which can't be checked in the validate method
        struct.validate();
      }

      public void write(org.apache.thrift.protocol.TProtocol oprot, statement_getWarnings_args struct) throws org.apache.thrift.TException {
        struct.validate();

        oprot.writeStructBegin(STRUCT_DESC);
        if (struct.statement != null) {
          oprot.writeFieldBegin(STATEMENT_FIELD_DESC);
          struct.statement.write(oprot);
          oprot.writeFieldEnd();
        }
        oprot.writeFieldStop();
        oprot.writeStructEnd();
      }

    }

    private static class statement_getWarnings_argsTupleSchemeFactory implements SchemeFactory {
      public statement_getWarnings_argsTupleScheme getScheme() {
        return new statement_getWarnings_argsTupleScheme();
      }
    }

    private static class statement_getWarnings_argsTupleScheme extends TupleScheme<statement_getWarnings_args> {

      @Override
      public void write(org.apache.thrift.protocol.TProtocol prot, statement_getWarnings_args struct) throws org.apache.thrift.TException {
        TTupleProtocol oprot = (TTupleProtocol) prot;
        BitSet optionals = new BitSet();
        if (struct.isSetStatement()) {
          optionals.set(0);
        }
        oprot.writeBitSet(optionals, 1);
        if (struct.isSetStatement()) {
          struct.statement.write(oprot);
        }
      }

      @Override
      public void read(org.apache.thrift.protocol.TProtocol prot, statement_getWarnings_args struct) throws org.apache.thrift.TException {
        TTupleProtocol iprot = (TTupleProtocol) prot;
        BitSet incoming = iprot.readBitSet(1);
        if (incoming.get(0)) {
          struct.statement = new RStatement();
          struct.statement.read(iprot);
          struct.setStatementIsSet(true);
        }
      }
    }

  }

  public static class statement_getWarnings_result implements org.apache.thrift.TBase<statement_getWarnings_result, statement_getWarnings_result._Fields>, java.io.Serializable, Cloneable, Comparable<statement_getWarnings_result>   {
    private static final org.apache.thrift.protocol.TStruct STRUCT_DESC = new org.apache.thrift.protocol.TStruct("statement_getWarnings_result");

    private static final org.apache.thrift.protocol.TField SUCCESS_FIELD_DESC = new org.apache.thrift.protocol.TField("success", org.apache.thrift.protocol.TType.STRUCT, (short)0);
    private static final org.apache.thrift.protocol.TField SQL_EXCEPTION_FIELD_DESC = new org.apache.thrift.protocol.TField("sqlException", org.apache.thrift.protocol.TType.STRUCT, (short)1);

    private static final Map<Class<? extends IScheme>, SchemeFactory> schemes = new HashMap<Class<? extends IScheme>, SchemeFactory>();
    static {
      schemes.put(StandardScheme.class, new statement_getWarnings_resultStandardSchemeFactory());
      schemes.put(TupleScheme.class, new statement_getWarnings_resultTupleSchemeFactory());
    }

    public statement_getWarnings_return success; // required
    public RSQLException sqlException; // required

    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements org.apache.thrift.TFieldIdEnum {
      SUCCESS((short)0, "success"),
      SQL_EXCEPTION((short)1, "sqlException");

      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        switch(fieldId) {
          case 0: // SUCCESS
            return SUCCESS;
          case 1: // SQL_EXCEPTION
            return SQL_EXCEPTION;
          default:
            return null;
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }

    // isset id assignments
    public static final Map<_Fields, org.apache.thrift.meta_data.FieldMetaData> metaDataMap;
    static {
      Map<_Fields, org.apache.thrift.meta_data.FieldMetaData> tmpMap = new EnumMap<_Fields, org.apache.thrift.meta_data.FieldMetaData>(_Fields.class);
      tmpMap.put(_Fields.SUCCESS, new org.apache.thrift.meta_data.FieldMetaData("success", org.apache.thrift.TFieldRequirementType.DEFAULT, 
          new org.apache.thrift.meta_data.StructMetaData(org.apache.thrift.protocol.TType.STRUCT, statement_getWarnings_return.class)));
      tmpMap.put(_Fields.SQL_EXCEPTION, new org.apache.thrift.meta_data.FieldMetaData("sqlException", org.apache.thrift.TFieldRequirementType.DEFAULT, 
          new org.apache.thrift.meta_data.FieldValueMetaData(org.apache.thrift.protocol.TType.STRUCT)));
      metaDataMap = Collections.unmodifiableMap(tmpMap);
      org.apache.thrift.meta_data.FieldMetaData.addStructMetaDataMap(statement_getWarnings_result.class, metaDataMap);
    }

    public statement_getWarnings_result() {
    }

    public statement_getWarnings_result(
      statement_getWarnings_return success,
      RSQLException sqlException)
    {
      this();
      this.success = success;
      this.sqlException = sqlException;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public statement_getWarnings_result(statement_getWarnings_result other) {
      if (other.isSetSuccess()) {
        this.success = new statement_getWarnings_return(other.success);
      }
      if (other.isSetSqlException()) {
        this.sqlException = new RSQLException(other.sqlException);
      }
    }

    public statement_getWarnings_result deepCopy() {
      return new statement_getWarnings_result(this);
    }

    @Override
    public void clear() {
      this.success = null;
      this.sqlException = null;
    }

    public statement_getWarnings_return getSuccess() {
      return this.success;
    }

    public statement_getWarnings_result setSuccess(statement_getWarnings_return success) {
      this.success = success;
      return this;
    }

    public void unsetSuccess() {
      this.success = null;
    }

    /** Returns true if field success is set (has been assigned a value) and false otherwise */
    public boolean isSetSuccess() {
      return this.success != null;
    }

    public void setSuccessIsSet(boolean value) {
      if (!value) {
        this.success = null;
      }
    }

    public RSQLException getSqlException() {
      return this.sqlException;
    }

    public statement_getWarnings_result setSqlException(RSQLException sqlException) {
      this.sqlException = sqlException;
      return this;
    }

    public void unsetSqlException() {
      this.sqlException = null;
    }

    /** Returns true if field sqlException is set (has been assigned a value) and false otherwise */
    public boolean isSetSqlException() {
      return this.sqlException != null;
    }

    public void setSqlExceptionIsSet(boolean value) {
      if (!value) {
        this.sqlException = null;
      }
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          setSuccess((statement_getWarnings_return)value);
        }
        break;

      case SQL_EXCEPTION:
        if (value == null) {
          unsetSqlException();
        } else {
          setSqlException((RSQLException)value);
        }
        break;

      }
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      case SUCCESS:
        return getSuccess();

      case SQL_EXCEPTION:
        return getSqlException();

      }
      throw new IllegalStateException();
    }

    /** Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      if (field == null) {
        throw new IllegalArgumentException();
      }

      switch (field) {
      case SUCCESS:
        return isSetSuccess();
      case SQL_EXCEPTION:
        return isSetSqlException();
      }
      throw new IllegalStateException();
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof statement_getWarnings_result)
        return this.equals((statement_getWarnings_result)that);
      return false;
    }

    public boolean equals(statement_getWarnings_result that) {
      if (that == null)
        return false;

      boolean this_present_success = true && this.isSetSuccess();
      boolean that_present_success = true && that.isSetSuccess();
      if (this_present_success || that_present_success) {
        if (!(this_present_success && that_present_success))
          return false;
        if (!this.success.equals(that.success))
          return false;
      }

      boolean this_present_sqlException = true && this.isSetSqlException();
      boolean that_present_sqlException = true && that.isSetSqlException();
      if (this_present_sqlException || that_present_sqlException) {
        if (!(this_present_sqlException && that_present_sqlException))
          return false;
        if (!this.sqlException.equals(that.sqlException))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      List<Object> list = new ArrayList<Object>();

      boolean present_success = true && (isSetSuccess());
      list.add(present_success);
      if (present_success)
        list.add(success);

      boolean present_sqlException = true && (isSetSqlException());
      list.add(present_sqlException);
      if (present_sqlException)
        list.add(sqlException);

      return list.hashCode();
    }

    @Override
    public int compareTo(statement_getWarnings_result other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetSuccess()).compareTo(other.isSetSuccess());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetSuccess()) {
        lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.success, other.success);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      lastComparison = Boolean.valueOf(isSetSqlException()).compareTo(other.isSetSqlException());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetSqlException()) {
        lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.sqlException, other.sqlException);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      return 0;
    }

    public _Fields fieldForId(int fieldId) {
      return _Fields.findByThriftId(fieldId);
    }

    public void read(org.apache.thrift.protocol.TProtocol iprot) throws org.apache.thrift.TException {
      schemes.get(iprot.getScheme()).getScheme().read(iprot, this);
    }

    public void write(org.apache.thrift.protocol.TProtocol oprot) throws org.apache.thrift.TException {
      schemes.get(oprot.getScheme()).getScheme().write(oprot, this);
      }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("statement_getWarnings_result(");
      boolean first = true;

      sb.append("success:");
      if (this.success == null) {
        sb.append("null");
      } else {
        sb.append(this.success);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("sqlException:");
      if (this.sqlException == null) {
        sb.append("null");
      } else {
        sb.append(this.sqlException);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws org.apache.thrift.TException {
      // check for required fields
      // check for sub-struct validity
      if (success != null) {
        success.validate();
      }
    }

    private void writeObject(java.io.ObjectOutputStream out) throws java.io.IOException {
      try {
        write(new org.apache.thrift.protocol.TCompactProtocol(new org.apache.thrift.transport.TIOStreamTransport(out)));
      } catch (org.apache.thrift.TException te) {
        throw new java.io.IOException(te);
      }
    }

    private void readObject(java.io.ObjectInputStream in) throws java.io.IOException, ClassNotFoundException {
      try {
        read(new org.apache.thrift.protocol.TCompactProtocol(new org.apache.thrift.transport.TIOStreamTransport(in)));
      } catch (org.apache.thrift.TException te) {
        throw new java.io.IOException(te);
      }
    }

    private static class statement_getWarnings_resultStandardSchemeFactory implements SchemeFactory {
      public statement_getWarnings_resultStandardScheme getScheme() {
        return new statement_getWarnings_resultStandardScheme();
      }
    }

    private static class statement_getWarnings_resultStandardScheme extends StandardScheme<statement_getWarnings_result> {

      public void read(org.apache.thrift.protocol.TProtocol iprot, statement_getWarnings_result struct) throws org.apache.thrift.TException {
        org.apache.thrift.protocol.TField schemeField;
        iprot.readStructBegin();
        while (true)
        {
          schemeField = iprot.readFieldBegin();
          if (schemeField.type == org.apache.thrift.protocol.TType.STOP) { 
            break;
          }
          switch (schemeField.id) {
            case 0: // SUCCESS
              if (schemeField.type == org.apache.thrift.protocol.TType.STRUCT) {
                struct.success = new statement_getWarnings_return();
                struct.success.read(iprot);
                struct.setSuccessIsSet(true);
              } else { 
                org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
              }
              break;
            case 1: // SQL_EXCEPTION
              if (schemeField.type == org.apache.thrift.protocol.TType.STRUCT) {
                struct.sqlException = new RSQLException();
                struct.sqlException.read(iprot);
                struct.setSqlExceptionIsSet(true);
              } else { 
                org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
              }
              break;
            default:
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
          }
          iprot.readFieldEnd();
        }
        iprot.readStructEnd();

        // check for required fields of primitive type, which can't be checked in the validate method
        struct.validate();
      }

      public void write(org.apache.thrift.protocol.TProtocol oprot, statement_getWarnings_result struct) throws org.apache.thrift.TException {
        struct.validate();

        oprot.writeStructBegin(STRUCT_DESC);
        if (struct.success != null) {
          oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
          struct.success.write(oprot);
          oprot.writeFieldEnd();
        }
        if (struct.sqlException != null) {
          oprot.writeFieldBegin(SQL_EXCEPTION_FIELD_DESC);
          struct.sqlException.write(oprot);
          oprot.writeFieldEnd();
        }
        oprot.writeFieldStop();
        oprot.writeStructEnd();
      }

    }

    private static class statement_getWarnings_resultTupleSchemeFactory implements SchemeFactory {
      public statement_getWarnings_resultTupleScheme getScheme() {
        return new statement_getWarnings_resultTupleScheme();
      }
    }

    private static class statement_getWarnings_resultTupleScheme extends TupleScheme<statement_getWarnings_result> {

      @Override
      public void write(org.apache.thrift.protocol.TProtocol prot, statement_getWarnings_result struct) throws org.apache.thrift.TException {
        TTupleProtocol oprot = (TTupleProtocol) prot;
        BitSet optionals = new BitSet();
        if (struct.isSetSuccess()) {
          optionals.set(0);
        }
        if (struct.isSetSqlException()) {
          optionals.set(1);
        }
        oprot.writeBitSet(optionals, 2);
        if (struct.isSetSuccess()) {
          struct.success.write(oprot);
        }
        if (struct.isSetSqlException()) {
          struct.sqlException.write(oprot);
        }
      }

      @Override
      public void read(org.apache.thrift.protocol.TProtocol prot, statement_getWarnings_result struct) throws org.apache.thrift.TException {
        TTupleProtocol iprot = (TTupleProtocol) prot;
        BitSet incoming = iprot.readBitSet(2);
        if (incoming.get(0)) {
          struct.success = new statement_getWarnings_return();
          struct.success.read(iprot);
          struct.setSuccessIsSet(true);
        }
        if (incoming.get(1)) {
          struct.sqlException = new RSQLException();
          struct.sqlException.read(iprot);
          struct.setSqlExceptionIsSet(true);
        }
      }
    }

  }

  public static class statement_clearWarnings_args implements org.apache.thrift.TBase<statement_clearWarnings_args, statement_clearWarnings_args._Fields>, java.io.Serializable, Cloneable, Comparable<statement_clearWarnings_args>   {
    private static final org.apache.thrift.protocol.TStruct STRUCT_DESC = new org.apache.thrift.protocol.TStruct("statement_clearWarnings_args");

    private static final org.apache.thrift.protocol.TField STATEMENT_FIELD_DESC = new org.apache.thrift.protocol.TField("statement", org.apache.thrift.protocol.TType.STRUCT, (short)1);

    private static final Map<Class<? extends IScheme>, SchemeFactory> schemes = new HashMap<Class<? extends IScheme>, SchemeFactory>();
    static {
      schemes.put(StandardScheme.class, new statement_clearWarnings_argsStandardSchemeFactory());
      schemes.put(TupleScheme.class, new statement_clearWarnings_argsTupleSchemeFactory());
    }

    public RStatement statement; // required

    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements org.apache.thrift.TFieldIdEnum {
      STATEMENT((short)1, "statement");

      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        switch(fieldId) {
          case 1: // STATEMENT
            return STATEMENT;
          default:
            return null;
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }

    // isset id assignments
    public static final Map<_Fields, org.apache.thrift.meta_data.FieldMetaData> metaDataMap;
    static {
      Map<_Fields, org.apache.thrift.meta_data.FieldMetaData> tmpMap = new EnumMap<_Fields, org.apache.thrift.meta_data.FieldMetaData>(_Fields.class);
      tmpMap.put(_Fields.STATEMENT, new org.apache.thrift.meta_data.FieldMetaData("statement", org.apache.thrift.TFieldRequirementType.DEFAULT, 
          new org.apache.thrift.meta_data.StructMetaData(org.apache.thrift.protocol.TType.STRUCT, RStatement.class)));
      metaDataMap = Collections.unmodifiableMap(tmpMap);
      org.apache.thrift.meta_data.FieldMetaData.addStructMetaDataMap(statement_clearWarnings_args.class, metaDataMap);
    }

    public statement_clearWarnings_args() {
    }

    public statement_clearWarnings_args(
      RStatement statement)
    {
      this();
      this.statement = statement;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public statement_clearWarnings_args(statement_clearWarnings_args other) {
      if (other.isSetStatement()) {
        this.statement = new RStatement(other.statement);
      }
    }

    public statement_clearWarnings_args deepCopy() {
      return new statement_clearWarnings_args(this);
    }

    @Override
    public void clear() {
      this.statement = null;
    }

    public RStatement getStatement() {
      return this.statement;
    }

    public statement_clearWarnings_args setStatement(RStatement statement) {
      this.statement = statement;
      return this;
    }

    public void unsetStatement() {
      this.statement = null;
    }

    /** Returns true if field statement is set (has been assigned a value) and false otherwise */
    public boolean isSetStatement() {
      return this.statement != null;
    }

    public void setStatementIsSet(boolean value) {
      if (!value) {
        this.statement = null;
      }
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      case STATEMENT:
        if (value == null) {
          unsetStatement();
        } else {
          setStatement((RStatement)value);
        }
        break;

      }
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      case STATEMENT:
        return getStatement();

      }
      throw new IllegalStateException();
    }

    /** Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      if (field == null) {
        throw new IllegalArgumentException();
      }

      switch (field) {
      case STATEMENT:
        return isSetStatement();
      }
      throw new IllegalStateException();
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof statement_clearWarnings_args)
        return this.equals((statement_clearWarnings_args)that);
      return false;
    }

    public boolean equals(statement_clearWarnings_args that) {
      if (that == null)
        return false;

      boolean this_present_statement = true && this.isSetStatement();
      boolean that_present_statement = true && that.isSetStatement();
      if (this_present_statement || that_present_statement) {
        if (!(this_present_statement && that_present_statement))
          return false;
        if (!this.statement.equals(that.statement))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      List<Object> list = new ArrayList<Object>();

      boolean present_statement = true && (isSetStatement());
      list.add(present_statement);
      if (present_statement)
        list.add(statement);

      return list.hashCode();
    }

    @Override
    public int compareTo(statement_clearWarnings_args other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetStatement()).compareTo(other.isSetStatement());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetStatement()) {
        lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.statement, other.statement);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      return 0;
    }

    public _Fields fieldForId(int fieldId) {
      return _Fields.findByThriftId(fieldId);
    }

    public void read(org.apache.thrift.protocol.TProtocol iprot) throws org.apache.thrift.TException {
      schemes.get(iprot.getScheme()).getScheme().read(iprot, this);
    }

    public void write(org.apache.thrift.protocol.TProtocol oprot) throws org.apache.thrift.TException {
      schemes.get(oprot.getScheme()).getScheme().write(oprot, this);
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("statement_clearWarnings_args(");
      boolean first = true;

      sb.append("statement:");
      if (this.statement == null) {
        sb.append("null");
      } else {
        sb.append(this.statement);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws org.apache.thrift.TException {
      // check for required fields
      // check for sub-struct validity
      if (statement != null) {
        statement.validate();
      }
    }

    private void writeObject(java.io.ObjectOutputStream out) throws java.io.IOException {
      try {
        write(new org.apache.thrift.protocol.TCompactProtocol(new org.apache.thrift.transport.TIOStreamTransport(out)));
      } catch (org.apache.thrift.TException te) {
        throw new java.io.IOException(te);
      }
    }

    private void readObject(java.io.ObjectInputStream in) throws java.io.IOException, ClassNotFoundException {
      try {
        read(new org.apache.thrift.protocol.TCompactProtocol(new org.apache.thrift.transport.TIOStreamTransport(in)));
      } catch (org.apache.thrift.TException te) {
        throw new java.io.IOException(te);
      }
    }

    private static class statement_clearWarnings_argsStandardSchemeFactory implements SchemeFactory {
      public statement_clearWarnings_argsStandardScheme getScheme() {
        return new statement_clearWarnings_argsStandardScheme();
      }
    }

    private static class statement_clearWarnings_argsStandardScheme extends StandardScheme<statement_clearWarnings_args> {

      public void read(org.apache.thrift.protocol.TProtocol iprot, statement_clearWarnings_args struct) throws org.apache.thrift.TException {
        org.apache.thrift.protocol.TField schemeField;
        iprot.readStructBegin();
        while (true)
        {
          schemeField = iprot.readFieldBegin();
          if (schemeField.type == org.apache.thrift.protocol.TType.STOP) { 
            break;
          }
          switch (schemeField.id) {
            case 1: // STATEMENT
              if (schemeField.type == org.apache.thrift.protocol.TType.STRUCT) {
                struct.statement = new RStatement();
                struct.statement.read(iprot);
                struct.setStatementIsSet(true);
              } else { 
                org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
              }
              break;
            default:
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
          }
          iprot.readFieldEnd();
        }
        iprot.readStructEnd();

        // check for required fields of primitive type, which can't be checked in the validate method
        struct.validate();
      }

      public void write(org.apache.thrift.protocol.TProtocol oprot, statement_clearWarnings_args struct) throws org.apache.thrift.TException {
        struct.validate();

        oprot.writeStructBegin(STRUCT_DESC);
        if (struct.statement != null) {
          oprot.writeFieldBegin(STATEMENT_FIELD_DESC);
          struct.statement.write(oprot);
          oprot.writeFieldEnd();
        }
        oprot.writeFieldStop();
        oprot.writeStructEnd();
      }

    }

    private static class statement_clearWarnings_argsTupleSchemeFactory implements SchemeFactory {
      public statement_clearWarnings_argsTupleScheme getScheme() {
        return new statement_clearWarnings_argsTupleScheme();
      }
    }

    private static class statement_clearWarnings_argsTupleScheme extends TupleScheme<statement_clearWarnings_args> {

      @Override
      public void write(org.apache.thrift.protocol.TProtocol prot, statement_clearWarnings_args struct) throws org.apache.thrift.TException {
        TTupleProtocol oprot = (TTupleProtocol) prot;
        BitSet optionals = new BitSet();
        if (struct.isSetStatement()) {
          optionals.set(0);
        }
        oprot.writeBitSet(optionals, 1);
        if (struct.isSetStatement()) {
          struct.statement.write(oprot);
        }
      }

      @Override
      public void read(org.apache.thrift.protocol.TProtocol prot, statement_clearWarnings_args struct) throws org.apache.thrift.TException {
        TTupleProtocol iprot = (TTupleProtocol) prot;
        BitSet incoming = iprot.readBitSet(1);
        if (incoming.get(0)) {
          struct.statement = new RStatement();
          struct.statement.read(iprot);
          struct.setStatementIsSet(true);
        }
      }
    }

  }

  public static class statement_clearWarnings_result implements org.apache.thrift.TBase<statement_clearWarnings_result, statement_clearWarnings_result._Fields>, java.io.Serializable, Cloneable, Comparable<statement_clearWarnings_result>   {
    private static final org.apache.thrift.protocol.TStruct STRUCT_DESC = new org.apache.thrift.protocol.TStruct("statement_clearWarnings_result");

    private static final org.apache.thrift.protocol.TField SQL_EXCEPTION_FIELD_DESC = new org.apache.thrift.protocol.TField("sqlException", org.apache.thrift.protocol.TType.STRUCT, (short)1);

    private static final Map<Class<? extends IScheme>, SchemeFactory> schemes = new HashMap<Class<? extends IScheme>, SchemeFactory>();
    static {
      schemes.put(StandardScheme.class, new statement_clearWarnings_resultStandardSchemeFactory());
      schemes.put(TupleScheme.class, new statement_clearWarnings_resultTupleSchemeFactory());
    }

    public RSQLException sqlException; // required

    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements org.apache.thrift.TFieldIdEnum {
      SQL_EXCEPTION((short)1, "sqlException");

      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        switch(fieldId) {
          case 1: // SQL_EXCEPTION
            return SQL_EXCEPTION;
          default:
            return null;
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }

    // isset id assignments
    public static final Map<_Fields, org.apache.thrift.meta_data.FieldMetaData> metaDataMap;
    static {
      Map<_Fields, org.apache.thrift.meta_data.FieldMetaData> tmpMap = new EnumMap<_Fields, org.apache.thrift.meta_data.FieldMetaData>(_Fields.class);
      tmpMap.put(_Fields.SQL_EXCEPTION, new org.apache.thrift.meta_data.FieldMetaData("sqlException", org.apache.thrift.TFieldRequirementType.DEFAULT, 
          new org.apache.thrift.meta_data.FieldValueMetaData(org.apache.thrift.protocol.TType.STRUCT)));
      metaDataMap = Collections.unmodifiableMap(tmpMap);
      org.apache.thrift.meta_data.FieldMetaData.addStructMetaDataMap(statement_clearWarnings_result.class, metaDataMap);
    }

    public statement_clearWarnings_result() {
    }

    public statement_clearWarnings_result(
      RSQLException sqlException)
    {
      this();
      this.sqlException = sqlException;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public statement_clearWarnings_result(statement_clearWarnings_result other) {
      if (other.isSetSqlException()) {
        this.sqlException = new RSQLException(other.sqlException);
      }
    }

    public statement_clearWarnings_result deepCopy() {
      return new statement_clearWarnings_result(this);
    }

    @Override
    public void clear() {
      this.sqlException = null;
    }

    public RSQLException getSqlException() {
      return this.sqlException;
    }

    public statement_clearWarnings_result setSqlException(RSQLException sqlException) {
      this.sqlException = sqlException;
      return this;
    }

    public void unsetSqlException() {
      this.sqlException = null;
    }

    /** Returns true if field sqlException is set (has been assigned a value) and false otherwise */
    public boolean isSetSqlException() {
      return this.sqlException != null;
    }

    public void setSqlExceptionIsSet(boolean value) {
      if (!value) {
        this.sqlException = null;
      }
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      case SQL_EXCEPTION:
        if (value == null) {
          unsetSqlException();
        } else {
          setSqlException((RSQLException)value);
        }
        break;

      }
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      case SQL_EXCEPTION:
        return getSqlException();

      }
      throw new IllegalStateException();
    }

    /** Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      if (field == null) {
        throw new IllegalArgumentException();
      }

      switch (field) {
      case SQL_EXCEPTION:
        return isSetSqlException();
      }
      throw new IllegalStateException();
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof statement_clearWarnings_result)
        return this.equals((statement_clearWarnings_result)that);
      return false;
    }

    public boolean equals(statement_clearWarnings_result that) {
      if (that == null)
        return false;

      boolean this_present_sqlException = true && this.isSetSqlException();
      boolean that_present_sqlException = true && that.isSetSqlException();
      if (this_present_sqlException || that_present_sqlException) {
        if (!(this_present_sqlException && that_present_sqlException))
          return false;
        if (!this.sqlException.equals(that.sqlException))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      List<Object> list = new ArrayList<Object>();

      boolean present_sqlException = true && (isSetSqlException());
      list.add(present_sqlException);
      if (present_sqlException)
        list.add(sqlException);

      return list.hashCode();
    }

    @Override
    public int compareTo(statement_clearWarnings_result other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetSqlException()).compareTo(other.isSetSqlException());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetSqlException()) {
        lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.sqlException, other.sqlException);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      return 0;
    }

    public _Fields fieldForId(int fieldId) {
      return _Fields.findByThriftId(fieldId);
    }

    public void read(org.apache.thrift.protocol.TProtocol iprot) throws org.apache.thrift.TException {
      schemes.get(iprot.getScheme()).getScheme().read(iprot, this);
    }

    public void write(org.apache.thrift.protocol.TProtocol oprot) throws org.apache.thrift.TException {
      schemes.get(oprot.getScheme()).getScheme().write(oprot, this);
      }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("statement_clearWarnings_result(");
      boolean first = true;

      sb.append("sqlException:");
      if (this.sqlException == null) {
        sb.append("null");
      } else {
        sb.append(this.sqlException);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws org.apache.thrift.TException {
      // check for required fields
      // check for sub-struct validity
    }

    private void writeObject(java.io.ObjectOutputStream out) throws java.io.IOException {
      try {
        write(new org.apache.thrift.protocol.TCompactProtocol(new org.apache.thrift.transport.TIOStreamTransport(out)));
      } catch (org.apache.thrift.TException te) {
        throw new java.io.IOException(te);
      }
    }

    private void readObject(java.io.ObjectInputStream in) throws java.io.IOException, ClassNotFoundException {
      try {
        read(new org.apache.thrift.protocol.TCompactProtocol(new org.apache.thrift.transport.TIOStreamTransport(in)));
      } catch (org.apache.thrift.TException te) {
        throw new java.io.IOException(te);
      }
    }

    private static class statement_clearWarnings_resultStandardSchemeFactory implements SchemeFactory {
      public statement_clearWarnings_resultStandardScheme getScheme() {
        return new statement_clearWarnings_resultStandardScheme();
      }
    }

    private static class statement_clearWarnings_resultStandardScheme extends StandardScheme<statement_clearWarnings_result> {

      public void read(org.apache.thrift.protocol.TProtocol iprot, statement_clearWarnings_result struct) throws org.apache.thrift.TException {
        org.apache.thrift.protocol.TField schemeField;
        iprot.readStructBegin();
        while (true)
        {
          schemeField = iprot.readFieldBegin();
          if (schemeField.type == org.apache.thrift.protocol.TType.STOP) { 
            break;
          }
          switch (schemeField.id) {
            case 1: // SQL_EXCEPTION
              if (schemeField.type == org.apache.thrift.protocol.TType.STRUCT) {
                struct.sqlException = new RSQLException();
                struct.sqlException.read(iprot);
                struct.setSqlExceptionIsSet(true);
              } else { 
                org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
              }
              break;
            default:
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
          }
          iprot.readFieldEnd();
        }
        iprot.readStructEnd();

        // check for required fields of primitive type, which can't be checked in the validate method
        struct.validate();
      }

      public void write(org.apache.thrift.protocol.TProtocol oprot, statement_clearWarnings_result struct) throws org.apache.thrift.TException {
        struct.validate();

        oprot.writeStructBegin(STRUCT_DESC);
        if (struct.sqlException != null) {
          oprot.writeFieldBegin(SQL_EXCEPTION_FIELD_DESC);
          struct.sqlException.write(oprot);
          oprot.writeFieldEnd();
        }
        oprot.writeFieldStop();
        oprot.writeStructEnd();
      }

    }

    private static class statement_clearWarnings_resultTupleSchemeFactory implements SchemeFactory {
      public statement_clearWarnings_resultTupleScheme getScheme() {
        return new statement_clearWarnings_resultTupleScheme();
      }
    }

    private static class statement_clearWarnings_resultTupleScheme extends TupleScheme<statement_clearWarnings_result> {

      @Override
      public void write(org.apache.thrift.protocol.TProtocol prot, statement_clearWarnings_result struct) throws org.apache.thrift.TException {
        TTupleProtocol oprot = (TTupleProtocol) prot;
        BitSet optionals = new BitSet();
        if (struct.isSetSqlException()) {
          optionals.set(0);
        }
        oprot.writeBitSet(optionals, 1);
        if (struct.isSetSqlException()) {
          struct.sqlException.write(oprot);
        }
      }

      @Override
      public void read(org.apache.thrift.protocol.TProtocol prot, statement_clearWarnings_result struct) throws org.apache.thrift.TException {
        TTupleProtocol iprot = (TTupleProtocol) prot;
        BitSet incoming = iprot.readBitSet(1);
        if (incoming.get(0)) {
          struct.sqlException = new RSQLException();
          struct.sqlException.read(iprot);
          struct.setSqlExceptionIsSet(true);
        }
      }
    }

  }

  public static class statement_getMaxRows_args implements org.apache.thrift.TBase<statement_getMaxRows_args, statement_getMaxRows_args._Fields>, java.io.Serializable, Cloneable, Comparable<statement_getMaxRows_args>   {
    private static final org.apache.thrift.protocol.TStruct STRUCT_DESC = new org.apache.thrift.protocol.TStruct("statement_getMaxRows_args");

    private static final org.apache.thrift.protocol.TField STATEMENT_FIELD_DESC = new org.apache.thrift.protocol.TField("statement", org.apache.thrift.protocol.TType.STRUCT, (short)1);

    private static final Map<Class<? extends IScheme>, SchemeFactory> schemes = new HashMap<Class<? extends IScheme>, SchemeFactory>();
    static {
      schemes.put(StandardScheme.class, new statement_getMaxRows_argsStandardSchemeFactory());
      schemes.put(TupleScheme.class, new statement_getMaxRows_argsTupleSchemeFactory());
    }

    public RStatement statement; // required

    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements org.apache.thrift.TFieldIdEnum {
      STATEMENT((short)1, "statement");

      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        switch(fieldId) {
          case 1: // STATEMENT
            return STATEMENT;
          default:
            return null;
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }

    // isset id assignments
    public static final Map<_Fields, org.apache.thrift.meta_data.FieldMetaData> metaDataMap;
    static {
      Map<_Fields, org.apache.thrift.meta_data.FieldMetaData> tmpMap = new EnumMap<_Fields, org.apache.thrift.meta_data.FieldMetaData>(_Fields.class);
      tmpMap.put(_Fields.STATEMENT, new org.apache.thrift.meta_data.FieldMetaData("statement", org.apache.thrift.TFieldRequirementType.DEFAULT, 
          new org.apache.thrift.meta_data.StructMetaData(org.apache.thrift.protocol.TType.STRUCT, RStatement.class)));
      metaDataMap = Collections.unmodifiableMap(tmpMap);
      org.apache.thrift.meta_data.FieldMetaData.addStructMetaDataMap(statement_getMaxRows_args.class, metaDataMap);
    }

    public statement_getMaxRows_args() {
    }

    public statement_getMaxRows_args(
      RStatement statement)
    {
      this();
      this.statement = statement;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public statement_getMaxRows_args(statement_getMaxRows_args other) {
      if (other.isSetStatement()) {
        this.statement = new RStatement(other.statement);
      }
    }

    public statement_getMaxRows_args deepCopy() {
      return new statement_getMaxRows_args(this);
    }

    @Override
    public void clear() {
      this.statement = null;
    }

    public RStatement getStatement() {
      return this.statement;
    }

    public statement_getMaxRows_args setStatement(RStatement statement) {
      this.statement = statement;
      return this;
    }

    public void unsetStatement() {
      this.statement = null;
    }

    /** Returns true if field statement is set (has been assigned a value) and false otherwise */
    public boolean isSetStatement() {
      return this.statement != null;
    }

    public void setStatementIsSet(boolean value) {
      if (!value) {
        this.statement = null;
      }
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      case STATEMENT:
        if (value == null) {
          unsetStatement();
        } else {
          setStatement((RStatement)value);
        }
        break;

      }
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      case STATEMENT:
        return getStatement();

      }
      throw new IllegalStateException();
    }

    /** Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      if (field == null) {
        throw new IllegalArgumentException();
      }

      switch (field) {
      case STATEMENT:
        return isSetStatement();
      }
      throw new IllegalStateException();
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof statement_getMaxRows_args)
        return this.equals((statement_getMaxRows_args)that);
      return false;
    }

    public boolean equals(statement_getMaxRows_args that) {
      if (that == null)
        return false;

      boolean this_present_statement = true && this.isSetStatement();
      boolean that_present_statement = true && that.isSetStatement();
      if (this_present_statement || that_present_statement) {
        if (!(this_present_statement && that_present_statement))
          return false;
        if (!this.statement.equals(that.statement))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      List<Object> list = new ArrayList<Object>();

      boolean present_statement = true && (isSetStatement());
      list.add(present_statement);
      if (present_statement)
        list.add(statement);

      return list.hashCode();
    }

    @Override
    public int compareTo(statement_getMaxRows_args other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetStatement()).compareTo(other.isSetStatement());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetStatement()) {
        lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.statement, other.statement);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      return 0;
    }

    public _Fields fieldForId(int fieldId) {
      return _Fields.findByThriftId(fieldId);
    }

    public void read(org.apache.thrift.protocol.TProtocol iprot) throws org.apache.thrift.TException {
      schemes.get(iprot.getScheme()).getScheme().read(iprot, this);
    }

    public void write(org.apache.thrift.protocol.TProtocol oprot) throws org.apache.thrift.TException {
      schemes.get(oprot.getScheme()).getScheme().write(oprot, this);
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("statement_getMaxRows_args(");
      boolean first = true;

      sb.append("statement:");
      if (this.statement == null) {
        sb.append("null");
      } else {
        sb.append(this.statement);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws org.apache.thrift.TException {
      // check for required fields
      // check for sub-struct validity
      if (statement != null) {
        statement.validate();
      }
    }

    private void writeObject(java.io.ObjectOutputStream out) throws java.io.IOException {
      try {
        write(new org.apache.thrift.protocol.TCompactProtocol(new org.apache.thrift.transport.TIOStreamTransport(out)));
      } catch (org.apache.thrift.TException te) {
        throw new java.io.IOException(te);
      }
    }

    private void readObject(java.io.ObjectInputStream in) throws java.io.IOException, ClassNotFoundException {
      try {
        read(new org.apache.thrift.protocol.TCompactProtocol(new org.apache.thrift.transport.TIOStreamTransport(in)));
      } catch (org.apache.thrift.TException te) {
        throw new java.io.IOException(te);
      }
    }

    private static class statement_getMaxRows_argsStandardSchemeFactory implements SchemeFactory {
      public statement_getMaxRows_argsStandardScheme getScheme() {
        return new statement_getMaxRows_argsStandardScheme();
      }
    }

    private static class statement_getMaxRows_argsStandardScheme extends StandardScheme<statement_getMaxRows_args> {

      public void read(org.apache.thrift.protocol.TProtocol iprot, statement_getMaxRows_args struct) throws org.apache.thrift.TException {
        org.apache.thrift.protocol.TField schemeField;
        iprot.readStructBegin();
        while (true)
        {
          schemeField = iprot.readFieldBegin();
          if (schemeField.type == org.apache.thrift.protocol.TType.STOP) { 
            break;
          }
          switch (schemeField.id) {
            case 1: // STATEMENT
              if (schemeField.type == org.apache.thrift.protocol.TType.STRUCT) {
                struct.statement = new RStatement();
                struct.statement.read(iprot);
                struct.setStatementIsSet(true);
              } else { 
                org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
              }
              break;
            default:
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
          }
          iprot.readFieldEnd();
        }
        iprot.readStructEnd();

        // check for required fields of primitive type, which can't be checked in the validate method
        struct.validate();
      }

      public void write(org.apache.thrift.protocol.TProtocol oprot, statement_getMaxRows_args struct) throws org.apache.thrift.TException {
        struct.validate();

        oprot.writeStructBegin(STRUCT_DESC);
        if (struct.statement != null) {
          oprot.writeFieldBegin(STATEMENT_FIELD_DESC);
          struct.statement.write(oprot);
          oprot.writeFieldEnd();
        }
        oprot.writeFieldStop();
        oprot.writeStructEnd();
      }

    }

    private static class statement_getMaxRows_argsTupleSchemeFactory implements SchemeFactory {
      public statement_getMaxRows_argsTupleScheme getScheme() {
        return new statement_getMaxRows_argsTupleScheme();
      }
    }

    private static class statement_getMaxRows_argsTupleScheme extends TupleScheme<statement_getMaxRows_args> {

      @Override
      public void write(org.apache.thrift.protocol.TProtocol prot, statement_getMaxRows_args struct) throws org.apache.thrift.TException {
        TTupleProtocol oprot = (TTupleProtocol) prot;
        BitSet optionals = new BitSet();
        if (struct.isSetStatement()) {
          optionals.set(0);
        }
        oprot.writeBitSet(optionals, 1);
        if (struct.isSetStatement()) {
          struct.statement.write(oprot);
        }
      }

      @Override
      public void read(org.apache.thrift.protocol.TProtocol prot, statement_getMaxRows_args struct) throws org.apache.thrift.TException {
        TTupleProtocol iprot = (TTupleProtocol) prot;
        BitSet incoming = iprot.readBitSet(1);
        if (incoming.get(0)) {
          struct.statement = new RStatement();
          struct.statement.read(iprot);
          struct.setStatementIsSet(true);
        }
      }
    }

  }

  public static class statement_getMaxRows_result implements org.apache.thrift.TBase<statement_getMaxRows_result, statement_getMaxRows_result._Fields>, java.io.Serializable, Cloneable, Comparable<statement_getMaxRows_result>   {
    private static final org.apache.thrift.protocol.TStruct STRUCT_DESC = new org.apache.thrift.protocol.TStruct("statement_getMaxRows_result");

    private static final org.apache.thrift.protocol.TField SUCCESS_FIELD_DESC = new org.apache.thrift.protocol.TField("success", org.apache.thrift.protocol.TType.I32, (short)0);
    private static final org.apache.thrift.protocol.TField SQL_EXCEPTION_FIELD_DESC = new org.apache.thrift.protocol.TField("sqlException", org.apache.thrift.protocol.TType.STRUCT, (short)1);

    private static final Map<Class<? extends IScheme>, SchemeFactory> schemes = new HashMap<Class<? extends IScheme>, SchemeFactory>();
    static {
      schemes.put(StandardScheme.class, new statement_getMaxRows_resultStandardSchemeFactory());
      schemes.put(TupleScheme.class, new statement_getMaxRows_resultTupleSchemeFactory());
    }

    public int success; // required
    public RSQLException sqlException; // required

    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements org.apache.thrift.TFieldIdEnum {
      SUCCESS((short)0, "success"),
      SQL_EXCEPTION((short)1, "sqlException");

      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        switch(fieldId) {
          case 0: // SUCCESS
            return SUCCESS;
          case 1: // SQL_EXCEPTION
            return SQL_EXCEPTION;
          default:
            return null;
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }

    // isset id assignments
    private static final int __SUCCESS_ISSET_ID = 0;
    private byte __isset_bitfield = 0;
    public static final Map<_Fields, org.apache.thrift.meta_data.FieldMetaData> metaDataMap;
    static {
      Map<_Fields, org.apache.thrift.meta_data.FieldMetaData> tmpMap = new EnumMap<_Fields, org.apache.thrift.meta_data.FieldMetaData>(_Fields.class);
      tmpMap.put(_Fields.SUCCESS, new org.apache.thrift.meta_data.FieldMetaData("success", org.apache.thrift.TFieldRequirementType.DEFAULT, 
          new org.apache.thrift.meta_data.FieldValueMetaData(org.apache.thrift.protocol.TType.I32)));
      tmpMap.put(_Fields.SQL_EXCEPTION, new org.apache.thrift.meta_data.FieldMetaData("sqlException", org.apache.thrift.TFieldRequirementType.DEFAULT, 
          new org.apache.thrift.meta_data.FieldValueMetaData(org.apache.thrift.protocol.TType.STRUCT)));
      metaDataMap = Collections.unmodifiableMap(tmpMap);
      org.apache.thrift.meta_data.FieldMetaData.addStructMetaDataMap(statement_getMaxRows_result.class, metaDataMap);
    }

    public statement_getMaxRows_result() {
    }

    public statement_getMaxRows_result(
      int success,
      RSQLException sqlException)
    {
      this();
      this.success = success;
      setSuccessIsSet(true);
      this.sqlException = sqlException;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public statement_getMaxRows_result(statement_getMaxRows_result other) {
      __isset_bitfield = other.__isset_bitfield;
      this.success = other.success;
      if (other.isSetSqlException()) {
        this.sqlException = new RSQLException(other.sqlException);
      }
    }

    public statement_getMaxRows_result deepCopy() {
      return new statement_getMaxRows_result(this);
    }

    @Override
    public void clear() {
      setSuccessIsSet(false);
      this.success = 0;
      this.sqlException = null;
    }

    public int getSuccess() {
      return this.success;
    }

    public statement_getMaxRows_result setSuccess(int success) {
      this.success = success;
      setSuccessIsSet(true);
      return this;
    }

    public void unsetSuccess() {
      __isset_bitfield = EncodingUtils.clearBit(__isset_bitfield, __SUCCESS_ISSET_ID);
    }

    /** Returns true if field success is set (has been assigned a value) and false otherwise */
    public boolean isSetSuccess() {
      return EncodingUtils.testBit(__isset_bitfield, __SUCCESS_ISSET_ID);
    }

    public void setSuccessIsSet(boolean value) {
      __isset_bitfield = EncodingUtils.setBit(__isset_bitfield, __SUCCESS_ISSET_ID, value);
    }

    public RSQLException getSqlException() {
      return this.sqlException;
    }

    public statement_getMaxRows_result setSqlException(RSQLException sqlException) {
      this.sqlException = sqlException;
      return this;
    }

    public void unsetSqlException() {
      this.sqlException = null;
    }

    /** Returns true if field sqlException is set (has been assigned a value) and false otherwise */
    public boolean isSetSqlException() {
      return this.sqlException != null;
    }

    public void setSqlExceptionIsSet(boolean value) {
      if (!value) {
        this.sqlException = null;
      }
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          setSuccess((Integer)value);
        }
        break;

      case SQL_EXCEPTION:
        if (value == null) {
          unsetSqlException();
        } else {
          setSqlException((RSQLException)value);
        }
        break;

      }
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      case SUCCESS:
        return Integer.valueOf(getSuccess());

      case SQL_EXCEPTION:
        return getSqlException();

      }
      throw new IllegalStateException();
    }

    /** Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      if (field == null) {
        throw new IllegalArgumentException();
      }

      switch (field) {
      case SUCCESS:
        return isSetSuccess();
      case SQL_EXCEPTION:
        return isSetSqlException();
      }
      throw new IllegalStateException();
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof statement_getMaxRows_result)
        return this.equals((statement_getMaxRows_result)that);
      return false;
    }

    public boolean equals(statement_getMaxRows_result that) {
      if (that == null)
        return false;

      boolean this_present_success = true;
      boolean that_present_success = true;
      if (this_present_success || that_present_success) {
        if (!(this_present_success && that_present_success))
          return false;
        if (this.success != that.success)
          return false;
      }

      boolean this_present_sqlException = true && this.isSetSqlException();
      boolean that_present_sqlException = true && that.isSetSqlException();
      if (this_present_sqlException || that_present_sqlException) {
        if (!(this_present_sqlException && that_present_sqlException))
          return false;
        if (!this.sqlException.equals(that.sqlException))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      List<Object> list = new ArrayList<Object>();

      boolean present_success = true;
      list.add(present_success);
      if (present_success)
        list.add(success);

      boolean present_sqlException = true && (isSetSqlException());
      list.add(present_sqlException);
      if (present_sqlException)
        list.add(sqlException);

      return list.hashCode();
    }

    @Override
    public int compareTo(statement_getMaxRows_result other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetSuccess()).compareTo(other.isSetSuccess());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetSuccess()) {
        lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.success, other.success);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      lastComparison = Boolean.valueOf(isSetSqlException()).compareTo(other.isSetSqlException());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetSqlException()) {
        lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.sqlException, other.sqlException);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      return 0;
    }

    public _Fields fieldForId(int fieldId) {
      return _Fields.findByThriftId(fieldId);
    }

    public void read(org.apache.thrift.protocol.TProtocol iprot) throws org.apache.thrift.TException {
      schemes.get(iprot.getScheme()).getScheme().read(iprot, this);
    }

    public void write(org.apache.thrift.protocol.TProtocol oprot) throws org.apache.thrift.TException {
      schemes.get(oprot.getScheme()).getScheme().write(oprot, this);
      }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("statement_getMaxRows_result(");
      boolean first = true;

      sb.append("success:");
      sb.append(this.success);
      first = false;
      if (!first) sb.append(", ");
      sb.append("sqlException:");
      if (this.sqlException == null) {
        sb.append("null");
      } else {
        sb.append(this.sqlException);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws org.apache.thrift.TException {
      // check for required fields
      // check for sub-struct validity
    }

    private void writeObject(java.io.ObjectOutputStream out) throws java.io.IOException {
      try {
        write(new org.apache.thrift.protocol.TCompactProtocol(new org.apache.thrift.transport.TIOStreamTransport(out)));
      } catch (org.apache.thrift.TException te) {
        throw new java.io.IOException(te);
      }
    }

    private void readObject(java.io.ObjectInputStream in) throws java.io.IOException, ClassNotFoundException {
      try {
        // it doesn't seem like you should have to do this, but java serialization is wacky, and doesn't call the default constructor.
        __isset_bitfield = 0;
        read(new org.apache.thrift.protocol.TCompactProtocol(new org.apache.thrift.transport.TIOStreamTransport(in)));
      } catch (org.apache.thrift.TException te) {
        throw new java.io.IOException(te);
      }
    }

    private static class statement_getMaxRows_resultStandardSchemeFactory implements SchemeFactory {
      public statement_getMaxRows_resultStandardScheme getScheme() {
        return new statement_getMaxRows_resultStandardScheme();
      }
    }

    private static class statement_getMaxRows_resultStandardScheme extends StandardScheme<statement_getMaxRows_result> {

      public void read(org.apache.thrift.protocol.TProtocol iprot, statement_getMaxRows_result struct) throws org.apache.thrift.TException {
        org.apache.thrift.protocol.TField schemeField;
        iprot.readStructBegin();
        while (true)
        {
          schemeField = iprot.readFieldBegin();
          if (schemeField.type == org.apache.thrift.protocol.TType.STOP) { 
            break;
          }
          switch (schemeField.id) {
            case 0: // SUCCESS
              if (schemeField.type == org.apache.thrift.protocol.TType.I32) {
                struct.success = iprot.readI32();
                struct.setSuccessIsSet(true);
              } else { 
                org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
              }
              break;
            case 1: // SQL_EXCEPTION
              if (schemeField.type == org.apache.thrift.protocol.TType.STRUCT) {
                struct.sqlException = new RSQLException();
                struct.sqlException.read(iprot);
                struct.setSqlExceptionIsSet(true);
              } else { 
                org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
              }
              break;
            default:
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
          }
          iprot.readFieldEnd();
        }
        iprot.readStructEnd();

        // check for required fields of primitive type, which can't be checked in the validate method
        struct.validate();
      }

      public void write(org.apache.thrift.protocol.TProtocol oprot, statement_getMaxRows_result struct) throws org.apache.thrift.TException {
        struct.validate();

        oprot.writeStructBegin(STRUCT_DESC);
        if (struct.isSetSuccess()) {
          oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
          oprot.writeI32(struct.success);
          oprot.writeFieldEnd();
        }
        if (struct.sqlException != null) {
          oprot.writeFieldBegin(SQL_EXCEPTION_FIELD_DESC);
          struct.sqlException.write(oprot);
          oprot.writeFieldEnd();
        }
        oprot.writeFieldStop();
        oprot.writeStructEnd();
      }

    }

    private static class statement_getMaxRows_resultTupleSchemeFactory implements SchemeFactory {
      public statement_getMaxRows_resultTupleScheme getScheme() {
        return new statement_getMaxRows_resultTupleScheme();
      }
    }

    private static class statement_getMaxRows_resultTupleScheme extends TupleScheme<statement_getMaxRows_result> {

      @Override
      public void write(org.apache.thrift.protocol.TProtocol prot, statement_getMaxRows_result struct) throws org.apache.thrift.TException {
        TTupleProtocol oprot = (TTupleProtocol) prot;
        BitSet optionals = new BitSet();
        if (struct.isSetSuccess()) {
          optionals.set(0);
        }
        if (struct.isSetSqlException()) {
          optionals.set(1);
        }
        oprot.writeBitSet(optionals, 2);
        if (struct.isSetSuccess()) {
          oprot.writeI32(struct.success);
        }
        if (struct.isSetSqlException()) {
          struct.sqlException.write(oprot);
        }
      }

      @Override
      public void read(org.apache.thrift.protocol.TProtocol prot, statement_getMaxRows_result struct) throws org.apache.thrift.TException {
        TTupleProtocol iprot = (TTupleProtocol) prot;
        BitSet incoming = iprot.readBitSet(2);
        if (incoming.get(0)) {
          struct.success = iprot.readI32();
          struct.setSuccessIsSet(true);
        }
        if (incoming.get(1)) {
          struct.sqlException = new RSQLException();
          struct.sqlException.read(iprot);
          struct.setSqlExceptionIsSet(true);
        }
      }
    }

  }

  public static class statement_setMaxRows_args implements org.apache.thrift.TBase<statement_setMaxRows_args, statement_setMaxRows_args._Fields>, java.io.Serializable, Cloneable, Comparable<statement_setMaxRows_args>   {
    private static final org.apache.thrift.protocol.TStruct STRUCT_DESC = new org.apache.thrift.protocol.TStruct("statement_setMaxRows_args");

    private static final org.apache.thrift.protocol.TField STATEMENT_FIELD_DESC = new org.apache.thrift.protocol.TField("statement", org.apache.thrift.protocol.TType.STRUCT, (short)1);
    private static final org.apache.thrift.protocol.TField MAX_FIELD_DESC = new org.apache.thrift.protocol.TField("max", org.apache.thrift.protocol.TType.I32, (short)2);

    private static final Map<Class<? extends IScheme>, SchemeFactory> schemes = new HashMap<Class<? extends IScheme>, SchemeFactory>();
    static {
      schemes.put(StandardScheme.class, new statement_setMaxRows_argsStandardSchemeFactory());
      schemes.put(TupleScheme.class, new statement_setMaxRows_argsTupleSchemeFactory());
    }

    public RStatement statement; // required
    public int max; // required

    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements org.apache.thrift.TFieldIdEnum {
      STATEMENT((short)1, "statement"),
      MAX((short)2, "max");

      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        switch(fieldId) {
          case 1: // STATEMENT
            return STATEMENT;
          case 2: // MAX
            return MAX;
          default:
            return null;
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }

    // isset id assignments
    private static final int __MAX_ISSET_ID = 0;
    private byte __isset_bitfield = 0;
    public static final Map<_Fields, org.apache.thrift.meta_data.FieldMetaData> metaDataMap;
    static {
      Map<_Fields, org.apache.thrift.meta_data.FieldMetaData> tmpMap = new EnumMap<_Fields, org.apache.thrift.meta_data.FieldMetaData>(_Fields.class);
      tmpMap.put(_Fields.STATEMENT, new org.apache.thrift.meta_data.FieldMetaData("statement", org.apache.thrift.TFieldRequirementType.DEFAULT, 
          new org.apache.thrift.meta_data.StructMetaData(org.apache.thrift.protocol.TType.STRUCT, RStatement.class)));
      tmpMap.put(_Fields.MAX, new org.apache.thrift.meta_data.FieldMetaData("max", org.apache.thrift.TFieldRequirementType.DEFAULT, 
          new org.apache.thrift.meta_data.FieldValueMetaData(org.apache.thrift.protocol.TType.I32)));
      metaDataMap = Collections.unmodifiableMap(tmpMap);
      org.apache.thrift.meta_data.FieldMetaData.addStructMetaDataMap(statement_setMaxRows_args.class, metaDataMap);
    }

    public statement_setMaxRows_args() {
    }

    public statement_setMaxRows_args(
      RStatement statement,
      int max)
    {
      this();
      this.statement = statement;
      this.max = max;
      setMaxIsSet(true);
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public statement_setMaxRows_args(statement_setMaxRows_args other) {
      __isset_bitfield = other.__isset_bitfield;
      if (other.isSetStatement()) {
        this.statement = new RStatement(other.statement);
      }
      this.max = other.max;
    }

    public statement_setMaxRows_args deepCopy() {
      return new statement_setMaxRows_args(this);
    }

    @Override
    public void clear() {
      this.statement = null;
      setMaxIsSet(false);
      this.max = 0;
    }

    public RStatement getStatement() {
      return this.statement;
    }

    public statement_setMaxRows_args setStatement(RStatement statement) {
      this.statement = statement;
      return this;
    }

    public void unsetStatement() {
      this.statement = null;
    }

    /** Returns true if field statement is set (has been assigned a value) and false otherwise */
    public boolean isSetStatement() {
      return this.statement != null;
    }

    public void setStatementIsSet(boolean value) {
      if (!value) {
        this.statement = null;
      }
    }

    public int getMax() {
      return this.max;
    }

    public statement_setMaxRows_args setMax(int max) {
      this.max = max;
      setMaxIsSet(true);
      return this;
    }

    public void unsetMax() {
      __isset_bitfield = EncodingUtils.clearBit(__isset_bitfield, __MAX_ISSET_ID);
    }

    /** Returns true if field max is set (has been assigned a value) and false otherwise */
    public boolean isSetMax() {
      return EncodingUtils.testBit(__isset_bitfield, __MAX_ISSET_ID);
    }

    public void setMaxIsSet(boolean value) {
      __isset_bitfield = EncodingUtils.setBit(__isset_bitfield, __MAX_ISSET_ID, value);
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      case STATEMENT:
        if (value == null) {
          unsetStatement();
        } else {
          setStatement((RStatement)value);
        }
        break;

      case MAX:
        if (value == null) {
          unsetMax();
        } else {
          setMax((Integer)value);
        }
        break;

      }
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      case STATEMENT:
        return getStatement();

      case MAX:
        return Integer.valueOf(getMax());

      }
      throw new IllegalStateException();
    }

    /** Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      if (field == null) {
        throw new IllegalArgumentException();
      }

      switch (field) {
      case STATEMENT:
        return isSetStatement();
      case MAX:
        return isSetMax();
      }
      throw new IllegalStateException();
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof statement_setMaxRows_args)
        return this.equals((statement_setMaxRows_args)that);
      return false;
    }

    public boolean equals(statement_setMaxRows_args that) {
      if (that == null)
        return false;

      boolean this_present_statement = true && this.isSetStatement();
      boolean that_present_statement = true && that.isSetStatement();
      if (this_present_statement || that_present_statement) {
        if (!(this_present_statement && that_present_statement))
          return false;
        if (!this.statement.equals(that.statement))
          return false;
      }

      boolean this_present_max = true;
      boolean that_present_max = true;
      if (this_present_max || that_present_max) {
        if (!(this_present_max && that_present_max))
          return false;
        if (this.max != that.max)
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      List<Object> list = new ArrayList<Object>();

      boolean present_statement = true && (isSetStatement());
      list.add(present_statement);
      if (present_statement)
        list.add(statement);

      boolean present_max = true;
      list.add(present_max);
      if (present_max)
        list.add(max);

      return list.hashCode();
    }

    @Override
    public int compareTo(statement_setMaxRows_args other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetStatement()).compareTo(other.isSetStatement());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetStatement()) {
        lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.statement, other.statement);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      lastComparison = Boolean.valueOf(isSetMax()).compareTo(other.isSetMax());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetMax()) {
        lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.max, other.max);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      return 0;
    }

    public _Fields fieldForId(int fieldId) {
      return _Fields.findByThriftId(fieldId);
    }

    public void read(org.apache.thrift.protocol.TProtocol iprot) throws org.apache.thrift.TException {
      schemes.get(iprot.getScheme()).getScheme().read(iprot, this);
    }

    public void write(org.apache.thrift.protocol.TProtocol oprot) throws org.apache.thrift.TException {
      schemes.get(oprot.getScheme()).getScheme().write(oprot, this);
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("statement_setMaxRows_args(");
      boolean first = true;

      sb.append("statement:");
      if (this.statement == null) {
        sb.append("null");
      } else {
        sb.append(this.statement);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("max:");
      sb.append(this.max);
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws org.apache.thrift.TException {
      // check for required fields
      // check for sub-struct validity
      if (statement != null) {
        statement.validate();
      }
    }

    private void writeObject(java.io.ObjectOutputStream out) throws java.io.IOException {
      try {
        write(new org.apache.thrift.protocol.TCompactProtocol(new org.apache.thrift.transport.TIOStreamTransport(out)));
      } catch (org.apache.thrift.TException te) {
        throw new java.io.IOException(te);
      }
    }

    private void readObject(java.io.ObjectInputStream in) throws java.io.IOException, ClassNotFoundException {
      try {
        // it doesn't seem like you should have to do this, but java serialization is wacky, and doesn't call the default constructor.
        __isset_bitfield = 0;
        read(new org.apache.thrift.protocol.TCompactProtocol(new org.apache.thrift.transport.TIOStreamTransport(in)));
      } catch (org.apache.thrift.TException te) {
        throw new java.io.IOException(te);
      }
    }

    private static class statement_setMaxRows_argsStandardSchemeFactory implements SchemeFactory {
      public statement_setMaxRows_argsStandardScheme getScheme() {
        return new statement_setMaxRows_argsStandardScheme();
      }
    }

    private static class statement_setMaxRows_argsStandardScheme extends StandardScheme<statement_setMaxRows_args> {

      public void read(org.apache.thrift.protocol.TProtocol iprot, statement_setMaxRows_args struct) throws org.apache.thrift.TException {
        org.apache.thrift.protocol.TField schemeField;
        iprot.readStructBegin();
        while (true)
        {
          schemeField = iprot.readFieldBegin();
          if (schemeField.type == org.apache.thrift.protocol.TType.STOP) { 
            break;
          }
          switch (schemeField.id) {
            case 1: // STATEMENT
              if (schemeField.type == org.apache.thrift.protocol.TType.STRUCT) {
                struct.statement = new RStatement();
                struct.statement.read(iprot);
                struct.setStatementIsSet(true);
              } else { 
                org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
              }
              break;
            case 2: // MAX
              if (schemeField.type == org.apache.thrift.protocol.TType.I32) {
                struct.max = iprot.readI32();
                struct.setMaxIsSet(true);
              } else { 
                org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
              }
              break;
            default:
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
          }
          iprot.readFieldEnd();
        }
        iprot.readStructEnd();

        // check for required fields of primitive type, which can't be checked in the validate method
        struct.validate();
      }

      public void write(org.apache.thrift.protocol.TProtocol oprot, statement_setMaxRows_args struct) throws org.apache.thrift.TException {
        struct.validate();

        oprot.writeStructBegin(STRUCT_DESC);
        if (struct.statement != null) {
          oprot.writeFieldBegin(STATEMENT_FIELD_DESC);
          struct.statement.write(oprot);
          oprot.writeFieldEnd();
        }
        oprot.writeFieldBegin(MAX_FIELD_DESC);
        oprot.writeI32(struct.max);
        oprot.writeFieldEnd();
        oprot.writeFieldStop();
        oprot.writeStructEnd();
      }

    }

    private static class statement_setMaxRows_argsTupleSchemeFactory implements SchemeFactory {
      public statement_setMaxRows_argsTupleScheme getScheme() {
        return new statement_setMaxRows_argsTupleScheme();
      }
    }

    private static class statement_setMaxRows_argsTupleScheme extends TupleScheme<statement_setMaxRows_args> {

      @Override
      public void write(org.apache.thrift.protocol.TProtocol prot, statement_setMaxRows_args struct) throws org.apache.thrift.TException {
        TTupleProtocol oprot = (TTupleProtocol) prot;
        BitSet optionals = new BitSet();
        if (struct.isSetStatement()) {
          optionals.set(0);
        }
        if (struct.isSetMax()) {
          optionals.set(1);
        }
        oprot.writeBitSet(optionals, 2);
        if (struct.isSetStatement()) {
          struct.statement.write(oprot);
        }
        if (struct.isSetMax()) {
          oprot.writeI32(struct.max);
        }
      }

      @Override
      public void read(org.apache.thrift.protocol.TProtocol prot, statement_setMaxRows_args struct) throws org.apache.thrift.TException {
        TTupleProtocol iprot = (TTupleProtocol) prot;
        BitSet incoming = iprot.readBitSet(2);
        if (incoming.get(0)) {
          struct.statement = new RStatement();
          struct.statement.read(iprot);
          struct.setStatementIsSet(true);
        }
        if (incoming.get(1)) {
          struct.max = iprot.readI32();
          struct.setMaxIsSet(true);
        }
      }
    }

  }

  public static class statement_setMaxRows_result implements org.apache.thrift.TBase<statement_setMaxRows_result, statement_setMaxRows_result._Fields>, java.io.Serializable, Cloneable, Comparable<statement_setMaxRows_result>   {
    private static final org.apache.thrift.protocol.TStruct STRUCT_DESC = new org.apache.thrift.protocol.TStruct("statement_setMaxRows_result");

    private static final org.apache.thrift.protocol.TField SQL_EXCEPTION_FIELD_DESC = new org.apache.thrift.protocol.TField("sqlException", org.apache.thrift.protocol.TType.STRUCT, (short)1);

    private static final Map<Class<? extends IScheme>, SchemeFactory> schemes = new HashMap<Class<? extends IScheme>, SchemeFactory>();
    static {
      schemes.put(StandardScheme.class, new statement_setMaxRows_resultStandardSchemeFactory());
      schemes.put(TupleScheme.class, new statement_setMaxRows_resultTupleSchemeFactory());
    }

    public RSQLException sqlException; // required

    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements org.apache.thrift.TFieldIdEnum {
      SQL_EXCEPTION((short)1, "sqlException");

      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        switch(fieldId) {
          case 1: // SQL_EXCEPTION
            return SQL_EXCEPTION;
          default:
            return null;
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }

    // isset id assignments
    public static final Map<_Fields, org.apache.thrift.meta_data.FieldMetaData> metaDataMap;
    static {
      Map<_Fields, org.apache.thrift.meta_data.FieldMetaData> tmpMap = new EnumMap<_Fields, org.apache.thrift.meta_data.FieldMetaData>(_Fields.class);
      tmpMap.put(_Fields.SQL_EXCEPTION, new org.apache.thrift.meta_data.FieldMetaData("sqlException", org.apache.thrift.TFieldRequirementType.DEFAULT, 
          new org.apache.thrift.meta_data.FieldValueMetaData(org.apache.thrift.protocol.TType.STRUCT)));
      metaDataMap = Collections.unmodifiableMap(tmpMap);
      org.apache.thrift.meta_data.FieldMetaData.addStructMetaDataMap(statement_setMaxRows_result.class, metaDataMap);
    }

    public statement_setMaxRows_result() {
    }

    public statement_setMaxRows_result(
      RSQLException sqlException)
    {
      this();
      this.sqlException = sqlException;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public statement_setMaxRows_result(statement_setMaxRows_result other) {
      if (other.isSetSqlException()) {
        this.sqlException = new RSQLException(other.sqlException);
      }
    }

    public statement_setMaxRows_result deepCopy() {
      return new statement_setMaxRows_result(this);
    }

    @Override
    public void clear() {
      this.sqlException = null;
    }

    public RSQLException getSqlException() {
      return this.sqlException;
    }

    public statement_setMaxRows_result setSqlException(RSQLException sqlException) {
      this.sqlException = sqlException;
      return this;
    }

    public void unsetSqlException() {
      this.sqlException = null;
    }

    /** Returns true if field sqlException is set (has been assigned a value) and false otherwise */
    public boolean isSetSqlException() {
      return this.sqlException != null;
    }

    public void setSqlExceptionIsSet(boolean value) {
      if (!value) {
        this.sqlException = null;
      }
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      case SQL_EXCEPTION:
        if (value == null) {
          unsetSqlException();
        } else {
          setSqlException((RSQLException)value);
        }
        break;

      }
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      case SQL_EXCEPTION:
        return getSqlException();

      }
      throw new IllegalStateException();
    }

    /** Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      if (field == null) {
        throw new IllegalArgumentException();
      }

      switch (field) {
      case SQL_EXCEPTION:
        return isSetSqlException();
      }
      throw new IllegalStateException();
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof statement_setMaxRows_result)
        return this.equals((statement_setMaxRows_result)that);
      return false;
    }

    public boolean equals(statement_setMaxRows_result that) {
      if (that == null)
        return false;

      boolean this_present_sqlException = true && this.isSetSqlException();
      boolean that_present_sqlException = true && that.isSetSqlException();
      if (this_present_sqlException || that_present_sqlException) {
        if (!(this_present_sqlException && that_present_sqlException))
          return false;
        if (!this.sqlException.equals(that.sqlException))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      List<Object> list = new ArrayList<Object>();

      boolean present_sqlException = true && (isSetSqlException());
      list.add(present_sqlException);
      if (present_sqlException)
        list.add(sqlException);

      return list.hashCode();
    }

    @Override
    public int compareTo(statement_setMaxRows_result other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetSqlException()).compareTo(other.isSetSqlException());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetSqlException()) {
        lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.sqlException, other.sqlException);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      return 0;
    }

    public _Fields fieldForId(int fieldId) {
      return _Fields.findByThriftId(fieldId);
    }

    public void read(org.apache.thrift.protocol.TProtocol iprot) throws org.apache.thrift.TException {
      schemes.get(iprot.getScheme()).getScheme().read(iprot, this);
    }

    public void write(org.apache.thrift.protocol.TProtocol oprot) throws org.apache.thrift.TException {
      schemes.get(oprot.getScheme()).getScheme().write(oprot, this);
      }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("statement_setMaxRows_result(");
      boolean first = true;

      sb.append("sqlException:");
      if (this.sqlException == null) {
        sb.append("null");
      } else {
        sb.append(this.sqlException);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws org.apache.thrift.TException {
      // check for required fields
      // check for sub-struct validity
    }

    private void writeObject(java.io.ObjectOutputStream out) throws java.io.IOException {
      try {
        write(new org.apache.thrift.protocol.TCompactProtocol(new org.apache.thrift.transport.TIOStreamTransport(out)));
      } catch (org.apache.thrift.TException te) {
        throw new java.io.IOException(te);
      }
    }

    private void readObject(java.io.ObjectInputStream in) throws java.io.IOException, ClassNotFoundException {
      try {
        read(new org.apache.thrift.protocol.TCompactProtocol(new org.apache.thrift.transport.TIOStreamTransport(in)));
      } catch (org.apache.thrift.TException te) {
        throw new java.io.IOException(te);
      }
    }

    private static class statement_setMaxRows_resultStandardSchemeFactory implements SchemeFactory {
      public statement_setMaxRows_resultStandardScheme getScheme() {
        return new statement_setMaxRows_resultStandardScheme();
      }
    }

    private static class statement_setMaxRows_resultStandardScheme extends StandardScheme<statement_setMaxRows_result> {

      public void read(org.apache.thrift.protocol.TProtocol iprot, statement_setMaxRows_result struct) throws org.apache.thrift.TException {
        org.apache.thrift.protocol.TField schemeField;
        iprot.readStructBegin();
        while (true)
        {
          schemeField = iprot.readFieldBegin();
          if (schemeField.type == org.apache.thrift.protocol.TType.STOP) { 
            break;
          }
          switch (schemeField.id) {
            case 1: // SQL_EXCEPTION
              if (schemeField.type == org.apache.thrift.protocol.TType.STRUCT) {
                struct.sqlException = new RSQLException();
                struct.sqlException.read(iprot);
                struct.setSqlExceptionIsSet(true);
              } else { 
                org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
              }
              break;
            default:
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
          }
          iprot.readFieldEnd();
        }
        iprot.readStructEnd();

        // check for required fields of primitive type, which can't be checked in the validate method
        struct.validate();
      }

      public void write(org.apache.thrift.protocol.TProtocol oprot, statement_setMaxRows_result struct) throws org.apache.thrift.TException {
        struct.validate();

        oprot.writeStructBegin(STRUCT_DESC);
        if (struct.sqlException != null) {
          oprot.writeFieldBegin(SQL_EXCEPTION_FIELD_DESC);
          struct.sqlException.write(oprot);
          oprot.writeFieldEnd();
        }
        oprot.writeFieldStop();
        oprot.writeStructEnd();
      }

    }

    private static class statement_setMaxRows_resultTupleSchemeFactory implements SchemeFactory {
      public statement_setMaxRows_resultTupleScheme getScheme() {
        return new statement_setMaxRows_resultTupleScheme();
      }
    }

    private static class statement_setMaxRows_resultTupleScheme extends TupleScheme<statement_setMaxRows_result> {

      @Override
      public void write(org.apache.thrift.protocol.TProtocol prot, statement_setMaxRows_result struct) throws org.apache.thrift.TException {
        TTupleProtocol oprot = (TTupleProtocol) prot;
        BitSet optionals = new BitSet();
        if (struct.isSetSqlException()) {
          optionals.set(0);
        }
        oprot.writeBitSet(optionals, 1);
        if (struct.isSetSqlException()) {
          struct.sqlException.write(oprot);
        }
      }

      @Override
      public void read(org.apache.thrift.protocol.TProtocol prot, statement_setMaxRows_result struct) throws org.apache.thrift.TException {
        TTupleProtocol iprot = (TTupleProtocol) prot;
        BitSet incoming = iprot.readBitSet(1);
        if (incoming.get(0)) {
          struct.sqlException = new RSQLException();
          struct.sqlException.read(iprot);
          struct.setSqlExceptionIsSet(true);
        }
      }
    }

  }

  public static class statement_getQueryTimeout_args implements org.apache.thrift.TBase<statement_getQueryTimeout_args, statement_getQueryTimeout_args._Fields>, java.io.Serializable, Cloneable, Comparable<statement_getQueryTimeout_args>   {
    private static final org.apache.thrift.protocol.TStruct STRUCT_DESC = new org.apache.thrift.protocol.TStruct("statement_getQueryTimeout_args");

    private static final org.apache.thrift.protocol.TField STATEMENT_FIELD_DESC = new org.apache.thrift.protocol.TField("statement", org.apache.thrift.protocol.TType.STRUCT, (short)1);

    private static final Map<Class<? extends IScheme>, SchemeFactory> schemes = new HashMap<Class<? extends IScheme>, SchemeFactory>();
    static {
      schemes.put(StandardScheme.class, new statement_getQueryTimeout_argsStandardSchemeFactory());
      schemes.put(TupleScheme.class, new statement_getQueryTimeout_argsTupleSchemeFactory());
    }

    public RStatement statement; // required

    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements org.apache.thrift.TFieldIdEnum {
      STATEMENT((short)1, "statement");

      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        switch(fieldId) {
          case 1: // STATEMENT
            return STATEMENT;
          default:
            return null;
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }

    // isset id assignments
    public static final Map<_Fields, org.apache.thrift.meta_data.FieldMetaData> metaDataMap;
    static {
      Map<_Fields, org.apache.thrift.meta_data.FieldMetaData> tmpMap = new EnumMap<_Fields, org.apache.thrift.meta_data.FieldMetaData>(_Fields.class);
      tmpMap.put(_Fields.STATEMENT, new org.apache.thrift.meta_data.FieldMetaData("statement", org.apache.thrift.TFieldRequirementType.DEFAULT, 
          new org.apache.thrift.meta_data.StructMetaData(org.apache.thrift.protocol.TType.STRUCT, RStatement.class)));
      metaDataMap = Collections.unmodifiableMap(tmpMap);
      org.apache.thrift.meta_data.FieldMetaData.addStructMetaDataMap(statement_getQueryTimeout_args.class, metaDataMap);
    }

    public statement_getQueryTimeout_args() {
    }

    public statement_getQueryTimeout_args(
      RStatement statement)
    {
      this();
      this.statement = statement;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public statement_getQueryTimeout_args(statement_getQueryTimeout_args other) {
      if (other.isSetStatement()) {
        this.statement = new RStatement(other.statement);
      }
    }

    public statement_getQueryTimeout_args deepCopy() {
      return new statement_getQueryTimeout_args(this);
    }

    @Override
    public void clear() {
      this.statement = null;
    }

    public RStatement getStatement() {
      return this.statement;
    }

    public statement_getQueryTimeout_args setStatement(RStatement statement) {
      this.statement = statement;
      return this;
    }

    public void unsetStatement() {
      this.statement = null;
    }

    /** Returns true if field statement is set (has been assigned a value) and false otherwise */
    public boolean isSetStatement() {
      return this.statement != null;
    }

    public void setStatementIsSet(boolean value) {
      if (!value) {
        this.statement = null;
      }
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      case STATEMENT:
        if (value == null) {
          unsetStatement();
        } else {
          setStatement((RStatement)value);
        }
        break;

      }
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      case STATEMENT:
        return getStatement();

      }
      throw new IllegalStateException();
    }

    /** Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      if (field == null) {
        throw new IllegalArgumentException();
      }

      switch (field) {
      case STATEMENT:
        return isSetStatement();
      }
      throw new IllegalStateException();
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof statement_getQueryTimeout_args)
        return this.equals((statement_getQueryTimeout_args)that);
      return false;
    }

    public boolean equals(statement_getQueryTimeout_args that) {
      if (that == null)
        return false;

      boolean this_present_statement = true && this.isSetStatement();
      boolean that_present_statement = true && that.isSetStatement();
      if (this_present_statement || that_present_statement) {
        if (!(this_present_statement && that_present_statement))
          return false;
        if (!this.statement.equals(that.statement))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      List<Object> list = new ArrayList<Object>();

      boolean present_statement = true && (isSetStatement());
      list.add(present_statement);
      if (present_statement)
        list.add(statement);

      return list.hashCode();
    }

    @Override
    public int compareTo(statement_getQueryTimeout_args other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetStatement()).compareTo(other.isSetStatement());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetStatement()) {
        lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.statement, other.statement);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      return 0;
    }

    public _Fields fieldForId(int fieldId) {
      return _Fields.findByThriftId(fieldId);
    }

    public void read(org.apache.thrift.protocol.TProtocol iprot) throws org.apache.thrift.TException {
      schemes.get(iprot.getScheme()).getScheme().read(iprot, this);
    }

    public void write(org.apache.thrift.protocol.TProtocol oprot) throws org.apache.thrift.TException {
      schemes.get(oprot.getScheme()).getScheme().write(oprot, this);
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("statement_getQueryTimeout_args(");
      boolean first = true;

      sb.append("statement:");
      if (this.statement == null) {
        sb.append("null");
      } else {
        sb.append(this.statement);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws org.apache.thrift.TException {
      // check for required fields
      // check for sub-struct validity
      if (statement != null) {
        statement.validate();
      }
    }

    private void writeObject(java.io.ObjectOutputStream out) throws java.io.IOException {
      try {
        write(new org.apache.thrift.protocol.TCompactProtocol(new org.apache.thrift.transport.TIOStreamTransport(out)));
      } catch (org.apache.thrift.TException te) {
        throw new java.io.IOException(te);
      }
    }

    private void readObject(java.io.ObjectInputStream in) throws java.io.IOException, ClassNotFoundException {
      try {
        read(new org.apache.thrift.protocol.TCompactProtocol(new org.apache.thrift.transport.TIOStreamTransport(in)));
      } catch (org.apache.thrift.TException te) {
        throw new java.io.IOException(te);
      }
    }

    private static class statement_getQueryTimeout_argsStandardSchemeFactory implements SchemeFactory {
      public statement_getQueryTimeout_argsStandardScheme getScheme() {
        return new statement_getQueryTimeout_argsStandardScheme();
      }
    }

    private static class statement_getQueryTimeout_argsStandardScheme extends StandardScheme<statement_getQueryTimeout_args> {

      public void read(org.apache.thrift.protocol.TProtocol iprot, statement_getQueryTimeout_args struct) throws org.apache.thrift.TException {
        org.apache.thrift.protocol.TField schemeField;
        iprot.readStructBegin();
        while (true)
        {
          schemeField = iprot.readFieldBegin();
          if (schemeField.type == org.apache.thrift.protocol.TType.STOP) { 
            break;
          }
          switch (schemeField.id) {
            case 1: // STATEMENT
              if (schemeField.type == org.apache.thrift.protocol.TType.STRUCT) {
                struct.statement = new RStatement();
                struct.statement.read(iprot);
                struct.setStatementIsSet(true);
              } else { 
                org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
              }
              break;
            default:
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
          }
          iprot.readFieldEnd();
        }
        iprot.readStructEnd();

        // check for required fields of primitive type, which can't be checked in the validate method
        struct.validate();
      }

      public void write(org.apache.thrift.protocol.TProtocol oprot, statement_getQueryTimeout_args struct) throws org.apache.thrift.TException {
        struct.validate();

        oprot.writeStructBegin(STRUCT_DESC);
        if (struct.statement != null) {
          oprot.writeFieldBegin(STATEMENT_FIELD_DESC);
          struct.statement.write(oprot);
          oprot.writeFieldEnd();
        }
        oprot.writeFieldStop();
        oprot.writeStructEnd();
      }

    }

    private static class statement_getQueryTimeout_argsTupleSchemeFactory implements SchemeFactory {
      public statement_getQueryTimeout_argsTupleScheme getScheme() {
        return new statement_getQueryTimeout_argsTupleScheme();
      }
    }

    private static class statement_getQueryTimeout_argsTupleScheme extends TupleScheme<statement_getQueryTimeout_args> {

      @Override
      public void write(org.apache.thrift.protocol.TProtocol prot, statement_getQueryTimeout_args struct) throws org.apache.thrift.TException {
        TTupleProtocol oprot = (TTupleProtocol) prot;
        BitSet optionals = new BitSet();
        if (struct.isSetStatement()) {
          optionals.set(0);
        }
        oprot.writeBitSet(optionals, 1);
        if (struct.isSetStatement()) {
          struct.statement.write(oprot);
        }
      }

      @Override
      public void read(org.apache.thrift.protocol.TProtocol prot, statement_getQueryTimeout_args struct) throws org.apache.thrift.TException {
        TTupleProtocol iprot = (TTupleProtocol) prot;
        BitSet incoming = iprot.readBitSet(1);
        if (incoming.get(0)) {
          struct.statement = new RStatement();
          struct.statement.read(iprot);
          struct.setStatementIsSet(true);
        }
      }
    }

  }

  public static class statement_getQueryTimeout_result implements org.apache.thrift.TBase<statement_getQueryTimeout_result, statement_getQueryTimeout_result._Fields>, java.io.Serializable, Cloneable, Comparable<statement_getQueryTimeout_result>   {
    private static final org.apache.thrift.protocol.TStruct STRUCT_DESC = new org.apache.thrift.protocol.TStruct("statement_getQueryTimeout_result");

    private static final org.apache.thrift.protocol.TField SUCCESS_FIELD_DESC = new org.apache.thrift.protocol.TField("success", org.apache.thrift.protocol.TType.I32, (short)0);
    private static final org.apache.thrift.protocol.TField SQL_EXCEPTION_FIELD_DESC = new org.apache.thrift.protocol.TField("sqlException", org.apache.thrift.protocol.TType.STRUCT, (short)1);

    private static final Map<Class<? extends IScheme>, SchemeFactory> schemes = new HashMap<Class<? extends IScheme>, SchemeFactory>();
    static {
      schemes.put(StandardScheme.class, new statement_getQueryTimeout_resultStandardSchemeFactory());
      schemes.put(TupleScheme.class, new statement_getQueryTimeout_resultTupleSchemeFactory());
    }

    public int success; // required
    public RSQLException sqlException; // required

    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements org.apache.thrift.TFieldIdEnum {
      SUCCESS((short)0, "success"),
      SQL_EXCEPTION((short)1, "sqlException");

      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        switch(fieldId) {
          case 0: // SUCCESS
            return SUCCESS;
          case 1: // SQL_EXCEPTION
            return SQL_EXCEPTION;
          default:
            return null;
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }

    // isset id assignments
    private static final int __SUCCESS_ISSET_ID = 0;
    private byte __isset_bitfield = 0;
    public static final Map<_Fields, org.apache.thrift.meta_data.FieldMetaData> metaDataMap;
    static {
      Map<_Fields, org.apache.thrift.meta_data.FieldMetaData> tmpMap = new EnumMap<_Fields, org.apache.thrift.meta_data.FieldMetaData>(_Fields.class);
      tmpMap.put(_Fields.SUCCESS, new org.apache.thrift.meta_data.FieldMetaData("success", org.apache.thrift.TFieldRequirementType.DEFAULT, 
          new org.apache.thrift.meta_data.FieldValueMetaData(org.apache.thrift.protocol.TType.I32)));
      tmpMap.put(_Fields.SQL_EXCEPTION, new org.apache.thrift.meta_data.FieldMetaData("sqlException", org.apache.thrift.TFieldRequirementType.DEFAULT, 
          new org.apache.thrift.meta_data.FieldValueMetaData(org.apache.thrift.protocol.TType.STRUCT)));
      metaDataMap = Collections.unmodifiableMap(tmpMap);
      org.apache.thrift.meta_data.FieldMetaData.addStructMetaDataMap(statement_getQueryTimeout_result.class, metaDataMap);
    }

    public statement_getQueryTimeout_result() {
    }

    public statement_getQueryTimeout_result(
      int success,
      RSQLException sqlException)
    {
      this();
      this.success = success;
      setSuccessIsSet(true);
      this.sqlException = sqlException;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public statement_getQueryTimeout_result(statement_getQueryTimeout_result other) {
      __isset_bitfield = other.__isset_bitfield;
      this.success = other.success;
      if (other.isSetSqlException()) {
        this.sqlException = new RSQLException(other.sqlException);
      }
    }

    public statement_getQueryTimeout_result deepCopy() {
      return new statement_getQueryTimeout_result(this);
    }

    @Override
    public void clear() {
      setSuccessIsSet(false);
      this.success = 0;
      this.sqlException = null;
    }

    public int getSuccess() {
      return this.success;
    }

    public statement_getQueryTimeout_result setSuccess(int success) {
      this.success = success;
      setSuccessIsSet(true);
      return this;
    }

    public void unsetSuccess() {
      __isset_bitfield = EncodingUtils.clearBit(__isset_bitfield, __SUCCESS_ISSET_ID);
    }

    /** Returns true if field success is set (has been assigned a value) and false otherwise */
    public boolean isSetSuccess() {
      return EncodingUtils.testBit(__isset_bitfield, __SUCCESS_ISSET_ID);
    }

    public void setSuccessIsSet(boolean value) {
      __isset_bitfield = EncodingUtils.setBit(__isset_bitfield, __SUCCESS_ISSET_ID, value);
    }

    public RSQLException getSqlException() {
      return this.sqlException;
    }

    public statement_getQueryTimeout_result setSqlException(RSQLException sqlException) {
      this.sqlException = sqlException;
      return this;
    }

    public void unsetSqlException() {
      this.sqlException = null;
    }

    /** Returns true if field sqlException is set (has been assigned a value) and false otherwise */
    public boolean isSetSqlException() {
      return this.sqlException != null;
    }

    public void setSqlExceptionIsSet(boolean value) {
      if (!value) {
        this.sqlException = null;
      }
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          setSuccess((Integer)value);
        }
        break;

      case SQL_EXCEPTION:
        if (value == null) {
          unsetSqlException();
        } else {
          setSqlException((RSQLException)value);
        }
        break;

      }
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      case SUCCESS:
        return Integer.valueOf(getSuccess());

      case SQL_EXCEPTION:
        return getSqlException();

      }
      throw new IllegalStateException();
    }

    /** Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      if (field == null) {
        throw new IllegalArgumentException();
      }

      switch (field) {
      case SUCCESS:
        return isSetSuccess();
      case SQL_EXCEPTION:
        return isSetSqlException();
      }
      throw new IllegalStateException();
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof statement_getQueryTimeout_result)
        return this.equals((statement_getQueryTimeout_result)that);
      return false;
    }

    public boolean equals(statement_getQueryTimeout_result that) {
      if (that == null)
        return false;

      boolean this_present_success = true;
      boolean that_present_success = true;
      if (this_present_success || that_present_success) {
        if (!(this_present_success && that_present_success))
          return false;
        if (this.success != that.success)
          return false;
      }

      boolean this_present_sqlException = true && this.isSetSqlException();
      boolean that_present_sqlException = true && that.isSetSqlException();
      if (this_present_sqlException || that_present_sqlException) {
        if (!(this_present_sqlException && that_present_sqlException))
          return false;
        if (!this.sqlException.equals(that.sqlException))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      List<Object> list = new ArrayList<Object>();

      boolean present_success = true;
      list.add(present_success);
      if (present_success)
        list.add(success);

      boolean present_sqlException = true && (isSetSqlException());
      list.add(present_sqlException);
      if (present_sqlException)
        list.add(sqlException);

      return list.hashCode();
    }

    @Override
    public int compareTo(statement_getQueryTimeout_result other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetSuccess()).compareTo(other.isSetSuccess());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetSuccess()) {
        lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.success, other.success);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      lastComparison = Boolean.valueOf(isSetSqlException()).compareTo(other.isSetSqlException());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetSqlException()) {
        lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.sqlException, other.sqlException);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      return 0;
    }

    public _Fields fieldForId(int fieldId) {
      return _Fields.findByThriftId(fieldId);
    }

    public void read(org.apache.thrift.protocol.TProtocol iprot) throws org.apache.thrift.TException {
      schemes.get(iprot.getScheme()).getScheme().read(iprot, this);
    }

    public void write(org.apache.thrift.protocol.TProtocol oprot) throws org.apache.thrift.TException {
      schemes.get(oprot.getScheme()).getScheme().write(oprot, this);
      }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("statement_getQueryTimeout_result(");
      boolean first = true;

      sb.append("success:");
      sb.append(this.success);
      first = false;
      if (!first) sb.append(", ");
      sb.append("sqlException:");
      if (this.sqlException == null) {
        sb.append("null");
      } else {
        sb.append(this.sqlException);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws org.apache.thrift.TException {
      // check for required fields
      // check for sub-struct validity
    }

    private void writeObject(java.io.ObjectOutputStream out) throws java.io.IOException {
      try {
        write(new org.apache.thrift.protocol.TCompactProtocol(new org.apache.thrift.transport.TIOStreamTransport(out)));
      } catch (org.apache.thrift.TException te) {
        throw new java.io.IOException(te);
      }
    }

    private void readObject(java.io.ObjectInputStream in) throws java.io.IOException, ClassNotFoundException {
      try {
        // it doesn't seem like you should have to do this, but java serialization is wacky, and doesn't call the default constructor.
        __isset_bitfield = 0;
        read(new org.apache.thrift.protocol.TCompactProtocol(new org.apache.thrift.transport.TIOStreamTransport(in)));
      } catch (org.apache.thrift.TException te) {
        throw new java.io.IOException(te);
      }
    }

    private static class statement_getQueryTimeout_resultStandardSchemeFactory implements SchemeFactory {
      public statement_getQueryTimeout_resultStandardScheme getScheme() {
        return new statement_getQueryTimeout_resultStandardScheme();
      }
    }

    private static class statement_getQueryTimeout_resultStandardScheme extends StandardScheme<statement_getQueryTimeout_result> {

      public void read(org.apache.thrift.protocol.TProtocol iprot, statement_getQueryTimeout_result struct) throws org.apache.thrift.TException {
        org.apache.thrift.protocol.TField schemeField;
        iprot.readStructBegin();
        while (true)
        {
          schemeField = iprot.readFieldBegin();
          if (schemeField.type == org.apache.thrift.protocol.TType.STOP) { 
            break;
          }
          switch (schemeField.id) {
            case 0: // SUCCESS
              if (schemeField.type == org.apache.thrift.protocol.TType.I32) {
                struct.success = iprot.readI32();
                struct.setSuccessIsSet(true);
              } else { 
                org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
              }
              break;
            case 1: // SQL_EXCEPTION
              if (schemeField.type == org.apache.thrift.protocol.TType.STRUCT) {
                struct.sqlException = new RSQLException();
                struct.sqlException.read(iprot);
                struct.setSqlExceptionIsSet(true);
              } else { 
                org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
              }
              break;
            default:
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
          }
          iprot.readFieldEnd();
        }
        iprot.readStructEnd();

        // check for required fields of primitive type, which can't be checked in the validate method
        struct.validate();
      }

      public void write(org.apache.thrift.protocol.TProtocol oprot, statement_getQueryTimeout_result struct) throws org.apache.thrift.TException {
        struct.validate();

        oprot.writeStructBegin(STRUCT_DESC);
        if (struct.isSetSuccess()) {
          oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
          oprot.writeI32(struct.success);
          oprot.writeFieldEnd();
        }
        if (struct.sqlException != null) {
          oprot.writeFieldBegin(SQL_EXCEPTION_FIELD_DESC);
          struct.sqlException.write(oprot);
          oprot.writeFieldEnd();
        }
        oprot.writeFieldStop();
        oprot.writeStructEnd();
      }

    }

    private static class statement_getQueryTimeout_resultTupleSchemeFactory implements SchemeFactory {
      public statement_getQueryTimeout_resultTupleScheme getScheme() {
        return new statement_getQueryTimeout_resultTupleScheme();
      }
    }

    private static class statement_getQueryTimeout_resultTupleScheme extends TupleScheme<statement_getQueryTimeout_result> {

      @Override
      public void write(org.apache.thrift.protocol.TProtocol prot, statement_getQueryTimeout_result struct) throws org.apache.thrift.TException {
        TTupleProtocol oprot = (TTupleProtocol) prot;
        BitSet optionals = new BitSet();
        if (struct.isSetSuccess()) {
          optionals.set(0);
        }
        if (struct.isSetSqlException()) {
          optionals.set(1);
        }
        oprot.writeBitSet(optionals, 2);
        if (struct.isSetSuccess()) {
          oprot.writeI32(struct.success);
        }
        if (struct.isSetSqlException()) {
          struct.sqlException.write(oprot);
        }
      }

      @Override
      public void read(org.apache.thrift.protocol.TProtocol prot, statement_getQueryTimeout_result struct) throws org.apache.thrift.TException {
        TTupleProtocol iprot = (TTupleProtocol) prot;
        BitSet incoming = iprot.readBitSet(2);
        if (incoming.get(0)) {
          struct.success = iprot.readI32();
          struct.setSuccessIsSet(true);
        }
        if (incoming.get(1)) {
          struct.sqlException = new RSQLException();
          struct.sqlException.read(iprot);
          struct.setSqlExceptionIsSet(true);
        }
      }
    }

  }

  public static class statement_setQueryTimeout_args implements org.apache.thrift.TBase<statement_setQueryTimeout_args, statement_setQueryTimeout_args._Fields>, java.io.Serializable, Cloneable, Comparable<statement_setQueryTimeout_args>   {
    private static final org.apache.thrift.protocol.TStruct STRUCT_DESC = new org.apache.thrift.protocol.TStruct("statement_setQueryTimeout_args");

    private static final org.apache.thrift.protocol.TField STATEMENT_FIELD_DESC = new org.apache.thrift.protocol.TField("statement", org.apache.thrift.protocol.TType.STRUCT, (short)1);
    private static final org.apache.thrift.protocol.TField SECONDS_FIELD_DESC = new org.apache.thrift.protocol.TField("seconds", org.apache.thrift.protocol.TType.I32, (short)2);

    private static final Map<Class<? extends IScheme>, SchemeFactory> schemes = new HashMap<Class<? extends IScheme>, SchemeFactory>();
    static {
      schemes.put(StandardScheme.class, new statement_setQueryTimeout_argsStandardSchemeFactory());
      schemes.put(TupleScheme.class, new statement_setQueryTimeout_argsTupleSchemeFactory());
    }

    public RStatement statement; // required
    public int seconds; // required

    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements org.apache.thrift.TFieldIdEnum {
      STATEMENT((short)1, "statement"),
      SECONDS((short)2, "seconds");

      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        switch(fieldId) {
          case 1: // STATEMENT
            return STATEMENT;
          case 2: // SECONDS
            return SECONDS;
          default:
            return null;
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }

    // isset id assignments
    private static final int __SECONDS_ISSET_ID = 0;
    private byte __isset_bitfield = 0;
    public static final Map<_Fields, org.apache.thrift.meta_data.FieldMetaData> metaDataMap;
    static {
      Map<_Fields, org.apache.thrift.meta_data.FieldMetaData> tmpMap = new EnumMap<_Fields, org.apache.thrift.meta_data.FieldMetaData>(_Fields.class);
      tmpMap.put(_Fields.STATEMENT, new org.apache.thrift.meta_data.FieldMetaData("statement", org.apache.thrift.TFieldRequirementType.DEFAULT, 
          new org.apache.thrift.meta_data.StructMetaData(org.apache.thrift.protocol.TType.STRUCT, RStatement.class)));
      tmpMap.put(_Fields.SECONDS, new org.apache.thrift.meta_data.FieldMetaData("seconds", org.apache.thrift.TFieldRequirementType.DEFAULT, 
          new org.apache.thrift.meta_data.FieldValueMetaData(org.apache.thrift.protocol.TType.I32)));
      metaDataMap = Collections.unmodifiableMap(tmpMap);
      org.apache.thrift.meta_data.FieldMetaData.addStructMetaDataMap(statement_setQueryTimeout_args.class, metaDataMap);
    }

    public statement_setQueryTimeout_args() {
    }

    public statement_setQueryTimeout_args(
      RStatement statement,
      int seconds)
    {
      this();
      this.statement = statement;
      this.seconds = seconds;
      setSecondsIsSet(true);
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public statement_setQueryTimeout_args(statement_setQueryTimeout_args other) {
      __isset_bitfield = other.__isset_bitfield;
      if (other.isSetStatement()) {
        this.statement = new RStatement(other.statement);
      }
      this.seconds = other.seconds;
    }

    public statement_setQueryTimeout_args deepCopy() {
      return new statement_setQueryTimeout_args(this);
    }

    @Override
    public void clear() {
      this.statement = null;
      setSecondsIsSet(false);
      this.seconds = 0;
    }

    public RStatement getStatement() {
      return this.statement;
    }

    public statement_setQueryTimeout_args setStatement(RStatement statement) {
      this.statement = statement;
      return this;
    }

    public void unsetStatement() {
      this.statement = null;
    }

    /** Returns true if field statement is set (has been assigned a value) and false otherwise */
    public boolean isSetStatement() {
      return this.statement != null;
    }

    public void setStatementIsSet(boolean value) {
      if (!value) {
        this.statement = null;
      }
    }

    public int getSeconds() {
      return this.seconds;
    }

    public statement_setQueryTimeout_args setSeconds(int seconds) {
      this.seconds = seconds;
      setSecondsIsSet(true);
      return this;
    }

    public void unsetSeconds() {
      __isset_bitfield = EncodingUtils.clearBit(__isset_bitfield, __SECONDS_ISSET_ID);
    }

    /** Returns true if field seconds is set (has been assigned a value) and false otherwise */
    public boolean isSetSeconds() {
      return EncodingUtils.testBit(__isset_bitfield, __SECONDS_ISSET_ID);
    }

    public void setSecondsIsSet(boolean value) {
      __isset_bitfield = EncodingUtils.setBit(__isset_bitfield, __SECONDS_ISSET_ID, value);
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      case STATEMENT:
        if (value == null) {
          unsetStatement();
        } else {
          setStatement((RStatement)value);
        }
        break;

      case SECONDS:
        if (value == null) {
          unsetSeconds();
        } else {
          setSeconds((Integer)value);
        }
        break;

      }
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      case STATEMENT:
        return getStatement();

      case SECONDS:
        return Integer.valueOf(getSeconds());

      }
      throw new IllegalStateException();
    }

    /** Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      if (field == null) {
        throw new IllegalArgumentException();
      }

      switch (field) {
      case STATEMENT:
        return isSetStatement();
      case SECONDS:
        return isSetSeconds();
      }
      throw new IllegalStateException();
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof statement_setQueryTimeout_args)
        return this.equals((statement_setQueryTimeout_args)that);
      return false;
    }

    public boolean equals(statement_setQueryTimeout_args that) {
      if (that == null)
        return false;

      boolean this_present_statement = true && this.isSetStatement();
      boolean that_present_statement = true && that.isSetStatement();
      if (this_present_statement || that_present_statement) {
        if (!(this_present_statement && that_present_statement))
          return false;
        if (!this.statement.equals(that.statement))
          return false;
      }

      boolean this_present_seconds = true;
      boolean that_present_seconds = true;
      if (this_present_seconds || that_present_seconds) {
        if (!(this_present_seconds && that_present_seconds))
          return false;
        if (this.seconds != that.seconds)
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      List<Object> list = new ArrayList<Object>();

      boolean present_statement = true && (isSetStatement());
      list.add(present_statement);
      if (present_statement)
        list.add(statement);

      boolean present_seconds = true;
      list.add(present_seconds);
      if (present_seconds)
        list.add(seconds);

      return list.hashCode();
    }

    @Override
    public int compareTo(statement_setQueryTimeout_args other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetStatement()).compareTo(other.isSetStatement());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetStatement()) {
        lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.statement, other.statement);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      lastComparison = Boolean.valueOf(isSetSeconds()).compareTo(other.isSetSeconds());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetSeconds()) {
        lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.seconds, other.seconds);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      return 0;
    }

    public _Fields fieldForId(int fieldId) {
      return _Fields.findByThriftId(fieldId);
    }

    public void read(org.apache.thrift.protocol.TProtocol iprot) throws org.apache.thrift.TException {
      schemes.get(iprot.getScheme()).getScheme().read(iprot, this);
    }

    public void write(org.apache.thrift.protocol.TProtocol oprot) throws org.apache.thrift.TException {
      schemes.get(oprot.getScheme()).getScheme().write(oprot, this);
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("statement_setQueryTimeout_args(");
      boolean first = true;

      sb.append("statement:");
      if (this.statement == null) {
        sb.append("null");
      } else {
        sb.append(this.statement);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("seconds:");
      sb.append(this.seconds);
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws org.apache.thrift.TException {
      // check for required fields
      // check for sub-struct validity
      if (statement != null) {
        statement.validate();
      }
    }

    private void writeObject(java.io.ObjectOutputStream out) throws java.io.IOException {
      try {
        write(new org.apache.thrift.protocol.TCompactProtocol(new org.apache.thrift.transport.TIOStreamTransport(out)));
      } catch (org.apache.thrift.TException te) {
        throw new java.io.IOException(te);
      }
    }

    private void readObject(java.io.ObjectInputStream in) throws java.io.IOException, ClassNotFoundException {
      try {
        // it doesn't seem like you should have to do this, but java serialization is wacky, and doesn't call the default constructor.
        __isset_bitfield = 0;
        read(new org.apache.thrift.protocol.TCompactProtocol(new org.apache.thrift.transport.TIOStreamTransport(in)));
      } catch (org.apache.thrift.TException te) {
        throw new java.io.IOException(te);
      }
    }

    private static class statement_setQueryTimeout_argsStandardSchemeFactory implements SchemeFactory {
      public statement_setQueryTimeout_argsStandardScheme getScheme() {
        return new statement_setQueryTimeout_argsStandardScheme();
      }
    }

    private static class statement_setQueryTimeout_argsStandardScheme extends StandardScheme<statement_setQueryTimeout_args> {

      public void read(org.apache.thrift.protocol.TProtocol iprot, statement_setQueryTimeout_args struct) throws org.apache.thrift.TException {
        org.apache.thrift.protocol.TField schemeField;
        iprot.readStructBegin();
        while (true)
        {
          schemeField = iprot.readFieldBegin();
          if (schemeField.type == org.apache.thrift.protocol.TType.STOP) { 
            break;
          }
          switch (schemeField.id) {
            case 1: // STATEMENT
              if (schemeField.type == org.apache.thrift.protocol.TType.STRUCT) {
                struct.statement = new RStatement();
                struct.statement.read(iprot);
                struct.setStatementIsSet(true);
              } else { 
                org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
              }
              break;
            case 2: // SECONDS
              if (schemeField.type == org.apache.thrift.protocol.TType.I32) {
                struct.seconds = iprot.readI32();
                struct.setSecondsIsSet(true);
              } else { 
                org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
              }
              break;
            default:
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
          }
          iprot.readFieldEnd();
        }
        iprot.readStructEnd();

        // check for required fields of primitive type, which can't be checked in the validate method
        struct.validate();
      }

      public void write(org.apache.thrift.protocol.TProtocol oprot, statement_setQueryTimeout_args struct) throws org.apache.thrift.TException {
        struct.validate();

        oprot.writeStructBegin(STRUCT_DESC);
        if (struct.statement != null) {
          oprot.writeFieldBegin(STATEMENT_FIELD_DESC);
          struct.statement.write(oprot);
          oprot.writeFieldEnd();
        }
        oprot.writeFieldBegin(SECONDS_FIELD_DESC);
        oprot.writeI32(struct.seconds);
        oprot.writeFieldEnd();
        oprot.writeFieldStop();
        oprot.writeStructEnd();
      }

    }

    private static class statement_setQueryTimeout_argsTupleSchemeFactory implements SchemeFactory {
      public statement_setQueryTimeout_argsTupleScheme getScheme() {
        return new statement_setQueryTimeout_argsTupleScheme();
      }
    }

    private static class statement_setQueryTimeout_argsTupleScheme extends TupleScheme<statement_setQueryTimeout_args> {

      @Override
      public void write(org.apache.thrift.protocol.TProtocol prot, statement_setQueryTimeout_args struct) throws org.apache.thrift.TException {
        TTupleProtocol oprot = (TTupleProtocol) prot;
        BitSet optionals = new BitSet();
        if (struct.isSetStatement()) {
          optionals.set(0);
        }
        if (struct.isSetSeconds()) {
          optionals.set(1);
        }
        oprot.writeBitSet(optionals, 2);
        if (struct.isSetStatement()) {
          struct.statement.write(oprot);
        }
        if (struct.isSetSeconds()) {
          oprot.writeI32(struct.seconds);
        }
      }

      @Override
      public void read(org.apache.thrift.protocol.TProtocol prot, statement_setQueryTimeout_args struct) throws org.apache.thrift.TException {
        TTupleProtocol iprot = (TTupleProtocol) prot;
        BitSet incoming = iprot.readBitSet(2);
        if (incoming.get(0)) {
          struct.statement = new RStatement();
          struct.statement.read(iprot);
          struct.setStatementIsSet(true);
        }
        if (incoming.get(1)) {
          struct.seconds = iprot.readI32();
          struct.setSecondsIsSet(true);
        }
      }
    }

  }

  public static class statement_setQueryTimeout_result implements org.apache.thrift.TBase<statement_setQueryTimeout_result, statement_setQueryTimeout_result._Fields>, java.io.Serializable, Cloneable, Comparable<statement_setQueryTimeout_result>   {
    private static final org.apache.thrift.protocol.TStruct STRUCT_DESC = new org.apache.thrift.protocol.TStruct("statement_setQueryTimeout_result");

    private static final org.apache.thrift.protocol.TField SQL_EXCEPTION_FIELD_DESC = new org.apache.thrift.protocol.TField("sqlException", org.apache.thrift.protocol.TType.STRUCT, (short)1);

    private static final Map<Class<? extends IScheme>, SchemeFactory> schemes = new HashMap<Class<? extends IScheme>, SchemeFactory>();
    static {
      schemes.put(StandardScheme.class, new statement_setQueryTimeout_resultStandardSchemeFactory());
      schemes.put(TupleScheme.class, new statement_setQueryTimeout_resultTupleSchemeFactory());
    }

    public RSQLException sqlException; // required

    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements org.apache.thrift.TFieldIdEnum {
      SQL_EXCEPTION((short)1, "sqlException");

      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        switch(fieldId) {
          case 1: // SQL_EXCEPTION
            return SQL_EXCEPTION;
          default:
            return null;
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }

    // isset id assignments
    public static final Map<_Fields, org.apache.thrift.meta_data.FieldMetaData> metaDataMap;
    static {
      Map<_Fields, org.apache.thrift.meta_data.FieldMetaData> tmpMap = new EnumMap<_Fields, org.apache.thrift.meta_data.FieldMetaData>(_Fields.class);
      tmpMap.put(_Fields.SQL_EXCEPTION, new org.apache.thrift.meta_data.FieldMetaData("sqlException", org.apache.thrift.TFieldRequirementType.DEFAULT, 
          new org.apache.thrift.meta_data.FieldValueMetaData(org.apache.thrift.protocol.TType.STRUCT)));
      metaDataMap = Collections.unmodifiableMap(tmpMap);
      org.apache.thrift.meta_data.FieldMetaData.addStructMetaDataMap(statement_setQueryTimeout_result.class, metaDataMap);
    }

    public statement_setQueryTimeout_result() {
    }

    public statement_setQueryTimeout_result(
      RSQLException sqlException)
    {
      this();
      this.sqlException = sqlException;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public statement_setQueryTimeout_result(statement_setQueryTimeout_result other) {
      if (other.isSetSqlException()) {
        this.sqlException = new RSQLException(other.sqlException);
      }
    }

    public statement_setQueryTimeout_result deepCopy() {
      return new statement_setQueryTimeout_result(this);
    }

    @Override
    public void clear() {
      this.sqlException = null;
    }

    public RSQLException getSqlException() {
      return this.sqlException;
    }

    public statement_setQueryTimeout_result setSqlException(RSQLException sqlException) {
      this.sqlException = sqlException;
      return this;
    }

    public void unsetSqlException() {
      this.sqlException = null;
    }

    /** Returns true if field sqlException is set (has been assigned a value) and false otherwise */
    public boolean isSetSqlException() {
      return this.sqlException != null;
    }

    public void setSqlExceptionIsSet(boolean value) {
      if (!value) {
        this.sqlException = null;
      }
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      case SQL_EXCEPTION:
        if (value == null) {
          unsetSqlException();
        } else {
          setSqlException((RSQLException)value);
        }
        break;

      }
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      case SQL_EXCEPTION:
        return getSqlException();

      }
      throw new IllegalStateException();
    }

    /** Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      if (field == null) {
        throw new IllegalArgumentException();
      }

      switch (field) {
      case SQL_EXCEPTION:
        return isSetSqlException();
      }
      throw new IllegalStateException();
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof statement_setQueryTimeout_result)
        return this.equals((statement_setQueryTimeout_result)that);
      return false;
    }

    public boolean equals(statement_setQueryTimeout_result that) {
      if (that == null)
        return false;

      boolean this_present_sqlException = true && this.isSetSqlException();
      boolean that_present_sqlException = true && that.isSetSqlException();
      if (this_present_sqlException || that_present_sqlException) {
        if (!(this_present_sqlException && that_present_sqlException))
          return false;
        if (!this.sqlException.equals(that.sqlException))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      List<Object> list = new ArrayList<Object>();

      boolean present_sqlException = true && (isSetSqlException());
      list.add(present_sqlException);
      if (present_sqlException)
        list.add(sqlException);

      return list.hashCode();
    }

    @Override
    public int compareTo(statement_setQueryTimeout_result other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetSqlException()).compareTo(other.isSetSqlException());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetSqlException()) {
        lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.sqlException, other.sqlException);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      return 0;
    }

    public _Fields fieldForId(int fieldId) {
      return _Fields.findByThriftId(fieldId);
    }

    public void read(org.apache.thrift.protocol.TProtocol iprot) throws org.apache.thrift.TException {
      schemes.get(iprot.getScheme()).getScheme().read(iprot, this);
    }

    public void write(org.apache.thrift.protocol.TProtocol oprot) throws org.apache.thrift.TException {
      schemes.get(oprot.getScheme()).getScheme().write(oprot, this);
      }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("statement_setQueryTimeout_result(");
      boolean first = true;

      sb.append("sqlException:");
      if (this.sqlException == null) {
        sb.append("null");
      } else {
        sb.append(this.sqlException);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws org.apache.thrift.TException {
      // check for required fields
      // check for sub-struct validity
    }

    private void writeObject(java.io.ObjectOutputStream out) throws java.io.IOException {
      try {
        write(new org.apache.thrift.protocol.TCompactProtocol(new org.apache.thrift.transport.TIOStreamTransport(out)));
      } catch (org.apache.thrift.TException te) {
        throw new java.io.IOException(te);
      }
    }

    private void readObject(java.io.ObjectInputStream in) throws java.io.IOException, ClassNotFoundException {
      try {
        read(new org.apache.thrift.protocol.TCompactProtocol(new org.apache.thrift.transport.TIOStreamTransport(in)));
      } catch (org.apache.thrift.TException te) {
        throw new java.io.IOException(te);
      }
    }

    private static class statement_setQueryTimeout_resultStandardSchemeFactory implements SchemeFactory {
      public statement_setQueryTimeout_resultStandardScheme getScheme() {
        return new statement_setQueryTimeout_resultStandardScheme();
      }
    }

    private static class statement_setQueryTimeout_resultStandardScheme extends StandardScheme<statement_setQueryTimeout_result> {

      public void read(org.apache.thrift.protocol.TProtocol iprot, statement_setQueryTimeout_result struct) throws org.apache.thrift.TException {
        org.apache.thrift.protocol.TField schemeField;
        iprot.readStructBegin();
        while (true)
        {
          schemeField = iprot.readFieldBegin();
          if (schemeField.type == org.apache.thrift.protocol.TType.STOP) { 
            break;
          }
          switch (schemeField.id) {
            case 1: // SQL_EXCEPTION
              if (schemeField.type == org.apache.thrift.protocol.TType.STRUCT) {
                struct.sqlException = new RSQLException();
                struct.sqlException.read(iprot);
                struct.setSqlExceptionIsSet(true);
              } else { 
                org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
              }
              break;
            default:
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
          }
          iprot.readFieldEnd();
        }
        iprot.readStructEnd();

        // check for required fields of primitive type, which can't be checked in the validate method
        struct.validate();
      }

      public void write(org.apache.thrift.protocol.TProtocol oprot, statement_setQueryTimeout_result struct) throws org.apache.thrift.TException {
        struct.validate();

        oprot.writeStructBegin(STRUCT_DESC);
        if (struct.sqlException != null) {
          oprot.writeFieldBegin(SQL_EXCEPTION_FIELD_DESC);
          struct.sqlException.write(oprot);
          oprot.writeFieldEnd();
        }
        oprot.writeFieldStop();
        oprot.writeStructEnd();
      }

    }

    private static class statement_setQueryTimeout_resultTupleSchemeFactory implements SchemeFactory {
      public statement_setQueryTimeout_resultTupleScheme getScheme() {
        return new statement_setQueryTimeout_resultTupleScheme();
      }
    }

    private static class statement_setQueryTimeout_resultTupleScheme extends TupleScheme<statement_setQueryTimeout_result> {

      @Override
      public void write(org.apache.thrift.protocol.TProtocol prot, statement_setQueryTimeout_result struct) throws org.apache.thrift.TException {
        TTupleProtocol oprot = (TTupleProtocol) prot;
        BitSet optionals = new BitSet();
        if (struct.isSetSqlException()) {
          optionals.set(0);
        }
        oprot.writeBitSet(optionals, 1);
        if (struct.isSetSqlException()) {
          struct.sqlException.write(oprot);
        }
      }

      @Override
      public void read(org.apache.thrift.protocol.TProtocol prot, statement_setQueryTimeout_result struct) throws org.apache.thrift.TException {
        TTupleProtocol iprot = (TTupleProtocol) prot;
        BitSet incoming = iprot.readBitSet(1);
        if (incoming.get(0)) {
          struct.sqlException = new RSQLException();
          struct.sqlException.read(iprot);
          struct.setSqlExceptionIsSet(true);
        }
      }
    }

  }

}
